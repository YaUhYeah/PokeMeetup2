package org.discord;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class ServerWorldObjectManager {

    private final Map<String, Map<Vector2, List<WorldObject>>> worldObjectsByWorld = new ConcurrentHashMap<>();
    private final Map<Vector2, Long> lastChunkAccess = new ConcurrentHashMap<>();

    public void initializeWorld(String worldName) {
        worldObjectsByWorld.putIfAbsent(worldName, new ConcurrentHashMap<>());
    }

    public List<WorldObject> getObjectsForChunk(String worldName, Vector2 chunkPos) {
        Map<Vector2, List<WorldObject>> worldObjects = worldObjectsByWorld.get(worldName);
        if (worldObjects == null) return new ArrayList<>();
        List<WorldObject> objects = worldObjects.get(chunkPos);
        lastChunkAccess.put(chunkPos, System.currentTimeMillis());
        return objects != null ? objects : new ArrayList<>();
    }

    public void removeObject(String worldName, Vector2 chunkPos, String objectId) {
        Map<Vector2, List<WorldObject>> worldObjects = worldObjectsByWorld.get(worldName);
        if (worldObjects == null) return;
        List<WorldObject> objects = worldObjects.get(chunkPos);
        if (objects != null) {
            objects.removeIf(obj -> obj.getId().equals(objectId));
            if (objects.isEmpty()) {
                worldObjects.remove(chunkPos);
            }
            GameLogger.info("Removed object " + objectId + " from chunk " + chunkPos);
        }
    }

    /**
     * Instead of running our own perâ€“tile object placement algorithm,
     * we simply retrieve the world objects that were already generated by UnifiedWorldGenerator.
     */
    public List<WorldObject> generateObjectsForChunk(String worldName, Vector2 chunkPos, Chunk chunk) {
        if (chunk == null) return Collections.emptyList();
        List<WorldObject> objects = chunk.getWorldObjects();
        if (objects == null) {
            objects = new ArrayList<>();
        }
        // Ensure that each object has an ID and its texture is loaded.
        for (WorldObject obj : objects) {
            if (obj != null) {
                if (obj.getId() == null) {
                    obj.setId(UUID.randomUUID().toString());
                }
                obj.ensureTexture();
            }
        }
        // Populate the cache.
        setObjectsForChunk(worldName, chunkPos, objects);
        return objects;
    }

    public void setObjectsForChunk(String worldName, Vector2 chunkPos, List<WorldObject> objects) {
        try {
            if (objects == null) {
                worldObjectsByWorld.computeIfAbsent(worldName, k -> new ConcurrentHashMap<>())
                    .remove(chunkPos);
                return;
            }
            List<WorldObject> safeObjects = new CopyOnWriteArrayList<>();
            for (WorldObject obj : objects) {
                if (obj != null) {
                    if (obj.getId() == null) {
                        obj.setId(UUID.randomUUID().toString());
                    }
                    obj.ensureTexture();
                    safeObjects.add(obj);
                }
            }
            worldObjectsByWorld.computeIfAbsent(worldName, k -> new ConcurrentHashMap<>())
                .put(chunkPos, safeObjects);
            GameLogger.info("Updated " + safeObjects.size() + " objects in chunk " + chunkPos +
                " for world " + worldName);
        } catch (Exception e) {
            GameLogger.error("Error setting chunk objects: " + e.getMessage());
        }
    }

    public void cleanup() {
        worldObjectsByWorld.clear();
        lastChunkAccess.clear();
    }
}
