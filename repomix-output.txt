This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
build.gradle
src/main/java/io/github/pokemeetup/audio/AudioManager.java
src/main/java/io/github/pokemeetup/blocks/BlockManager.java
src/main/java/io/github/pokemeetup/blocks/BuildingData.java
src/main/java/io/github/pokemeetup/blocks/BuildingTemplate.java
src/main/java/io/github/pokemeetup/blocks/ConnectionPattern.java
src/main/java/io/github/pokemeetup/blocks/PlaceableBlock.java
src/main/java/io/github/pokemeetup/blocks/SmartBlockConfig.java
src/main/java/io/github/pokemeetup/blocks/SmartBuildingManager.java
src/main/java/io/github/pokemeetup/chat/ChatSystem.java
src/main/java/io/github/pokemeetup/chat/Command.java
src/main/java/io/github/pokemeetup/chat/CommandManager.java
src/main/java/io/github/pokemeetup/chat/commands/GiveCommand.java
src/main/java/io/github/pokemeetup/chat/commands/SetWorldSpawnCommand.java
src/main/java/io/github/pokemeetup/chat/commands/SpawnCommand.java
src/main/java/io/github/pokemeetup/chat/commands/TeleportManager.java
src/main/java/io/github/pokemeetup/chat/commands/TeleportPositionCommand.java
src/main/java/io/github/pokemeetup/chat/commands/TimeCommand.java
src/main/java/io/github/pokemeetup/chat/commands/WeatherCommand.java
src/main/java/io/github/pokemeetup/context/GameContext.java
src/main/java/io/github/pokemeetup/context/UIManager.java
src/main/java/io/github/pokemeetup/CreatureCaptureGame.java
src/main/java/io/github/pokemeetup/FileSystemDelegate.java
src/main/java/io/github/pokemeetup/managers/BiomeManager.java
src/main/java/io/github/pokemeetup/managers/BiomeRenderer.java
src/main/java/io/github/pokemeetup/managers/BiomeTransitionResult.java
src/main/java/io/github/pokemeetup/managers/DatabaseManager.java
src/main/java/io/github/pokemeetup/managers/DisconnectionManager.java
src/main/java/io/github/pokemeetup/managers/FootstepEffect.java
src/main/java/io/github/pokemeetup/managers/FootstepEffectManager.java
src/main/java/io/github/pokemeetup/managers/WaterEffectManager.java
src/main/java/io/github/pokemeetup/managers/WaterEffectsRenderer.java
src/main/java/io/github/pokemeetup/multiplayer/client/GameClient.java
src/main/java/io/github/pokemeetup/multiplayer/client/GameClientSingleton.java
src/main/java/io/github/pokemeetup/multiplayer/client/PlayerDataResponseHandler.java
src/main/java/io/github/pokemeetup/multiplayer/network/NetworkProtocol.java
src/main/java/io/github/pokemeetup/multiplayer/OtherPlayer.java
src/main/java/io/github/pokemeetup/multiplayer/PlayerManager.java
src/main/java/io/github/pokemeetup/multiplayer/server/config/ServerConfigManager.java
src/main/java/io/github/pokemeetup/multiplayer/server/config/ServerConnectionConfig.java
src/main/java/io/github/pokemeetup/multiplayer/server/events/BaseServerEvent.java
src/main/java/io/github/pokemeetup/multiplayer/server/events/blocks/BlockPlaceEvent.java
src/main/java/io/github/pokemeetup/multiplayer/server/events/EventListener.java
src/main/java/io/github/pokemeetup/multiplayer/server/events/EventManager.java
src/main/java/io/github/pokemeetup/multiplayer/server/events/player/PlayerJoinEvent.java
src/main/java/io/github/pokemeetup/multiplayer/server/events/ServerEvent.java
src/main/java/io/github/pokemeetup/multiplayer/server/GameStateHandler.java
src/main/java/io/github/pokemeetup/multiplayer/server/PlayerDataManager.java
src/main/java/io/github/pokemeetup/multiplayer/server/ServerStorageSystem.java
src/main/java/io/github/pokemeetup/multiplayer/ServerPlayer.java
src/main/java/io/github/pokemeetup/pokemon/attacks/LearnableMove.java
src/main/java/io/github/pokemeetup/pokemon/attacks/Move.java
src/main/java/io/github/pokemeetup/pokemon/attacks/MoveLoader.java
src/main/java/io/github/pokemeetup/pokemon/data/PokemonDatabase.java
src/main/java/io/github/pokemeetup/pokemon/Pokemon.java
src/main/java/io/github/pokemeetup/pokemon/PokemonCaptureAnimation.java
src/main/java/io/github/pokemeetup/pokemon/PokemonDespawnAnimation.java
src/main/java/io/github/pokemeetup/pokemon/PokemonParty.java
src/main/java/io/github/pokemeetup/pokemon/server/PokemonNetworkSyncComponent.java
src/main/java/io/github/pokemeetup/pokemon/WildPokemon.java
src/main/java/io/github/pokemeetup/screens/ChestScreen.java
src/main/java/io/github/pokemeetup/screens/CraftingTableScreen.java
src/main/java/io/github/pokemeetup/screens/DisconnectionScreen.java
src/main/java/io/github/pokemeetup/screens/GameScreen.java
src/main/java/io/github/pokemeetup/screens/InventoryScreen.java
src/main/java/io/github/pokemeetup/screens/InventoryScreenInterface.java
src/main/java/io/github/pokemeetup/screens/LoadingScreen.java
src/main/java/io/github/pokemeetup/screens/LoginScreen.java
src/main/java/io/github/pokemeetup/screens/ModeSelectionScreen.java
src/main/java/io/github/pokemeetup/screens/otherui/BagScreen.java
src/main/java/io/github/pokemeetup/screens/otherui/BattleTable.java
src/main/java/io/github/pokemeetup/screens/otherui/BuildingHotbar.java
src/main/java/io/github/pokemeetup/screens/otherui/BuildModeUI.java
src/main/java/io/github/pokemeetup/screens/otherui/CharacterPreviewDialog.java
src/main/java/io/github/pokemeetup/screens/otherui/GameMenu.java
src/main/java/io/github/pokemeetup/screens/otherui/HotbarSlot.java
src/main/java/io/github/pokemeetup/screens/otherui/HotbarSystem.java
src/main/java/io/github/pokemeetup/screens/otherui/InventorySlotUI.java
src/main/java/io/github/pokemeetup/screens/otherui/PokemonPartyWindow.java
src/main/java/io/github/pokemeetup/screens/otherui/ServerManagementDialog.java
src/main/java/io/github/pokemeetup/screens/otherui/StarterSelectionTable.java
src/main/java/io/github/pokemeetup/screens/WorldSelectionScreen.java
src/main/java/io/github/pokemeetup/system/AndroidMovementController.java
src/main/java/io/github/pokemeetup/system/battle/BattleInitiationHandler.java
src/main/java/io/github/pokemeetup/system/battle/BattleSystemHandler.java
src/main/java/io/github/pokemeetup/system/data/BlockSaveData.java
src/main/java/io/github/pokemeetup/system/data/ChestData.java
src/main/java/io/github/pokemeetup/system/data/ItemData.java
src/main/java/io/github/pokemeetup/system/data/PlayerData.java
src/main/java/io/github/pokemeetup/system/data/PokemonData.java
src/main/java/io/github/pokemeetup/system/data/WorldData.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/ChestInteractionHandler.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/CraftingGrid.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/CraftingSystem.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/RecipeGlossaryUI.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/RecipeManager.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/Inventory.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/Item.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/ItemEntity.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/ItemEntityManager.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/ItemManager.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventoryLock.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventoryObserver.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventorySlotData.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventorySlotDataObserver.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/ItemContainer.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/ItemDataObserver.java
src/main/java/io/github/pokemeetup/system/gameplay/inventory/Slot.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/biomes/Biome.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/biomes/BiomeType.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/Chunk.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/DayNightCycle.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/EnhancedWorldObjectSpawner.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/ApproachPlayerBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/DefendTerritoryBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/FleeBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/FollowPackBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/IdleBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/InvestigateBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/PackLeaderBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/PatrolBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/PokemonBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/SocialInteractionBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/TerritorialBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/WanderBehavior.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/PokemonAI.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/PokemonPersonalityTrait.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/mechanics/AutoTileSystem.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/multiworld/PokemonSpawnManager.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/multiworld/WorldManager.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/PersistOperation.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/RemoveOperation.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/UnifiedWorldGenerator.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/WeatherAudioSystem.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/WeatherSystem.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/World.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/WorldObject.java
src/main/java/io/github/pokemeetup/system/gameplay/overworld/WorldObjectOperation.java
src/main/java/io/github/pokemeetup/system/gameplay/PlayerAnimations.java
src/main/java/io/github/pokemeetup/system/gameplay/PokemonAnimations.java
src/main/java/io/github/pokemeetup/system/GlobalInputProcessor.java
src/main/java/io/github/pokemeetup/system/InputHandler.java
src/main/java/io/github/pokemeetup/system/InputManager.java
src/main/java/io/github/pokemeetup/system/keybinds/ControllerBinds.java
src/main/java/io/github/pokemeetup/system/keybinds/ControllerBindsDialog.java
src/main/java/io/github/pokemeetup/system/keybinds/KeyBinds.java
src/main/java/io/github/pokemeetup/system/keybinds/KeyBindsDialog.java
src/main/java/io/github/pokemeetup/system/PickupActionHandler.java
src/main/java/io/github/pokemeetup/system/Player.java
src/main/java/io/github/pokemeetup/system/Positionable.java
src/main/java/io/github/pokemeetup/system/servers/PluginContext.java
src/main/java/io/github/pokemeetup/system/UITransitionManager.java
src/main/java/io/github/pokemeetup/utils/GameLogger.java
src/main/java/io/github/pokemeetup/utils/NoiseCache.java
src/main/java/io/github/pokemeetup/utils/OpenSimplex2.java
src/main/java/io/github/pokemeetup/utils/PasswordUtils.java
src/main/java/io/github/pokemeetup/utils/PokemonLevelCalculator.java
src/main/java/io/github/pokemeetup/utils/ResponsiveLayout.java
src/main/java/io/github/pokemeetup/utils/storage/DesktopFileSystem.java
src/main/java/io/github/pokemeetup/utils/storage/GameFileSystem.java
src/main/java/io/github/pokemeetup/utils/storage/InventoryConverter.java
src/main/java/io/github/pokemeetup/utils/storage/JsonConfig.java
src/main/java/io/github/pokemeetup/utils/textures/BlockTextureManager.java
src/main/java/io/github/pokemeetup/utils/textures/TextureManager.java
src/main/java/io/github/pokemeetup/utils/textures/TileType.java
src/main/java/io/github/pokemeetup/utils/TimeUtils.java

================================================================
Files
================================================================

================
File: build.gradle
================
plugins {
  id 'java-library'
}
java {
  sourceCompatibility = JavaVersion.VERSION_11
  targetCompatibility = JavaVersion.VERSION_11
}

jar {
  manifest {
    attributes 'Implementation-Title': 'Pokemon Meetup Core',
      'Implementation-Version': project.version
  }

  from sourceSets.main.output
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
dependencies {
  implementation('org.mongodb:mongodb-driver-sync:4.11.1') {
    exclude group: 'org.mongodb', module: 'bson-record-codec'
    exclude group: 'javax.activation', module: 'activation'
  }
  implementation "com.badlogicgames.gdx-controllers:gdx-controllers-core:$gdxControllersVersion"

  api "com.badlogicgames.ashley:ashley:$ashleyVersion"
  api "com.badlogicgames.gdx:gdx-ai:$aiVersion"
  api "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
  api "com.badlogicgames.gdx:gdx:$gdxVersion"
  implementation group: 'org.lz4', name: 'lz4-java', version: '1.8.0'
  api "com.badlogicgames.gdx:gdx-tools:$gdxVersion"
  implementation 'com.h2database:h2:2.1.214'
  implementation 'com.google.code.gson:gson:2.10.1'
  implementation 'org.slf4j:slf4j-api:2.0.9'
  implementation 'ch.qos.logback:logback-classic:1.4.11'
  implementation "com.esotericsoftware:kryonet:2.22.0-RC1"
  implementation "com.esotericsoftware.kryo:kryo:2.24.0"
  implementation "net.java.dev.jna:jna:5.13.0"
  implementation "net.java.dev.jna:jna-platform:5.13.0"
  implementation "com.badlogicgames.gdx:gdx-backend-headless:$gdxVersion"

  // If you're using Java 9+ also add:
  implementation "javax.activation:activation:1.1.1"
  implementation "javax.xml.bind:jaxb-api:2.3.1"


  implementation("at.favre.lib:bcrypt:0.10.2")
  implementation 'androidx.games:games-activity:3.0.5'
  if(enableGraalNative == 'true') {
    implementation "io.github.berstanio:gdx-svmhelper-annotations:$graalHelperVersion"
  }
}

================
File: src/main/java/io/github/pokemeetup/audio/AudioManager.java
================
package io.github.pokemeetup.audio;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.math.MathUtils;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class AudioManager {
    private static AudioManager instance;
    private final Map<WeatherSoundEffect, Sound> weatherSounds = new EnumMap<>(WeatherSoundEffect.class);
    private final Map<WeatherSoundEffect, Long> loopingSoundIds = new EnumMap<>(WeatherSoundEffect.class);
    private final Map<SoundEffect, Sound> sounds;
    private final Map<BiomeType, List<Music>> biomeMusic;

    private final Map<String, Sound> customSounds;
    private final float MUSIC_FADE_DURATION = 2.0f;
    private final Map<AmbientSoundType, Sound> ambientSounds;
    private final Map<AmbientSoundType, Long> activeAmbientLoops;
    private final Map<WeatherSoundEffect, Long> loopingStartTimes = new EnumMap<>(WeatherSoundEffect.class);
    private final Map<WeatherSoundEffect, Float> loopingDurations = new EnumMap<>(WeatherSoundEffect.class);
    private List<Music> menuMusicList;

    private Music currentMusic;
    private BiomeType currentBiome;
    private final float masterVolume = 1.0f;
    private float musicVolume = 0.7f;
    private float soundVolume = 1.0f;
    private boolean musicEnabled = true;
    private boolean soundEnabled = true;
    private BiomeType pendingBiome;
    private boolean isFadingOutMusic = false;
    private float fadeOutMusicTimer = 0f;
    private boolean isFadingInMusic = false;
    private float fadeInMusicTimer = 0f;

    private AudioManager() {
        sounds = new EnumMap<>(SoundEffect.class);
        biomeMusic = new EnumMap<>(BiomeType.class);
        customSounds = new ConcurrentHashMap<>();
        this.ambientSounds = new EnumMap<>(AmbientSoundType.class);
        this.activeAmbientLoops = new EnumMap<>(AmbientSoundType.class);
        initializeAmbientSounds();
        initializeWeatherSounds();
        initializeAudio();
    }

    public static AudioManager getInstance() {
        if (instance == null) {
            instance = new AudioManager();
        }
        return instance;
    }

    public static void setInstance(AudioManager instance) {
        AudioManager.instance = instance;
    }

    private void updateVolumes() {
        if (currentMusic != null) {
            currentMusic.setVolume(Math.max(0, musicVolume * masterVolume));
        }
        for (List<Music> musicList : biomeMusic.values()) {
            for (Music music : musicList) {
                music.setVolume(musicVolume * masterVolume);
            }
        }
    }

    private void updateSoundVolumes() {
        for (Map.Entry<WeatherSoundEffect, Long> entry : loopingSoundIds.entrySet()) {
            Sound sound = weatherSounds.get(entry.getKey());
            Long soundId = entry.getValue();
            if (sound != null && soundId != null) {
                sound.setVolume(soundId, soundVolume * masterVolume);
            }
        }
    }

    private void initializeWeatherSounds() {
        for (WeatherSoundEffect effect : WeatherSoundEffect.values()) {
            try {
                Sound sound = Gdx.audio.newSound(Gdx.files.internal(effect.getPath()));
                weatherSounds.put(effect, sound);
            } catch (Exception e) {
                GameLogger.error("Failed to load weather sound: " + effect.getPath());
            }
        }
    }

    private void initializeAmbientSounds() {
        for (AmbientSoundType type : AmbientSoundType.values()) {
            try {
                Sound sound = Gdx.audio.newSound(Gdx.files.internal(type.getPath()));
                ambientSounds.put(type, sound);
                GameLogger.info("Loaded ambient sound: " + type.name());
            } catch (Exception e) {
                GameLogger.error("Failed to load ambient sound: " + type.name() + " - " + e.getMessage());
            }
        }
    }

    public void stopAllAmbientSounds() {
        for (Map.Entry<AmbientSoundType, Long> entry : activeAmbientLoops.entrySet()) {
            Sound sound = ambientSounds.get(entry.getKey());
            if (sound != null) {
                sound.stop(entry.getValue());
            }
        }
        activeAmbientLoops.clear();
    }

    public void playWeatherSound(WeatherSoundEffect effect, float volume, float pitch) {
        if (!soundEnabled) return;

        Sound sound = weatherSounds.get(effect);
        if (sound != null) {
            sound.play(volume * soundVolume * masterVolume, pitch, 0);
        }
    }

    public void updateWeatherLoop(WeatherSoundEffect effect, float volume) {
        if (!soundEnabled) {
            stopWeatherLoop(effect);
            return;
        }

        Sound sound = weatherSounds.get(effect);
        if (sound != null) {
            Long currentId = loopingSoundIds.get(effect);

            if (currentId == null || !isPlaying(effect)) {
                // Start new loop
                long id = sound.loop(volume * soundVolume * masterVolume);
                loopingSoundIds.put(effect, id);
                loopingStartTimes.put(effect, System.currentTimeMillis());

                // Store duration based on effect type
                float duration = getEffectDuration(effect);
                loopingDurations.put(effect, duration);
            } else {
                // Update existing loop volume
                sound.setVolume(currentId, volume * soundVolume * masterVolume);
            }
        }
    }

    private float getEffectDuration(WeatherSoundEffect effect) {
        // Define durations for each effect (in seconds)
        switch (effect) {
            case LIGHT_RAIN:
            case WIND:
            case SAND_WIND:
                return 10.0f; // 10-second loop for ambient sounds
            case THUNDER:
                return 3.0f; // 3-second duration for thunder
            default:
                return 5.0f; // Default duration
        }
    }

    public void stopWeatherLoop(WeatherSoundEffect effect) {
        Sound sound = weatherSounds.get(effect);
        Long id = loopingSoundIds.get(effect);
        if (sound != null && id != null) {
            sound.stop(id);
            loopingSoundIds.remove(effect);
            loopingStartTimes.remove(effect);
            loopingDurations.remove(effect);
        }
    }

    public void stopAllWeatherLoops() {
        for (WeatherSoundEffect effect : WeatherSoundEffect.values()) {
            stopWeatherLoop(effect);
        }
    }

    private boolean isPlaying(WeatherSoundEffect effect) {
        Long startTime = loopingStartTimes.get(effect);
        Float duration = loopingDurations.get(effect);
        Long soundId = loopingSoundIds.get(effect);

        if (startTime == null || duration == null || soundId == null) {
            return false;
        }
        long currentTime = System.currentTimeMillis();
        long elapsedTime = currentTime - startTime;

        if (elapsedTime > duration * 1000) { // Convert duration to milliseconds
            loopingSoundIds.remove(effect);
            loopingStartTimes.remove(effect);
            return false;
        }

        return true;
    }

    public void playSound(AudioManager.SoundEffect effect) {
        if (!soundEnabled) return;

        Sound sound = sounds.get(effect);
        if (sound != null) {
            sound.play(soundVolume * masterVolume);
        }
    }

    private void initializeAudio() {
        // Load sound effects
        for (SoundEffect effect : SoundEffect.values()) {
            try {
                Sound sound = Gdx.audio.newSound(Gdx.files.internal(effect.getPath()));
                sounds.put(effect, sound);
            } catch (Exception e) {
                Gdx.app.error("AudioManager", "Failed to load sound: " + effect.getPath());
            }
        }
        menuMusicList = new ArrayList<>();
        loadMenuMusic(Arrays.asList(
            "music/Menu-Music-1.mp3",
            "music/Menu-Music-2.mp3",
            "music/Menu-Music-0.mp3",
            "music/Menu-Music-3.mp3",
            "music/Menu-Music-4.mp3"
        ));
        loadBiomeMusic(BiomeType.BEACH, (Arrays.asList("music/Beach-Biome-0.mp3", "music/Beach-Biome-1.mp3", "music/Beach-Biome-2.mp3")));
        loadBiomeMusic(BiomeType.OCEAN, (Arrays.asList("music/Ocean-Biome-0.mp3", "music/Ocean-Biome-1.mp3", "music/Ocean-Biome-2.mp3")));
        loadBiomeMusic(BiomeType.CHERRY_GROVE, (Arrays.asList("music/CherryGrove-Biome-0.mp3", "music/CherryGrove-Biome-1.mp3", "music/CherryGrove-Biome-2.mp3", "music/CherryGrove-Biome-3.mp3")));
        loadBiomeMusic(BiomeType.RUINS, (Arrays.asList("music/Ruins-Biome-0.mp3", "music/Ruins-Biome-1.mp3")));
        loadBiomeMusic(BiomeType.FOREST, (Arrays.asList("music/Forest-Biome-0.mp3", "music/Forest-Biome-1.mp3", "music/Forest-Biome-2.mp3", "music/Forest-Biome-3.mp3")));
        loadBiomeMusic(BiomeType.SNOW, (Arrays.asList("music/Snow-Biome-0.mp3", "music/Snow-Biome-1.mp3", "music/Snow-Biome-2.mp3")));
        loadBiomeMusic(BiomeType.HAUNTED, (Arrays.asList("music/Haunted-Biome-0.mp3", "music/Haunted-Biome-1.mp3")));
        loadBiomeMusic(BiomeType.PLAINS, (Arrays.asList("music/Plains-Biome-0.mp3", "music/Plains-Biome-1.mp3", "music/Plains-Biome-2.mp3", "music/Plains-Biome-3.mp3", "music/Plains-Biome-4.mp3")));
        loadBiomeMusic(BiomeType.RAIN_FOREST, (Arrays.asList("music/RainForest-Biome-0.mp3", "music/RainForest-Biome-1.mp3", "music/RainForest-Biome-2.mp3", "music/RainForest-Biome-3.mp3")));
        loadBiomeMusic(BiomeType.DESERT, (Arrays.asList("music/Desert-Biome-0.mp3", "music/Desert-Biome-1.mp3", "music/Desert-Biome-2.mp3", "music/Desert-Biome-3.mp3", "music/Desert-Biome-4.mp3")));

    }

    private void loadMenuMusic(List<String> paths) {
        for (String path : paths) {
            try {
                Music music = Gdx.audio.newMusic(Gdx.files.internal(path));
                music.setVolume(musicVolume * masterVolume);
                menuMusicList.add(music);
            } catch (Exception e) {
                Gdx.app.error("AudioManager", "Failed to load menu music: " + path + ", error: " + e.getMessage(), e);
            }
        }
    }

    private void loadBiomeMusic(BiomeType biome, List<String> paths) {
        List<Music> musicList = new ArrayList<>();
        for (String path : paths) {
            try {
                Music music = Gdx.audio.newMusic(Gdx.files.internal(path));
                music.setVolume(musicVolume * masterVolume);
                musicList.add(music);
            } catch (Exception e) {
                Gdx.app.error("AudioManager", "Failed to load music: " + path + ", error: " + e.getMessage(), e);
            }
        }
        biomeMusic.put(biome, musicList);
    }


    public void playMenuMusic() {
        if (musicEnabled && (currentMusic == null || !currentMusic.isPlaying())) {
            stopCurrentMusic();
            int index = MathUtils.random(menuMusicList.size() - 1);
            currentMusic = menuMusicList.get(index);
            currentBiome = null;
            currentMusic.setVolume(0f);
            currentMusic.setLooping(false);
            currentMusic.play();
            isFadingInMusic = true;
            fadeInMusicTimer = MUSIC_FADE_DURATION;
            setMusicCompletionListenerForMenu();
        }
    }

    private void setMusicCompletionListenerForMenu() {
        if (currentMusic != null) {
            currentMusic.setOnCompletionListener(music -> {
                // Play next menu music track
                playMenuMusic();
            });
        }
    }

    public void stopMenuMusic() {
        if (currentMusic != null && menuMusicList.contains(currentMusic)) {
            isFadingOutMusic = true;
            fadeOutMusicTimer = MUSIC_FADE_DURATION;
        }
    }

    public float getMusicVolume() {
        return musicVolume;
    }

    public void setMusicVolume(float musicVolume) {
        this.musicVolume = musicVolume;
        updateVolumes();
    }

    public float getSoundVolume() {
        return soundVolume;
    }

    public void setSoundVolume(float soundVolume) {
        this.soundVolume = soundVolume;
        // Optionally update volumes of looping sounds
        updateSoundVolumes();
    }

    public boolean isMusicEnabled() {
        return musicEnabled;
    }

    public void setMusicEnabled(boolean musicEnabled) {
        this.musicEnabled = musicEnabled;
        if (currentMusic != null) {
            if (musicEnabled) {
                if (!currentMusic.isPlaying()) {
                    currentMusic.play();
                }
                currentMusic.setVolume(musicVolume * masterVolume);
            } else {
                currentMusic.pause();
            }
        }
    }

    public boolean isSoundEnabled() {
        return soundEnabled;
    }

    public void setSoundEnabled(boolean soundEnabled) {
        this.soundEnabled = soundEnabled;
        if (!soundEnabled) {
            // Stop all playing sounds if necessary
            stopAllWeatherLoops();
            stopAllAmbientSounds();
        }
    }

    public void fadeOutMenuMusic() {
    }

    public void updateBiomeMusic(BiomeType newBiome) {
        if (!musicEnabled || (pendingBiome != null && newBiome == pendingBiome)) return;

        if (currentBiome != newBiome) {
            pendingBiome = newBiome;
            GameLogger.info("Pending biome set to: " + pendingBiome);

            if (currentMusic != null && menuMusicList.contains(currentMusic)) {
                isFadingOutMusic = true;
                fadeOutMusicTimer = MUSIC_FADE_DURATION;
            } else if (currentMusic == null || !currentMusic.isPlaying()) {
                startMusicForPendingBiome();
            }
        }
    }

    private void startMusicForPendingBiome() {
        if (pendingBiome != null) {
            List<Music> musicList = biomeMusic.get(pendingBiome);
            if (musicList != null && !musicList.isEmpty()) {
                int index = MathUtils.random(musicList.size() - 1);
                currentMusic = musicList.get(index);
                currentBiome = pendingBiome;
                pendingBiome = null;
                currentMusic.setVolume(0f); // Start from 0 volume for fade-in
                currentMusic.setLooping(false); // Don't loop so it can end naturally
                currentMusic.play();
                GameLogger.info("Started playing music for biome: " + currentBiome);
                setMusicCompletionListener();
                isFadingInMusic = true; // Flag to start fade-in
                fadeInMusicTimer = MUSIC_FADE_DURATION;
            } else {
                GameLogger.error("No music found for biome: " + pendingBiome);
                currentMusic = null;
                currentBiome = null;
                pendingBiome = null;
            }
        } else {
            currentMusic = null;
            currentBiome = null;
        }
    }


    public void update(float delta) {

        if (isFadingInMusic && currentMusic != null) {
            fadeInMusicTimer -= delta;
            float progress = 1 - Math.max(0, fadeInMusicTimer / MUSIC_FADE_DURATION);
            float volume = progress * musicVolume * masterVolume;
            currentMusic.setVolume(volume);

            if (fadeInMusicTimer <= 0) {
                isFadingInMusic = false;
                currentMusic.setVolume(musicVolume * masterVolume);
            }
        }
        if (isFadingOutMusic && currentMusic != null) {
            fadeOutMusicTimer -= delta;
            float volume = Math.max(0, (fadeOutMusicTimer / MUSIC_FADE_DURATION) * musicVolume * masterVolume);
            currentMusic.setVolume(volume);

            if (fadeOutMusicTimer <= 0) {
                currentMusic.stop();
                isFadingOutMusic = false;
                currentMusic = null;
                if (pendingBiome != null) {
                    startMusicForPendingBiome();
                } else if (menuMusicList.contains(null)) {
                    playMenuMusic();
                }
            }
        }
    }

    private void stopCurrentMusic() {
        if (currentMusic != null) {
            isFadingOutMusic = true;
            fadeOutMusicTimer = MUSIC_FADE_DURATION;
        }
    }


    private void setMusicCompletionListener() {
        if (currentMusic != null) {
            currentMusic.setOnCompletionListener(music -> {
                if (pendingBiome != null && pendingBiome != currentBiome) {
                    // Biome has changed, start music for new biome
                    startMusicForPendingBiome();
                } else {
                    // Biome hasn't changed, pick another random song from currentBiome
                    pendingBiome = currentBiome; // Ensure pendingBiome is set
                    startMusicForPendingBiome();
                }
            });
        }
    }

    public void dispose() {
        for (Sound sound : sounds.values()) {
            sound.dispose();
        }
        loopingStartTimes.clear();
        loopingDurations.clear();

        for (List<Music> musicList : biomeMusic.values()) {
            for (Music music : musicList) {
                music.dispose();
            }
        }
        biomeMusic.clear();
        for (Sound sound : customSounds.values()) {
            sound.dispose();
        }
        sounds.clear();
        biomeMusic.clear();
        customSounds.clear();
        for (Sound sound : weatherSounds.values()) {
            sound.dispose();
        }
        stopAllAmbientSounds();
        for (Sound sound : ambientSounds.values()) {
            sound.dispose();
        }
        ambientSounds.clear();
        weatherSounds.clear();
        loopingSoundIds.clear();
    }

    public enum AmbientSoundType {
        ;

        private final String path;

        AmbientSoundType(String path) {
            this.path = path;
        }

        public String getPath() {
            return path;
        }
    }


    public enum WeatherSoundEffect {
        LIGHT_RAIN("sounds/weather/rain.ogg"),
        THUNDER("sounds/weather/thunder.ogg"),
        WIND("sounds/weather/wind.ogg"),
        SAND_WIND("sounds/weather/sandwind.ogg");

        private final String path;

        WeatherSoundEffect(String path) {
            this.path = path;
        }

        public String getPath() {
            return path;
        }
    }

    public enum SoundEffect {
        POKEMON_SENDOUT("sounds/SENDOUT.ogg"),
        POKEMON_RETURN("sounds/RETREAT.ogg"),
        ITEM_PICKUP("sounds/pickup.ogg"),
        ITEM_PICKUP_OW("sounds/item_ow_pickup.ogg"),
        MENU_SELECT("sounds/select.ogg"),
        MENU_BACK("sounds/back.ogg"),
        BATTLE_WIN("sounds/battle_win.ogg"),
        CRITICAL_HIT("sounds/critical_hit.ogg"),
        CURSOR_MOVE("sounds/cursor_move.ogg"),
        DAMAGE("sounds/damage.ogg"),
        COLLIDE("sounds/player-bump.ogg"),
        MOVE_SELECT("sounds/move_select.ogg"),
        NOT_EFFECTIVE("sounds/not_effective.ogg"),
        SUPER_EFFECTIVE("sounds/super_effective.ogg"),
        CRAFT("sounds/crafting.ogg"),
        BLOCK_PLACE_0("sounds/block_place_0.ogg"),
        BLOCK_PLACE_1("sounds/block_place_1.ogg"),
        BLOCK_PLACE_2("sounds/block_place_2.ogg"),
        BLOCK_BREAK_WOOD("sounds/break_wood.ogg"),
        TOOL_BREAK("sounds/tool_break.ogg"),
        BLOCK_BREAK_WOOD_HAND("sounds/break_wood_hand.ogg"),
        PUDDLE("sounds/puddle.ogg"),
        CHEST_OPEN("sounds/chest-open.ogg"),
        CHEST_CLOSE("sounds/chest-close.ogg"),
        HOUSE_BUILD("sounds/house_build.ogg");

        private final String path;

        SoundEffect(String path) {
            this.path = path;
        }

        public String getPath() {
            return path;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/blocks/BlockManager.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.BlockTextureManager;

public class BlockManager {
    private boolean initialized = false;


    public BlockManager() {
        GameLogger.info("Initialized BlockManager");
    }

    public boolean placeBlockFromPlayer(PlaceableBlock.BlockType type) {
        if (type == null || GameContext.get().getPlayer() == null || GameContext.get().getWorld() == null) {
            GameLogger.error("Invalid parameters for player block placement");
            return false;
        }

        Vector2 targetPos = calculateTargetPosition(GameContext.get().getPlayer());
        int targetX = (int) targetPos.x;
        int targetY = (int) targetPos.y;

        GameLogger.info("Checking placement - Player(" + GameContext.get().getPlayer().getTileX() + "," + GameContext.get().getPlayer().getTileY() +
            ") Target(" + targetX + "," + targetY + ") Dir:" + GameContext.get().getPlayer().getDirection());

        if (!isValidPlacement(targetX, targetY, GameContext.get().getWorld())) {
            return false;
        }

        if (GameContext.get().getGameClient() != null && GameContext.get().isMultiplayer()) {
            NetworkProtocol.BlockPlacement placement = new NetworkProtocol.BlockPlacement();
            placement.username = GameContext.get().getPlayer().getUsername();
            placement.blockTypeId = type.id;
            placement.tileX = targetX;
            placement.tileY = targetY;
            placement.action = NetworkProtocol.BlockAction.PLACE;
            GameContext.get().getGameClient().sendBlockPlacement(placement);
        }
        return placeBlock(type, targetX, targetY);
    }

    private Vector2 calculateTargetPosition(Player player) {
        int targetX = player.getTileX();
        int targetY = player.getTileY();

        switch (player.getDirection()) {
            case "up":
                targetY++;
                break;
            case "down":
                targetY--;
                break;
            case "left":
                targetX--;
                break;
            case "right":
                targetX++;
                break;
        }

        return new Vector2(targetX, targetY);
    }


    public PlaceableBlock getBlockAt(int worldX, int worldY) {
        Chunk chunk = GameContext.get().getWorld().getChunkAtPosition(worldX, worldY);
        if (chunk == null) return null;
        Vector2 blockPos = new Vector2(worldX, worldY);
        return chunk.getBlock(blockPos);
    }

    private boolean isValidPlacement(int tileX, int tileY, World world) {
        if (!world.isPassable(tileX, tileY)) {
            GameLogger.info("Cannot place at non-passable location");
            return false;
        }

        return true;
    }


    public boolean placeBlock(PlaceableBlock.BlockType type, int tileX, int tileY) {
        // Calculate the chunk position
        int chunkX = Math.floorDiv(tileX, Chunk.CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, Chunk.CHUNK_SIZE);
        Vector2 chunkPos = new Vector2(chunkX, chunkY);

        // Get or load the chunk
        Chunk chunk = GameContext.get().getWorld().getChunkAtPosition(tileX, tileY);
        if (chunk == null) {
            chunk = GameContext.get().getWorld().loadOrGenerateChunk(chunkPos);
            GameContext.get().getWorld().getChunks().put(chunkPos, chunk);
        }

        // Check if there's already a block at this position
        Vector2 blockPos = new Vector2(tileX, tileY);
        if (chunk.getBlock(blockPos) != null) {
            GameLogger.info("Block already exists at position: " + blockPos);
            return false; // Can't place block on top of another block
        }

        // Create the block
        PlaceableBlock block = new PlaceableBlock(type, blockPos, null, false);

        // Set the texture
        block.setTexture(BlockTextureManager.getBlockFrame(block, 0));

        // Add the block to the chunk
        chunk.addBlock(block);
        chunk.setDirty(true); // Mark chunk as dirty for saving
        GameLogger.info("Placed block of type " + type + " at " + blockPos);

        return true;
    }


    public void removeBlock(int tileX, int tileY) {
        // Calculate the chunk position
        int chunkX = Math.floorDiv(tileX, Chunk.CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, Chunk.CHUNK_SIZE);
        Vector2 chunkPos = new Vector2(chunkX, chunkY);

        // Get the chunk
        Chunk chunk = GameContext.get().getWorld().getChunkAtPosition(tileX, tileY);
        if (chunk == null) {
            GameLogger.info("Chunk not loaded at position: " + chunkPos);
            return;
        }

        // Check if there's a block at this position
        Vector2 blockPos = new Vector2(tileX, tileY);
        PlaceableBlock block = chunk.getBlock(blockPos);
        if (block == null) {
            GameLogger.info("No block exists at position: " + blockPos);
            return; // Can't remove a block that doesn't exist
        }

        // Remove the block from the chunk
        chunk.removeBlock(blockPos);
        chunk.setDirty(true); // Mark chunk as dirty for saving
        GameLogger.info("Removed block at " + blockPos);

    }

    public boolean isInitialized() {
        return initialized;
    }


    public boolean hasCollisionAt(int tileX, int tileY) {
        PlaceableBlock block = getBlockAt(tileX, tileY);
        return block != null && block.getType().hasCollision;
    }

    public void render(SpriteBatch batch, double worldTimeInMinutes) {
        for (Chunk chunk : GameContext.get().getWorld().getChunks().values()) {
            for (PlaceableBlock block : chunk.getBlocks().values()) {
                TextureRegion currentFrame = BlockTextureManager.getBlockFrame(
                    block, (float) worldTimeInMinutes
                );

                if (currentFrame != null) {
                    float tileX = block.getPosition().x * World.TILE_SIZE;
                    float tileY = block.getPosition().y * World.TILE_SIZE;
                    float blockWidth = currentFrame.getRegionWidth();
                    float blockHeight = currentFrame.getRegionHeight();
                    float offsetX = (World.TILE_SIZE - blockWidth) / 2;
                    float offsetY = 0;

                    Color originalColor = batch.getColor().cpy();

                    // Get light level for this block's position
                    Vector2 tilePos = block.getPosition();
                    Float lightLevel = GameContext.get().getWorld().getLightLevelAtTile(tilePos);

                    // Apply light level if it exists
                    if (lightLevel != null && lightLevel > 0) {
                        Color lightColor = new Color(1f, 0.8f, 0.6f, 1f);
                        Color baseColor = GameContext.get().getWorld().getCurrentWorldColor().cpy();
                        baseColor.lerp(lightColor, lightLevel * 0.7f);
                        batch.setColor(baseColor);
                    } else {
                        batch.setColor(GameContext.get().getWorld().getCurrentWorldColor());
                    }

                    // Handle flipped rendering
                    if (block.isFlipped()) {
                        batch.draw(currentFrame,
                            tileX + offsetX + blockWidth, // X position (offset + width for flip)
                            tileY + offsetY,              // Y position
                            -blockWidth,                  // Negative width for horizontal flip
                            blockHeight                   // Normal height
                        );
                    } else {
                        batch.draw(currentFrame,
                            tileX + offsetX,
                            tileY + offsetY,
                            blockWidth,
                            blockHeight
                        );
                    }

                    // Restore original color
                    batch.setColor(originalColor);
                }
            }
        }
    }


}

================
File: src/main/java/io/github/pokemeetup/blocks/BuildingData.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.graphics.g2d.TextureRegion;

import java.util.HashMap;
import java.util.Map;

public class BuildingData {
    private final String id;
    private final String name;
    private final Map<String, Integer> requirements;
    private final BuildingTemplate template;
    private TextureRegion previewTexture;

    public void setPreviewTexture(TextureRegion texture) {
        this.previewTexture = texture;
    }

    public TextureRegion getPreviewTexture() {
        return previewTexture;
    }
    public BuildingData(String id, String name, BuildingTemplate template) {
        this.id = id;
        this.name = name;
        this.template = template;
        this.requirements = new HashMap<>();
    }

    public void addRequirement(String itemId, int amount) {
        requirements.put(itemId, amount);
    }

    public String getId() { return id; }
    public String getName() { return name; }
    public Map<String, Integer> getRequirements() { return requirements; }
    public BuildingTemplate getTemplate() { return template; }

    public static class BuildingSlot {
        public BuildingData buildingData;
        public boolean isLocked;

        public BuildingSlot(BuildingData data, boolean locked) {
            this.buildingData = data;
            this.isLocked = locked;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/blocks/BuildingTemplate.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.utils.GameLogger;

public class BuildingTemplate {
    private final int width;
    private final int height;
    private final BlockData[][] layout;

    public BuildingTemplate(int width, int height) {
        this.width = width;
        this.height = height;
        this.layout = new BlockData[width][height];
    }

    public static BuildingTemplate createWoodenHouse() {
        BuildingTemplate template = new BuildingTemplate(5, 4);

        template.setBlock(2, 0, new BlockData(PlaceableBlock.BlockType.WOODEN_DOOR, false));
        template.setBlock(0, 0, new BlockData(PlaceableBlock.BlockType.HOUSE_PART, false));
        template.setBlock(1, 0, new BlockData(PlaceableBlock.BlockType.HOUSE_PLANKS, false));
        template.setBlock(3, 0, new BlockData(PlaceableBlock.BlockType.HOUSE_PLANKS, true));
        template.setBlock(4, 0, new BlockData(PlaceableBlock.BlockType.HOUSE_PART, true));

        template.setBlock(0, 1, new BlockData(PlaceableBlock.BlockType.HOUSE_MIDDLE_PART, false));
        template.setBlock(1, 1, new BlockData(PlaceableBlock.BlockType.HOUSE_MIDDLE_PART_1, false));
        template.setBlock(2, 1, new BlockData(PlaceableBlock.BlockType.HOUSE_MIDDLE_PART_0, false));
        template.setBlock(3, 1, new BlockData(PlaceableBlock.BlockType.HOUSE_MIDDLE_PART_1, true));
        template.setBlock(4, 1, new BlockData(PlaceableBlock.BlockType.HOUSE_MIDDLE_PART, true));

        template.setBlock(0, 2, new BlockData(PlaceableBlock.BlockType.ROOFINNER, false));
        template.setBlock(1, 2, new BlockData(PlaceableBlock.BlockType.ROOF_MIDDLE_OUTSIDE, false));
        template.setBlock(2, 2, new BlockData(PlaceableBlock.BlockType.ROOF_MIDDLE_OUTER, false));
        template.setBlock(3, 2, new BlockData(PlaceableBlock.BlockType.ROOF_MIDDLE_OUTSIDE, true));
        template.setBlock(4, 2, new BlockData(PlaceableBlock.BlockType.ROOFINNER, true));

        template.setBlock(0, 3, new BlockData(PlaceableBlock.BlockType.ROOF_CORNER, false));
        template.setBlock(1, 3, new BlockData(PlaceableBlock.BlockType.ROOF_CORNER_1, false));
        template.setBlock(2, 3, new BlockData(PlaceableBlock.BlockType.ROOF_MIDDLE, false));
        template.setBlock(3, 3, new BlockData(PlaceableBlock.BlockType.ROOF_CORNER_1, true));
        template.setBlock(4, 3, new BlockData(PlaceableBlock.BlockType.ROOF_CORNER, true));

        return template;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    public BlockData[][] getLayout() {
        return layout;
    }

    public BlockData getBlockAt(int x, int y) {
        if (x < 0 || x >= width || y < 0 || y >= height) {
            return null;
        }
        return layout[x][y];
    }

    public void setBlock(int x, int y, BlockData blockData) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
            layout[x][y] = blockData;
        }
    }

    public boolean placeBuilding(World world, int startX, int startY) {
        // Check if area is clear
        if (!canPlaceAt(world, startX, startY)) {
            GameLogger.info("Cannot place building - area not clear");
            return false;
        }

        try {
            // Place all blocks
            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    BlockData blockData = layout[x][y];
                    if (blockData != null) {
                        Vector2 pos = new Vector2(startX + x, startY + y);
                        boolean placed = world.getBlockManager().placeBlock(blockData.type, startX + x, startY + y);
                        if (!placed) {
                            GameLogger.error("Failed to place block at " + pos + " of type " + blockData.type);
                            return false;
                        }
                        PlaceableBlock placedBlock = world.getBlockManager().getBlockAt(startX + x, startY + y);
                        if (placedBlock != null && blockData.isFlipped) {
                            placedBlock.toggleFlip();
                            // Mark the chunk as dirty so flipping is saved
                            int chunkX = Math.floorDiv((int) placedBlock.getPosition().x, World.CHUNK_SIZE);
                            int chunkY = Math.floorDiv((int) placedBlock.getPosition().y, World.CHUNK_SIZE);
                            Chunk chunk = world.getChunks().get(new Vector2(chunkX, chunkY));
                            if (chunk != null) {
                                chunk.setDirty(true);
                            }
                        }
                        GameLogger.info("Placed block: " + blockData.type + " at " + pos +
                            " flipped: " + blockData.isFlipped);
                    }
                }
            }
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.HOUSE_BUILD);
            return true;
        } catch (Exception e) {
            GameLogger.error("Error placing building: " + e.getMessage());
            return false;
        }
    }

    private boolean canPlaceAt(World world, int startX, int startY) {
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                if (!world.isPassable(startX + x, startY + y) ||
                    world.getBlockManager().getBlockAt(startX + x, startY + y) != null) {
                    return false;
                }
            }
        }
        return true;
    }

    public NetworkProtocol.BuildingPlacement toNetworkMessage(String username, int startX, int startY) {
        NetworkProtocol.BuildingPlacement bp = new NetworkProtocol.BuildingPlacement();
        bp.username = username;
        bp.startX = startX;
        bp.startY = startY;
        bp.width = this.width;
        bp.height = this.height;
        bp.blockTypeIds = new String[width][height];
        bp.flippedFlags = new boolean[width][height];
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                BlockData data = this.getBlockAt(x, y);
                if (data != null) {
                    bp.blockTypeIds[x][y] = data.type.id;
                    bp.flippedFlags[x][y] = data.isFlipped;
                } else {
                    bp.blockTypeIds[x][y] = "";
                    bp.flippedFlags[x][y] = false;
                }
            }
        }
        bp.timestamp = System.currentTimeMillis();
        return bp;
    }

    public static class BlockData {
        public PlaceableBlock.BlockType type;
        public boolean isFlipped;

        public BlockData(PlaceableBlock.BlockType type, boolean isFlipped) {
            this.type = type;
            this.isFlipped = isFlipped;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/blocks/ConnectionPattern.java
================
package io.github.pokemeetup.blocks;

public class ConnectionPattern {
    public static final ConnectionPattern NONE = new ConnectionPattern(false, false, false, false);

    private final boolean north;
    private final boolean south;
    private final boolean east;
    private final boolean west;

    public ConnectionPattern(boolean north, boolean south, boolean east, boolean west) {
        this.north = north;
        this.south = south;
        this.east = east;
        this.west = west;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ConnectionPattern)) return false;
        ConnectionPattern that = (ConnectionPattern) o;
        return north == that.north &&
            south == that.south &&
            east == that.east &&
            west == that.west;
    }

    @Override
    public int hashCode() {
        int result = (north ? 1 : 0);
        result = 31 * result + (south ? 1 : 0);
        result = 31 * result + (east ? 1 : 0);
        result = 31 * result + (west ? 1 : 0);
        return result;
    }
}

================
File: src/main/java/io/github/pokemeetup/blocks/PlaceableBlock.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

public class PlaceableBlock {
    private static final float CHEST_ANIMATION_DURATION = 0.3f;
    private final String id;
    private final Vector2 position;
    private final BlockType type;
    private transient TextureRegion texture;
    private boolean isChestOpen = false;
    private float animationTime = 0;
    private ChestData chestData;
    private boolean isFlipped = false;

    public PlaceableBlock(BlockType type, Vector2 position, TextureRegion texture, boolean isFlipped) {
        this.type = type;
        this.id = type.id;
        this.isFlipped = isFlipped;
        this.position = position;
        this.texture = texture;
        if (type == BlockType.CHEST) {
            this.chestData = new ChestData((int) position.x, (int) position.y);
        }
    }

    public PlaceableBlock(BlockType type, Vector2 position) {
        this.type = type;
        this.position = position;
        this.texture = null;
        this.id = type.id;
    }

    public boolean isChestOpen() {
        return isChestOpen;
    }

    public void setChestOpen(boolean isOpen) {
        this.isChestOpen = isOpen;
    }

    public boolean isFlipped() {
        return isFlipped;
    }

    public void toggleFlip() {
        if (type.isFlippable) {
            isFlipped = !isFlipped;
        }
    }


    public void render(SpriteBatch batch, float x, float y) {
        if (type == BlockType.CHEST) {
            TextureRegion chestTexture = isChestOpen ?
                TextureManager.blocks.findRegion("chest", 1) :
                TextureManager.blocks.findRegion("chest", 0);
            float width = chestTexture.getRegionWidth();
            float height = chestTexture.getRegionHeight();

            if (isFlipped) {
                batch.draw(chestTexture,
                    x + width, y,        // Position (x + width for flip)
                    -width, height);     // Negative width for horizontal flip
            } else {
                batch.draw(chestTexture, x, y);
            }
        } else if (texture != null) {
            float width = texture.getRegionWidth();
            float height = texture.getRegionHeight();

            if (isFlipped) {
                batch.draw(texture,
                    x + width, y,        // Position (x + width for flip)
                    -width, height);
            } else {
                batch.draw(texture, x, y);
            }
        }
    }

    public ChestData getChestData() {
        return chestData;
    }

    public void setChestData(ChestData chestData) {
        this.chestData = chestData;
    }

    public void update(float delta) {
        if (type == BlockType.CHEST) {
            if (isChestOpen) {
                animationTime = Math.min(animationTime + delta, CHEST_ANIMATION_DURATION);
            } else {
                animationTime = Math.max(animationTime - delta, 0);
            }
        }
    }

    public BlockType getType() {
        return type;
    }

    public Vector2 getPosition() {
        return position;
    }

    public TextureRegion getTexture() {
        return texture;
    }

    public void setTexture(TextureRegion texture) {
        this.texture = texture;
    }

    public String getId() {
        return id;
    }


    public enum BlockType {
        CRAFTINGTABLE("craftingtable", true, true, 4.0f, ItemManager.ItemIDs.CRAFTING_TABLE, false),
        WOODEN_PLANKS("wooden_planks", true, true, 3.0f, ItemManager.ItemIDs.WOODEN_PLANKS, true),
        HOUSE_PLANKS("house_planks", true, true, 3.0f, ItemManager.ItemIDs.HOUSE_PLANKS, true),
        WOODEN_DOOR("wooden_door", true, true, 3.0f, ItemManager.ItemIDs.WOODEN_DOOR, true),
        CHEST("chest", true, true, 4.0f, ItemManager.ItemIDs.CHEST, false),
        FURNACE("furnace", true, true, 8.0f, ItemManager.ItemIDs.FURNACE, false),
        ROOF_MIDDLE("roof_middle", true, true, 6.0f, ItemManager.ItemIDs.ROOF_MIDDLE, true),
        ROOF_CORNER("roof_corner", true, true, 3.0f, ItemManager.ItemIDs.ROOF_CORNER, true),
        HOUSE_PART("house_part", true, true, 3.0f, ItemManager.ItemIDs.HOUSE_PART, true),
        ROOF_INSIDE("roof_inside", true, true, 3.0f, ItemManager.ItemIDs.ROOF_INSIDE, true),
        HOUSE_MIDDLE_PART("house_midsection_part", true, true, 4.0f, ItemManager.ItemIDs.HOUSE_MIDDLE_PART, true),
        HOUSE_MIDDLE_PART_0("house_middlesection", true, true, 4.0f, ItemManager.ItemIDs.HOUSE_MIDDLE_PART_0, true),
        HOUSE_MIDDLE_PART_1("house_middlesection_part", true, true, 4.0f, ItemManager.ItemIDs.HOUSE_MIDDLE_PART_1, true),
        ROOF_CORNER_1("roof_middle_part", true, true, 4.0f, ItemManager.ItemIDs.ROOF_CORNER_1, true),
        ROOF_MIDDLE_OUTSIDE("roof_middle_outside", true, true, 4.0f, ItemManager.ItemIDs.ROOF_CORNER_1, true),
        ROOFINNER("roofinner", true, true, 3.0f, ItemManager.ItemIDs.ROOFINNER, true),
        ROOF_MIDDLE_OUTERSIDE("roof_middle_outerside", true, true, 4.0f, ItemManager.ItemIDs.ROOF_CORNER_1, true),
        ROOF_MIDDLE_OUTER("roof_middle_outer", true, true, 4.0f, ItemManager.ItemIDs.ROOF_CORNER_1, true);

        public final String id;
        public final boolean interactive;
        public final boolean isFlippable;
        public final boolean hasCollision;
        public final float breakTime;
        public final String itemId;

        BlockType(String id, boolean interactive, boolean hasCollision, float breakTime, String itemId, boolean isFlippable) {
            this.id = id;
            this.isFlippable = isFlippable;
            this.interactive = interactive;
            this.hasCollision = hasCollision;
            this.breakTime = breakTime;
            this.itemId = itemId;

        }

        public static BlockType fromId(String id) {
            for (BlockType type : values()) {
                if (type.id.equalsIgnoreCase(id)) {
                    return type;
                }
            }
            return null;
        }


        public static BlockType fromItemId(String itemId) {
            if (itemId == null) return null;
            try {
                return valueOf(itemId.toUpperCase());
            } catch (IllegalArgumentException e) {
                for (BlockType type : values()) {
                    if (type.itemId.equalsIgnoreCase(itemId) ||
                        type.id.equalsIgnoreCase(itemId.replace("_item", ""))) {
                        return type;
                    }
                }
                GameLogger.error("No matching block type for item: " + itemId);
                return null;
            }
        }

        public float getBreakTime(boolean hasAxe) {
            return hasAxe ? breakTime * 0.5f : breakTime * 1.5f;
        }

        public String getId() {
            return id;
        }
    }

}

================
File: src/main/java/io/github/pokemeetup/blocks/SmartBlockConfig.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.utils.GameLogger;
import java.util.*;

public class SmartBlockConfig {
    private final Map<ConnectionPattern, PlaceableBlock.BlockType> variants = new HashMap<>();
    private final String groupId;

    public SmartBlockConfig(String groupId) {
        this.groupId = groupId;
    }

    public void addVariant(ConnectionPattern pattern, PlaceableBlock.BlockType blockType) {
        variants.put(pattern, blockType);
        GameLogger.info("Added variant for " + groupId + ": " + blockType.getId());
    }

    public PlaceableBlock.BlockType getVariantForPattern(ConnectionPattern pattern) {
        return variants.getOrDefault(pattern, getDefaultVariant());
    }

    public boolean containsBlockType(PlaceableBlock.BlockType blockType) {
        return variants.containsValue(blockType);
    }

    private PlaceableBlock.BlockType getDefaultVariant() {
        return variants.values().iterator().next();
    }

}

================
File: src/main/java/io/github/pokemeetup/blocks/SmartBuildingManager.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import java.util.*;

public class SmartBuildingManager {
    private final World world;
    private final Map<String, SmartBlockConfig> smartBlocks = new HashMap<>();
    private final Map<String, BuildingTemplate> buildingTemplates = new HashMap<>();

    public SmartBuildingManager(World world) {
        this.world = world;
        initializeSmartBlocks();
        initializeBuildingTemplates();
    }

    private void initializeBuildingTemplates() {
        buildingTemplates.put("wooden_house", BuildingTemplate.createWoodenHouse());
    }

    private void initializeSmartBlocks() {
        // Initialize roof configuration
        SmartBlockConfig roofConfig = new SmartBlockConfig("roof");
        roofConfig.addVariant(new ConnectionPattern(false, true, true, true),
            PlaceableBlock.BlockType.ROOF_CORNER);
        roofConfig.addVariant(new ConnectionPattern(true, true, true, true),
            PlaceableBlock.BlockType.ROOF_MIDDLE);
        roofConfig.addVariant(new ConnectionPattern(true, false, true, true),
            PlaceableBlock.BlockType.ROOF_INSIDE);
        smartBlocks.put("roof", roofConfig);

        // Initialize wall configuration
        SmartBlockConfig wallConfig = new SmartBlockConfig("wall");
        wallConfig.addVariant(new ConnectionPattern(true, true, false, false),
            PlaceableBlock.BlockType.WOODEN_PLANKS);
        wallConfig.addVariant(new ConnectionPattern(false, true, true, true),
            PlaceableBlock.BlockType.HOUSE_MIDDLE_PART);
        smartBlocks.put("wall", wallConfig);

        GameLogger.info("Initialized smart block configurations");
    }

    public PlaceableBlock.BlockType getSmartBlockType(String groupId, int x, int y) {
        SmartBlockConfig config = smartBlocks.get(groupId);
        if (config == null) return null;
        ConnectionPattern pattern = calculateConnectionPattern(groupId, x, y);
        return config.getVariantForPattern(pattern);
    }

    private ConnectionPattern calculateConnectionPattern(String groupId, int x, int y) {
        boolean north = hasConnection(groupId, x, y + 1);
        boolean south = hasConnection(groupId, x, y - 1);
        boolean east = hasConnection(groupId, x + 1, y);
        boolean west = hasConnection(groupId, x - 1, y);
        return new ConnectionPattern(north, south, east, west);
    }

    private boolean hasConnection(String groupId, int x, int y) {
        PlaceableBlock block = world.getBlockManager().getBlockAt(x, y);
        if (block == null) return false;
        SmartBlockConfig config = smartBlocks.get(groupId);
        return config != null && config.containsBlockType(block.getType());
    }

    public void updateSurroundingBlocks(int x, int y, String groupId) {
        updateBlockIfNeeded(x + 1, y, groupId);
        updateBlockIfNeeded(x - 1, y, groupId);
        updateBlockIfNeeded(x, y + 1, groupId);
        updateBlockIfNeeded(x, y - 1, groupId);
    }

    private void updateBlockIfNeeded(int x, int y, String groupId) {
        PlaceableBlock existingBlock = world.getBlockManager().getBlockAt(x, y);
        if (existingBlock == null) return;
        SmartBlockConfig config = smartBlocks.get(groupId);
        if (config != null && config.containsBlockType(existingBlock.getType())) {
            PlaceableBlock.BlockType newType = getSmartBlockType(groupId, x, y);
            if (newType != null && newType != existingBlock.getType()) {
                world.getBlockManager().placeBlock(newType, x, y);
            }
        }
    }

    public String getGroupIdForBlockType(PlaceableBlock.BlockType blockType) {
        for (Map.Entry<String, SmartBlockConfig> entry : smartBlocks.entrySet()) {
            if (entry.getValue().containsBlockType(blockType)) {
                return entry.getKey();
            }
        }
        return null;
    }
}

================
File: src/main/java/io/github/pokemeetup/chat/ChatSystem.java
================
package io.github.pokemeetup.chat;

import com.badlogic.gdx.Application;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.InputManager;  // <--- For setUIState
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.TimeUtils;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class ChatSystem extends Table {
    public static final float CHAT_PADDING = 10f;
    public static final float MIN_CHAT_WIDTH = 250f;
    public static final float MIN_CHAT_HEIGHT = 200f;
    private static final int MAX_MESSAGES = 50;
    private static final float MESSAGE_FADE_TIME = 10f;
    private static final Color WINDOW_BACKGROUND = new Color(0, 0, 0, 0.8f);

    private static final Color[] CHAT_COLORS = {
        new Color(0.8f, 0.3f, 0.3f, 1), // Red
        new Color(0.3f, 0.8f, 0.3f, 1), // Green
        new Color(0.3f, 0.3f, 0.8f, 1), // Blue
        new Color(0.8f, 0.8f, 0.3f, 1), // Yellow
        new Color(0.8f, 0.3f, 0.8f, 1), // Purple
        new Color(0.3f, 0.8f, 0.8f, 1), // Cyan
        new Color(0.8f, 0.5f, 0.3f, 1), // Orange
        new Color(0.5f, 0.8f, 0.3f, 1)  // Lime
    };

    private final List<String> messageHistory = new ArrayList<>();
    private final Stage stage;
    private final Skin skin;
    private final GameClient gameClient;
    private final String username;
    private final Queue<ChatMessage> messages;
    private final CommandManager commandManager;
    private boolean commandsEnabled;

    private int messageHistoryIndex = -1; // -1 => no history selected
    private Table chatWindow;
    private ScrollPane messageScroll;
    private Table messageTable;
    private boolean isActive;
    private float inactiveTimer;
    private boolean isInitialized = false;
    private TextField inputField;

    public ChatSystem(Stage stage, Skin skin, GameClient gameClient, String username,
                      CommandManager commandManager, boolean commandsEnabled) {
        this.stage = stage;
        this.skin = skin;
        this.gameClient = gameClient;
        this.username = username;
        this.messages = new LinkedList<>();
        this.commandsEnabled = commandsEnabled;
        this.commandManager = commandManager;

        // top alignment
        this.top();

        createChatUI();
        setupChatHandler();
        setupInputHandling();
    }

    @Override
    public void act(float delta) {
        super.act(delta);
        update(delta);
    }

    @Override
    public void setSize(float width, float height) {
        super.setSize(width, height);
        if (chatWindow != null) {
            chatWindow.setSize(width, height);
            if (messageScroll != null) {
                messageScroll.setSize(width, height - 40); // reserve input field space
            }
            chatWindow.invalidateHierarchy();
        }
    }

    @Override
    public Actor hit(float x, float y, boolean touchable) {
        if (!isActive) {
            return null; // Let touches fall through when not active.
        }
        return super.hit(x, y, touchable);
    }


    @Override
    public void setPosition(float x, float y) {
        super.setPosition(x, y);
        if (chatWindow != null) {
            chatWindow.setPosition(x, y);
        }
    }

    public void resize(int width, int height) {
        float chatWidth = Math.max(MIN_CHAT_WIDTH, width * 0.25f);
        float chatHeight = Math.max(MIN_CHAT_HEIGHT, height * 0.3f);
        setSize(chatWidth, chatHeight);
        // Place near top-left
        setPosition(CHAT_PADDING, height - chatHeight - CHAT_PADDING);
    }

    public boolean isActive() {
        return isActive;
    }

    private void setupChatHandler() {
        gameClient.setChatMessageHandler(this::handleIncomingMessage);
    }

    public void sendMessage(String content) {
        GameLogger.info("sendMessage called with content: " + content);
        if (content.isEmpty()) return;

        // store in local message history if not duplicate
        if (messageHistory.isEmpty() || !content.equals(messageHistory.get(messageHistory.size() - 1))) {
            messageHistory.add(content);
            messageHistoryIndex = messageHistory.size();
        }

        // handle commands:
        if (content.startsWith("/")) {
            if (commandsEnabled || GameContext.get().isMultiplayer()) {
                String command = content.substring(1);
                String[] parts = command.split(" ", 2);
                String commandName = parts[0].toLowerCase();
                String args = parts.length > 1 ? parts[1] : "";
                if (commandManager != null) {
                    Command cmd = commandManager.getCommand(commandName);
                    if (cmd != null) {
                        try {
                            cmd.execute(args, gameClient, this);
                            return;
                        } catch (Exception e) {
                            addSystemMessage("Error executing command: " + e.getMessage());
                            return;
                        }
                    } else {
                        addSystemMessage("Unknown command: " + commandName);
                        return;
                    }
                } else {
                    addSystemMessage("Command system not initialized!");
                    return;
                }
            } else {
                addSystemMessage("Commands are currently disabled.");
                return;
            }
        }

        // normal chat
        NetworkProtocol.ChatMessage chatMessage = new NetworkProtocol.ChatMessage();
        chatMessage.sender = username;
        chatMessage.content = content;
        chatMessage.timestamp = System.currentTimeMillis();
        chatMessage.type = NetworkProtocol.ChatType.NORMAL;

        if (!GameContext.get().isMultiplayer()) {
            handleIncomingMessage(chatMessage);
        } else {
            gameClient.sendMessage(chatMessage);
        }
    }

    public void addSystemMessage(String message) {
        NetworkProtocol.ChatMessage chatMessage = new NetworkProtocol.ChatMessage();
        chatMessage.sender = "System";
        chatMessage.content = message;
        chatMessage.timestamp = System.currentTimeMillis();
        chatMessage.type = NetworkProtocol.ChatType.SYSTEM;
        handleIncomingMessage(chatMessage);
    }

    public void handleIncomingMessage(NetworkProtocol.ChatMessage message) {
        Gdx.app.postRunnable(() -> addMessageToChat(message));
    }

    public void activateChat() {
        isActive = true;
        inputField.setVisible(true);
        inputField.setText("");
        messageHistoryIndex = messageHistory.size();
        inactiveTimer = 0;
        chatWindow.getColor().a = 1f;

        // set keyboard focus to inputField
        Gdx.app.postRunnable(() -> {
            stage.setKeyboardFocus(inputField);
        });
    }

    public void deactivateChat() {
        isActive = false;
        chatWindow.setTouchable(Touchable.disabled);

        inputField.setVisible(false);
        stage.setKeyboardFocus(null);

        // Hide on-screen keyboard on mobile
        if (Gdx.app.getType() == Application.ApplicationType.Android) {
            Gdx.input.setOnscreenKeyboardVisible(false);
        }

        // Restore normal movement or “UIState.NORMAL”
        if (GameContext.get().getGameScreen() != null &&
            GameContext.get().getGameScreen().getInputManager() != null) {
            // This line is crucial: forcibly set the game’s InputManager to NORMAL
            GameContext.get().getGameScreen().getInputManager()
                .setUIState(InputManager.UIState.NORMAL);
        }

        // Optionally reset movement flags to be safe
        if (GameContext.get().getGameScreen() != null &&
            GameContext.get().getGameScreen().getInputHandler() != null) {
            GameContext.get().getGameScreen().getInputHandler().resetMovementFlags();
        }
    }

    private void update(float delta) {
        if (!isActive) {
            inactiveTimer += delta;
            if (inactiveTimer > MESSAGE_FADE_TIME) {
                chatWindow.getColor().a =
                    Math.max(0.3f, 1 - (inactiveTimer - MESSAGE_FADE_TIME) / 2f);
            }
        }
        while (messages.size() > MAX_MESSAGES) {
            ((LinkedList<ChatMessage>) messages).removeFirst();
            messageTable.getChildren().first().remove();
        }
    }

    private void createChatUI() {
        if (isInitialized) {
            return;
        }
        chatWindow = new Table();
        chatWindow.top();
        // Background
        Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        pixmap.setColor(WINDOW_BACKGROUND);
        pixmap.fill();
        TextureRegion bgTexture = new TextureRegion(new Texture(pixmap));
        pixmap.dispose();
        chatWindow.setBackground(new TextureRegionDrawable(bgTexture));

        Table contentTable = new Table();
        contentTable.pad(10);

        // message area
        messageTable = new Table();
        messageScroll = new ScrollPane(messageTable, skin);
        messageScroll.setFadeScrollBars(false);
        messageScroll.setScrollingDisabled(true, false);
        contentTable.add(messageScroll).expand().fill().padBottom(5).row();

        // input field
        TextField.TextFieldStyle textFieldStyle =
            new TextField.TextFieldStyle(skin.get(TextField.TextFieldStyle.class));
        textFieldStyle.background = skin.newDrawable("white", new Color(0.2f, 0.2f, 0.2f, 0.8f));
        textFieldStyle.fontColor = Color.WHITE;
        textFieldStyle.cursor = skin.newDrawable("white", Color.WHITE);

        inputField = new TextField("", textFieldStyle);
        inputField.setMessageText("Press T to chat...");
        inputField.setTouchable(Touchable.enabled);

        // Add capture listener for key input
        inputField.addCaptureListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (!isActive) return false; // Only intercept if chat is active.

                switch (keycode) {
                    case Input.Keys.UP:
                        if (!messageHistory.isEmpty() && messageHistoryIndex > 0) {
                            messageHistoryIndex--;
                            String upMsg = messageHistory.get(messageHistoryIndex);
                            inputField.setText(upMsg);
                            inputField.setCursorPosition(upMsg.length());
                        }
                        // **Notice we do NOT call event.stop()** so other input
                        // processors can see keyUp if needed. We'll just return true.
                        return true;

                    case Input.Keys.DOWN:
                        if (!messageHistory.isEmpty()) {
                            if (messageHistoryIndex < messageHistory.size() - 1) {
                                messageHistoryIndex++;
                                String downMsg = messageHistory.get(messageHistoryIndex);
                                inputField.setText(downMsg);
                                inputField.setCursorPosition(downMsg.length());
                            } else {
                                messageHistoryIndex = messageHistory.size();
                                inputField.setText("");
                            }
                        }
                        return true;

                    case Input.Keys.ENTER:
                        // Send chat, then deactivate
                        String content = inputField.getText().trim();
                        if (!content.isEmpty()) {
                            sendMessage(content);
                            inputField.setText("");
                        }
                        deactivateChat();

                        // DO NOT call event.stop() here. Let the event pass through
                        // so other input can see it if needed
                        return true;

                    case Input.Keys.ESCAPE:
                        // Esc just deactivates chat
                        deactivateChat();
                        return true;
                }
                return false;
            }

            @Override
            public boolean keyTyped(InputEvent event, char character) {
                // If user typed something, set messageHistoryIndex to end
                if (character != '\0' && character != '\r' && character != '\n') {
                    messageHistoryIndex = messageHistory.size();
                }
                return false;
            }
        });

        // For mobile: if user taps chat window, we show onscreen keyboard
        chatWindow.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (Gdx.app.getType() == Application.ApplicationType.Android && !isActive) {
                    activateChat();
                    Gdx.input.setOnscreenKeyboardVisible(true);
                }
            }
        });

        contentTable.add(inputField).expandX().fillX().height(30);
        chatWindow.add(contentTable).expand().fill();
        this.add(chatWindow).expand().fill();

        inputField.setVisible(false);
        isInitialized = true;
    }

    private Color getSenderColor(String sender) {
        int index = Math.abs(sender.hashCode()) % CHAT_COLORS.length;
        return CHAT_COLORS[index];
    }

    private void addMessageToChat(NetworkProtocol.ChatMessage message) {
        Table messageEntry = new Table();
        messageEntry.pad(5);

        Label.LabelStyle timeStyle = new Label.LabelStyle(skin.get(Label.LabelStyle.class));
        timeStyle.fontColor = Color.GRAY;
        Label timeLabel = new Label(TimeUtils.formatTime(message.timestamp), timeStyle);

        Label.LabelStyle nameStyle = new Label.LabelStyle(skin.get(Label.LabelStyle.class));
        nameStyle.fontColor = getSenderColor(message.sender);
        Label nameLabel = new Label(message.sender + ": ", nameStyle);

        Label.LabelStyle contentStyle = new Label.LabelStyle(skin.get(Label.LabelStyle.class));
        contentStyle.fontColor = Color.WHITE;
        Label contentLabel = new Label(message.content, contentStyle);
        contentLabel.setWrap(true);

        messageEntry.add(timeLabel).padRight(5);
        messageEntry.add(nameLabel).padRight(5);
        messageEntry.add(contentLabel).expandX().fillX();

        messages.add(new ChatMessage(message));
        messageTable.add(messageEntry).expandX().fillX().padBottom(2).row();
        messageScroll.scrollTo(0, 0, 0, 0);

        chatWindow.getColor().a = 1f;
        inactiveTimer = 0;
    }

    private void setupInputHandling() {
        // We attach a general listener to the entire stage to open chat if T or slash
        stage.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                // if chat is active, we handle it in inputField. If not active, check for T or slash
                if (!isActive && (keycode == Input.Keys.T || keycode == Input.Keys.SLASH)) {
                    activateChat();
                    if (keycode == Input.Keys.SLASH) {
                        inputField.setText("/");
                        inputField.setCursorPosition(1);
                    }
                    // Here we do NOT call event.stop(). We just return true so other
                    // processors know we've handled T or slash, but not forcibly stopping.
                    return true;
                }
                // If chat is active and ESC pressed, we want to deactivate
                if (isActive && keycode == Input.Keys.ESCAPE) {
                    deactivateChat();
                    return true;
                }
                return false;
            }
        });
        // Also re‑attach the same capturing logic to inputField if you want
        // That’s already done above in createChatUI() for ENTER, ESC, etc.
    }

    private static class ChatMessage {
        public final String sender;
        public final String content;
        public final long timestamp;

        public ChatMessage(NetworkProtocol.ChatMessage msg) {
            this.sender = msg.sender;
            this.content = msg.content;
            this.timestamp = msg.timestamp;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/chat/Command.java
================
package io.github.pokemeetup.chat;

import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.system.Player;

public interface Command {
    String getName();
    String[] getAliases();
    String getDescription();
    String getUsage();
    boolean isMultiplayerOnly();
    void execute(String args, GameClient player, ChatSystem chatSystem);
}

================
File: src/main/java/io/github/pokemeetup/chat/CommandManager.java
================
package io.github.pokemeetup.chat;

import io.github.pokemeetup.utils.GameLogger;

import java.util.HashMap;
import java.util.Map;

public class CommandManager {
    private final Map<String, Command> commands = new HashMap<>();


    public Command getCommand(String name) {
        if (name == null) {
            GameLogger.error("Attempted to get null command name");
            return null;
        }
        Command cmd = commands.get(name.toLowerCase());
        if (cmd == null) {
            GameLogger.info("Command not found: " + name);
        }
        return cmd;
    }

    public void registerCommand(Command command) {
        if (command == null) {
            GameLogger.error("Attempted to register null command");
            return;
        }
        commands.put(command.getName().toLowerCase(), command);
        for (String alias : command.getAliases()) {
            commands.put(alias.toLowerCase(), command);
        }
        GameLogger.info("Registered command: " + command.getName() +
            " with " + command.getAliases().length + " aliases");
    }
}

================
File: src/main/java/io/github/pokemeetup/chat/commands/GiveCommand.java
================
package io.github.pokemeetup.chat.commands;

import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.Command;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.utils.storage.InventoryConverter;

public class GiveCommand implements Command {

    @Override
    public String getName() {
        return "give";
    }

    @Override
    public String[] getAliases() {
        return new String[0];
    }

    @Override
    public String getDescription() {
        return "gives item to player";
    }

    @Override
    public String getUsage() {
        return "/give <item> <amount> || Optional: <player>";
    }

    @Override
    public boolean isMultiplayerOnly() {
        return false;
    }

    @Override
    public void execute(String args, GameClient gameClient, ChatSystem chatSystem) {
        String[] argsArray = args.split(" ");

        if (argsArray.length != 2) {
            chatSystem.addSystemMessage("Usage: /give <item> <amount>");
            return;
        }

        String itemId = argsArray[0];
        try {
            int count = Integer.parseInt(argsArray[1]);
            ItemData item = InventoryConverter.itemToItemData(ItemManager.getItem(itemId));

            if (item == null) {
                chatSystem.addSystemMessage("Item " + itemId + " not found");
                return;
            }

            if (count <= 0 || count > 64) {
                chatSystem.addSystemMessage("Invalid count; must be between 1 and 64");
                return;
            }

            item.setCount(count);
            boolean added = GameContext.get().getPlayer().getInventory().addItem(item);

            if (added) {
                chatSystem.addSystemMessage("You got " + count + "x " + itemId);
            } else {
                chatSystem.addSystemMessage("Inventory full! Could not add item.");
            }

        } catch (NumberFormatException e) {
            chatSystem.addSystemMessage("Invalid number format: " + argsArray[1]);
        } catch (Exception e) {
            chatSystem.addSystemMessage("Error executing command: " + e.getMessage());
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/chat/commands/SetWorldSpawnCommand.java
================
package io.github.pokemeetup.chat.commands;

import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.Command;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class SetWorldSpawnCommand implements Command {

    @Override
    public String getName() {
        return "setSpawn";
    }

    @Override
    public String[] getAliases() {
        return new String[0];
    }

    @Override
    public String getDescription() {
        return "sets the world spawn to the player";
    }

    @Override
    public String getUsage() {
        return "/setSpawn";
    }

    @Override
    public boolean isMultiplayerOnly() {
        return false;
    }

    @Override
    public void execute(String args, GameClient gameClient, ChatSystem chatSystem) {
        String[] argsArray = args.split(" ");

        try {
            GameLogger.info("Executing setSpawn command...");

            Player player = GameContext.get().getPlayer();
            if (player == null) {
                chatSystem.addSystemMessage("Error: Player not found");
                return;
            }

            World currentWorld = GameContext.get().getWorld();
            if (currentWorld == null) {
                chatSystem.addSystemMessage("Error: World not found");
                return;
            }

            if (currentWorld.getWorldData() == null || currentWorld.getWorldData().getConfig() == null) {
                chatSystem.addSystemMessage("Error: World configuration not available");
                return;
            }

            if (argsArray.length > 2) {
                chatSystem.addSystemMessage("Invalid arguments: " + getUsage());
                return;
            }

            int tileX = player.getTileX();
            int tileY = player.getTileY();

            if (argsArray.length == 2) {
                tileX = Integer.parseInt(argsArray[0]);
                tileY = Integer.parseInt(argsArray[1]);
            }

            currentWorld.getWorldData().getConfig().setTileSpawnX(tileX);
            currentWorld.getWorldData().getConfig().setTileSpawnY(tileY);

            chatSystem.addSystemMessage("You set the world's spawn coords to " + tileX + " " + tileY);
        } catch (Exception e) {
            GameLogger.error("Error executing spawn command: " + e.getMessage());
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/chat/commands/SpawnCommand.java
================
package io.github.pokemeetup.chat.commands;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.Command;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class SpawnCommand implements Command {

    @Override
    public String getName() { return "spawn"; }

    @Override
    public String[] getAliases() { return new String[0]; }

    @Override
    public String getDescription() { return "Teleports the player to spawn."; }

    @Override
    public String getUsage() { return "/spawn"; }

    @Override
    public boolean isMultiplayerOnly() { return false; }

    @Override
    public void execute(String args, GameClient gameClient, ChatSystem chatSystem) {
        try {
            GameLogger.info("Executing spawn command...");
            Player player = GameContext.get().getPlayer();
            if (player == null) {
                chatSystem.addSystemMessage("Error: Player not found.");
                return;
            }
            World currentWorld = GameContext.get().getWorld();
            if (currentWorld == null) {
                chatSystem.addSystemMessage("Error: World not found.");
                return;
            }
            // Get spawn coordinates from the world configuration.
            int tileX = currentWorld.getWorldData().getConfig().getTileSpawnX();
            int tileY = currentWorld.getWorldData().getConfig().getTileSpawnY();
            float pixelX = tileX * World.TILE_SIZE;
            float pixelY = tileY * World.TILE_SIZE;

            // Teleport the player.
            player.getPosition().set(pixelX, pixelY);
            player.setTileX(tileX);
            player.setTileY(tileY);
            player.setX(pixelX);
            player.setY(pixelY);
            player.setMoving(false);
            player.setRenderPosition(new Vector2(pixelX, pixelY));

            chatSystem.addSystemMessage("Teleported to spawn point! (" + tileX + ", " + tileY + ")");
            GameLogger.info("Player teleported to spawn: " + pixelX + ", " + pixelY);

            // **The crucial fix: Reset the chunk state.**
            currentWorld.clearChunks();
            // Now trigger a fresh initial load (this method does not check the flag)
            currentWorld.loadChunksAroundPlayer();

            // If in multiplayer mode, update the server.
            if (GameContext.get().isMultiplayer()) {
                gameClient.sendPlayerUpdate();
                gameClient.savePlayerState(player.getPlayerData());
            }
        } catch (Exception e) {
            GameLogger.error("Spawn command failed: " + e.getMessage());
            chatSystem.addSystemMessage("Error executing spawn command: " + e.getMessage());
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/chat/commands/TeleportManager.java
================
package io.github.pokemeetup.chat.commands;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class TeleportManager {
    private final Map<String, TeleportRequest> pendingRequests = new ConcurrentHashMap<>();
    private static final long REQUEST_TIMEOUT = 60000; // 60 seconds

    public static class TeleportRequest {
        public final String from;
        public final String to;
        public final long timestamp;

        public TeleportRequest(String from, String to) {
            this.from = from;
            this.to = to;
            this.timestamp = System.currentTimeMillis();
        }

        public boolean isExpired() {
            return System.currentTimeMillis() - timestamp > REQUEST_TIMEOUT;
        }
    }

    public void addRequest(String from, String to) {
        cleanExpiredRequests();
        pendingRequests.put(from, new TeleportRequest(from, to));
    }

    public TeleportRequest getRequest(String from) {
        return pendingRequests.get(from);
    }

    public void removeRequest(String from) {
        pendingRequests.remove(from);
    }

    private void cleanExpiredRequests() {
        pendingRequests.entrySet().removeIf(entry -> entry.getValue().isExpired());
    }
}

================
File: src/main/java/io/github/pokemeetup/chat/commands/TeleportPositionCommand.java
================
package io.github.pokemeetup.chat.commands;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.Command;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class TeleportPositionCommand implements Command {

    @Override
    public String getName() {
        return "tp";
    }

    @Override
    public String[] getAliases() {
        return new String[0];
    }

    @Override
    public String getDescription() {
        return "Teleports user to specified location.";
    }

    @Override
    public String getUsage() {
        return "tp <x> <y>";
    }

    @Override
    public boolean isMultiplayerOnly() {
        return false;
    }

    @Override
    public void execute(String args, GameClient gameClient, ChatSystem chatSystem) {
        String[] argsArray = args.split(" ");
        try {
            GameLogger.info("Executing tp command...");

            // Get player and world from the global context.
            Player player = GameContext.get().getPlayer();
            if (player == null) {
                chatSystem.addSystemMessage("Error: Player not found");
                return;
            }
            World currentWorld = GameContext.get().getWorld();
            if (currentWorld == null) {
                chatSystem.addSystemMessage("Error: World not found");
                return;
            }
            if (argsArray.length != 2) {
                chatSystem.addSystemMessage("Invalid arguments. Use: " + getUsage());
                return;
            }

            // Parse target tile coordinates.
            int tileX = Integer.parseInt(argsArray[0]);
            int tileY = Integer.parseInt(argsArray[1]);

            // *** NEW CHECK: Ensure the target is within the world border ***
            if (!currentWorld.isWithinWorldBounds(tileX, tileY)) {
                chatSystem.addSystemMessage("Error: Teleport location (" + tileX + ", " + tileY + ") is outside the world border.");
                return;
            }

            float pixelX = tileX * World.TILE_SIZE;
            float pixelY = tileY * World.TILE_SIZE;

            // Teleport the player by updating his position and tile coordinates.
            player.getPosition().set(pixelX, pixelY);
            player.setTileX(tileX);
            player.setTileY(tileY);
            player.setX(pixelX);
            player.setY(pixelY);
            player.setRenderPosition(new Vector2(pixelX, pixelY));
            player.setMoving(false);

            // Reset the chunk state so that a fresh set of chunks are loaded around the new position.
            currentWorld.clearChunks();
            currentWorld.loadChunksAroundPlayer();

            // If in multiplayer mode, update the server.
            if (GameContext.get().isMultiplayer()) {
                gameClient.sendPlayerUpdate();
                gameClient.savePlayerState(player.getPlayerData());
            }
            // Multiplayer Mode: Send position update to server
            if (GameContext.get().isMultiplayer()) {
                NetworkProtocol.PlayerUpdate update = new NetworkProtocol.PlayerUpdate();
                update.username = player.getUsername();
                update.x = pixelX;
                update.y = pixelY;
                update.direction = player.getDirection();
                update.isMoving = false;
                update.timestamp = System.currentTimeMillis();
                gameClient.getClient().sendTCP(update);
                chatSystem.addSystemMessage("Teleported and updated position on server.");
            } else {
                chatSystem.addSystemMessage("Teleported successfully.");
            }

        } catch (Exception e) {
            GameLogger.error("Error executing tp command: " + e.getMessage());
            chatSystem.addSystemMessage("Error: " + e.getMessage());
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/chat/commands/TimeCommand.java
================
package io.github.pokemeetup.chat.commands;

import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.Command;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class TimeCommand implements Command {
    @Override
    public String getName() {
        return "time";
    }

    @Override
    public String[] getAliases() {
        return new String[0];
    }

    @Override
    public String getDescription() {
        return "sets or gets the time";
    }

    @Override
    public String getUsage() {
        return "/time <set|get> <time>";
    }

    @Override
    public boolean isMultiplayerOnly() {
        return false;
    }

    @Override
    public void execute(String args, GameClient gameClient, ChatSystem chatSystem) {
        String[] argsArray = args.split(" ");

        try {
            GameLogger.info("executing time command");

            Player player = GameContext.get().getPlayer();
            if (player == null) {
                chatSystem.addSystemMessage("Error: Player not found");
                return;
            }

            World currentWorld = GameContext.get().getWorld();
            if (currentWorld == null) {
                chatSystem.addSystemMessage("Error: World not found");
                return;
            }

            if (currentWorld.getWorldData() == null || currentWorld.getWorldData().getConfig() == null) {
                chatSystem.addSystemMessage("Error: World configuration not available");
                return;
            }

            if (argsArray[0].equals("get")) {
                chatSystem.addSystemMessage("the current world time is: " + currentWorld.getWorldData().getWorldTimeInMinutes());
                return;
            }
            if (argsArray[0].equals("set")) {
                float playerTimeInput = Float.parseFloat(argsArray[1]);

                if (playerTimeInput < 0) {
                    chatSystem.addSystemMessage("time must be a positive number");
                }

                currentWorld.getWorldData().setWorldTimeInMinutes(playerTimeInput);
                currentWorld.getWorldData().save();
                chatSystem.addSystemMessage("set world time to " + playerTimeInput);
            }
        } catch (Exception e) {
            GameLogger.error("error executing /time command: " + e);
        }

    }
}

================
File: src/main/java/io/github/pokemeetup/chat/commands/WeatherCommand.java
================
package io.github.pokemeetup.chat.commands;

import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.Command;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.WeatherSystem;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class WeatherCommand implements Command {

    @Override
    public String getName() {
        return "weather";
    }

    @Override
    public String[] getAliases() {
        return new String[0];
    }

    @Override
    public String getDescription() {
        return "Gets or sets the weather. When setting, an optional time (in seconds) can be provided to override biome changes.";
    }

    @Override
    public String getUsage() {
        // Note: The 4th argument is optional
        return "/weather <set|get> <weatherType|blank> <intensity|blank> [time in seconds]";
    }

    @Override
    public boolean isMultiplayerOnly() {
        return false;
    }

    @Override
    public void execute(String args, GameClient gameClient, ChatSystem chatSystem) {
        String[] argsArray = args.split(" ");
        try {
            GameLogger.info("Executing weather command");

            // Retrieve the player and world context.
            Player player = GameContext.get().getPlayer();
            if (player == null) {
                chatSystem.addSystemMessage("Error: Player not found");
                return;
            }

            World currentWorld = GameContext.get().getWorld();
            if (currentWorld == null) {
                chatSystem.addSystemMessage("Error: World not found");
                return;
            }
            currentWorld.getWeatherSystem().setWorld(currentWorld);

            // Get current weather
            if (argsArray[0].equalsIgnoreCase("get")) {
                chatSystem.addSystemMessage("Current weather is: "
                    + currentWorld.getWeatherSystem().getCurrentWeather().name());
                return;
            }

            // Set new weather
            if (argsArray[0].equalsIgnoreCase("set")) {
                if (argsArray.length < 3) {
                    chatSystem.addSystemMessage("Usage: " + getUsage());
                    return;
                }
                float intensity = Float.parseFloat(argsArray[2]);
                if (intensity < 0) {
                    chatSystem.addSystemMessage("Weather intensity must be a positive number");
                    return;
                }
                boolean weatherFound = false;
                for (WeatherSystem.WeatherType weather : WeatherSystem.WeatherType.values()) {
                    if (weather.name().equalsIgnoreCase(argsArray[1])) {
                        currentWorld.getWeatherSystem().setWeather(weather, intensity);
                        weatherFound = true;
                        String response = "Weather set to: " + weather.name() + " with intensity: " + intensity;
                        // Check for an optional time argument to override automatic biome changes.
                        if (argsArray.length >= 4) {
                            float duration = Float.parseFloat(argsArray[3]);
                            currentWorld.getWeatherSystem().setManualOverrideTimer(duration);
                            response += " for " + duration + " seconds";
                        }
                        chatSystem.addSystemMessage(response);
                        break;
                    }
                }
                if (!weatherFound) {
                    chatSystem.addSystemMessage("Invalid weather type specified. Available types: "
                        + "CLEAR, RAIN, HEAVY_RAIN, SNOW, BLIZZARD, SANDSTORM, FOG, THUNDERSTORM");
                    return;
                }
            }
        } catch (Exception e) {
            GameLogger.error("Error executing weather command: " + e);
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/context/GameContext.java
================
package io.github.pokemeetup.context;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.scenes.scene2d.Stage;

import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.managers.DisconnectionManager;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.screens.ChestScreen;
import io.github.pokemeetup.screens.CraftingTableScreen;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.screens.InventoryScreen;
import io.github.pokemeetup.screens.otherui.BattleTable;
import io.github.pokemeetup.screens.otherui.BuildModeUI;
import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.screens.otherui.GameMenu;
import io.github.pokemeetup.screens.otherui.HotbarSystem;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.battle.BattleSystemHandler;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;

public final class GameContext {

    private static GameContext instance;
    private final CreatureCaptureGame game;
    private final BattleSystemHandler battleSystem;
    private ChatSystem chatSystem;
    private BattleTable battleTable;
    private boolean isMultiplayer;
    private GameClient gameClient;
    private World world;
    private HotbarSystem hotbarSystem;
    private Player player;
    private SpriteBatch batch;

    public BiomeManager getBiomeManager() {
        return biomeManager;
    }

    public void setBiomeManager(BiomeManager biomeManager) {
        this.biomeManager = biomeManager;
    }

    private SpriteBatch uiBatch;
    private Stage uiStage;
    private Skin skin;
    private Stage battleStage;
    private InventoryScreen inventoryScreen;
    private BuildModeUI buildModeUI;
    private ChestScreen chestScreen;
    private CraftingTableScreen craftingScreen;
    private GameMenu gameMenu;
    private WorldManager worldManager;
    private BiomeManager biomeManager;
    private GameScreen gameScreen;
    private DisconnectionManager disconnectionManager;
    private UIManager uiManager;
    /**
     * Private constructor to enforce singleton usage.
     */
    private GameContext(
        CreatureCaptureGame game,
        GameClient gameClient,
        World world,
        Player player,
        SpriteBatch batch,
        SpriteBatch uiBatch,
        Stage uiStage,
        Stage battleStage,
        ChatSystem chatSystem,
        BattleSystemHandler battleSystem,
        InventoryScreen inventoryScreen,
        BuildModeUI buildModeUI,
        CraftingTableScreen craftingScreen, HotbarSystem hotbarSystem,
        GameMenu gameMenu,
        ChestScreen chestScreen, WorldManager worldManager,
        GameScreen gameScreen, DisconnectionManager disconnectionManager, boolean isMultiplayer, Skin skin, UIManager uiManager, BattleTable battleTable, BiomeManager biomeManager
    ) {
        this.game = game;
        this.gameClient = gameClient;
        this.world = world;
        this.player = player;
        this.batch = batch;
        this.uiBatch = uiBatch;
        this.uiStage = uiStage;
        this.battleStage = battleStage;
        this.skin = skin;
        this.chatSystem = chatSystem;
        this.battleSystem = battleSystem;
        this.inventoryScreen = inventoryScreen;
        this.buildModeUI = buildModeUI;
        this.hotbarSystem = hotbarSystem;
        this.craftingScreen = craftingScreen;
        this.gameMenu = gameMenu;
        this.chestScreen = chestScreen;
        this.worldManager = worldManager;
        this.gameScreen = gameScreen;
        this.disconnectionManager = disconnectionManager;
        this.isMultiplayer = isMultiplayer;
        this.uiManager = uiManager;
        this.battleTable = battleTable;
        this.biomeManager = biomeManager;
    }

    public static void init(
        CreatureCaptureGame game,
        GameClient gameClient,
        World world,
        Player player,
        SpriteBatch batch,
        SpriteBatch uiBatch,
        Stage uiStage,
        Stage battleStage,
        ChatSystem chatSystem,
        BattleSystemHandler battleSystem,
        InventoryScreen inventoryScreen,
        BuildModeUI buildModeUI,
        CraftingTableScreen craftingScreen,
        GameMenu gameMenu,
        ChestScreen chestScreen, WorldManager worldManager, HotbarSystem hotbarSystem,
        GameScreen gameScreen, DisconnectionManager disconnectionManager, boolean isMultiplayer, Skin skin, UIManager uiManager, BattleTable battleTable, BiomeManager biomeManager
    ) {
        if (instance != null) {
            throw new IllegalStateException("GameContext already initialized!");
        }
        instance = new GameContext(
            game,
            gameClient,
            world,
            player,
            batch,
            uiBatch,
            uiStage,
            battleStage,
            chatSystem,
            battleSystem,
            inventoryScreen,
            buildModeUI,
            craftingScreen, hotbarSystem,
            gameMenu,
            chestScreen, worldManager, gameScreen, disconnectionManager, isMultiplayer, skin, uiManager, battleTable, biomeManager
        );
    }

    /**
     * Returns the singleton instance of the GameContext. Make sure {@link #(...)}
     * has been called first.
     */
    public static GameContext get() {
        if (instance == null) {
            throw new IllegalStateException("GameContext not initialized yet!");
        }
        return instance;
    }

    public HotbarSystem getHotbarSystem() {
        return hotbarSystem;
    }

    public void setHotbarSystem(HotbarSystem hotbarSystem) {
        this.hotbarSystem = hotbarSystem;
    }

    public BattleTable getBattleTable() {
        return battleTable;
    }

    public void setBattleTable(BattleTable battleTable) {
        this.battleTable = battleTable;
    }

    public UIManager getUiManager() {
        return uiManager;
    }

    public void setUiManager(UIManager uiManager) {
        this.uiManager = uiManager;
    }

    public boolean isMultiplayer() {
        return isMultiplayer;
    }

    public void setMultiplayer(boolean multiplayer) {
        isMultiplayer = multiplayer;
    }

    public Skin getSkin() {
        return skin;
    }

    public void setSkin(Skin skin) {
        this.skin = skin;
    }

    public CraftingTableScreen getCraftingScreen() {
        return craftingScreen;
    }

    public void setCraftingScreen(CraftingTableScreen craftingScreen) {
        this.craftingScreen = craftingScreen;
    }

    public DisconnectionManager getDisconnectionManager() {
        return disconnectionManager;
    }

    public void setDisconnectionManager(DisconnectionManager disconnectionManager) {
        this.disconnectionManager = disconnectionManager;
    }

    public GameScreen getGameScreen() {
        return gameScreen;
    }

    public void setGameScreen(GameScreen gameScreen) {
        this.gameScreen = gameScreen;
    }

    public GameMenu getGameMenu() {
        return gameMenu;
    }

    public void setGameMenu(GameMenu gameMenu) {
        this.gameMenu = gameMenu;
    }

    public WorldManager getWorldManager() {
        return worldManager;
    }

    public void setWorldManager(WorldManager worldManager) {
        this.worldManager = worldManager;
    }

    public CreatureCaptureGame getGame() {
        return game;
    }

    public GameClient getGameClient() {
        return gameClient;
    }

    public void setGameClient(GameClient gameClient) {
        this.gameClient = gameClient;
    }

    public World getWorld() {
        return world;
    }

    public void setWorld(World world) {
        this.world = world;
    }

    public Player getPlayer() {
        return player;
    }

    public void setPlayer(Player player) {
        this.player = player;
    }

    public SpriteBatch getBatch() {
        return batch;
    }

    public void setBatch(SpriteBatch batch) {
        this.batch = batch;
    }

    public SpriteBatch getUiBatch() {
        return uiBatch;
    }

    public void setUiBatch(SpriteBatch uiBatch) {
        this.uiBatch = uiBatch;
    }

    public Stage getUiStage() {
        return uiStage;
    }

    public void setUiStage(Stage uiStage) {
        this.uiStage = uiStage;
    }

    public Stage getBattleStage() {
        return battleStage;
    }

    public void setBattleStage(Stage battleStage) {
        this.battleStage = battleStage;
    }

    public ChatSystem getChatSystem() {
        return chatSystem;
    }

    public void setChatSystem(ChatSystem chatSystem) {
        this.chatSystem = chatSystem;
    }

    public BattleSystemHandler getBattleSystem() {
        return battleSystem;
    }

    public InventoryScreen getInventoryScreen() {
        return inventoryScreen;
    }

    public void setInventoryScreen(InventoryScreen inventoryScreen) {
        this.inventoryScreen = inventoryScreen;
    }

    public BuildModeUI getBuildModeUI() {
        return buildModeUI;
    }

    public void setBuildModeUI(BuildModeUI buildModeUI) {
        this.buildModeUI = buildModeUI;
    }

    public ChestScreen getChestScreen() {
        return chestScreen;
    }

    public void setChestScreen(ChestScreen chestScreen) {
        this.chestScreen = chestScreen;
    }

    public void dispose() {
        // Dispose of SpriteBatches
        if (batch != null) {
            batch.dispose();
        }
        if (skin != null) {
            skin.dispose();
        }
        if (uiBatch != null) {
            uiBatch.dispose();
        }
        // Dispose of Stages
        if (uiStage != null) {
            uiStage.dispose();
        }
        if (battleStage != null) {
            battleStage.dispose();
        }
        if (battleSystem != null) {
            battleSystem.endBattle();
        }

        instance = null;
    }
}

================
File: src/main/java/io/github/pokemeetup/context/UIManager.java
================
package io.github.pokemeetup.context;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import io.github.pokemeetup.screens.otherui.HotbarSystem;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

public class UIManager {
    private final Stage uiStage;
    private final Skin skin;

    public UIManager(Stage stage, Skin skin) {
        this.uiStage = stage;
        this.skin = skin;
        initializeComponents();
    }

    private void initializeComponents() {
        // Ensure the skin and required regions are loaded.
        TextureRegion hotbarBg = TextureManager.ui.findRegion("hotbar_bg");
        if (hotbarBg == null) {
            GameLogger.error("Missing 'hotbar_bg' region in skin!");
        }
    }


    public void resize(int width, int height) {
        // Update positions, if needed.
    }
}

================
File: src/main/java/io/github/pokemeetup/CreatureCaptureGame.java
================
package io.github.pokemeetup;

import com.badlogic.gdx.Application;
import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.assets.AssetManager;
import com.badlogic.gdx.assets.loaders.TextureAtlasLoader;
import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.managers.DisconnectionManager;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.client.GameClientSingleton;
import io.github.pokemeetup.multiplayer.server.GameStateHandler;
import io.github.pokemeetup.multiplayer.server.config.ServerConfigManager;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.pokemon.data.PokemonDatabase;
import io.github.pokemeetup.screens.*;
import io.github.pokemeetup.screens.otherui.HotbarSystem;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.storage.DesktopFileSystem;
import io.github.pokemeetup.utils.storage.GameFileSystem;

import java.io.IOException;
import java.util.Map;
import java.util.Random;

public class CreatureCaptureGame extends Game implements GameStateHandler {
    public static final String MULTIPLAYER_WORLD_NAME = "multiplayer_world";
    private GameClient gameClient;
    private BiomeManager biomeManager;
    private Player player;
    private World currentWorld;
    private AssetManager assetManager;

    public CreatureCaptureGame(boolean isAndroid) {
        if (
            !isAndroid) {
            GameFileSystem system = GameFileSystem.getInstance();
            DesktopFileSystem delegate = new DesktopFileSystem();
            system.setDelegate(delegate);
        }
    }

    public CreatureCaptureGame() {
    }

    public boolean isMultiplayerMode() {
        return GameContext.get().isMultiplayer();
    }

    @Override
    public void create() {
        GameLogger.error("Working directory: " + System.getProperty("user.dir"));


        assetManager = new AssetManager();
        queueAssets();
        GameLogger.info("Loading assets...");
        assetManager.finishLoading();
        initializeManagers();


        setScreen(new ModeSelectionScreen(this));

        Gdx.app.setLogLevel(Application.LOG_INFO);
        GameLogger.info("Game initialization complete");
    }

    /**
     * Saves the current world, disposes the game screen, and transitions back to the world selection screen.
     * This is the proper way to "quit" a world without closing the application.
     */
    public void exitToMenu() {
        GameLogger.info("Exiting game to menu...");
        if (getScreen() instanceof GameScreen) {
            World currentWorld = GameContext.get().getWorld();
            if (currentWorld != null && !isMultiplayerMode()) {
                currentWorld.save(); // Centralized save logic
            }
        }

        // Dispose the current screen
        if (getScreen() != null) {
            getScreen().dispose();
        }

        // Reset game-specific context but keep application-level context
        // This prevents holding onto disposed objects like the old GameScreen
        if (GameContext.get() != null) {
            GameContext.get().setWorld(null);
            GameContext.get().setPlayer(null);
            GameContext.get().setHotbarSystem(null);
            GameContext.get().setGameMenu(null);
            GameContext.get().setInventoryScreen(null);
            GameContext.get().setCraftingScreen(null);
            GameContext.get().setChatSystem(null);
            // DO NOT dispose the uiStage, batch, or skin here. They persist.
        }

        // Transition to the world selection screen
        setScreen(new WorldSelectionScreen(this));
    }


    /**
     * Fully saves the game state and closes the application.
     */
    public void shutdown() {
        Gdx.app.postRunnable(() -> {
            try {
                // Save the current world if we are in a GameScreen
                if (getScreen() instanceof GameScreen && GameContext.get().getWorld() != null && !isMultiplayerMode()) {
                    GameLogger.info("Performing final save before shutdown...");
                    GameContext.get().getWorld().save();
                }

                if (assetManager != null) {
                    assetManager.dispose();
                    assetManager = null;
                }

                AudioManager audioManager = AudioManager.getInstance();
                if (audioManager != null) {
                    audioManager.dispose();
                }

                Gdx.app.exit();
            } catch (Exception e) {
                GameLogger.error("Error during final shutdown: " + e.getMessage());
            }
        });
    }


    @Override
    public void dispose() {
        try {
            GameLogger.info("Starting game disposal...");

            // Queue on main thread if we're not already there
            if (!Gdx.app.getType().equals(Application.ApplicationType.Desktop) ||
                !Thread.currentThread().getName().equals("LWJGL Application")) {

                Gdx.app.postRunnable(() -> {
                    try {
                        if (getScreen() instanceof GameScreen && GameContext.get().getWorld() != null && !isMultiplayerMode()) {
                            GameContext.get().getWorld().save();
                        }
                        if (assetManager != null) {
                            assetManager.dispose();
                        }
                    } catch (Exception e) {
                        GameLogger.error("Error during final disposal: " + e.getMessage());
                    }
                });
            } else {
                if (getScreen() instanceof GameScreen && GameContext.get().getWorld() != null && !isMultiplayerMode()) {
                    GameContext.get().getWorld().save();
                }
                if (assetManager != null) {
                    assetManager.dispose();
                }
            }
        } catch (Exception e) {
            GameLogger.error("Error during disposal: " + e.getMessage());
        }
    }

    public void initializeWorld(String worldName, boolean isMultiplayer) throws IOException {
        GameLogger.info("Starting world initialization: " + worldName);

        try {
            if (GameContext.get().getGameClient() == null) {
                if (isMultiplayer) {
                    ServerConnectionConfig config = ServerConfigManager.getDefaultServerConfig();
                    GameContext.get().setGameClient(GameClientSingleton.getInstance(config));
                } else {
                    GameContext.get().setGameClient(GameClientSingleton.getSinglePlayerInstance());
                }

                if (GameContext.get().getGameClient() == null) {
                    throw new IllegalStateException("Failed to initialize GameClient");
                }
            }
            WorldData worldData = GameContext.get().getWorldManager().loadAndValidateWorld(worldName);
            if (worldData == null) {
                GameLogger.error("Failed to load world data for: " + worldName);
                throw new IOException("Failed to load world data");
            }
            String username = isMultiplayer ? GameContext.get().getGameClient().getLocalUsername() : "Player";
            PlayerData savedPlayerData = worldData.getPlayerData(username, false);

            long worldSeed = worldData.getConfig().getSeed();
            this.biomeManager = new BiomeManager(worldSeed);
            if (savedPlayerData != null) {
                GameLogger.info("Found saved player data for: " + username +
                    " Items: " + savedPlayerData.getInventoryItems().size() +
                    " Pokemon: " + savedPlayerData.getPartyPokemon().size());

            }// Initialize world
            GameContext.get().setWorld(new World(worldName,
                worldData.getConfig().getSeed()));
            GameContext.get().getWorld().setWorldData(worldData);

            if (savedPlayerData != null) {
                World currentWorld = GameContext.get().getWorld();
                // We'll pick a safe spawn tile from the islands
                Random rng = new Random(currentWorld.getWorldData().getConfig().getSeed());

                Vector2 safeTile = biomeManager.findSafeSpawnLocation(currentWorld, rng);


                Player newPlayer = new Player(
                    (int) safeTile.x,
                    (int) safeTile.y,
                    currentWorld,
                    username
                );
                GameContext.get().setPlayer(newPlayer);
                GameContext.get().getPlayer().initializeResources();
                savedPlayerData.applyToPlayer(GameContext.get().getPlayer());
                GameLogger.info("Restored player state - Items: " +
                    GameContext.get().getPlayer().getInventory().getAllItems().size() +
                    " Pokemon: " + GameContext.get().getPlayer().getPokemonParty().getSize());
            } else {
                World currentWorld = GameContext.get().getWorld();
                BiomeManager bm = currentWorld.getBiomeManager();
                // We'll pick a safe spawn tile from the islands
                Random rng = new Random(currentWorld.getWorldData().getConfig().getSeed());
                Vector2 safeTile = bm.findSafeSpawnLocation(currentWorld, rng);

                Player newPlayer = new Player(
                    (int) safeTile.x,
                    (int) safeTile.y,
                    currentWorld,
                    username
                );
                GameContext.get().setPlayer(newPlayer);
            }


            GameContext.get().getWorld().setPlayer(GameContext.get().getPlayer());
            GameLogger.info("World initialization complete: " + worldName);

        } catch (Exception e) {
            GameLogger.error("Failed to initialize world: " + e.getMessage());
            throw new IOException("World initialization failed", e);
        }
    }

    private void queueAssets() {
        String[] atlasFiles = {
            "atlas/steps.atlas",
            "atlas/ui-gfx-atlas.atlas",
            "atlas/back-gfx-atlas",
            "atlas/front-gfx-atlas",
            "atlas/boy-gfx-atlas",
            "atlas/tiles-gfx-atlas",
            "atlas/icon_gfx_atlas",
            "atlas/items-gfx-atlas",
            "atlas/overworld-gfx-atlas.atlas",
            "atlas/battlebacks-gfx-atlas",
            "atlas/move-effects-gfx",
            "atlas/haunted_biome.atlas",
            "atlas/mountain-atlas.atlas",
            "atlas/move_effects_gfx.atlas",
            "atlas/blocks.atlas",
            "atlas/characters.atlas",
            "atlas/clothing.atlas",
            "atlas/hairstyles.atlas",
            "atlas/buildings.atlas",
            "atlas/girl.atlas",
            "atlas/autotiles_sheets.atlas",
            "atlas/capsule_throw.atlas",
            "atlas/ow-effects.atlas"
        };

        for (String path : atlasFiles) {
            verifyAssetExists(path);
            assetManager.load(path, TextureAtlas.class);
        }

        // Verify required data files exist
        String[] dataFiles = {
            "Data/pokemon.json",
            "Data/biomes.json",
            "Data/moves.json"
        };
        for (String dataFile : dataFiles) {
            verifyDataFileExists(dataFile);
        }

        assetManager.setLoader(TextureAtlas.class, new TextureAtlasLoader(new InternalFileHandleResolver()));

        GameLogger.info("Asset loading queued");
    }

    private void verifyDataFileExists(String path) {
        try {
            FileHandle fileHandle = Gdx.files.internal(path);
            if (!fileHandle.exists()) {
                throw new RuntimeException("Data file not found: " + path);
            }
            String content = fileHandle.readString();
            if (content == null || content.isEmpty()) {
                throw new RuntimeException("Empty data file: " + path);
            }
            GameLogger.info("Successfully verified data file: " + path);
        } catch (Exception e) {
            GameLogger.error("Failed to verify data file: " + path + " - " + e.getMessage());
            throw new RuntimeException("Required data file missing: " + path, e);
        }
    }

    @Override
    public void returnToLogin(String message) {
        try {
            if (screen != null) {
                screen.dispose();
            }
            setScreen(new LoginScreen(this));
        } catch (Exception e) {
            GameLogger.error("Error returning to login: " + e.getMessage());
        }
    }

    private void verifyAssetExists(String path) {
        try {
            if (!Gdx.files.internal(path).exists()) {
                String[] alternatives = {
                    path.toLowerCase(),
                    "assets/" + path,
                    path.replace("Data/", "data/")
                };

                boolean found = false;
                for (String alt : alternatives) {
                    if (Gdx.files.internal(alt).exists()) {
                        GameLogger.info("Found asset at alternate path: " + alt);
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    throw new RuntimeException("Required asset not found: " + path +
                        " (tried multiple path variants)");
                }
            }
        } catch (Exception e) {
            GameLogger.error("Error verifying asset: " + path + " - " + e.getMessage());
            throw new RuntimeException("Asset verification failed", e);
        }
    }

    private void initializeManagers() {
        try {

            GameLogger.info("Initializing managers with loaded assets...");
            TextureAtlas stepsAtlas = assetManager.get("atlas/steps.atlas", TextureAtlas.class);
            TextureAtlas battleAtlas = assetManager.get("atlas/battlebacks-gfx-atlas", TextureAtlas.class);
            TextureAtlas uiAtlas = assetManager.get("atlas/ui-gfx-atlas.atlas", TextureAtlas.class);
            TextureAtlas backAtlas = assetManager.get("atlas/back-gfx-atlas", TextureAtlas.class);
            TextureAtlas frontAtlas = assetManager.get("atlas/front-gfx-atlas", TextureAtlas.class);
            TextureAtlas iconAtlas = assetManager.get("atlas/icon_gfx_atlas", TextureAtlas.class);
            TextureAtlas overworldAtlas = assetManager.get("atlas/overworld-gfx-atlas.atlas", TextureAtlas.class);
            TextureAtlas itemsAtlas = assetManager.get("atlas/items-gfx-atlas", TextureAtlas.class);
            TextureAtlas boyAtlas = assetManager.get("atlas/boy-gfx-atlas", TextureAtlas.class);
            TextureAtlas girlAtlas = assetManager.get("atlas/girl.atlas", TextureAtlas.class);
            TextureAtlas effects = assetManager.get("atlas/move_effects_gfx.atlas", TextureAtlas.class);
            TextureAtlas mountains = assetManager.get("atlas/mountain-atlas.atlas", TextureAtlas.class);
            TextureAtlas tilesAtlas = assetManager.get("atlas/tiles-gfx-atlas", TextureAtlas.class);
            TextureAtlas blocks = assetManager.get("atlas/blocks.atlas", TextureAtlas.class);
            TextureAtlas characters = assetManager.get("atlas/characters.atlas", TextureAtlas.class);
            TextureAtlas clothing = assetManager.get("atlas/clothing.atlas", TextureAtlas.class);
            TextureAtlas hairstyles = assetManager.get("atlas/hairstyles.atlas", TextureAtlas.class);
            TextureAtlas buildings = assetManager.get("atlas/buildings.atlas", TextureAtlas.class);
            TextureAtlas autotiles = assetManager.get("atlas/autotiles_sheets.atlas", TextureAtlas.class);
            TextureAtlas capsuleThrow = assetManager.get("atlas/capsule_throw.atlas", TextureAtlas.class);
            TextureAtlas owEffectAtlas = assetManager.get("atlas/ow-effects.atlas", TextureAtlas.class);


            if (!verifyAtlas(boyAtlas)) {
                throw new RuntimeException("Boy atlas verification failed");
            }

            TextureManager.initialize(
                stepsAtlas,
                battleAtlas,
                uiAtlas,
                backAtlas,
                frontAtlas,
                iconAtlas,
                overworldAtlas,
                itemsAtlas,
                boyAtlas,
                tilesAtlas,
                effects,
                mountains, blocks, characters, clothing, hairstyles, buildings, girlAtlas, autotiles, capsuleThrow, owEffectAtlas

            );

            PokemonDatabase.initialize();

            ItemManager.initialize(TextureManager.items);
            AudioManager.getInstance();

            SpriteBatch mainBatch = new SpriteBatch();
            SpriteBatch uiBatch = new SpriteBatch();
            // This UI Stage will persist across screens.
            Stage uiStage = new Stage(new ScreenViewport(), uiBatch);
            Stage battleStage = new Stage();
            Skin skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));

            GameContext.init(this, this.gameClient, this.currentWorld, this.player, mainBatch, uiBatch, uiStage, battleStage, null, null, null, null, null, null, null, WorldManager.getInstance(), null, null, new DisconnectionManager(this), false, skin, null, null, new BiomeManager(System.currentTimeMillis()));

            GameContext.get().getWorldManager().init();

            GameLogger.info("Managers initialized successfully");

        } catch (Exception e) {
            GameLogger.error("Failed to initialize managers: " + e.getMessage());
            throw new RuntimeException("Failed to initialize game managers", e);
        }
    }

    private boolean verifyAtlas(TextureAtlas atlas) {
        if (atlas == null) {
            GameLogger.error("Boy" + " atlas is null");
            return false;
        }

        try {
            for (Texture texture : atlas.getTextures()) {
                if (texture == null) {
                    GameLogger.error("Boy" + " atlas has invalid textures");
                    return false;
                }
            }
            if (atlas.getRegions().isEmpty()) {
                GameLogger.error("Boy" + " atlas has no regions");
                return false;
            }

            return true;
        } catch (Exception e) {
            GameLogger.error("Error verifying " + "Boy" + " atlas: " + e.getMessage());
            return false;
        }
    }

    public Player getPlayer() {
        return GameContext.get().getPlayer();
    }


    public WorldManager getWorldManager() {
        return GameContext.get().getWorldManager();
    }
}

================
File: src/main/java/io/github/pokemeetup/FileSystemDelegate.java
================
package io.github.pokemeetup;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public interface FileSystemDelegate {
    boolean exists(String path);
    void createDirectory(String path);
    void writeString(String path, String content) throws IOException;
    String readString(String path) throws IOException;
    void deleteFile(String path);
    void deleteDirectory(String path);
    boolean isDirectory(String path); void moveFile(String sourcePath, String destinationPath) throws IOException;
    String[] list(String path);
    void copyFile(String sourcePath, String destinationPath) throws IOException;
    InputStream openInputStream(String path) throws IOException;
    OutputStream openOutputStream(String path) throws IOException;
}

================
File: src/main/java/io/github/pokemeetup/managers/BiomeManager.java
================
package io.github.pokemeetup.managers;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.google.gson.*;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.NoiseCache;
import io.github.pokemeetup.utils.OpenSimplex2;
import io.github.pokemeetup.utils.storage.GameFileSystem;
import io.github.pokemeetup.utils.textures.TileType;

import java.io.Serializable;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Enhanced BiomeManager for large, expansive biomes with smooth transitions.
 *
 * Key improvements:
 * - Larger biome scales for more expansive regions
 * - Biome clustering to group similar biomes together
 * - Multi-scale noise for better variety
 * - Reduced Voronoi site count for larger regions
 * - Smoother transitions between biomes
 */
public class BiomeManager {

    // ─────────────────────────────────────────────────────────────────────────
    // 1. TUNING CONSTANTS & FIELD DEFINITIONS
    // ─────────────────────────────────────────────────────────────────────────

    // MAJOR CHANGE: Increased scales for larger biomes (lower frequency = larger features)
    private static final float TEMPERATURE_SCALE = 0.00015f; // Was 0.0008f - now 5x larger
    private static final float MOISTURE_SCALE = 0.00018f;    // Was 0.0008f - now 4.5x larger
    private static final float ALTITUDE_SCALE = 0.0002f;     // Was 0.001f - now 5x larger

    // Multi-scale noise for more interesting variation
    private static final float TEMPERATURE_SCALE_DETAIL = 0.001f;  // Fine detail
    private static final float MOISTURE_SCALE_DETAIL = 0.0012f;    // Fine detail

    // Domain warp parameters (slightly reduced for smoother transitions)
    private static final float FREQ_WARP_1 = 0.0002f; // Was 0.0003f
    private static final float AMP_WARP_1 = 4f;       // Was 5f
    private static final float FREQ_WARP_2 = 0.0005f; // Was 0.0006f
    private static final float AMP_WARP_2 = 1.5f;     // Was 2f

    // Island parameters
    private static final int ISLAND_COUNT = 50;
    private static final float ISLAND_MIN_RADIUS = 3000f;
    private static final float ISLAND_MAX_RADIUS = 8000f;
    private static final float WORLD_RADIUS = 50000f;

    // MAJOR CHANGE: Reduced Voronoi sites for larger biome regions
    private static final int NUM_BIOME_SITES = 120; // Was 400 - now 3x larger regions

    // Biome clustering radius - biomes within this distance tend to be similar
    private static final float BIOME_CLUSTER_RADIUS = 8000f;

    // Transition smoothing distance
    private static final float TRANSITION_DISTANCE = 2000f;

    // Cache and state
    private final Map<Vector2, BiomeTransitionResult[][]> chunkBiomeCache = new ConcurrentHashMap<>();
    private final long temperatureSeed;
    private final long moistureSeed;
    private final long altitudeSeed;
    private final long detailSeed;
    private final long clusterSeed;
    private final List<BiomeSite> biomeSites = new ArrayList<>();
    private final List<BiomeCluster> biomeClusters = new ArrayList<>();
    private final List<Island> islandSites = new ArrayList<>();
    private final long warpSeed;
    private final Map<BiomeType, Biome> biomes;
    private long baseSeed;

    // ─────────────────────────────────────────────────────────────────────────
    // 2. CONSTRUCTOR & INITIALIZATION
    // ─────────────────────────────────────────────────────────────────────────

    public BiomeManager(long baseSeed) {
        this.baseSeed = baseSeed;
        this.temperatureSeed = baseSeed + 1000;
        this.moistureSeed = baseSeed + 2000;
        this.detailSeed = baseSeed + 3000;
        this.warpSeed = baseSeed + 4000;
        this.altitudeSeed = baseSeed + 5000;
        this.clusterSeed = baseSeed + 6000;

        this.biomes = new HashMap<>();

        loadBiomesFromJson();
        generateBiomeClusters(baseSeed);     // NEW: Generate biome clusters first
        generateBiomeSites(baseSeed);        // Then create sites within clusters
        generateRandomIslands(baseSeed);
    }

    // ─────────────────────────────────────────────────────────────────────────
    // 3. BIOME CLUSTERING SYSTEM (NEW)
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Generate biome clusters to ensure similar biomes group together
     */
    private void generateBiomeClusters(long seed) {
        biomeClusters.clear();
        Random rng = new Random(seed ^ 0xCAFEBABEL);

        // Define cluster archetypes
        BiomeClusterType[] clusterTypes = {
            BiomeClusterType.HOT_DRY,      // Desert regions
            BiomeClusterType.HOT_WET,      // Rainforest regions
            BiomeClusterType.COLD_DRY,     // Tundra/mountain regions
            BiomeClusterType.COLD_WET,     // Snow regions
            BiomeClusterType.TEMPERATE,    // Forest/plains regions
            BiomeClusterType.MYSTICAL      // Cherry/haunted regions
        };

        // Generate 15-25 major cluster regions
        int clusterCount = 15 + rng.nextInt(11);

        for (int i = 0; i < clusterCount; i++) {
            float x = (rng.nextFloat() - 0.5f) * 2f * WORLD_RADIUS * 0.8f;
            float y = (rng.nextFloat() - 0.5f) * 2f * WORLD_RADIUS * 0.8f;
            BiomeClusterType type = clusterTypes[rng.nextInt(clusterTypes.length)];
            float radius = BIOME_CLUSTER_RADIUS * (0.8f + rng.nextFloat() * 0.4f);

            BiomeCluster cluster = new BiomeCluster(x, y, radius, type);
            biomeClusters.add(cluster);
        }

        GameLogger.info("BiomeManager => created " + biomeClusters.size() + " biome clusters.");
    }

    /**
     * Enhanced biome site generation that respects clusters
     */
    private void generateBiomeSites(long seed) {
        biomeSites.clear();
        Random rng = new Random(seed ^ 0xDEADBEEFL);

        for (int i = 0; i < NUM_BIOME_SITES; i++) {
            float x = (rng.nextFloat() - 0.5f) * 2f * WORLD_RADIUS;
            float y = (rng.nextFloat() - 0.5f) * 2f * WORLD_RADIUS;

            // Find nearest cluster to influence this site
            BiomeCluster nearestCluster = findNearestCluster(x, y);

            // MAJOR CHANGE: Reduced random offsets for more consistent biomes
            double tOff = 0.0;
            double mOff = 0.0;

            if (nearestCluster != null) {
                float distToCluster = Vector2.dst(x, y, nearestCluster.x, nearestCluster.y);
                float influence = 1.0f - Math.min(1.0f, distToCluster / (nearestCluster.radius * 2));

                // Apply cluster-based offsets
                switch (nearestCluster.type) {
                    case HOT_DRY:
                        tOff = 0.3 * influence;   // Higher temperature
                        mOff = -0.3 * influence;  // Lower moisture
                        break;
                    case HOT_WET:
                        tOff = 0.25 * influence;  // Higher temperature
                        mOff = 0.3 * influence;   // Higher moisture
                        break;
                    case COLD_DRY:
                        tOff = -0.3 * influence;  // Lower temperature
                        mOff = -0.2 * influence;  // Lower moisture
                        break;
                    case COLD_WET:
                        tOff = -0.25 * influence; // Lower temperature
                        mOff = 0.2 * influence;   // Higher moisture
                        break;
                    case TEMPERATE:
                        // Small random variation for temperate zones
                        tOff = (rng.nextFloat() - 0.5) * 0.1 * influence;
                        mOff = (rng.nextFloat() - 0.5) * 0.1 * influence;
                        break;
                    case MYSTICAL:
                        // Moderate temperature with varied moisture
                        tOff = 0.1 * influence;
                        mOff = (rng.nextFloat() - 0.3) * 0.2 * influence;
                        break;
                }
            } else {
                // Sites far from clusters get small random variation
                tOff = (rng.nextFloat() - 0.5) * 0.1;
                mOff = (rng.nextFloat() - 0.5) * 0.1;
            }

            long detail = rng.nextLong();
            BiomeSite site = new BiomeSite(x, y, tOff, mOff, detail);
            biomeSites.add(site);
        }

        GameLogger.info("BiomeManager => created " + biomeSites.size() + " Voronoi sites with cluster influence.");
    }

    private BiomeCluster findNearestCluster(float x, float y) {
        BiomeCluster nearest = null;
        float minDist = Float.MAX_VALUE;

        for (BiomeCluster cluster : biomeClusters) {
            float dist = Vector2.dst(x, y, cluster.x, cluster.y);
            if (dist < minDist) {
                minDist = dist;
                nearest = cluster;
            }
        }

        return nearest;
    }

    // ─────────────────────────────────────────────────────────────────────────
    // 4. ENHANCED BIOME CLASSIFICATION
    // ─────────────────────────────────────────────────────────────────────────

    private Biome classifySiteToBiome(BiomeSite site, float wx, float wy) {
        // Multi-scale temperature sampling
        double baseTemp = NoiseCache.getNoise(temperatureSeed, wx, wy, TEMPERATURE_SCALE);
        double detailTemp = NoiseCache.getNoise(temperatureSeed + 1, wx, wy, TEMPERATURE_SCALE_DETAIL) * 0.1;

        // Multi-scale moisture sampling
        double baseMoist = NoiseCache.getNoise(moistureSeed, wx, wy, MOISTURE_SCALE);
        double detailMoist = NoiseCache.getNoise(moistureSeed + 1, wx, wy, MOISTURE_SCALE_DETAIL) * 0.1;

        // Altitude with less variation
        double baseAltitude = NoiseCache.getNoise(altitudeSeed, wx, wy, ALTITUDE_SCALE);

        // Combine base and detail
        double temp = baseTemp + detailTemp + site.tempOffset;
        double moist = baseMoist + detailMoist + site.moistOffset;

        // Add very subtle local variation
        double localVar = OpenSimplex2.noise2(detailSeed ^ site.siteDetail, wx * 0.0001, wy * 0.0001) * 0.02;

        temp = Math.min(Math.max(0, temp + localVar), 1);
        moist = Math.min(Math.max(0, moist + localVar), 1);
        double altitude = Math.min(Math.max(0, baseAltitude), 1);

        BiomeType type = BiomeClassifier.determineBiomeType(temp, moist, altitude, detailSeed, site.siteDetail);
        return getBiome(type);
    }

    // ─────────────────────────────────────────────────────────────────────────
    // 5. SMOOTH TRANSITIONS
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Enhanced Voronoi with smoother transitions
     */
    public BiomeTransitionResult landBiomeVoronoi(float wx, float wy) {
        // Find nearest sites (up to 4 for smoother blending)
        List<SiteDistance> nearestSites = findNearestSites(wx, wy, 4);

        if (nearestSites.isEmpty()) {
            return new BiomeTransitionResult(getBiome(BiomeType.PLAINS), null, 1f);
        }

        if (nearestSites.size() == 1) {
            Biome b = classifySiteToBiome(nearestSites.get(0).site, wx, wy);
            return new BiomeTransitionResult(b, null, 1f);
        }

        // Calculate smooth blending weights
        float totalWeight = 0;
        for (SiteDistance sd : nearestSites) {
            // Use inverse distance with smoothing
            sd.weight = 1f / (1f + sd.distance / TRANSITION_DISTANCE);
            totalWeight += sd.weight;
        }

        // Normalize weights
        for (SiteDistance sd : nearestSites) {
            sd.weight /= totalWeight;
        }

        // Get primary and secondary biomes
        Biome primary = classifySiteToBiome(nearestSites.get(0).site, wx, wy);
        Biome secondary = classifySiteToBiome(nearestSites.get(1).site, wx, wy);

        // Calculate smooth transition factor
        float d1 = nearestSites.get(0).distance;
        float d2 = nearestSites.get(1).distance;
        float raw = d2 / (d1 + d2);

        // Enhanced smoothstep for even smoother transitions
        float t = smoothStep(smoothStep(raw));

        // Prevent harsh desert-snow transitions
        if ((primary.getType() == BiomeType.SNOW && secondary.getType() == BiomeType.DESERT) ||
            (primary.getType() == BiomeType.DESERT && secondary.getType() == BiomeType.SNOW)) {
            return new BiomeTransitionResult(getBiome(BiomeType.PLAINS), null, 1f);
        }

        return new BiomeTransitionResult(primary, secondary, t);
    }

    private List<SiteDistance> findNearestSites(float wx, float wy, int count) {
        List<SiteDistance> distances = new ArrayList<>();

        for (BiomeSite site : biomeSites) {
            float dx = wx - site.x;
            float dy = wy - site.y;
            float dist = (float) Math.sqrt(dx * dx + dy * dy);
            distances.add(new SiteDistance(site, dist));
        }

        distances.sort(Comparator.comparingDouble(sd -> sd.distance));

        return distances.subList(0, Math.min(count, distances.size()));
    }

    private static float smoothStep(float t) {
        return t * t * (3f - 2f * t);
    }

    // ─────────────────────────────────────────────────────────────────────────
    // 6. EXISTING METHODS (with minor adjustments)
    // ─────────────────────────────────────────────────────────────────────────

    public void setBaseSeed(long baseSeed) {
        this.baseSeed = baseSeed;
    }

    public BiomeTransitionResult getBiomeAtTile(int tileX, int tileY) {
        float worldX = (tileX + 0.5f) * World.TILE_SIZE;
        float worldY = (tileY + 0.5f) * World.TILE_SIZE;
        float[] warped = domainWarp(worldX, worldY);
        return getBiomeFromAlreadyWarped(warped[0], warped[1]);
    }

    public BiomeTransitionResult getBiomeAt(float worldPixelX, float worldPixelY) {
        int tileX = (int) Math.floor(worldPixelX / World.TILE_SIZE);
        int tileY = (int) Math.floor(worldPixelY / World.TILE_SIZE);
        return getBiomeAtTile(tileX, tileY);
    }

    public BiomeTransitionResult getBiomeFromAlreadyWarped(float wx, float wy) {
        Island isl = findClosestIsland(wx, wy);
        if (isl == null) {
            return new BiomeTransitionResult(getBiome(BiomeType.OCEAN), null, 1f);
        }

        float dx = wx - isl.centerX;
        float dy = wy - isl.centerY;
        float dist = (float) Math.sqrt(dx * dx + dy * dy);

        float angle = MathUtils.atan2(dy, dx);
        float distort = OpenSimplex2.noise2(isl.seed, MathUtils.cos(angle), MathUtils.sin(angle));
        distort = Math.max(0f, distort);

        float newExpandFactor = 1.3f;
        float reducedFactor = 0.1f;
        float effectiveRadius = isl.radius * newExpandFactor + (isl.radius * newExpandFactor * reducedFactor * distort);

        float beachBand = effectiveRadius * 0.1f;
        float innerThreshold = effectiveRadius;
        float outerThreshold = effectiveRadius + beachBand;

        if (dist < innerThreshold) {
            return landBiomeVoronoi(wx, wy);
        } else if (dist < outerThreshold) {
            return new BiomeTransitionResult(getBiome(BiomeType.BEACH), null, 1f);
        } else {
            return new BiomeTransitionResult(getBiome(BiomeType.OCEAN), null, 1f);
        }
    }

    public Vector2 findSafeSpawnLocation(World world, Random rng) {
        if (islandSites.isEmpty()) {
            GameLogger.error("No islands found; defaulting spawn to (0,0)");
            return new Vector2(0, 0);
        }
        int maxAttempts = 200;
        Island isl = islandSites.get(rng.nextInt(islandSites.size()));
        float margin = 100f;
        float safeRange = Math.max(isl.radius - margin, 20f);

        for (int i = 0; i < maxAttempts; i++) {
            float angle = rng.nextFloat() * MathUtils.PI2;
            float dist = rng.nextFloat() * safeRange;
            float candX = isl.centerX + MathUtils.cos(angle) * dist;
            float candY = isl.centerY + MathUtils.sin(angle) * dist;

            int tileX = MathUtils.floor(candX / World.TILE_SIZE);
            int tileY = MathUtils.floor(candY / World.TILE_SIZE);

            if (world.isWithinWorldBounds(tileX, tileY) && world.isPassable(tileX, tileY)) {
                return new Vector2(tileX, tileY);
            }
        }

        GameLogger.error("Failed to find safe island spawn; use center");
        int cx = MathUtils.floor(isl.centerX / World.TILE_SIZE);
        int cy = MathUtils.floor(isl.centerY / World.TILE_SIZE);
        if (!world.isWithinWorldBounds(cx, cy)) {
            return new Vector2(0, 0);
        }
        return new Vector2(cx, cy);
    }

    public long getWarpSeed() {
        return warpSeed;
    }

    public float[] domainWarp(float x, float y) {
        float dx1 = (float) OpenSimplex2.noise2(warpSeed, x * FREQ_WARP_1, y * FREQ_WARP_1) * AMP_WARP_1;
        float dy1 = (float) OpenSimplex2.noise2(warpSeed + 1337, x * FREQ_WARP_1, y * FREQ_WARP_1) * AMP_WARP_1;
        float wx1 = x + dx1;
        float wy1 = y + dy1;

        float dx2 = (float) OpenSimplex2.noise2(warpSeed + 999, wx1 * FREQ_WARP_2, wy1 * FREQ_WARP_2) * AMP_WARP_2;
        float dy2 = (float) OpenSimplex2.noise2(warpSeed + 1999, wx1 * FREQ_WARP_2, wy1 * FREQ_WARP_2) * AMP_WARP_2;

        return new float[]{wx1 + dx2, wy1 + dy2};
    }

    private void generateRandomIslands(long seed) {
        islandSites.clear();
        Random rng = new Random(seed ^ 0xBEEF9876L);
        float regionSize = WORLD_RADIUS * 0.85f;
        for (int i = 0; i < ISLAND_COUNT; i++) {
            float cx = -regionSize + rng.nextFloat() * (2 * regionSize);
            float cy = -regionSize + rng.nextFloat() * (2 * regionSize);
            float r = ISLAND_MIN_RADIUS + rng.nextFloat() * (ISLAND_MAX_RADIUS - ISLAND_MIN_RADIUS);
            long islandSeed = rng.nextLong();
            Island isl = new Island(cx, cy, r, islandSeed);
            islandSites.add(isl);
        }

        Island centerIsland = new Island(0, 0, ISLAND_MAX_RADIUS, baseSeed);
        islandSites.add(centerIsland);

        GameLogger.info("Created " + islandSites.size() + " island sites (including central island).");
    }

    public Island findClosestIsland(float wx, float wy) {
        float roundedX = (float) (Math.floor(wx / 100.0f) * 100.0f);
        float roundedY = (float) (Math.floor(wy / 100.0f) * 100.0f);

        Island best = null;
        float bestDist = Float.MAX_VALUE;

        List<Island> sortedIslands = new ArrayList<>(islandSites);
        sortedIslands.sort((a, b) -> Long.compare(a.seed, b.seed));

        for (Island isl : sortedIslands) {
            float dx = roundedX - isl.centerX;
            float dy = roundedY - isl.centerY;
            float dist = dx * dx + dy * dy;
            if (dist < bestDist) {
                bestDist = dist;
                best = isl;
            }
        }

        return best;
    }

    public BiomeTransitionResult[][] computeBiomeMatrixForChunk(int chunkX, int chunkY) {
        Vector2 key = new Vector2(chunkX, chunkY);
        if (chunkBiomeCache.containsKey(key)) {
            return chunkBiomeCache.get(key);
        }

        int size = Chunk.CHUNK_SIZE;
        int outW = size + 1;
        int outH = size + 1;
        BiomeTransitionResult[][] matrix = new BiomeTransitionResult[outW][outH];

        float baseWX = chunkX * size * World.TILE_SIZE;
        float baseWY = chunkY * size * World.TILE_SIZE;
        for (int bx = 0; bx < outW; bx++) {
            for (int by = 0; by < outH; by++) {
                float fx = baseWX + bx * World.TILE_SIZE;
                float fy = baseWY + by * World.TILE_SIZE;

                float[] warped = domainWarp(fx, fy);
                matrix[bx][by] = getBiomeFromAlreadyWarped(warped[0], warped[1]);
            }
        }

        chunkBiomeCache.put(key, matrix);
        return matrix;
    }

    public Biome getBiome(BiomeType type) {
        Biome b = biomes.get(type);
        if (b == null) {
            GameLogger.error("Biome data missing for " + type + ", fallback to PLAINS");
            return biomes.get(BiomeType.PLAINS);
        }
        return b;
    }

    private void loadBiomesFromJson() {
        try {
            String content = GameFileSystem.getInstance().getDelegate().readString("Data/biomes.json");
            if (content == null) {
                initializeDefaultBiomes();
                return;
            }
            JsonParser parser = new JsonParser();
            JsonArray arr = parser.parse(content).getAsJsonArray();
            for (JsonElement elem : arr) {
                JsonObject obj = elem.getAsJsonObject();
                BiomeData data = parseBiomeData(obj);
                if (validateBiomeData(data)) {
                    Biome b = createBiomeFromData(data);
                    biomes.put(b.getType(), b);
                } else {
                    GameLogger.error("Invalid biome data => " + data.getName());
                }
            }
        } catch (Exception e) {
            GameLogger.error("BiomeManager => failed to load JSON => " + e.getMessage());
            initializeDefaultBiomes();
        }
    }

    private void initializeDefaultBiomes() {
        if (!biomes.containsKey(BiomeType.OCEAN)) {
            Biome ocean = new Biome("Ocean", BiomeType.OCEAN);
            ocean.setAllowedTileTypes(List.of());
            ocean.getTileDistribution().put(TileType.WATER, 100);
            biomes.put(BiomeType.OCEAN, ocean);
        }
        if (!biomes.containsKey(BiomeType.BEACH)) {
            Biome beach = new Biome("Beach", BiomeType.BEACH);
            beach.setAllowedTileTypes(List.of());
            beach.getTileDistribution().put(TileType.BEACH_SAND, 100);
            biomes.put(BiomeType.BEACH, beach);
        }
        GameLogger.info("Default fallback biomes have been created");
    }

    private BiomeData parseBiomeData(JsonObject json) {
        BiomeData data = new BiomeData();

        data.setName(json.get("name").getAsString());
        data.setType(json.get("type").getAsString());

        List<Integer> atypes = new ArrayList<>();
        if (json.has("allowedTileTypes")) {
            JsonArray arr = json.getAsJsonArray("allowedTileTypes");
            for (JsonElement e : arr) {
                atypes.add(e.getAsInt());
            }
        }
        data.setAllowedTileTypes(atypes);

        if (json.has("tileDistribution")) {
            JsonObject distObj = json.getAsJsonObject("tileDistribution");
            Map<Integer, Integer> dist = new HashMap<>();
            double sum = 0.0;
            for (Map.Entry<String, JsonElement> en : distObj.entrySet()) {
                int tid = Integer.parseInt(en.getKey());
                double w = en.getValue().getAsDouble();
                dist.put(tid, (int) Math.round(w));
                sum += w;
            }
            data.setTileDistribution(dist);
        }

        if (json.has("transitionTileTypes")) {
            JsonObject trans = json.getAsJsonObject("transitionTileTypes");
            Map<Integer, Integer> tdist = new HashMap<>();
            for (Map.Entry<String, JsonElement> en : trans.entrySet()) {
                int tid = Integer.parseInt(en.getKey());
                double w = en.getValue().getAsDouble();
                tdist.put(tid, (int) Math.round(w));
            }
            data.setTransitionTileDistribution(tdist);
        }

        if (json.has("spawnableObjects")) {
            JsonArray arr = json.getAsJsonArray("spawnableObjects");
            List<String> sObjs = new ArrayList<>();
            for (JsonElement e : arr) {
                sObjs.add(e.getAsString());
            }
            data.setSpawnableObjects(sObjs);
        }

        if (json.has("spawnChances")) {
            JsonObject cobj = json.getAsJsonObject("spawnChances");
            Map<String, Double> sc = new HashMap<>();
            for (Map.Entry<String, JsonElement> e : cobj.entrySet()) {
                sc.put(e.getKey(), e.getValue().getAsDouble());
            }
            data.setSpawnChances(sc);
        }

        data.validate();
        return data;
    }

    private boolean validateBiomeData(BiomeData data) {
        if (data.getName() == null || data.getType() == null) return false;
        if (data.getAllowedTileTypes().isEmpty()) return false;
        return !data.getTileDistribution().isEmpty();
    }

    private Biome createBiomeFromData(BiomeData data) {
        BiomeType btype = BiomeType.valueOf(data.getType());
        Biome b = new Biome(data.getName(), btype);
        b.setAllowedTileTypes(data.getAllowedTileTypes());
        b.setTileDistribution(data.getTileDistribution());
        b.setTransitionTileDistribution(data.getTransitionTileDistribution());
        if (data.getSpawnableObjects() != null) {
            b.loadSpawnableObjects(data.getSpawnableObjects());
        }
        if (data.getSpawnChances() != null) {
            b.loadSpawnChances(data.getSpawnChances());
        }
        return b;
    }

    // ─────────────────────────────────────────────────────────────────────────
    // 7. HELPER CLASSES
    // ─────────────────────────────────────────────────────────────────────────

    public static class Island {
        public float centerX, centerY, radius;
        public long seed;

        public Island(float x, float y, float r, long s) {
            centerX = x;
            centerY = y;
            radius = r;
            seed = s;
        }
    }

    private static class BiomeSite {
        public float x, y;
        public double tempOffset, moistOffset;
        public long siteDetail;

        public BiomeSite(float x, float y, double tOff, double mOff, long detail) {
            this.x = x;
            this.y = y;
            this.tempOffset = tOff;
            this.moistOffset = mOff;
            this.siteDetail = detail;
        }
    }

    /**
     * Biome cluster for grouping similar biomes
     */
    private static class BiomeCluster {
        public float x, y, radius;
        public BiomeClusterType type;

        public BiomeCluster(float x, float y, float radius, BiomeClusterType type) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.type = type;
        }
    }

    private enum BiomeClusterType {
        HOT_DRY,      // Desert clusters
        HOT_WET,      // Rainforest clusters
        COLD_DRY,     // Mountain/tundra clusters
        COLD_WET,     // Snow clusters
        TEMPERATE,    // Forest/plains clusters
        MYSTICAL      // Cherry/haunted clusters
    }

    private static class SiteDistance {
        public BiomeSite site;
        public float distance;
        public float weight;

        public SiteDistance(BiomeSite site, float distance) {
            this.site = site;
            this.distance = distance;
            this.weight = 0;
        }
    }

    public static class BiomeData implements Serializable {
        private String name;
        private String type;
        private ArrayList<Integer> allowedTileTypes = new ArrayList<>();
        private HashMap<Integer, Integer> tileDistribution = new HashMap<>();
        private HashMap<Integer, Integer> transitionTileDistribution = new HashMap<>();
        private List<String> spawnableObjects = new ArrayList<>();
        private Map<String, Double> spawnChances = new HashMap<>();

        public void validate() {
            if (tileDistribution == null) tileDistribution = new HashMap<>();
            if (transitionTileDistribution == null) transitionTileDistribution = new HashMap<>();
            if (allowedTileTypes == null) allowedTileTypes = new ArrayList<>();
            if (spawnableObjects == null) spawnableObjects = new ArrayList<>();
            if (spawnChances == null) spawnChances = new HashMap<>();
        }

        public String getName() { return name; }
        public void setName(String n) { name = n; }
        public String getType() { return type; }
        public void setType(String t) { type = t; }
        public ArrayList<Integer> getAllowedTileTypes() { return allowedTileTypes; }
        public void setAllowedTileTypes(List<Integer> t) {
            if (t != null) {
                allowedTileTypes.clear();
                allowedTileTypes.addAll(t);
            }
        }
        public HashMap<Integer, Integer> getTileDistribution() { return tileDistribution; }
        public void setTileDistribution(Map<Integer, Integer> dist) {
            if (dist != null) {
                tileDistribution.clear();
                tileDistribution.putAll(dist);
            }
        }
        public HashMap<Integer, Integer> getTransitionTileDistribution() { return transitionTileDistribution; }
        public void setTransitionTileDistribution(Map<Integer, Integer> dist) {
            if (dist != null) {
                transitionTileDistribution.clear();
                transitionTileDistribution.putAll(dist);
            }
        }
        public List<String> getSpawnableObjects() { return spawnableObjects; }
        public void setSpawnableObjects(List<String> s) { spawnableObjects = s; }
        public Map<String, Double> getSpawnChances() { return spawnChances; }
        public void setSpawnChances(Map<String, Double> c) { spawnChances = c; }
    }

    // ─────────────────────────────────────────────────────────────────────────
    // 8. ENHANCED BIOME CLASSIFIER
    // ─────────────────────────────────────────────────────────────────────────

    private static class BiomeClassifier {

        /**
         * Enhanced biome classification with better thresholds for expansive biomes
         */
        public static BiomeType determineBiomeType(double temperature, double moisture, double altitude, long detailSeed, long siteDetail) {
            // Adjust temperature based on altitude (gentler curve)
            double adjustedTemp = temperature - (altitude * 0.3f); // Was 0.4f
            adjustedTemp = Math.min(Math.max(0, adjustedTemp), 1);

            double t = adjustedTemp;
            double m = moisture;

            // === Improved Biome Thresholds for Larger Regions ===

            // Very Cold (expanded threshold)
            if (t < 0.2) { // Was 0.15
                if (m < 0.35) return BiomeType.HAUNTED; // Expanded haunted range
                return BiomeType.SNOW;
            }

            // Cold (expanded threshold)
            if (t < 0.35) { // Was 0.3
                if (m < 0.25 && altitude > 0.5) return BiomeType.HAUNTED;
                if (m > 0.6) return BiomeType.SNOW; // Cold and wet = snow
                return BiomeType.PLAINS; // Cold temperate
            }

            // Very Hot (expanded threshold)
            if (t > 0.7) { // Was 0.75
                if (m > 0.6) return BiomeType.RAIN_FOREST;
                if (m < 0.35) return BiomeType.DESERT; // Expanded desert range
                return BiomeType.PLAINS;
            }

            // Temperate zones (main biome variety)
            if (m > 0.65) { // Wet temperate
                if (t > 0.55) return BiomeType.RAIN_FOREST;
                return BiomeType.FOREST;
            } else if (m > 0.35) { // Moderate moisture
                // Use noise for special biome placement
                double detailNoise = OpenSimplex2.noise2(siteDetail ^ detailSeed, t * 8, m * 8);

                if (detailNoise > 0.6 && altitude < 0.5 && t > 0.45) {
                    return BiomeType.CHERRY_GROVE; // Cherry groves in warm, low areas
                }
                if (detailNoise < -0.5 && t < 0.45) {
                    return BiomeType.HAUNTED; // Haunted forests in cooler areas
                }

                // Default to forest with some plains
                if (detailNoise > 0.3 || detailNoise < -0.3) {
                    return BiomeType.FOREST;
                }
                return BiomeType.PLAINS;
            } else { // Dry temperate
                if (altitude > 0.7) return BiomeType.PLAINS; // High dry areas
                if (t > 0.6) return BiomeType.DESERT; // Warm and dry
                return BiomeType.PLAINS;
            }
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/managers/BiomeRenderer.java
================
// File: src/main/java/io/github/pokemeetup/managers/BiomeRenderer.java
package io.github.pokemeetup.managers;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.mechanics.AutoTileSystem;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.textures.TileType;

/**
 * Renders chunk tiles, including:
 *  - Animated ocean tiles (8 frames)
 *  - Day/night & torch lighting
 *  - Animated “sand_shore” overlay (with inner corners)
 */
public class BiomeRenderer {

    private static final float TEXTURE_BLEED_FIX = 0.001f;

    // Ocean animation timing
    private static final float OCEAN_FRAME_DELAY = 1.5f;
    private static float oceanFrameTimer = 0f;
    private static int oceanFrameIndex = 0; // 0..7

    // Shore animation timing
    private static final float SHORE_FRAME_DELAY = 1.5f;
    private static float shoreFrameTimer = 0f;
    private static int shoreFrameIndex = 0; // 0..7

    /**
     * Update both ocean and shore frames each frame (0..7).
     */
    public static void updateAnimations() {
        float delta = Gdx.graphics.getDeltaTime();

        // Ocean
        oceanFrameTimer += delta;
        if (oceanFrameTimer >= OCEAN_FRAME_DELAY) {
            oceanFrameIndex = (oceanFrameIndex + 1) % 8;
            oceanFrameTimer -= OCEAN_FRAME_DELAY;
        }

        // Shore
        shoreFrameTimer += delta;
        if (shoreFrameTimer >= SHORE_FRAME_DELAY) {
            shoreFrameIndex = (shoreFrameIndex + 1) % 8;
            shoreFrameTimer -= SHORE_FRAME_DELAY;
        }
    }

    /**
     * Render the given chunk’s tiles:
     *  1) Re‐apply shoreline autotiling with shoreFrameIndex (0..7) to animate
     *  2) Draw each tile (animated water if tile=water)
     *  3) Draw any overlay sub‐tile from chunk.getAutotileRegions(),
     *     including composite mini‐overlays for “inner corners.”
     */
    public void renderChunk(SpriteBatch batch, Chunk chunk, World world) {
        final int size = Chunk.CHUNK_SIZE;
        int chunkX = chunk.getChunkX();
        int chunkY = chunk.getChunkY();

        // 1) Re‐apply “sand_shore” autotiling with the updated frame
        //    so we see the 8–frame animation:
        AutoTileSystem autoTileSystem = new AutoTileSystem();
        autoTileSystem.applyShorelineAutotiling(chunk, shoreFrameIndex, world);

        // Update animation indexes
        updateAnimations();

        // 2) Obtain (or re‐obtain) the chunk’s overlay array:
        TextureRegion[][] overlay = chunk.getAutotileRegions();
        if (overlay == null) {
            // Possibly chunk just created, ensure it's allocated:
            overlay = new TextureRegion[size][size];
            chunk.setAutotileRegions(overlay);
        }

        // 3) Draw each cell
        for (int x = 0; x < size; x++) {
            for (int y = 0; y < size; y++) {
                float px = (chunkX * size + x) * World.TILE_SIZE;
                float py = (chunkY * size + y) * World.TILE_SIZE;

                // Decide day/night lighting color:
                Color tileColor = determineLightingColor(world, chunkX, chunkY, x, y);
                batch.setColor(tileColor);

                // If tile is water => draw animated ocean center frame
                int tileType = chunk.getTileType(x, y);
                if (tileType == TileType.WATER) {
                    TextureRegion waterAnim = TextureManager.getOceanCenterFrame(oceanFrameIndex);
                    if (waterAnim != null) {
                        batch.draw(waterAnim, px, py, World.TILE_SIZE, World.TILE_SIZE);
                    }
                } else {
                    // Otherwise, draw static tile
                    TextureRegion baseTex = TextureManager.getTileTexture(tileType);
                    if (baseTex != null) {
                        // Fix for potential bleeding
                        float u  = baseTex.getU()  + TEXTURE_BLEED_FIX;
                        float v2 = baseTex.getV2() - TEXTURE_BLEED_FIX;
                        float u2 = baseTex.getU2() - TEXTURE_BLEED_FIX;
                        float v  = baseTex.getV()  + TEXTURE_BLEED_FIX;

                        batch.draw(baseTex.getTexture(),
                            px, py,
                            World.TILE_SIZE, World.TILE_SIZE,
                            u, v2, u2, v);
                    }
                }

                TextureRegion shoreOverlay = overlay[x][y];
                if (shoreOverlay instanceof AutoTileSystem.CompositeRegion) {
                    AutoTileSystem.CompositeRegion comp = (AutoTileSystem.CompositeRegion) shoreOverlay;
                    // Draw base 32×32
                    batch.draw(comp.getBase32(), px, py, 32,32);
                    // Then corners
                    for (AutoTileSystem.MiniOverlay mo : comp.getOverlays()) {
                        batch.draw(mo.region16, px+mo.offsetX, py+mo.offsetY, 16,16);
                    }
                }
                else if (shoreOverlay != null) {
                    // Single tile
                    batch.draw(shoreOverlay, px, py, 32,32);
                }


            }
        }
    }

    /**
     * Combine day/night color + optional torch glow
     */
    private Color determineLightingColor(World world, int chunkX, int chunkY, int lx, int ly) {
        Color base = world.getCurrentWorldColor().cpy();
        // Torch glow?
        int gx = chunkX * Chunk.CHUNK_SIZE + lx;
        int gy = chunkY * Chunk.CHUNK_SIZE + ly;
        Float light = world.getLightLevelAtTile(new Vector2(gx, gy));
        if (light != null && light > 0f) {
            Color torch = new Color(1f, 0.8f, 0.6f, 1f);
            base.lerp(torch, light);
        }
        return base;
    }public enum Direction {
        NORTH, SOUTH, EAST, WEST
    }
}

================
File: src/main/java/io/github/pokemeetup/managers/BiomeTransitionResult.java
================
package io.github.pokemeetup.managers;

import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import java.util.Objects;

/**
 * Represents a biome transition result that can contain either a single biome
 * or a transition between two biomes with a blend factor.
 *
 * This class is immutable and thread-safe, following best practices for
 * data transfer objects in concurrent environments.
 *
 * @author PokeMeetup Team
 * @version 2.0
 */
public final class BiomeTransitionResult {

    private final Biome primaryBiome;
    private final Biome secondaryBiome;
    private final float transitionFactor;

    /**
     * Creates a biome transition result.
     *
     * @param primaryBiome The primary (dominant) biome, must not be null
     * @param secondaryBiome The secondary biome for transitions, can be null for single biome
     * @param transitionFactor The blend factor (0.0 = full secondary, 1.0 = full primary)
     * @throws IllegalArgumentException if primaryBiome is null or transitionFactor is out of range
     */
    public BiomeTransitionResult(Biome primaryBiome, Biome secondaryBiome, float transitionFactor) {
        if (primaryBiome == null) {
            throw new IllegalArgumentException("Primary biome cannot be null");
        }
        if (transitionFactor < 0.0f || transitionFactor > 1.0f) {
            throw new IllegalArgumentException("Transition factor must be between 0.0 and 1.0, got: " + transitionFactor);
        }

        this.primaryBiome = primaryBiome;
        this.secondaryBiome = secondaryBiome;
        this.transitionFactor = transitionFactor;
    }

    /**
     * Creates a single-biome result with no transition.
     *
     * @param biome The single biome
     * @return A BiomeTransitionResult with only the primary biome
     */
    public static BiomeTransitionResult single(Biome biome) {
        return new BiomeTransitionResult(biome, null, 1.0f);
    }

    /**
     * Creates a transition between two biomes.
     *
     * @param primary The primary biome
     * @param secondary The secondary biome
     * @param factor The transition factor (0.0 = full secondary, 1.0 = full primary)
     * @return A BiomeTransitionResult representing the transition
     */
    public static BiomeTransitionResult transition(Biome primary, Biome secondary, float factor) {
        return new BiomeTransitionResult(primary, secondary, factor);
    }

    /**
     * Gets the primary biome.
     *
     * @return The primary biome, never null
     */
    public Biome getPrimaryBiome() {
        return primaryBiome;
    }

    /**
     * Gets the secondary biome if this represents a transition.
     *
     * @return The secondary biome, or null if this is a single biome
     */
    public Biome getSecondaryBiome() {
        return secondaryBiome;
    }

    /**
     * Gets the transition factor between biomes.
     *
     * @return The transition factor (0.0 = full secondary, 1.0 = full primary)
     */
    public float getTransitionFactor() {
        return transitionFactor;
    }

    /**
     * Checks if this result represents a transition between two biomes.
     *
     * @return true if this is a transition, false if single biome
     */
    public boolean isTransition() {
        return secondaryBiome != null;
    }

    /**
     * Gets the effective biome based on the transition factor.
     * Returns primary if factor >= 0.5, otherwise secondary.
     *
     * @return The dominant biome based on transition factor
     */
    public Biome getEffectiveBiome() {
        if (!isTransition() || transitionFactor >= 0.5f) {
            return primaryBiome;
        }
        return secondaryBiome;
    }

    /**
     * Calculates the weight of the primary biome in the transition.
     *
     * @return The weight of the primary biome (same as transition factor)
     */
    public float getPrimaryWeight() {
        return transitionFactor;
    }

    /**
     * Calculates the weight of the secondary biome in the transition.
     *
     * @return The weight of the secondary biome (1 - transition factor)
     */
    public float getSecondaryWeight() {
        return 1.0f - transitionFactor;
    }

    /**
     * Inverts the transition, swapping primary and secondary biomes.
     *
     * @return A new BiomeTransitionResult with swapped biomes
     */
    public BiomeTransitionResult invert() {
        if (!isTransition()) {
            return this;
        }
        return new BiomeTransitionResult(secondaryBiome, primaryBiome, 1.0f - transitionFactor);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        BiomeTransitionResult that = (BiomeTransitionResult) o;

        return Float.compare(that.transitionFactor, transitionFactor) == 0 &&
            Objects.equals(primaryBiome, that.primaryBiome) &&
            Objects.equals(secondaryBiome, that.secondaryBiome);
    }

    @Override
    public int hashCode() {
        return Objects.hash(primaryBiome, secondaryBiome, transitionFactor);
    }

    @Override
    public String toString() {
        if (isTransition()) {
            return String.format("BiomeTransition[%s -> %s @ %.2f]",
                primaryBiome.getName(),
                secondaryBiome.getName(),
                transitionFactor);
        } else {
            return String.format("BiomeTransition[%s]", primaryBiome.getName());
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/managers/DatabaseManager.java
================
package io.github.pokemeetup.managers;

import at.favre.lib.crypto.bcrypt.BCrypt;
import io.github.pokemeetup.utils.GameLogger;

import java.nio.charset.StandardCharsets;
import java.sql.*;

import static io.github.pokemeetup.utils.PasswordUtils.hashPassword;

public class DatabaseManager {
    private static final String DB_PATH = "real";
    public static final String DB_USER = "sa";
    public static final String DB_PASS = "";
    private static final int BASE_PORT = 9101;
    private Connection connection;


    public DatabaseManager() {
        try {
            connectToDatabase();
            initializeDatabase();
        } catch (SQLException e) {
            GameLogger.info("Database initialization error: " + e.getMessage());
            throw new RuntimeException("Failed to initialize database", e);
        }
    }

    public boolean checkUsernameExists(String username) {
        String sql = "SELECT COUNT(*) FROM PLAYERS WHERE USERNAME = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                return rs.getInt(1) > 0;
            }
            return false;
        } catch (SQLException e) {
            GameLogger.error("Database error checking username: " + e.getMessage());
            throw new RuntimeException("Database error checking username", e);
        }
    }

    private void connectToDatabase() throws SQLException {
        @SuppressWarnings("DefaultLocale")
        String url = String.format("jdbc:h2:tcp://localhost:%d/%s", BASE_PORT, DB_PATH);
        connection = DriverManager.getConnection(url, DB_USER, DB_PASS);
        GameLogger.info("Connected to database on port " + BASE_PORT);
    }


    public void dispose() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
                GameLogger.info("Database connection closed");
            }
        } catch (SQLException e) {
            GameLogger.error("Error closing database connection: " + e.getMessage());
        }
    }

    private Connection getConnection() throws SQLException {
        if (connection == null || connection.isClosed()) {
            connectToDatabase();
        }
        return connection;
    }

    private void ensureConnection() {
        try {
            if (connection == null || connection.isClosed()) {
                GameLogger.info("Reconnecting to database...");
                connectToDatabase();
            }
        } catch (SQLException e) {
            GameLogger.info("Error checking connection: " + e.getMessage());
        }
    }
    public boolean registerPlayer(String username, String password) {
        if (doesUsernameExist(username)) {
            GameLogger.info("Username already exists: " + username);
            return false;
        }
        String sql = "INSERT INTO PLAYERS (username, password_hash, x_pos, y_pos) VALUES (?, ?, 0, 0)";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            String hashedPassword = hashPassword(password);
            stmt.setString(1, username);
            stmt.setString(2, hashedPassword);

            int result = stmt.executeUpdate();
            GameLogger.info("Player registration " + (result > 0 ? "successful" : "failed") +
                " for username: " + username);
            return result > 0;
        } catch (SQLException e) {
            GameLogger.error("Database error registering player: " + e.getMessage());
            throw new RuntimeException("Database error registering player", e);
        }
    }
    private void initializeDatabase() {
        String createPlayersTable =
            "CREATE TABLE IF NOT EXISTS PLAYERS (" +
                "id BIGINT AUTO_INCREMENT PRIMARY KEY, " +
                "username VARCHAR(255) NOT NULL UNIQUE, " +
                "password_hash VARCHAR(255) NOT NULL, " +
                "created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP(), " +
                "last_login TIMESTAMP, " +
                "status VARCHAR(20) DEFAULT 'OFFLINE', " +
                "x_pos INT DEFAULT 0, " +
                "y_pos INT DEFAULT 0" +
                ")";

        try (Statement stmt = connection.createStatement()) {
            stmt.execute(createPlayersTable);
            GameLogger.info("Database tables initialized successfully");
        } catch (SQLException e) {
            GameLogger.error("Error initializing database: " + e.getMessage());
            throw new RuntimeException("Failed to initialize database", e);
        }
    }

    public void updatePlayerCoordinates(String username, int x, int y) {
        ensureConnection();
        String updateSQL = "UPDATE PLAYERS SET x_pos = ?, y_pos = ? WHERE username = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(updateSQL)) {
            pstmt.setInt(1, x);
            pstmt.setInt(2, y);
            pstmt.setString(3, username);
            GameLogger.info("Updated coordinates for " + username + ": (" + x + ", " + y + ")");
        } catch (SQLException e) {
            GameLogger.error("Error updating coordinates: " + e.getMessage());
            throw new RuntimeException("Failed to update player coordinates", e);
        }
    }

    private boolean doesUsernameExist(String username) {
        String sql = "SELECT 1 FROM PLAYERS WHERE username = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();
            boolean exists = rs.next();
            GameLogger.info("Username check: '" + username + "' exists: " + exists);
            return exists;
        } catch (SQLException e) {
            GameLogger.error("Error checking if username exists: " + e.getMessage());
            throw new RuntimeException("Database error checking username", e);
        }
    }

    public void closeConnection() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
                GameLogger.info("Database connection closed.");
            }
        } catch (SQLException e) {
            GameLogger.info("Error closing database connection: " + e.getMessage());
        }
    }

    public boolean authenticatePlayer(String username, String password) {
        // Updated to use password_hash column name
        String query = "SELECT password_hash FROM PLAYERS WHERE username = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(query)) {

            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                String storedHash = rs.getString("password_hash");
                boolean verified = BCrypt.verifyer().verify(
                    password.getBytes(StandardCharsets.UTF_8),
                    storedHash.getBytes(StandardCharsets.UTF_8)
                ).verified;

                if (verified) {
                    updateLastLogin(username);
                    GameLogger.info("Authentication successful for username: " + username);
                } else {
                    GameLogger.info("Authentication failed - invalid password for username: " + username);
                }

                return verified;
            }
            GameLogger.info("Authentication failed - username not found: " + username);
            return false;
        } catch (SQLException e) {
            GameLogger.error("Database error during authentication: " + e.getMessage());
            return false;
        }
    }  public String getPasswordHash(String username) {
        String query = "SELECT password_hash FROM PLAYERS WHERE username = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(query)) {

            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                String storedHash = rs.getString("password_hash");
                GameLogger.info("Retrieved password hash for username: " + username);
                return storedHash;
            } else {
                GameLogger.info("No password hash found for username: " + username);
                return null;
            }
        } catch (SQLException e) {
            GameLogger.error("Database error retrieving password hash: " + e.getMessage());
            return null;
        }
    }
    private void updateLastLogin(String username) {
        String sql = "UPDATE PLAYERS SET LAST_LOGIN = CURRENT_TIMESTAMP(), STATUS = 'ONLINE' WHERE USERNAME = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, username);
            stmt.executeUpdate();
        } catch (SQLException e) {
            GameLogger.error("Error updating last login time: " + e.getMessage());
        }
    }


    public int[] getPlayerCoordinates(String username) {
        String sql = "SELECT x_pos, y_pos FROM PLAYERS WHERE username = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return new int[]{rs.getInt("x_pos"), rs.getInt("y_pos")};
            }
            return new int[]{0, 0};
        } catch (SQLException e) {
            GameLogger.error("Error retrieving coordinates: " + e.getMessage());
            return new int[]{0, 0};
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/managers/DisconnectionManager.java
================
package io.github.pokemeetup.managers;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.screens.DisconnectionScreen;
import io.github.pokemeetup.screens.LoginScreen;
import io.github.pokemeetup.utils.GameLogger;

import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

public class DisconnectionManager {
    private static final int MAX_RECONNECT_ATTEMPTS = 3;
    private static final long RECONNECT_DELAY = 5000; // 5 seconds
    private static final long SAVE_INTERVAL = 30000; // 30 seconds

    private final AtomicBoolean isHandlingDisconnect = new AtomicBoolean(false);
    private final AtomicInteger reconnectAttempts = new AtomicInteger(0);
    private final CreatureCaptureGame game;
    private Screen previousScreen;
    private DisconnectionScreen disconnectionScreen;
    private String disconnectReason;
    private boolean showingDisconnectScreen = false;
    private ScheduledFuture<?> autoSaveTask;
    private ScheduledExecutorService scheduler;

    public DisconnectionManager(CreatureCaptureGame game) {
        this.game = game;
    }

    public void handleDisconnect(String reason) {
        if (isHandlingDisconnect.getAndSet(true)) {
            return; // Already handling disconnect
        }

        GameLogger.info("Handling disconnect: " + reason);
        disconnectReason = reason;
        reconnectAttempts.set(0);
        previousScreen = game.getScreen();

        // Save player state if possible
        savePlayerState();

        // Schedule periodic saves while disconnected
        scheduleAutoSave();

        // Show disconnect screen on main thread
        Gdx.app.postRunnable(() -> {
            if (!showingDisconnectScreen) {
                showDisconnectScreen();
            }
        });
    }

    private void scheduleAutoSave() {
        if (scheduler != null && !scheduler.isShutdown()) {
            autoSaveTask = scheduler.scheduleWithFixedDelay(
                this::savePlayerState,
                SAVE_INTERVAL,
                SAVE_INTERVAL,
                TimeUnit.MILLISECONDS
            );
        }
    }

    private void savePlayerState() {
        try {
            if (GameContext.get().getPlayer() != null && GameContext.get().getWorld() != null) {
                GameContext.get().getWorld().save();
                GameLogger.info("Saved player state during disconnect");
            }
        } catch (Exception e) {
            GameLogger.error("Failed to save player state: " + e.getMessage());
        }
    }

    public void attemptReconnect() {
        if (reconnectAttempts.get() >= MAX_RECONNECT_ATTEMPTS) {
            exitToLogin("Maximum reconnection attempts reached");
            return;
        }

        reconnectAttempts.incrementAndGet();
        GameLogger.info("Attempting reconnect: " + reconnectAttempts.get() + "/" + MAX_RECONNECT_ATTEMPTS);

        GameClient client = GameContext.get().getGameClient();
        if (client != null) {
            client.dispose();
            GameContext.get().setGameClient(null);
            try {
                Thread.sleep(RECONNECT_DELAY);
                client.connectIfNeeded(() -> {
                    // Successfully connected
                    GameLogger.info("Successfully reconnected to server");
                }, (errorMsg) -> {
                    // Failed to connect
                    GameLogger.error("Failed to reconnect to server: " + errorMsg);
                },REGISTRATION_CONNECT_TIMEOUT_MS);
            } catch (Exception e) {
                GameLogger.error("Reconnection attempt failed: " + e.getMessage());
                handleReconnectFailure();
            }
        } else {
            exitToLogin("Game client is null");
        }
    }
    private static final long REGISTRATION_CONNECT_TIMEOUT_MS = 10000; // 10 seconds

    private void handleReconnectFailure() {
        if (reconnectAttempts.get() < MAX_RECONNECT_ATTEMPTS) {
            // Schedule another attempt
            Gdx.app.postRunnable(this::attemptReconnect);
        } else {
            exitToLogin("Unable to reconnect to server");
        }
    }

    private void showDisconnectScreen() {
        showingDisconnectScreen = true;
        disconnectionScreen = new DisconnectionScreen(game, disconnectReason, this);
        Gdx.app.postRunnable(() -> {
            game.setScreen(disconnectionScreen);
        });
    }

    public void onReconnectionSuccess() {
        Gdx.app.postRunnable(() -> {
            isHandlingDisconnect.set(false);
            showingDisconnectScreen = false;
            cancelAutoSave();

            if (previousScreen != null) {
                game.setScreen(previousScreen);
                GameLogger.info("Returned to previous screen after reconnection");
            }
        });
    }

    private void cancelAutoSave() {
        if (autoSaveTask != null && !autoSaveTask.isDone()) {
            autoSaveTask.cancel(false);
        }
    }

    private void exitToLogin(String reason) {
        Gdx.app.postRunnable(() -> {
            cleanup();
            game.setScreen(new LoginScreen(game));
            GameLogger.info("Exited to login: " + reason);
        });
    }

    public void cleanup() {
        isHandlingDisconnect.set(false);
        showingDisconnectScreen = false;
        cancelAutoSave();

        if (GameContext.get().getGameClient() != null) {
            GameContext.get().getGameClient().dispose();
            GameContext.get().setGameClient(null);
        }

        if (GameContext.get().getWorld() != null) {
            GameContext.get().getWorld().save();
            GameContext.get().getWorld().dispose();
            GameContext.get().setWorld(null);
        }

        if (previousScreen != null) {
            previousScreen.dispose();
            previousScreen = null;
        }

        if (disconnectionScreen != null) {
            disconnectionScreen.dispose();
            disconnectionScreen = null;
        }

        System.gc();
    }

    public boolean isHandlingDisconnect() {
        return isHandlingDisconnect.get();
    }

    public void setScheduler(ScheduledExecutorService scheduler) {
        this.scheduler = scheduler;
    }
}

================
File: src/main/java/io/github/pokemeetup/managers/FootstepEffect.java
================
package io.github.pokemeetup.managers;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.utils.textures.TextureManager;

public class FootstepEffect {
    private Vector2 position;
    private float stateTime;
    private final float duration;
    private final String direction; // "up", "down", "left", or "right"

    /**
     * @param position  the world position where the effect is drawn
     * @param direction the direction of the footstep (to choose the correct region)
     * @param duration  how long (in seconds) the effect takes to fade out
     */
    public FootstepEffect(Vector2 position, String direction, float duration) {
        // Create a copy of the position so it won’t be modified externally.
        this.position = new Vector2(position);
        this.direction = direction;
        this.duration = duration;
        this.stateTime = 0f;
    }

    public void update(float delta) {
        stateTime += delta;
    }

    public boolean isFinished() {
        return stateTime >= duration;
    }
    public void render(SpriteBatch batch) {
        // Calculate fading alpha: goes from 1 to 0 over the duration.
        float computedAlpha = 1.0f - (stateTime / duration);
        TextureRegion region = null;
        if (direction.equalsIgnoreCase("down")) {
            region = TextureManager.steps.findRegion("stepsDown");
        } else if (direction.equalsIgnoreCase("up")) {
            region = TextureManager.steps.findRegion("stepsUp");
        } else if (direction.equalsIgnoreCase("left")) {
            region = TextureManager.steps.findRegion("stepsLeft");
        } else if (direction.equalsIgnoreCase("right")) {
            region = TextureManager.steps.findRegion("stepsRight");
        }
        if (region != null) {
            // Instead of overriding with white, modulate the current batch color.
            Color ambient = batch.getColor(); // this is the current world tint (e.g. dark at night)
            // Multiply the current alpha by the computed fading factor.
            float newAlpha = ambient.a * computedAlpha;
            // Save the current color.
            Color previous = new Color(ambient);
            // Set the batch color to the current r, g, b with the new alpha.
            batch.setColor(ambient.r, ambient.g, ambient.b, newAlpha);
            // Draw the region centered horizontally at the given position.
            batch.draw(region, position.x - region.getRegionWidth() / 2f, position.y);
            // Restore the previous color.
            batch.setColor(previous);
        }
    }

}

================
File: src/main/java/io/github/pokemeetup/managers/FootstepEffectManager.java
================
package io.github.pokemeetup.managers;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.utils.Array;

public class FootstepEffectManager {
    private final Array<FootstepEffect> effects;

    public FootstepEffectManager() {
        effects = new Array<>();
    }

    public void addEffect(FootstepEffect effect) {
        effects.add(effect);
    }

    public void update(float delta) {
        for (int i = effects.size - 1; i >= 0; i--) {
            FootstepEffect effect = effects.get(i);
            effect.update(delta);
            if (effect.isFinished()) {
                effects.removeIndex(i);
            }
        }
    }

    public void render(SpriteBatch batch) {
        for(FootstepEffect effect : effects) {
            effect.render(batch);
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/managers/WaterEffectManager.java
================
package io.github.pokemeetup.managers;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Pool;
import io.github.pokemeetup.utils.textures.TextureManager;

public class WaterEffectManager {
    private static final float RIPPLE_DURATION = 0.5f;
    private static final float RIPPLE_MAX_SCALE = 1.5f;

    private final Pool<Ripple> ripplePool;
    private final Array<Ripple> activeRipples;
    private final TextureRegion rippleTexture;

    public WaterEffectManager() {
        rippleTexture = TextureManager.tiles.findRegion("water_puddle");
        activeRipples = new Array<>();

        ripplePool = new Pool<Ripple>() {
            @Override
            protected Ripple newObject() {
                return new Ripple();
            }
        };
    }

    public void createRipple(float x, float y) {
        Ripple ripple = ripplePool.obtain();
        ripple.init(x, y);
        activeRipples.add(ripple);
    }

    public void update(float delta) {
        for (int i = activeRipples.size - 1; i >= 0; i--) {
            Ripple ripple = activeRipples.get(i);
            ripple.update(delta);

            if (ripple.isComplete()) {
                activeRipples.removeIndex(i);
                ripplePool.free(ripple);
            }
        }
    }

    public void render(SpriteBatch batch) {
        Color originalColor = batch.getColor().cpy();

        for (Ripple ripple : activeRipples) {
            float alpha = 1f - (ripple.stateTime / RIPPLE_DURATION);
            batch.setColor(1, 1, 1, alpha * 0.5f);

            float scale = 1f + ((RIPPLE_MAX_SCALE - 1f) * (ripple.stateTime / RIPPLE_DURATION));
            float width = rippleTexture.getRegionWidth() * scale;
            float height = rippleTexture.getRegionHeight() * scale;

            batch.draw(rippleTexture,
                ripple.x - width/2,
                ripple.y - height/2,
                width, height);
        }

        batch.setColor(originalColor);
    }

    private static class Ripple {
        float x, y;
        float stateTime;

        void init(float x, float y) {
            this.x = x;
            this.y = y;
            this.stateTime = 0;
        }

        void update(float delta) {
            stateTime += delta;
        }

        boolean isComplete() {
            return stateTime >= RIPPLE_DURATION;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/managers/WaterEffectsRenderer.java
================
package io.github.pokemeetup.managers;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.system.Positionable;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.textures.TileType;

public class WaterEffectsRenderer {
    private static final float FRAME_DURATION = 0.15f;
    private static final float SCALE_FACTOR = 1.5f;
    private static final float SOUND_INTERVAL = 0.4f; // Time between splash sounds

    private Animation<TextureRegion> movingAnimation;
    private TextureRegion standingTexture;
    private float stateTime = 0;
    private boolean initialized = false;

    public WaterEffectsRenderer() {
        initializeAnimations();
    }

    private void initializeAnimations() {
        try {
            if (TextureManager.effects == null) {
                GameLogger.error("Effects atlas is null");
                return;
            }
            TextureRegion movingRegion = TextureManager.effects.findRegion("water_player_moving");
            standingTexture = TextureManager.effects.findRegion("water_player_standing");
            if (movingRegion == null || standingTexture == null) {
                GameLogger.error("Failed to load water effect textures");
                return;
            }
            int frameWidth = movingRegion.getRegionWidth() / 3;
            int frameHeight = movingRegion.getRegionHeight();
            TextureRegion[] movingFrames = new TextureRegion[3];
            for (int i = 0; i < 3; i++) {
                movingFrames[i] = new TextureRegion(movingRegion, i * frameWidth, 0, frameWidth, frameHeight);
            }
            movingAnimation = new Animation<>(FRAME_DURATION, movingFrames);
            initialized = true;
            GameLogger.info("Water effects animations initialized successfully");
        } catch (Exception e) {
            GameLogger.error("Error initializing water effects: " + e.getMessage());
            initialized = false;
        }
    }

    /**
     * Updates the animation timer.
     */
    public void update(float deltaTime) {
        if (!initialized) {
            initializeAnimations();
            return;
        }
        stateTime += deltaTime;
    }

    /**
     * Renders water effects for any Positionable entity that is “on water.”
     * The effect is drawn at the center–bottom of the tile in which the entity is located.
     *
     * IMPORTANT: Since your entities’ x–value is stored as the tile center,
     * we subtract half a tile width before converting to a tile index.
     *
     * @param batch  The SpriteBatch to draw on.
     * @param entity The Positionable entity (local or remote).
     * @param world  The World (used to look up tile information).
     */
    public void render(SpriteBatch batch, Positionable entity, World world) {
        if (!initialized || batch == null || entity == null || world == null) {
            return;
        }
        try {
            boolean onWater = isEntityOnWater(entity, world);

            if (onWater) {
                // Play sound only once when entering water
                if (!entity.wasOnWater()) {
                    playWaterSound();
                }
                // Play continuous sound while moving (but not for WildPokemon)
                else if (entity.isMoving() && entity.getWaterSoundTimer() <= 0) {
                    if (!(entity instanceof io.github.pokemeetup.pokemon.WildPokemon)) {
                        playWaterSound();
                        entity.setWaterSoundTimer(SOUND_INTERVAL);
                    }
                }
            }
            entity.setWasOnWater(onWater);

            if (!onWater) {
                return;
            }

            float effectWidth = World.TILE_SIZE * SCALE_FACTOR;
            float effectHeight = World.TILE_SIZE * 0.75f;
            // IMPORTANT: Because the entity’s x is at the center,
            // subtract half a tile width to compute the tile’s left edge.
            int tileX = MathUtils.floor((entity.getX() - World.TILE_SIZE / 2f) / World.TILE_SIZE);
            int tileY = MathUtils.floor(entity.getY() / World.TILE_SIZE);
            float tileCenterX = tileX * World.TILE_SIZE + World.TILE_SIZE / 2f;
            float tileBottomY = tileY * World.TILE_SIZE;
            float effectX = tileCenterX - (effectWidth / 2f);
            float effectY = tileBottomY;
            TextureRegion currentFrame = entity.isMoving() ?
                movingAnimation.getKeyFrame(stateTime, true) :
                standingTexture;
            if (currentFrame != null) {
                batch.draw(currentFrame, effectX, effectY, effectWidth, effectHeight);
            }
        } catch (Exception e) {
            GameLogger.error("Error rendering water effects: " + e.getMessage());
        }
    }

    private void playWaterSound() {
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.PUDDLE);
    }

    /**
     * Checks whether the given entity is currently on a water tile.
     * We subtract half a tile width from the x–coordinate so that if the entity’s x is at the center,
     * the computed tile index reflects the tile the entity is actually standing on.
     *
     * @param entity The Positionable entity.
     * @param world  The current World.
     * @return true if the underlying tile is a water tile.
     */
    private boolean isEntityOnWater(Positionable entity, World world) {
        int tileX = MathUtils.floor((entity.getX() - World.TILE_SIZE / 2f) / World.TILE_SIZE);
        int tileY = MathUtils.floor(entity.getY() / World.TILE_SIZE);
        int chunkX = Math.floorDiv(tileX, World.CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, World.CHUNK_SIZE);
        Vector2 chunkPos = new Vector2(chunkX, chunkY);
        if (!world.getChunks().containsKey(chunkPos)) {
            return false;
        }
        int localX = Math.floorMod(tileX, World.CHUNK_SIZE);
        int localY = Math.floorMod(tileY, World.CHUNK_SIZE);
        Chunk chunk = world.getChunks().get(chunkPos);
        if (chunk == null) {
            return false;
        }
        int tileType = chunk.getTileType(localX, localY);
        return isWaterTile(tileType);
    }

    private boolean isWaterTile(int tileType) {
        return tileType == TileType.WATER_PUDDLE ||
            tileType == TileType.WATER_PUDDLE_TOP_LEFT ||
            tileType == TileType.WATER_PUDDLE_TOP_RIGHT ||
            tileType == TileType.WATER_PUDDLE_BOTTOM_LEFT ||
            tileType == TileType.WATER_PUDDLE_BOTTOM_RIGHT ||
            tileType == TileType.WATER_PUDDLE_TOP_MIDDLE ||
            tileType == TileType.WATER_PUDDLE_BOTTOM_MIDDLE ||
            tileType == TileType.WATER_PUDDLE_LEFT_MIDDLE ||
            tileType == TileType.WATER_PUDDLE_RIGHT_MIDDLE;
    }

    public boolean isInitialized() {
        return initialized;
    }

    public void dispose() {
        movingAnimation = null;
        standingTexture = null;
        initialized = false;
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/client/GameClient.java
================
package io.github.pokemeetup.multiplayer.client;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Preferences;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryonet.Client;
import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.Listener;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.managers.BiomeTransitionResult;
import io.github.pokemeetup.managers.DisconnectionManager;
import io.github.pokemeetup.multiplayer.OtherPlayer;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.screens.ChestScreen;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.gameplay.overworld.*;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.system.gameplay.overworld.mechanics.AutoTileSystem;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;
import net.jpountz.lz4.LZ4Factory;
import net.jpountz.lz4.LZ4SafeDecompressor;

import java.io.ByteArrayInputStream;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;


public class GameClient {
    private static final long RECONNECT_DELAY = 3000;
    private static final int MAX_RECONNECT_ATTEMPTS = 5;
    private static final int MAX_CONCURRENT_CHUNK_REQUESTS = 4;
    private static final long CHUNK_REQUEST_INTERVAL = 50;
    private static final float SYNC_INTERVAL = 1 / 60f;
    private static final float INTERPOLATION_SPEED = 10f;
    private static final float UPDATE_INTERVAL = 1 / 20f;
    private static final int BUFFER_SIZE = 65536;
    private static final int INCREASED_BUFFER = 65536;
    private static final int CHUNK_LOAD_RADIUS = 3;
    private static final long PING_INTERVAL = 5000; // 5 seconds
    private static final int CONNECT_TIMEOUT_MS = 45000; // unify to 45s
    private final DisconnectionManager disconnectHandler;
    private final PlayerDataResponseHandler playerDataHandler = new PlayerDataResponseHandler();
    private final Queue<Vector2> chunkRequestQueue = new ConcurrentLinkedQueue<>();
    private final Set<Vector2> pendingChunks = new ConcurrentHashMap<Vector2, Boolean>().keySet(true);
    private final AtomicBoolean isAuthenticated = new AtomicBoolean(false);
    private final AtomicBoolean isDisposing = new AtomicBoolean(false);
    private final ReentrantLock connectionLock = new ReentrantLock();
    private final ConcurrentHashMap<String, OtherPlayer> otherPlayers = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<UUID, WildPokemon> trackedWildPokemon = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<UUID, NetworkSyncData> syncedPokemonData = new ConcurrentHashMap<>();
    private final BlockingQueue<NetworkProtocol.ChatMessage> chatMessageQueue = new LinkedBlockingQueue<>();
    private final ConcurrentHashMap<String, NetworkProtocol.PlayerUpdate> playerUpdates = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler;
    private final Queue<Object> pendingMessages = new ConcurrentLinkedQueue<>();
    private final Preferences credentials;
    private final AtomicBoolean isConnected = new AtomicBoolean(false);
    private final AtomicBoolean isConnecting = new AtomicBoolean(false);
    private final Map<Vector2, Future<Chunk>> loadingChunks = new ConcurrentHashMap<>();
    private final AtomicBoolean isShuttingDown = new AtomicBoolean(false);
    private final Set<String> recentJoinEvents = Collections.synchronizedSet(new HashSet<>());
    private final ConcurrentHashMap<String, Integer> playerPingMap = new ConcurrentHashMap<>();
    public AtomicBoolean shouldReconnect = new AtomicBoolean(true);
    private volatile boolean connecting = false;
    private volatile boolean connected = false;
    private boolean disposing = false;
    private boolean isSinglePlayer;
    private int reconnectAttempts = 0;
    private volatile boolean isInitializing = false;
    private long lastRequestTime = 0;
    private float syncTimer = 0;
    private PlayerData lastKnownState;
    private Consumer<NetworkProtocol.ChatMessage> chatMessageHandler;
    private PokemonUpdateHandler pokemonUpdateHandler;
    private WorldData worldData;
    private float updateAccumulator = 0;
    private volatile boolean isInitialized = false;
    private volatile boolean fullyInitialized = false;
    private InitializationListener initializationListener;
    private String pendingUsername;
    private String pendingPassword;
    private String currentPassword;
    private volatile boolean loginRequestSent = false;
    private volatile boolean processingMessages = false;
    private volatile ConnectionState connectionState = ConnectionState.DISCONNECTED;
    private volatile Client client;
    private ServerConnectionConfig serverConfig;
    private String localUsername;
    private long worldSeed;
    private ReconnectionListener reconnectionListener;
    private int localPing;
    private long lastPingTime = 0;
    private Consumer<NetworkProtocol.LoginResponse> loginResponseListener;

    public GameClient(ServerConnectionConfig config) {

        this.disconnectHandler = GameContext.get().getDisconnectionManager();
        this.serverConfig = config;
        this.isSinglePlayer = !GameContext.get().isMultiplayer();
        this.lastKnownState = new PlayerData();

        this.credentials = Gdx.app.getPreferences("game-credentials");
        this.serverConfig = config;
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
        this.lastKnownState = new PlayerData();

        if (!isSinglePlayer) {
            setupReconnectionHandler();
            loadSavedCredentials();
            if (serverConfig != null) {
                setServerConfig(serverConfig);
            } else {
                GameLogger.info("Failed to load server config, multiplayer disabled.");
            }

            this.client = new Client(INCREASED_BUFFER, INCREASED_BUFFER);
            NetworkProtocol.registerClasses(client.getKryo());
            client.getKryo().setReferences(false);
        }
    }

    public void connectIfNeeded(Runnable onSuccess, Consumer<String> onError, long timeoutMs) {
        // 1) If client is already connected, just callback success
        if (client != null && client.isConnected()) {
            Gdx.app.postRunnable(onSuccess);
            return;
        }
        // 2) If we are in the middle of connecting, do not connect again.
        if (!isConnecting.compareAndSet(false, true)) {
            // means isConnecting was already true
            Gdx.app.postRunnable(() -> onError.accept("Already connecting..."));
            return;
        }

        // 3) Not connected, not connecting => proceed with new connection
        client = new Client(65536, 65536);
        NetworkProtocol.registerClasses(client.getKryo());

        client.addListener(new Listener() {
            @Override
            public void connected(Connection connection) {
                // Mark as connected on the main thread:
                Gdx.app.postRunnable(() -> {
                    isConnecting.set(false);
                    // Mark the connection state as CONNECTED and set the isConnected flag.
                    connectionState = ConnectionState.CONNECTED;
                    isConnected.set(true);
                    isAuthenticated.set(false);
                    onSuccess.run();
                });
            }

            @Override
            public void disconnected(Connection connection) {
                if (!isDisposing.get()) {
                    if (!suppressDisconnectHandling) {
                        handleDisconnect("Disconnected from server");
                    } else {
                        // Optionally log that disconnect handling is suppressed.
                        GameLogger.info("Disconnect occurred while in registration mode – not triggering disconnect screen.");
                    }
                }
            }


            @Override
            public void received(Connection connection, Object object) {
                handleReceivedMessage(object);
            }
        });

        client.start();
        new Thread(() -> {
            try {
                client.connect((int)timeoutMs,
                    serverConfig.getServerIP(),
                    serverConfig.getTcpPort(),
                    serverConfig.getUdpPort());
            } catch (Exception e) {
                isConnecting.set(false);
                Gdx.app.postRunnable(() -> onError.accept("Connection failed: " + e.getMessage()));
            }
        }).start();
    }private static final long REGISTRATION_CONNECT_TIMEOUT_MS = 10000; // 10 seconds


    public void sendBuildingPlacement(NetworkProtocol.BuildingPlacement bp) {
        client.sendTCP(bp);
    }

    public void savePlayerData(UUID uuid, PlayerData data) {
        if (isSinglePlayer || !isConnected() || !isAuthenticated()) {
            GameLogger.error("Cannot save player data - not in multiplayer mode or not connected");
            return;
        }

        try {
            NetworkProtocol.SavePlayerDataRequest request = new NetworkProtocol.SavePlayerDataRequest();
            request.uuid = uuid;

            request.playerData = data;
            request.timestamp = System.currentTimeMillis();
            client.sendTCP(request);
            GameLogger.info("Sent player data save request for UUID: " + uuid);
        } catch (Exception e) {
            GameLogger.error("Failed to save player data: " + e.getMessage());
        }
    }

    public void update(float deltaTime) {
        if (!isAuthenticated.get() || connectionState != ConnectionState.CONNECTED) {
            return;
        }
        syncTimer += deltaTime;
        if (syncTimer >= SYNC_INTERVAL) {
            syncTimer = 0;
            processChatMessages();
            updatePokemonStates(deltaTime);
        }
        long now = System.currentTimeMillis();
        if (now - lastPingTime > PING_INTERVAL) {
            sendPingRequest();
            lastPingTime = now;
        }

        pokemonUpdateAccumulator += deltaTime;
        if (pokemonUpdateAccumulator >= POKEMON_UPDATE_THRESHOLD) {
            pokemonUpdateAccumulator = 0f;
            updatePokemonStates(deltaTime);
        }
        updateOtherPlayers(deltaTime);
        updateAccumulator += deltaTime;

        if (updateAccumulator >= UPDATE_INTERVAL) {
            updateAccumulator = 0;
            if (!isSinglePlayer && GameContext.get().getPlayer() != null && isAuthenticated() && isInitialized) {
                sendPlayerUpdate();
            }
            processChunkQueue();
            requestChunksAroundPlayer();
        }
    }

    private void handlePingResponse(NetworkProtocol.PingResponse response) {
        long now = System.currentTimeMillis();
        localPing = (int) (now - response.timestamp);

        // Now send our updated info to the server:
        NetworkProtocol.PlayerInfoUpdate update = new NetworkProtocol.PlayerInfoUpdate();
        update.username = localUsername;
        update.ping = localPing;
        client.sendTCP(update);
    }

    public void sendPokemonSpawn(NetworkProtocol.WildPokemonSpawn spawnData) {
        if (!isConnected() || !isAuthenticated() || isSinglePlayer) {
            return;
        }

        try {
            // Validate spawn data
            if (spawnData.data == null || spawnData.uuid == null) {
                GameLogger.error("Invalid Pokemon spawn data");
                return;
            }

            if (spawnData.timestamp == 0) {
                spawnData.timestamp = System.currentTimeMillis();
            }

            // Send spawn data to server
            client.sendTCP(spawnData);

            // Track locally
            if (!trackedWildPokemon.containsKey(spawnData.uuid)) {
                TextureRegion overworldSprite = TextureManager.getOverworldSprite(spawnData.data.getName());

                if (overworldSprite != null) {
                    WildPokemon pokemon = new WildPokemon(
                        spawnData.data.getName(),
                        spawnData.data.getLevel(),
                        (int) spawnData.x,
                        (int) spawnData.y,
                        overworldSprite
                    );
                    pokemon.setUuid(spawnData.uuid);
                    pokemon.setSpawnTime(spawnData.timestamp / 1000L);

                    if (GameContext.get().getWorld() != null) {
                        pokemon.setWorld(GameContext.get().getWorld());
                        Vector2 chunkPos = new Vector2(
                            Math.floorDiv((int) spawnData.x, World.CHUNK_SIZE * World.TILE_SIZE),
                            Math.floorDiv((int) spawnData.y, World.CHUNK_SIZE * World.TILE_SIZE)
                        );
                        GameContext.get().getWorld().getPokemonSpawnManager().addPokemonToChunk(pokemon, chunkPos);
                    }

                    trackedWildPokemon.put(spawnData.uuid, pokemon);
                    syncedPokemonData.put(spawnData.uuid, new NetworkSyncData());

                    GameLogger.info("Sent and tracked new Pokemon spawn: " + spawnData.data.getName() +
                        " at (" + spawnData.x + "," + spawnData.y + ")");
                } else {
                    GameLogger.error("Failed to load sprite for Pokemon: " + spawnData.data.getName());
                }
            } else {
                GameLogger.info("Pokemon already tracked locally with UUID: " + spawnData.uuid);
            }

        } catch (Exception e) {
            GameLogger.error("Failed to send Pokemon spawn: " + e.getMessage());
            if (!isConnected()) {
                handleConnectionFailure(e);
            }
        }
    }

    public Client getClient() {
        return client;
    }

    public void sendChestUpdate(ChestData chestData) {
        if (GameContext.get().isMultiplayer()) {
            try {
                NetworkProtocol.ChestUpdate update = new NetworkProtocol.ChestUpdate();
                // Use the public field chestId (a UUID) from ChestData
                update.chestId = chestData.chestId;
                update.username = GameContext.get().getPlayer().getUsername();
                // Use the items list from chestData (assumed non-null)
                update.items = chestData.getItems();
                update.timestamp = System.currentTimeMillis();
                client.sendTCP(update);
                GameLogger.info("Sent chest update: " + update.chestId + " with " + update.items.size() + " items");
            } catch (Exception e) {
                GameLogger.error("Failed to send chest update: " + e.getMessage());
            }
        }
    }

    private void loadSavedCredentials() {
        try {
            String savedUsername = credentials.getString("username", "");
            String savedPassword = credentials.getString("password", "");

            if (!savedUsername.isEmpty() && !savedPassword.isEmpty()) {
                this.localUsername = savedUsername;
                this.currentPassword = savedPassword;
                this.pendingUsername = savedUsername;
                this.pendingPassword = savedPassword;
                GameLogger.info("Loaded saved credentials for: " + savedUsername);
            } else {
                this.localUsername = "";
                this.currentPassword = "";
                this.pendingUsername = "";
                this.pendingPassword = "";
                GameLogger.info("No saved credentials found");
            }
        } catch (Exception e) {
            GameLogger.error("Failed to load credentials: " + e.getMessage());
        }
    }

    public void sendLoginRequest(String username, String password,
                                 Consumer<NetworkProtocol.LoginResponse> onResponse,
                                 Consumer<String> onError) {
        if (client == null || !client.isConnected()) {
            onError.accept("Not connected to server for login");
            return;
        }

        if (username == null || username.trim().isEmpty() ||
            password == null || password.trim().isEmpty()) {
            onError.accept("Username/password cannot be empty.");
            return;
        }
        NetworkProtocol.LoginRequest request = new NetworkProtocol.LoginRequest();
        request.username = username.trim();
        request.password = password.trim();
        request.timestamp = System.currentTimeMillis();
        GameLogger.info("Sending login request for: " + username);
        this.loginResponseListener = onResponse;
        client.sendTCP(request);
    }

    private void handleConnectionFailure(Exception e) {
        GameLogger.error("Connection failure: " + e.getMessage());
        synchronized (connectionLock) {
            connectionState = ConnectionState.DISCONNECTED;
            isConnected.set(false);
            isAuthenticated.set(false);
            cleanupExistingConnection();
            isConnecting.set(false);
            if (loginResponseListener != null) {
                Gdx.app.postRunnable(() -> {
                    NetworkProtocol.LoginResponse response = new NetworkProtocol.LoginResponse();
                    response.success = false;
                    response.message = "Connection failed: " + e.getMessage();
                    loginResponseListener.accept(response);
                });
            }
        }
    }

    private void cleanupExistingConnection() {
        if (client != null) {
            try {
                if (GameContext.get().getPlayer() != null) {
                    saveState(GameContext.get().getPlayer().getPlayerData());
                }
                if (client.isConnected()) {
                    client.close();
                }
            } catch (Exception e) {
                GameLogger.error("Error cleaning up connection: " + e.getMessage());
            } finally {
                try {
                    if (client != null) {
                        client.stop();
                    }
                } catch (Exception ex) {
                    GameLogger.error("Error stopping client: " + ex.getMessage());
                }
                client = null;
                isSinglePlayer = false;
            }
        }
    }


    public void sendItemDrop(ItemData itemData, Vector2 position) {
        NetworkProtocol.ItemDrop drop = new NetworkProtocol.ItemDrop();
        drop.itemData = itemData;
        drop.x = position.x;
        drop.y = position.y;
        drop.username = getLocalUsername();
        drop.timestamp = System.currentTimeMillis();

        client.sendTCP(drop);
    }

    public void sendItemPickup(NetworkProtocol.ItemPickup pickup) {
        NetworkProtocol.ItemPickup drop = new NetworkProtocol.ItemPickup();
        drop.entityId = pickup.entityId;
        drop.username = getLocalUsername();
        drop.timestamp = System.currentTimeMillis();

        client.sendTCP(drop);
    }

    public void sendPlayerUpdate() {
        if (!isConnected() || !isAuthenticated() || GameContext.get().getPlayer() == null) return;

        float playerX = GameContext.get().getPlayer().getX();
        float playerY = GameContext.get().getPlayer().getY();

        NetworkProtocol.PlayerUpdate update = new NetworkProtocol.PlayerUpdate();
        update.username = getLocalUsername();
        update.x = playerX;
        update.y = playerY;
        update.wantsToRun = GameContext.get().getPlayer().isRunning();
        update.direction = GameContext.get().getPlayer().getDirection();
        update.isMoving = GameContext.get().getPlayer().isMoving();
        update.inventoryItems = GameContext.get().getPlayer().getInventory().getAllItems().toArray(new ItemData[0]);
        update.timestamp = System.currentTimeMillis();
        client.sendTCP(update);
    }

    public void savePlayerState(PlayerData playerData) {
        if (isSinglePlayer) {
            if (GameContext.get().getWorld() != null) {
                GameContext.get().getWorld().getWorldData().savePlayerData(
                    playerData.getUsername(),
                    playerData,
                    false
                );
                WorldManager.getInstance().saveWorld(GameContext.get().getWorld().getWorldData());
                GameLogger.info("Saved singleplayer state for: " + playerData.getUsername());
            }
            return;
        }

        if (isAuthenticated.get()) {
            try {
                // Create save request
                NetworkProtocol.SavePlayerDataRequest request = new NetworkProtocol.SavePlayerDataRequest();
                request.playerData = playerData;
                request.timestamp = System.currentTimeMillis();

                // Send to server
                client.sendTCP(request);
                GameLogger.info("Sent player state update to server for: " + playerData.getUsername());

            } catch (Exception e) {
                GameLogger.error("Failed to send state to server: " + e.getMessage());
            }
        }
    }

    public Map<String, NetworkProtocol.PlayerUpdate> getPlayerUpdates() {
        Map<String, NetworkProtocol.PlayerUpdate> updates = new HashMap<>(playerUpdates);
        playerUpdates.clear();
        return updates;
    }

    public void saveState(PlayerData playerData) {
        if (isSinglePlayer) {
            if (GameContext.get().getWorld() != null) {
                GameContext.get().getWorld().getWorldData().savePlayerData(
                    playerData.getUsername(),
                    playerData,
                    false
                );
                GameContext.get().getWorldManager().saveWorld(GameContext.get().getWorld().getWorldData());
                GameLogger.info("Saved singleplayer state for: " + playerData.getUsername());
            }
        } else {
            if (isConnected() && isAuthenticated()) {
                try {
                    NetworkProtocol.SavePlayerDataRequest request = new NetworkProtocol.SavePlayerDataRequest();
                    request.playerData = playerData;
                    request.timestamp = System.currentTimeMillis();
                    client.sendTCP(request);
                    GameLogger.info("Sent player state to server for: " + playerData.getUsername());
                } catch (Exception e) {
                    GameLogger.error("Failed to send state to server: " + e.getMessage());
                }
            }
        }
    }

    private void handleWorldStateUpdate(NetworkProtocol.WorldStateUpdate update) {
        if (update == null) return;
        // Ensure that updates happen on the rendering thread
        Gdx.app.postRunnable(() -> {
            World world = GameContext.get().getWorld();
            if (world == null) return;
            // Update the local world data with the synchronized time and day length.
            world.getWorldData().setWorldTimeInMinutes(update.worldTimeInMinutes);
            world.getWorldData().setDayLength(update.dayLength);
            // Optionally, update the seed if needed:
            // world.getWorldData().getConfig().setSeed(update.seed);

            // Now update the weather system.
            WeatherSystem weatherSystem = world.getWeatherSystem();
            if (weatherSystem != null) {
                // You can simply “force” the weather parameters that the server sent:
                weatherSystem.setWeather(update.currentWeather, update.intensity);
                weatherSystem.setAccumulation(update.accumulation);
            }
            GameLogger.info("WorldStateUpdate applied: time " + update.worldTimeInMinutes +
                ", weather " + update.currentWeather);
        });
    }


    private void setupReconnectionHandler() {
        scheduler.scheduleWithFixedDelay(() -> {
            if (connectionState == ConnectionState.DISCONNECTED && shouldReconnect.get() && !isDisposing.get()) {
                attemptReconnection();
            }
        }, RECONNECT_DELAY, RECONNECT_DELAY, TimeUnit.MILLISECONDS);
    }

    public void setServerConfig(ServerConnectionConfig serverConfig) {
        this.serverConfig = serverConfig;
    }

    public boolean isSinglePlayer() {
        return !GameContext.get().isMultiplayer();
    }

    public void setSinglePlayer(boolean isSinglePlayer) {
        this.isSinglePlayer = isSinglePlayer;
    }

    public World getCurrentWorld() {
        return GameContext.get().getWorld();
    }

    public long getWorldSeed() {
        return worldSeed;
    }

    public WorldData getWorldData() {
        return worldData;
    }

    public void sendMessage(NetworkProtocol.ChatMessage message) {
        if (isSinglePlayer) {
            if (chatMessageHandler != null) {
                chatMessageHandler.accept(message);
            }
            return;
        }

        try {
            if (!isConnected() || !isAuthenticated()) {
                GameLogger.error("Cannot send chat message - not connected or authenticated");
                return;
            }
            if (message.timestamp == 0) {
                message.timestamp = System.currentTimeMillis();
            }
            if (message.type == null) {
                message.type = NetworkProtocol.ChatType.NORMAL;
            }
            client.sendTCP(message);

            GameLogger.info("Sent chat message from " + message.sender +
                ": " + message.content);

        } catch (Exception e) {
            GameLogger.error("Failed to send chat message: " + e.getMessage());

            if (!isConnected()) {
                handleConnectionFailure(e);
            }

            if (chatMessageHandler != null) {
                chatMessageHandler.accept(message);
            }
        }
    }

    public NetworkProtocol.ChatMessage createSystemMessage(String content) {
        NetworkProtocol.ChatMessage message = new NetworkProtocol.ChatMessage();
        message.sender = "System";
        message.content = content;
        message.timestamp = System.currentTimeMillis();
        message.type = NetworkProtocol.ChatType.SYSTEM;
        return message;
    }

    private void handleChatMessage(NetworkProtocol.ChatMessage message) {
        if (message == null || message.content == null) {
            return;
        }
        chatMessageQueue.offer(message);
        GameLogger.info("Client enqueued chat message: " + message.sender + ": " + message.content);

    }

    public String getLocalUsername() {
        return localUsername;
    }

    public void dispose() {
        synchronized (connectionLock) {
            if (isDisposing.get()) {
                return;
            }

            isDisposing.set(true);

            scheduler.shutdownNow();
            try {
                scheduler.awaitTermination(2, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }

            if (client != null) {
                try {
                    NetworkProtocol.ForceDisconnect disconnect = new NetworkProtocol.ForceDisconnect();
                    disconnect.reason = "Client closing";
                    client.sendTCP(disconnect);
                } catch (Exception ignored) {
                }
                client.close();
            }

            if (disconnectHandler != null) {
                disconnectHandler.cleanup();
            }
            GameLogger.info("GameClient disposed");
        }
    }

    public void shutdown() {
        isShuttingDown.set(true);
        dispose();
    }

    private void attemptReconnection() {
        synchronized (connectionLock) {
            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                GameLogger.error("Max reconnection attempts reached");
                if (chatMessageHandler != null) {
                    NetworkProtocol.ChatMessage message = createSystemMessage(
                        "Failed to reconnect after " + MAX_RECONNECT_ATTEMPTS + " attempts"
                    );
                    chatMessageHandler.accept(message);
                }
                return;
            }

            reconnectAttempts++;
            connectIfNeeded(() -> {
                // Successfully connected
                reconnectAttempts = 0;
                GameLogger.info("Successfully reconnected to server");
            }, (errorMsg) -> {
                // Failed to connect
                reconnectAttempts++;
                GameLogger.error("Failed to reconnect to server: " + errorMsg);
            }, REGISTRATION_CONNECT_TIMEOUT_MS);
        }
    }
    /**
     * Improved handling of compressed chunk data from server
     * Ensures proper biome transitions and object placement
     */
    private void handleCompressedChunkData(NetworkProtocol.CompressedChunkData compressed) {
        try {
            // Step 1: Create LZ4 decompressor
            LZ4Factory factory = LZ4Factory.fastestInstance();
            LZ4SafeDecompressor decompressor = factory.safeDecompressor();

            // Step 2: Prepare buffer for decompressed data with proper size
            byte[] restored = new byte[compressed.originalLength];
            int decompressedSize = decompressor.decompress(
                compressed.data, 0, compressed.data.length,
                restored, 0, compressed.originalLength
            );

            // Step 3: Verify complete decompression
            if (decompressedSize != compressed.originalLength) {
                GameLogger.error("Incomplete decompression: got " + decompressedSize +
                    " bytes, expected " + compressed.originalLength + " - requesting chunk again");

                // Request the chunk again since decompression failed
                Vector2 chunkPos = new Vector2(compressed.chunkX, compressed.chunkY);
                pendingChunks.remove(chunkPos);
                requestChunk(chunkPos);
                return;
            }

            // Step 4: Deserialize with Kryo
            ByteArrayInputStream bais = new ByteArrayInputStream(restored);
            Input input = new Input(bais);
            Kryo kryo = new Kryo();
            NetworkProtocol.registerClasses(kryo);
            kryo.setReferences(false);

            // Try to read the chunk data - handle possible errors
            NetworkProtocol.ChunkData chunkData;
            try {
                chunkData = kryo.readObject(input, NetworkProtocol.ChunkData.class);
            } catch (Exception e) {
                GameLogger.error("Failed to deserialize chunk data: " + e.getMessage());

                // Request the chunk again if deserialization fails
                Vector2 chunkPos = new Vector2(compressed.chunkX, compressed.chunkY);
                pendingChunks.remove(chunkPos);
                requestChunk(chunkPos);
                return;
            } finally {
                input.close();
                bais.close();
            }

            // Get the chunk position for reference
            final Vector2 chunkPos = new Vector2(chunkData.chunkX, chunkData.chunkY);
            GameLogger.info("Successfully decompressed chunk at " + chunkPos);

            // Process on main thread to avoid concurrency issues
            Gdx.app.postRunnable(() -> {
                try {
                    World world = GameContext.get().getWorld();
                    if (world == null) {
                        GameLogger.error("World is null when processing chunk " + chunkPos);
                        pendingChunks.remove(chunkPos);
                        return;
                    }

                    // Process chunk data
                    world.processChunkData(chunkData);

                    // Create biome transition result with complete information
                    BiomeTransitionResult transition = new BiomeTransitionResult(
                        world.getBiomeManager().getBiome(chunkData.primaryBiomeType),
                        (chunkData.secondaryBiomeType != null ?
                            world.getBiomeManager().getBiome(chunkData.secondaryBiomeType) : null),
                        chunkData.biomeTransitionFactor
                    );

                    // Store the transition in the world for future reference
                    world.storeBiomeTransition(chunkPos, transition);

                    // Apply auto-tiling to ensure smooth edges
                    Chunk chunk = world.getChunks().get(chunkPos);
                    if (chunk != null) {
                        try {
                            new AutoTileSystem().applyShorelineAutotiling(chunk, 0, world);
                            chunk.setDirty(true);
                        } catch (Exception e) {
                            GameLogger.error("Auto-tiling failed for chunk " + chunkPos + ": " + e.getMessage());
                            // Continue processing - non-fatal error
                        }
                    }

                    // Mark chunk as processed
                    pendingChunks.remove(chunkPos);

                    // Log success with detailed information
                    GameLogger.info("Processed chunk " + chunkPos + " with " +
                        (chunkData.worldObjects != null ? chunkData.worldObjects.size() : 0) + " objects, " +
                        "biome: " + chunkData.primaryBiomeType +
                        (chunkData.secondaryBiomeType != null ?
                            " blended with " + chunkData.secondaryBiomeType +
                                " at " + chunkData.biomeTransitionFactor : ""));

                    // Request adjacent chunks for smoother transitions
                    requestAdjacentChunksIfNeeded(chunkPos);

                } catch (Exception e) {
                    GameLogger.error("Error processing chunk " + chunkPos + ": " + e.getMessage());
                    e.printStackTrace();

                    // Clear pending status to allow retry, but delay to prevent spam
                    pendingChunks.remove(chunkPos);

                    // Schedule a retry after a short delay
                    scheduler.schedule(() -> {
                        if (GameContext.get().isMultiplayer() &&
                            GameContext.get().getWorld() != null &&
                            !GameContext.get().getWorld().getChunks().containsKey(chunkPos)) {
                            GameLogger.info("Retrying chunk request for " + chunkPos);
                            requestChunk(chunkPos);
                        }
                    }, 1000, TimeUnit.MILLISECONDS);
                }
            });
        } catch (Exception e) {
            GameLogger.error("Error handling compressed chunk data: " + e.getMessage());
            e.printStackTrace();

            // Request the chunk again, but delayed to prevent request spam
            if (compressed != null) {
                Vector2 chunkPos = new Vector2(compressed.chunkX, compressed.chunkY);
                pendingChunks.remove(chunkPos);

                scheduler.schedule(() -> {
                    if (GameContext.get().isMultiplayer() &&
                        GameContext.get().getWorld() != null &&
                        !GameContext.get().getWorld().getChunks().containsKey(chunkPos)) {
                        requestChunk(chunkPos);
                    }
                }, 2000, TimeUnit.MILLISECONDS);
            }
        }
    }

    /**
     * Request adjacent chunks if needed to ensure smooth transitions
     */
    private void requestAdjacentChunksIfNeeded(Vector2 processedChunkPos) {
        // Check all 8 surrounding chunks (including diagonals) for better transitions
        int[][] adjacentOffsets = {
            {0, 1}, {1, 1}, {1, 0}, {1, -1},
            {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}
        };

        World world = GameContext.get().getWorld();
        if (world == null) return;

        // Sort offsets by distance to player for more efficient loading
        Player player = GameContext.get().getPlayer();
        if (player != null) {
            int playerChunkX = Math.floorDiv(player.getTileX(), Chunk.CHUNK_SIZE);
            int playerChunkY = Math.floorDiv(player.getTileY(), Chunk.CHUNK_SIZE);
            final Vector2 playerChunkPos = new Vector2(playerChunkX, playerChunkY);

            // Sort by Manhattan distance to player's chunk
            Arrays.sort(adjacentOffsets, (a, b) -> {
                Vector2 posA = new Vector2(processedChunkPos.x + a[0], processedChunkPos.y + a[1]);
                Vector2 posB = new Vector2(processedChunkPos.x + b[0], processedChunkPos.y + b[1]);
                float distA = Math.abs(posA.x - playerChunkPos.x) + Math.abs(posA.y - playerChunkPos.y);
                float distB = Math.abs(posB.x - playerChunkPos.x) + Math.abs(posB.y - playerChunkPos.y);
                return Float.compare(distA, distB);
            });
        }

        // Request adjacent chunks with priority to those closer to player
        for (int[] offset : adjacentOffsets) {
            Vector2 adjPos = new Vector2(
                processedChunkPos.x + offset[0],
                processedChunkPos.y + offset[1]
            );

            // Only request if not already loaded or pending
            if (!world.getChunks().containsKey(adjPos) && !pendingChunks.contains(adjPos)) {
                // Check if chunk is within the loading radius
                if (isChunkNearPlayer(adjPos, 4)) { // Within 4 chunks of player
                    requestChunk(adjPos);
                    // Small delay between requests to prevent network flooding
                    try {
                        Thread.sleep(20);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }
    }

    /**
     * Determines if a chunk is within a given distance from the player
     */
    private boolean isChunkNearPlayer(Vector2 chunkPos, float radius) {
        Player player = GameContext.get().getPlayer();
        if (player == null) return false;

        int playerChunkX = Math.floorDiv(player.getTileX(), Chunk.CHUNK_SIZE);
        int playerChunkY = Math.floorDiv(player.getTileY(), Chunk.CHUNK_SIZE);
        Vector2 playerChunkPos = new Vector2(playerChunkX, playerChunkY);

        // Use Manhattan distance for better performance
        float distance = Math.abs(chunkPos.x - playerChunkPos.x) +
            Math.abs(chunkPos.y - playerChunkPos.y);

        return distance <= radius;
    }

    /**
     * Recalculate the sliding window of chunks based on the player's current chunk position.
     * Enqueue any missing chunks.
     */
    private void requestChunksAroundPlayer() {
        if (!isAuthenticated.get() || !isConnected() || isSinglePlayer) {
            return;
        }
        World world = GameContext.get().getWorld();
        Player player = GameContext.get().getPlayer();
        if (world == null || player == null) return;

        int playerTileX = GameContext.get().getPlayer().getTileX();
        int playerTileY = GameContext.get().getPlayer().getTileY();
        int playerChunkX = Math.floorDiv(playerTileX, Chunk.CHUNK_SIZE);
        int playerChunkY = Math.floorDiv(playerTileY, Chunk.CHUNK_SIZE);
        Vector2 playerChunkPos = new Vector2(playerChunkX, playerChunkY);

        // For each chunk within CHUNK_LOAD_RADIUS around the player, if it’s missing and not already pending, request it.
        for (int dx = -CHUNK_LOAD_RADIUS; dx <= CHUNK_LOAD_RADIUS; dx++) {
            for (int dy = -CHUNK_LOAD_RADIUS; dy <= CHUNK_LOAD_RADIUS; dy++) {
                Vector2 chunkPos = new Vector2(playerChunkX + dx, playerChunkY + dy);
                if (!world.getChunks().containsKey(chunkPos) && !pendingChunks.contains(chunkPos)) {
                    chunkRequestQueue.offer(chunkPos);
                }
            }
        }

        // Optionally, unload chunks that are far away (outside the load radius)
        unloadFarChunks(playerChunkPos);
    }

    /**
     * Unload (remove from memory) any chunks that are outside the given radius.
     */
    private void unloadFarChunks(Vector2 playerChunkPos) {
        World world = GameContext.get().getWorld();
        if (world == null) return;
        int unloadThreshold = 5; // increase this threshold to keep more chunks loaded
        List<Vector2> keysToRemove = new ArrayList<>();
        for (Vector2 key : world.getChunks().keySet()) {
            if (Math.abs(key.x - playerChunkPos.x) > unloadThreshold || Math.abs(key.y - playerChunkPos.y) > unloadThreshold) {
                keysToRemove.add(key);
            }
        }
        for (Vector2 key : keysToRemove) {
            world.getChunks().remove(key);
            GameLogger.info("Unloaded chunk at " + key);
        }
    }

    private void handleBuildingPlacement(NetworkProtocol.BuildingPlacement bp) {
        // Do not process your own placement if already applied.
        if (bp.username.equals(getLocalUsername())) return;

        // Place the building in the local world.
        for (int x = 0; x < bp.width; x++) {
            for (int y = 0; y < bp.height; y++) {
                String typeId = bp.blockTypeIds[x][y];
                boolean isFlipped = bp.flippedFlags[x][y];
                if (typeId == null || typeId.isEmpty()) continue;
                PlaceableBlock.BlockType type = PlaceableBlock.BlockType.fromItemId(typeId);
                int tileX = bp.startX + x;
                int tileY = bp.startY + y;
                GameContext.get().getWorld().getBlockManager().placeBlock(type, tileX, tileY);
                PlaceableBlock block = GameContext.get().getWorld().getBlockManager().getBlockAt(tileX, tileY);
                if (block != null && isFlipped) {
                    block.toggleFlip();
                }
            }
        }
        GameLogger.info("Processed building placement from " + bp.username + " at (" + bp.startX + "," + bp.startY + ")");
    }

    private void handleReceivedMessage(Object object) {
        if (object instanceof NetworkProtocol.CompressedChunkData) {
            handleCompressedChunkData((NetworkProtocol.CompressedChunkData) object);
            return;
        }
        if (object instanceof NetworkProtocol.ServerShutdown) {
            NetworkProtocol.ServerShutdown shutdown = (NetworkProtocol.ServerShutdown) object;
            handleDisconnect(shutdown.reason);
            return;
        }
        if (object instanceof NetworkProtocol.LoginResponse) {
            NetworkProtocol.LoginResponse response = (NetworkProtocol.LoginResponse) object;
            handleLoginResponse(response);
        }
        if (object instanceof NetworkProtocol.ForceDisconnect) {
            NetworkProtocol.ForceDisconnect disconnect = (NetworkProtocol.ForceDisconnect) object;
            GameLogger.error("Received ForceDisconnect from server: " + disconnect.reason);
            handleDisconnect("Connection lost");
            return;
        }
        if (!isAuthenticated.get()) {
            if (!(object instanceof NetworkProtocol.LoginResponse ||
                object instanceof NetworkProtocol.ConnectionResponse)) {
                pendingMessages.offer(object);
                return;
            }
        }


        try {
            if (object instanceof NetworkProtocol.LoginResponse) {
                GameLogger.info("CRITICAL - Received LoginResponse");
                NetworkProtocol.LoginResponse response = (NetworkProtocol.LoginResponse) object;
                GameLogger.info("CRITICAL - Login success: " + response.success);
                GameLogger.info("CRITICAL - Login message: " + response.message);
                handleLoginResponse((NetworkProtocol.LoginResponse) object);
            } else if (object instanceof NetworkProtocol.ChatMessage) {
                handleChatMessage((NetworkProtocol.ChatMessage) object);
            } else if (object instanceof NetworkProtocol.ChestUpdate) {
                NetworkProtocol.ChestUpdate update = (NetworkProtocol.ChestUpdate) object;
                // Assume you store a reference to the open chest screen (if any) in GameContext:
                ChestScreen chestScreen = GameContext.get().getGameScreen().getChestScreen();
                if (chestScreen != null && chestScreen.getChestData().chestId.equals(update.chestId)) {
                    // Update the chestData with the items from the update
                    chestScreen.getChestData().setItems(update.items);
                    // Optionally, you can call your helper method:
                    // chestScreen.updateChestData(updatedChestData);
                    // (if you choose to construct an updated ChestData from update)
                    chestScreen.updateUI();
                    GameContext.get().getGameScreen().setChestScreen(chestScreen);
                }
                return;
            } else if (object instanceof NetworkProtocol.PlayerUpdate) {
                handlePlayerUpdate((NetworkProtocol.PlayerUpdate) object);
            } else if (object instanceof NetworkProtocol.PlayerJoined) {
                handlePlayerJoined((NetworkProtocol.PlayerJoined) object);
            } else if (object instanceof NetworkProtocol.PlayerLeft) {
                handlePlayerLeft((NetworkProtocol.PlayerLeft) object);
            } else if (object instanceof NetworkProtocol.BuildingPlacement) {
                handleBuildingPlacement((NetworkProtocol.BuildingPlacement) object);
            } else if (object instanceof NetworkProtocol.PlayerList) {
                handlePlayerList((NetworkProtocol.PlayerList) object);
            } else if (object instanceof NetworkProtocol.PingResponse) {
                handlePingResponse((NetworkProtocol.PingResponse) object);
                return;
            }

            if (object instanceof NetworkProtocol.ItemDrop) {
                handleItemDrop((NetworkProtocol.ItemDrop) object);
            } else if (object instanceof NetworkProtocol.PlayerPosition) {
                handlePlayerPosition((NetworkProtocol.PlayerPosition) object);
            } else if (object instanceof NetworkProtocol.WildPokemonSpawn) {
                handlePokemonSpawn((NetworkProtocol.WildPokemonSpawn) object);
            } else if (object instanceof NetworkProtocol.WildPokemonDespawn) {
                handlePokemonDespawn((NetworkProtocol.WildPokemonDespawn) object);
            } else if (object instanceof NetworkProtocol.PokemonUpdate) {
                handlePokemonUpdate((NetworkProtocol.PokemonUpdate) object);
            } else if (object instanceof NetworkProtocol.WorldStateUpdate) {
                handleWorldStateUpdate((NetworkProtocol.WorldStateUpdate) object);
            } else if (object instanceof NetworkProtocol.WorldObjectUpdate) {
                handleWorldObjectUpdate((NetworkProtocol.WorldObjectUpdate) object);
            } else if (object instanceof NetworkProtocol.BlockPlacement) {
                handleBlockPlacement((NetworkProtocol.BlockPlacement) object);
            } else if (object instanceof NetworkProtocol.PlayerAction) {
                handlePlayerAction((NetworkProtocol.PlayerAction) object);
            }
            if (object instanceof NetworkProtocol.PokemonBatchUpdate) {
                NetworkProtocol.PokemonBatchUpdate batchUpdate = (NetworkProtocol.PokemonBatchUpdate) object;
                for (NetworkProtocol.PokemonUpdate update : batchUpdate.updates) {
                    handlePokemonUpdate(update);
                }
            }

        } catch (Exception e) {
            GameLogger.error("Error handling network message: " + e.getMessage());
        }

    }

    private void handlePlayerList(NetworkProtocol.PlayerList list) {
        for (NetworkProtocol.PlayerInfo info : list.players) {
            playerPingMap.put(info.username, info.ping);
            // Optionally, if you maintain OtherPlayer objects:
            OtherPlayer op = otherPlayers.get(info.username);
            if (op != null) {
                op.setPing(info.ping);
            }
        }
    }

    public Map<String, Integer> getPlayerPingMap() {
        return new HashMap<>(playerPingMap);
    }

    public int getLocalPing() {
        return localPing;
    }

    private void sendPingRequest() {
        NetworkProtocol.PingRequest ping = new NetworkProtocol.PingRequest();
        ping.timestamp = System.currentTimeMillis();
        client.sendTCP(ping);
    }

    private void handleItemDrop(NetworkProtocol.ItemDrop drop) {
        if (drop.username.equals(getLocalUsername())) {
            // This is our own drop, already handled locally
            return;
        }

        // Spawn the dropped item for other players
        GameContext.get().getWorld().getItemEntityManager()
            .spawnItemEntity(drop.itemData, drop.x, drop.y);

        // Play drop sound for nearby drops
        float distance = Vector2.dst(
            GameContext.get().getPlayer().getX(),
            GameContext.get().getPlayer().getY(),
            drop.x, drop.y
        );
        if (distance < World.TILE_SIZE * 10) {
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP_OW);
        }
    }

    private void handlePlayerAction(NetworkProtocol.PlayerAction action) {
        Gdx.app.postRunnable(() -> {
            OtherPlayer otherPlayer = otherPlayers.get(action.playerId);
            if (otherPlayer != null) {
                otherPlayer.updateAction(action);
            }
        });
    }

    private void handleBlockPlacement(NetworkProtocol.BlockPlacement placement) {
        Gdx.app.postRunnable(() -> {
            if (GameContext.get().getWorld() != null) {
                PlaceableBlock.BlockType type = PlaceableBlock.BlockType.fromItemId(placement.blockTypeId);
                if (type != null) {
                    if (placement.action == NetworkProtocol.BlockAction.PLACE) {
                        GameContext.get().getWorld().getBlockManager().placeBlock(type, placement.tileX, placement.tileY);
                        GameLogger.info("Block placed by " + placement.username + " at (" + placement.tileX + ", " + placement.tileY + ")");
                    } else if (placement.action == NetworkProtocol.BlockAction.REMOVE) {
                        GameContext.get().getWorld().getBlockManager().removeBlock(placement.tileX, placement.tileY);
                        GameLogger.info("Block removed by " + placement.username + " at (" + placement.tileX + ", " + placement.tileY + ")");
                    }
                } else {
                    GameLogger.error("Unknown block type: " + placement.blockTypeId);
                }
            }
        });
    }

    private void handlePlayerPosition(NetworkProtocol.PlayerPosition positionMsg) {
        if (positionMsg == null || positionMsg.players == null) {
            GameLogger.error("Received empty PlayerPosition message.");
            return;
        }

        Gdx.app.postRunnable(() -> {
            try {
                synchronized (otherPlayers) {
                    for (Map.Entry<String, NetworkProtocol.PlayerUpdate> entry : positionMsg.players.entrySet()) {
                        String username = entry.getKey();
                        if (username.equals(localUsername)) continue;

                        NetworkProtocol.PlayerUpdate update = entry.getValue();
                        GameLogger.error("Received update for " + username + " at (" + update.x + "," + update.y + ")");

                        OtherPlayer otherPlayer = otherPlayers.computeIfAbsent(username,
                            k -> new OtherPlayer(username, update.x, update.y));

                        otherPlayer.updateFromNetwork(update);
                        playerUpdates.put(username, update);
                    }
                }
            } catch (Exception e) {
                GameLogger.error("Error in handlePlayerPosition: " + e.getMessage());
            }
        });
    }



    public void handleDisconnect(String reason) {
        synchronized (connectionLock) {
            connectionState = ConnectionState.DISCONNECTED;
            isConnected.set(false);
            isAuthenticated.set(false);

            // Save any last known state, if needed:
            if (GameContext.get().getPlayer() != null) {
                lastKnownState = GameContext.get().getPlayer().getPlayerData();
            }

            // Actual cleanup of the network client:
            cleanupConnection();

            // Show the DisconnectionScreen (via DisconnectionManager) UNLESS we are already disposing:
            if (!isDisposing.get() && disconnectHandler != null) {
                disconnectHandler.handleDisconnect(reason);
            }
        }
    }


    private void cleanupConnection() {
        if (client != null) {
            try {
                client.close();
                client.stop();
                client = null;
            } catch (Exception e) {
                GameLogger.error("Error cleaning up connection: " + e.getMessage());
            }
        }
    }

    private void updatePokemonStates(float deltaTime) {
        for (Map.Entry<UUID, WildPokemon> entry : trackedWildPokemon.entrySet()) {
            WildPokemon pokemon = entry.getValue();
            NetworkSyncData syncData = syncedPokemonData.get(entry.getKey());

            if (syncData != null && syncData.targetPosition != null) {
                updatePokemonPosition(pokemon, syncData, deltaTime);
            }
            pokemon.update(deltaTime);
        }
    }

    private void updatePokemonPosition(WildPokemon pokemon, NetworkSyncData syncData, float deltaTime) {
        syncData.interpolationProgress = Math.min(1.0f,
            syncData.interpolationProgress + deltaTime * INTERPOLATION_SPEED);

        float newX = lerp(pokemon.getX(), syncData.targetPosition.x, syncData.interpolationProgress);
        float newY = lerp(pokemon.getY(), syncData.targetPosition.y, syncData.interpolationProgress);

        pokemon.setX(newX);
        pokemon.setY(newY);
        pokemon.updateBoundingBox();
    }

    private float lerp(float start, float end, float alpha) {
        return start + (end - start) * alpha;
    }

    private void updateOtherPlayers(float deltaTime) {
        otherPlayers.values().forEach(player -> {
            player.update(deltaTime);
        });
    }

    public void tick() {
        if (!isConnected() || isSinglePlayer) return;
        if (isInitialized && !processingMessages) {
            processQueuedMessages();
        }
    }


    public void sendRegisterRequest(String username, String password,
                                    Consumer<NetworkProtocol.RegisterResponse> onResponse,
                                    Consumer<String> onError) {
        if (!GameContext.get().isMultiplayer()) {
            GameLogger.info("Registration not needed in single player mode");
            return;
        }
        if (!isConnected.get() || client == null) {
            onError.accept("Not connected to server for registration");
            return;
        }
        if (username == null || username.trim().isEmpty() ||
            password == null || password.trim().isEmpty()) {
            onError.accept("Username and password are required");
            return;
        }
        String secureUsername = username.trim();
        String securePassword = password.trim();
        NetworkProtocol.RegisterRequest request = new NetworkProtocol.RegisterRequest();
        request.username = secureUsername;
        request.password = securePassword;
        GameLogger.info("Sending registration request for: " + secureUsername);
        client.sendTCP(request);
    }

    private void processChatMessages() {
        NetworkProtocol.ChatMessage message;
        while ((message = chatMessageQueue.poll()) != null) {
            final NetworkProtocol.ChatMessage finalMessage = message;
            Gdx.app.postRunnable(() -> {
                if (chatMessageHandler != null) {
                    chatMessageHandler.accept(finalMessage);
                }
            });
        }
    }

    public boolean isInitialized() {
        return fullyInitialized;
    }

    public void setInitialized(boolean initialized) {
        this.isInitialized = initialized;
    }

    public boolean isInitializing() {
        return isInitializing;
    }

    public void requestChunk(Vector2 chunkPos) {
        if (!isConnected() || !isAuthenticated()) {
            return;
        }

        try {
            // Check if chunk is already requested
            if (pendingChunks.contains(chunkPos)) {
                GameLogger.error("Chunk already requested: " + chunkPos);
                return;
            }

            // Add to pending chunks first to prevent duplicate requests
            pendingChunks.add(chunkPos);

            // Create the request with the exact coordinates
            NetworkProtocol.ChunkRequest request = new NetworkProtocol.ChunkRequest();
            request.chunkX = (int) chunkPos.x;
            request.chunkY = (int) chunkPos.y;
            request.timestamp = System.currentTimeMillis();

            // Check if this is the player's current chunk for prioritization
            boolean isPlayerCurrentChunk = false;
            if (GameContext.get().getPlayer() != null) {
                int playerChunkX = Math.floorDiv(GameContext.get().getPlayer().getTileX(), Chunk.CHUNK_SIZE);
                int playerChunkY = Math.floorDiv(GameContext.get().getPlayer().getTileY(), Chunk.CHUNK_SIZE);
                isPlayerCurrentChunk = (chunkPos.x == playerChunkX && chunkPos.y == playerChunkY);
            }

            // Send the request with appropriate logging
            client.sendTCP(request);

            if (isPlayerCurrentChunk) {
                GameLogger.info("Requested player's current chunk at " + chunkPos + " (HIGH PRIORITY)");
            } else {
                GameLogger.info("Requested chunk at " + chunkPos);
            }

            // Add timeout handling with progressive backoff retry system
            setupChunkRequestTimeout(chunkPos, 1);

        } catch (Exception e) {
            GameLogger.error("Failed to request chunk at " + chunkPos + ": " + e.getMessage());
            pendingChunks.remove(chunkPos);
        }
    }

    private void setupChunkRequestTimeout(Vector2 chunkPos, int attempt) {
        // Calculate timeout with progressive backoff
        long timeoutMs = Math.min(2000 + (attempt * 1000), 8000); // 2s first try, +1s per attempt, max 8s

        scheduler.schedule(() -> {
            // Check if chunk is still pending and not received
            if (pendingChunks.contains(chunkPos) &&
                GameContext.get().getWorld() != null &&
                !GameContext.get().getWorld().getChunks().containsKey(chunkPos)) {

                if (attempt <= 5) { // Max 5 retry attempts
                    GameLogger.error("Chunk request timeout for " + chunkPos +
                        " - retry attempt " + attempt + "/5");

                    // Check if we're still connected before retrying
                    if (isConnected() && isAuthenticated()) {
                        // First remove from pending chunks
                        pendingChunks.remove(chunkPos);

                        // Then request again with a small delay
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }

                        // Create a new request
                        NetworkProtocol.ChunkRequest request = new NetworkProtocol.ChunkRequest();
                        request.chunkX = (int) chunkPos.x;
                        request.chunkY = (int) chunkPos.y;
                        request.timestamp = System.currentTimeMillis();

                        // Mark as pending again
                        pendingChunks.add(chunkPos);

                        // Send retry request
                        client.sendTCP(request);

                        // Setup next timeout with increased attempt counter
                        setupChunkRequestTimeout(chunkPos, attempt + 1);
                    } else {
                        GameLogger.error("Cannot retry chunk request - not connected");
                        pendingChunks.remove(chunkPos);
                    }
                } else {
                    // Give up after max attempts
                    GameLogger.error("Max retry attempts reached for chunk " + chunkPos + " - giving up");
                    pendingChunks.remove(chunkPos);

                    // Potentially generate a fallback chunk if absolutely needed
                    if (isPlayerCurrentChunk(chunkPos)) {
                        GameLogger.error("Generating emergency fallback chunk for player position");
                        generateFallbackChunk(chunkPos);
                    }
                }
            }
        }, timeoutMs, TimeUnit.MILLISECONDS);
    }

    private void generateFallbackChunk(Vector2 chunkPos) {
        if (!GameContext.get().isMultiplayer() || GameContext.get().getWorld() == null) return;

        try {
            // Generate an emergency fallback chunk
            GameLogger.error("Generating emergency fallback chunk at " + chunkPos);

            // Use client-side generation as a last resort
            long seed = worldSeed;
            BiomeManager biomeManager = GameContext.get().getBiomeManager();

            // Generate a basic chunk
            Chunk fallbackChunk = UnifiedWorldGenerator.generateChunk(
                (int)chunkPos.x, (int)chunkPos.y, seed, biomeManager);

            // Use plains biome as fallback
            if (fallbackChunk.getBiome() == null) {
                fallbackChunk.setBiome(biomeManager.getBiome(BiomeType.PLAINS));
            }

            // Store in world's chunk map
            GameContext.get().getWorld().getChunks().put(chunkPos, fallbackChunk);

            // Add a visual indicator that this is a fallback chunk (e.g. special color)
            GameLogger.error("Added emergency fallback chunk at " + chunkPos);

        } catch (Exception e) {
            GameLogger.error("Failed to generate fallback chunk: " + e.getMessage());
        }
    }
    /**
     * Checks if the given chunk position is the player's current chunk
     */
    private boolean isPlayerCurrentChunk(Vector2 chunkPos) {
        if (GameContext.get().getPlayer() == null) return false;

        int playerChunkX = Math.floorDiv(GameContext.get().getPlayer().getTileX(), Chunk.CHUNK_SIZE);
        int playerChunkY = Math.floorDiv(GameContext.get().getPlayer().getTileY(), Chunk.CHUNK_SIZE);
        return (chunkPos.x == playerChunkX && chunkPos.y == playerChunkY);
    }
    private void handleWorldObjectUpdate(NetworkProtocol.WorldObjectUpdate update) {
        if (update == null || GameContext.get().getWorld() == null) {
            return;
        }

        Gdx.app.postRunnable(() -> {
            try {
                WorldObject.WorldObjectManager objectManager = GameContext.get().getWorld().getObjectManager();
                switch (update.type) {
                    case ADD:
                        // Create and add new object from update data.
                        WorldObject newObj = new WorldObject();
                        newObj.updateFromData(update.data);
                        objectManager.addObjectToChunk(newObj);
                        break;

                    case REMOVE:
                        // Ensure tile coordinates are present in the update.
                        if (update.data == null || !update.data.containsKey("tileX") || !update.data.containsKey("tileY")) {
                            GameLogger.error("Client: WorldObjectUpdate REMOVE missing tile position data.");
                            return;
                        }
                        // Parse the canonical tile coordinates.
                        int baseTileX = Integer.parseInt(update.data.get("tileX").toString());
                        int baseTileY = Integer.parseInt(update.data.get("tileY").toString());
                        // Use Math.floorDiv to compute the chunk coordinates reliably.
                        int chunkX = Math.floorDiv(baseTileX, Chunk.CHUNK_SIZE);
                        int chunkY = Math.floorDiv(baseTileY, Chunk.CHUNK_SIZE);
                        Vector2 chunkPos = new Vector2(chunkX, chunkY);

                        // Remove the object from the WorldObjectManager.
                        objectManager.removeObjectFromChunk(chunkPos, update.objectId, baseTileX, baseTileY);

                        // **New Code:** Also update the local world's chunk.
                        World world = GameContext.get().getWorld();
                        if (world != null) {
                            // Here we assume that the world's chunk retrieval uses the same coordinate system.
                            // (If your chunk lookup method expects pixel coordinates, adjust accordingly.)
                            Chunk chunk = world.getChunkAtPosition(baseTileX * World.TILE_SIZE, baseTileY * World.TILE_SIZE);
                            if (chunk != null) {
                                // Remove the world object from the chunk's internal list.
                                // (If you don’t already have a helper method, you can iterate through the chunk’s object list.)
                                chunk.getWorldObjects().removeIf(obj -> obj.getId().equals(update.objectId));
                                // Mark the chunk as dirty so that it will be re–rendered.
                                chunk.setDirty(true);
                            }
                        }
                        break;

                    case UPDATE:
                        objectManager.updateObject(update);
                        break;

                    default:
                        GameLogger.error("Client: Unknown world object update type: " + update.type);
                        break;
                }
            } catch (Exception e) {
                GameLogger.error("Error processing world object update on client: " + e.getMessage());
            }
        });
    }

    public Player getActivePlayer() {
        return GameContext.get().getPlayer();
    }

    public void setActivePlayer(Player activePlayer) {
        GameContext.get().setPlayer(activePlayer);
    }

    private void processQueuedMessages() {
        if (pendingMessages.isEmpty()) {
            return;
        }

        GameLogger.info("Processing " + pendingMessages.size() + " queued messages");

        Object message;
        while ((message = pendingMessages.poll()) != null) {
            try {
                handleReceivedMessage(message);
            } catch (Exception e) {
                GameLogger.error("Error processing queued message: " + e.getMessage());
            }
        }
    }


    private void processChunkQueue() {
        if (chunkRequestQueue.isEmpty() || !isConnected() || !isAuthenticated()) {
            return;
        }

        long now = System.currentTimeMillis();

        // Check if we've exceeded our chunk request rate limit
        if (now - lastRequestTime < CHUNK_REQUEST_INTERVAL) {
            return;
        }

        // Check if we're already at the maximum number of pending chunks
        if (pendingChunks.size() >= MAX_CONCURRENT_CHUNK_REQUESTS) {
            return;
        }

        // Get player's current position for prioritization
        Vector2 playerChunkPos;
        if (GameContext.get().getPlayer() != null) {
            int playerChunkX = Math.floorDiv(GameContext.get().getPlayer().getTileX(), Chunk.CHUNK_SIZE);
            int playerChunkY = Math.floorDiv(GameContext.get().getPlayer().getTileY(), Chunk.CHUNK_SIZE);
            playerChunkPos = new Vector2(playerChunkX, playerChunkY);
        } else {
            playerChunkPos = null;
        }

        // Sort the queue by distance to player for priority loading
        if (playerChunkPos != null && chunkRequestQueue.size() > 1) {
            List<Vector2> sortedQueue = new ArrayList<>(chunkRequestQueue);
            sortedQueue.sort((a, b) -> {
                float distA = Vector2.dst(a.x, a.y, playerChunkPos.x, playerChunkPos.y);
                float distB = Vector2.dst(b.x, b.y, playerChunkPos.x, playerChunkPos.y);
                return Float.compare(distA, distB);
            });

            // Clear the queue and add back in sorted order
            chunkRequestQueue.clear();
            chunkRequestQueue.addAll(sortedQueue);
        }

        // Process the next chunk in the queue
        Vector2 nextChunk = chunkRequestQueue.poll();

        // Double-check that this chunk is still needed
        if (nextChunk != null &&
            GameContext.get().getWorld() != null &&
            !GameContext.get().getWorld().getChunks().containsKey(nextChunk) &&
            !pendingChunks.contains(nextChunk) &&
            !loadingChunks.containsKey(nextChunk)) {

            // Request the chunk
            requestChunk(nextChunk);
            lastRequestTime = now;
        }
    }

    private void handlePlayerUpdate(NetworkProtocol.PlayerUpdate update) {
        // Ignore our own update.
        if (update == null || update.username == null || update.username.equals(localUsername)) {
            return;
        }

        Gdx.app.postRunnable(() -> {
            synchronized (otherPlayers) {
                OtherPlayer otherPlayer = otherPlayers.get(update.username);
                if (otherPlayer == null) {
                    // Create a new OtherPlayer if one does not exist yet.
                    otherPlayer = new OtherPlayer(update.username, update.x, update.y);
                    // Set the run flag for the new player:
                    otherPlayer.setWantsToRun(update.wantsToRun);
                    otherPlayers.put(update.username, otherPlayer);
                    GameLogger.info("Created new OtherPlayer: " + update.username);
                }
                // Always update the remote player’s data:
                otherPlayer.setWantsToRun(update.wantsToRun);
                otherPlayer.updateFromNetwork(update);
                playerUpdates.put(update.username, update);
            }
        });
    }


    private void handlePlayerJoined(NetworkProtocol.PlayerJoined joinMsg) {
        final String joinKey = joinMsg.username + "_" + joinMsg.timestamp;
        Gdx.app.postRunnable(() -> {
            // =========== IMPORTANT FIX ===========
            if (joinMsg.username.equals(localUsername)) {
                // This "join" event is actually our own player.
                // Do NOT create an OtherPlayer. Just return.
                return;
            }
            // ======================================

            synchronized (otherPlayers) {
                if (recentJoinEvents.contains(joinKey)) {
                    // We’ve already processed this join event
                    return;
                }

                if (otherPlayers.containsKey(joinMsg.username)) {
                    GameLogger.info("Player " + joinMsg.username +
                        " already exists, updating position");
                    OtherPlayer existingPlayer = otherPlayers.get(joinMsg.username);
                    existingPlayer.setPosition(new Vector2(joinMsg.x, joinMsg.y));
                    return;
                }

                // Create a new OtherPlayer only for different usernames
                OtherPlayer newPlayer = new OtherPlayer(joinMsg.username,
                    joinMsg.x, joinMsg.y);
                otherPlayers.put(joinMsg.username, newPlayer);

                recentJoinEvents.add(joinKey);
                com.badlogic.gdx.utils.Timer.schedule(new com.badlogic.gdx.utils.Timer.Task() {
                    @Override
                    public void run() {
                        recentJoinEvents.remove(joinKey);
                    }
                }, 5);

                if (chatMessageHandler != null) {
                    NetworkProtocol.ChatMessage joinNotification = new NetworkProtocol.ChatMessage();
                    joinNotification.sender = "System";
                    joinNotification.content = joinMsg.username + " has joined the game";
                    joinNotification.type = NetworkProtocol.ChatType.SYSTEM;
                    joinNotification.timestamp = System.currentTimeMillis();

                    chatMessageHandler.accept(joinNotification);
                }
            }
        });
    }

    public void sendBlockPlacement(NetworkProtocol.BlockPlacement placement) {
        if (!isConnected() || !isAuthenticated()) {
            return;
        }
        try {
            client.sendTCP(placement);
        } catch (Exception e) {
            GameLogger.error("Failed to send block placement: " + e.getMessage());
        }
    }

    private void handlePlayerLeft(NetworkProtocol.PlayerLeft leftMsg) {
        Gdx.app.postRunnable(() -> {
            // Remove the OtherPlayer instance
            OtherPlayer leftPlayer = otherPlayers.remove(leftMsg.username);
            if (leftPlayer != null) {
                leftPlayer.dispose();
            }

            // Remove any pending player updates for this username
            playerUpdates.remove(leftMsg.username);

            // **** Remove the player's ping data ****
            playerPingMap.remove(leftMsg.username);

            // Optionally, notify via chat that the player has left:
            if (chatMessageHandler != null) {
                NetworkProtocol.ChatMessage leaveNotification = new NetworkProtocol.ChatMessage();
                leaveNotification.sender = "System";
                leaveNotification.content = leftMsg.username + " has left the game";
                leaveNotification.type = NetworkProtocol.ChatType.SYSTEM;
                leaveNotification.timestamp = System.currentTimeMillis();
                chatMessageHandler.accept(leaveNotification);
            }
        });
    }


    private void handlePokemonSpawn(NetworkProtocol.WildPokemonSpawn spawnData) {
        if (spawnData == null || spawnData.uuid == null || spawnData.data == null) {
            GameLogger.error("Received invalid Pokemon spawn data");
            return;
        }

        Gdx.app.postRunnable(() -> {
            try {
                // Check if we already have this Pokemon
                if (trackedWildPokemon.containsKey(spawnData.uuid)) {
                    return;
                }

                TextureRegion overworldSprite = TextureManager.getOverworldSprite(spawnData.data.getName());
                if (overworldSprite == null) {
                    GameLogger.error("Could not load sprite for Pokemon: " + spawnData.data.getName());
                    return;
                }

                // Create the Pokemon instance
                WildPokemon pokemon = new WildPokemon(
                    spawnData.data.getName(),
                    spawnData.data.getLevel(),
                    (int) spawnData.x,
                    (int) spawnData.y,
                    overworldSprite
                );

                // Set additional data
                pokemon.setUuid(spawnData.uuid);
                pokemon.setWorld(GameContext.get().getWorld());
                pokemon.setDirection("down");
                pokemon.setSpawnTime(spawnData.timestamp / 1000L);

                // Mark as network controlled
                pokemon.setNetworkControlled(true);

                // Register in tracking collections
                trackedWildPokemon.put(spawnData.uuid, pokemon);

                // Add to the world
                if (GameContext.get().getWorld() != null &&
                    GameContext.get().getWorld().getPokemonSpawnManager() != null) {
                    GameContext.get().getWorld().getPokemonSpawnManager().addPokemonToChunk(
                        pokemon,
                        new Vector2(
                            Math.floorDiv((int)spawnData.x, World.CHUNK_SIZE * World.TILE_SIZE),
                            Math.floorDiv((int)spawnData.y, World.CHUNK_SIZE * World.TILE_SIZE)
                        )
                    );
                }

                GameLogger.info("Spawned network Pokemon: " + spawnData.data.getName() +
                    " at (" + spawnData.x + "," + spawnData.y + ")");
            } catch (Exception e) {
                GameLogger.error("Error handling Pokemon spawn: " + e.getMessage());
                e.printStackTrace();
            }
        });
    }

    private void handlePokemonDespawn(NetworkProtocol.WildPokemonDespawn despawnData) {
        if (despawnData == null || despawnData.uuid == null) {
            return;
        }

        Gdx.app.postRunnable(() -> {
            try {
                WildPokemon pokemon = trackedWildPokemon.remove(despawnData.uuid);
                syncedPokemonData.remove(despawnData.uuid);

                if (pokemon != null && GameContext.get().getWorld() != null) {
                    pokemon.startDespawnAnimation();

                    com.badlogic.gdx.utils.Timer.schedule(new com.badlogic.gdx.utils.Timer.Task() {
                        @Override
                        public void run() {
                            if (GameContext.get().getWorld() == null || GameContext.get().getWorld().getPokemonSpawnManager() == null) {
                                GameLogger.error("World or its PokemonSpawnManager is null; cannot remove spawned Pokémon.");
                                return;
                            }

                            GameContext.get().getWorld().getPokemonSpawnManager()
                                .removePokemon(despawnData.uuid);
                        }
                    }, 1.0f);
                }

                GameLogger.info("Handled Pokemon despawn for UUID: " + despawnData.uuid);

            } catch (Exception e) {
                GameLogger.error("Error handling Pokemon despawn: " + e.getMessage());
            }
        });
    }


    private void handlePokemonUpdate(NetworkProtocol.PokemonUpdate update) {
        if (update == null || update.uuid == null) return;

        Gdx.app.postRunnable(() -> {
            WildPokemon pokemon = trackedWildPokemon.get(update.uuid);

            if (pokemon == null) {
                // If this is a Pokemon we don't know about, request spawn data
                requestPokemonSpawnData(update.uuid);
                return;
            }

            // Mark as network controlled
            pokemon.setNetworkControlled(true);

            // Apply the network update
            pokemon.applyNetworkUpdate(update.x, update.y, update.direction, update.isMoving, update.timestamp);

            // Update other properties if provided
            if (update.level > 0) pokemon.setLevel(update.level);
            if (update.currentHp > 0) pokemon.setCurrentHp(update.currentHp);
            pokemon.setSpawnTime(update.timestamp / 1000L);

            if (pokemonUpdateHandler != null) {
                pokemonUpdateHandler.onUpdate(update);
            }
        });
    }
    private void handlePokemonBatchUpdate(NetworkProtocol.PokemonBatchUpdate batchUpdate) {
        if (batchUpdate == null || batchUpdate.updates == null) return;

        for (NetworkProtocol.PokemonUpdate update : batchUpdate.updates) {
            handlePokemonUpdate(update);
        }
    }


    public void sendPokemonUpdate(NetworkProtocol.PokemonUpdate update) {
        if (!isAuthenticated.get() || connectionState != ConnectionState.CONNECTED) return;

        try {
            if (update.timestamp == 0) {
                update.timestamp = System.currentTimeMillis();
            }
            client.sendTCP(update);
        } catch (Exception e) {
            GameLogger.error("Failed to send Pokemon update: " + e.getMessage());
        }
    }

    private void requestPokemonSpawnData(UUID pokemonId) {
        if (!isAuthenticated.get() || connectionState != ConnectionState.CONNECTED) return;

        try {
            NetworkProtocol.PokemonSpawnRequest request = new NetworkProtocol.PokemonSpawnRequest();
            request.uuid = pokemonId;
            client.sendTCP(request);
        } catch (Exception e) {
            GameLogger.error("Failed to request Pokemon spawn data: " + e.getMessage());
        }
    }

    public void sendWorldObjectUpdate(NetworkProtocol.WorldObjectUpdate update) {
        if (isSinglePlayer || !isConnected() || !isAuthenticated()) {
            return;
        }

        try {


            client.sendTCP(update);

        } catch (Exception e) {
            GameLogger.error("Failed to send world object update: " + e.getMessage());
            handleConnectionFailure(e);
        }
    }

    public void sendPlayerAction(NetworkProtocol.PlayerAction action) {
        if (!isConnected() || !isAuthenticated()) {
            return;
        }

        try {
            // Add position data if missing
            if (action.tileX == 0 && action.tileY == 0 && GameContext.get().getPlayer() != null) {
                action.tileX = (int) (GameContext.get().getPlayer().getX() / World.TILE_SIZE);
                action.tileY = (int) (GameContext.get().getPlayer().getY() / World.TILE_SIZE);
                GameLogger.info("Sending player action " + action.actionType +
                    " at position (" + action.tileX + "," + action.tileY +
                    ") direction: " + action.direction);
            }

            client.sendTCP(action);
        } catch (Exception e) {
            GameLogger.error("Failed to send player action: " + e.getMessage());
        }
    }

    public void sendPokemonDespawn(UUID pokemonId) {
        if (!isConnected() || client == null || isSinglePlayer) {
            return;
        }

        try {
            NetworkProtocol.WildPokemonDespawn despawnUpdate = new NetworkProtocol.WildPokemonDespawn();
            despawnUpdate.uuid = pokemonId;
            despawnUpdate.timestamp = System.currentTimeMillis();

            client.sendTCP(despawnUpdate);
            trackedWildPokemon.remove(pokemonId);
            syncedPokemonData.remove(pokemonId);

            GameLogger.info("Sent Pokemon despawn for ID: " + pokemonId);
        } catch (Exception e) {
            GameLogger.error("Failed to send Pokemon despawn: " + e.getMessage());
            if (!isConnected()) {
                handleConnectionFailure(e);
            }
        }
    }

    public void setChatMessageHandler(Consumer<NetworkProtocol.ChatMessage> handler) {
        this.chatMessageHandler = handler;
    }

    public Map<String, OtherPlayer> getOtherPlayers() {
        return new HashMap<>(otherPlayers);
    }

    public boolean isAuthenticated() {
        return isAuthenticated.get();
    }

    public boolean isConnected() {
        return connectionState == ConnectionState.CONNECTED || connectionState == ConnectionState.AUTHENTICATED;
    }private boolean suppressDisconnectHandling = false;

    public void setSuppressDisconnectHandling(boolean suppress) {
        this.suppressDisconnectHandling = suppress;
    }

    // In GameClient.java, update handleLoginResponse:

    private void handleLoginResponse(NetworkProtocol.LoginResponse response) {
        if (response.success) {
            isAuthenticated.set(true);
            localUsername = response.username;

            try {
                // Initialize basic world settings from the server response.
                initializeWorldBasic(response.seed, response.worldTimeInMinutes, response.dayLength);

                // **FIX:** If the world is null (for example, because the previous world was disposed),
                // force a reinitialization of the world.
                if (GameContext.get().getWorld() == null) {
                    GameContext.get().setWorld(new World(worldData));
                    GameLogger.info("Reinitialized world for multiplayer session.");
                }

                Gdx.app.postRunnable(() -> {
                    if (GameContext.get().getPlayer() == null) {
                        Player player = new Player(response.username, GameContext.get().getWorld());
                        player.setPlayerData(response.playerData);
                        GameContext.get().setPlayer(player);
                    }
                    GameContext.get().getPlayer().setX(response.x);
                    GameContext.get().getPlayer().setY(response.y);
                    GameContext.get().getPlayer().setPlayerData(response.playerData);
                    GameContext.get().getPlayer().updateFromPlayerData(response.playerData);
                    processQueuedMessages();

                    if (loginResponseListener != null) {
                        loginResponseListener.accept(response);
                    }
                });
            } catch (Exception e) {
                GameLogger.error("Initial world setup failed: " + e.getMessage());
                handleLoginFailure("World initialization failed: " + e.getMessage());
            }
        } else {
            handleLoginFailure(response.message);
        }
    }

    private void initializeWorldBasic(long seed, double worldTimeInMinutes, float dayLength) {
        try {
            GameLogger.info("Initializing basic world with seed: " + seed);
            if (worldData == null) {
                worldData = new WorldData("multiplayer_world");
                GameLogger.info("Created new WorldData instance");
            }

            WorldData.WorldConfig config = new WorldData.WorldConfig(seed);
            worldData.setConfig(config);
            worldData.setWorldTimeInMinutes(worldTimeInMinutes);
            worldData.setDayLength(dayLength);

            this.worldSeed = seed;
            // CRITICAL: Initialize BiomeManager with the correct seed
            BiomeManager biomeManager = new BiomeManager(seed);
            GameContext.get().setBiomeManager(biomeManager);

            if (GameContext.get().getWorld() == null) {
                GameContext.get().setWorld(new World(worldData));
                GameLogger.info("Basic world initialization complete");
            }

        } catch (Exception e) {
            GameLogger.error("Failed to initialize basic world: " + e.getMessage());
            throw new RuntimeException("World initialization failed", e);
        }
    }
    private void handleLoginFailure(String message) {
        loginRequestSent = false;
        GameLogger.error("Login failed: " + message);

        if (loginResponseListener != null) {
            Gdx.app.postRunnable(() -> {
                NetworkProtocol.LoginResponse response = new NetworkProtocol.LoginResponse();
                response.success = false;
                response.message = "Connection failed: " + message;
                loginResponseListener.accept(response);
            });
        }

    }



    private static final float POKEMON_UPDATE_THRESHOLD = 0.1f;
    private float pokemonUpdateAccumulator = 0f;

    private enum ConnectionState {
        DISCONNECTED,
        CONNECTING,
        CONNECTED,
        AUTHENTICATED
    }

    public interface LoginResponseListener {
        void onResponse(NetworkProtocol.LoginResponse response);
    }


    public interface RegistrationResponseListener {
        void onResponse(NetworkProtocol.RegisterResponse response);
    }

    public interface ReconnectionListener {
        void onReconnectionSuccess();

        void onReconnectionFailure(String reason);
    }

    public interface InitializationListener {
        void onInitializationComplete(boolean success);
    }


    public interface PokemonUpdateHandler {
        void onUpdate(NetworkProtocol.PokemonUpdate update);
    }

    private static class NetworkSyncData {
        Vector2 targetPosition;
        String direction;
        boolean isMoving;
        long lastUpdateTime;
        float interpolationProgress;

        NetworkSyncData() {
            this.lastUpdateTime = System.currentTimeMillis();
            this.interpolationProgress = 0f;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/client/GameClientSingleton.java
================
package io.github.pokemeetup.multiplayer.client;

import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.server.config.ServerConfigManager;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.utils.GameLogger;


public class GameClientSingleton {
    private static final Object lock = new Object();
    private static GameClient instance;

    public static void resetInstance() {
        if (instance != null) {
            instance.dispose();
            instance = null;
        }
    }

    public static GameClient getInstance(ServerConnectionConfig config) {
        if (config == null) {
            config = ServerConfigManager.getDefaultServerConfig();
        }

        synchronized (lock) {
            try {
                validateConfig(config);

                if (instance != null) {
                    instance.dispose();
                    instance = null;
                }

                GameContext.get().setMultiplayer(true);
                instance = new GameClient(config);

                return instance;

            } catch (Exception e) {
                GameLogger.error("Failed to initialize GameClient: " + e.getMessage());
                if (instance != null) {
                    instance.dispose();
                    instance = null;
                }
                throw new RuntimeException("Failed to initialize GameClient: " + e.getMessage(), e);
            }
        }
    }

    private static void validateConfig(ServerConnectionConfig config) {
        if (config.getServerIP() == null || config.getServerIP().isEmpty()) {
            throw new IllegalArgumentException("Server IP cannot be null or empty");
        }
        if (config.getTcpPort() <= 0) {
            throw new IllegalArgumentException("Invalid TCP port: " + config.getTcpPort());
        }
        if (config.getUdpPort() <= 0) {
            throw new IllegalArgumentException("Invalid UDP port: " + config.getUdpPort());
        }
    }

    public static synchronized GameClient getSinglePlayerInstance(Player player) {
        synchronized (lock) {
            try {
                if (instance != null) {
                    instance.dispose();
                    instance = null;
                }
                ServerConnectionConfig singlePlayerConfig = ServerConnectionConfig.getDefault();
                GameContext.get().setMultiplayer(false);
                instance = new GameClient(singlePlayerConfig);
                instance.setActivePlayer(player);
                return instance;
            } catch (Exception e) {
                GameLogger.error("Error disposing GameClient: " + e.getMessage());
                throw new RuntimeException("Failed to initialize single player GameClient", e);

            }
        }
    }

    public static synchronized GameClient getSinglePlayerInstance() {
        synchronized (lock) {
            try {
                if (instance != null) {
                    instance.dispose();
                    instance = null;
                }

                ServerConnectionConfig singlePlayerConfig = ServerConnectionConfig.getDefault();
                GameContext.get().setMultiplayer(false);
                instance = new GameClient(singlePlayerConfig);
                return instance;

            } catch (Exception e) {
                GameLogger.error("Failed to create single player GameClient: " + e.getMessage());
                throw new RuntimeException("Failed to initialize single player GameClient", e);
            }
        }
    }

    public static void clearInstance() {
        synchronized (lock) {
            if (instance != null) {
                try {
                    instance.dispose();
                } catch (Exception e) {
                    GameLogger.error("Error disconnecting GameClient: " + e.getMessage());
                }
                instance = null;
            }
        }
    }


}

================
File: src/main/java/io/github/pokemeetup/multiplayer/client/PlayerDataResponseHandler.java
================
package io.github.pokemeetup.multiplayer.client;

import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.utils.GameLogger;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.*;

public class PlayerDataResponseHandler {
    private final Map<UUID, CompletableFuture<PlayerData>> pendingRequests;
    private final Map<UUID, CachedPlayerData> dataCache;
    private static final long CACHE_DURATION = 60000; // 1 minute cache
    private static final int MAX_CACHE_SIZE = 100;

    private static class CachedPlayerData {
        final PlayerData data;
        final long timestamp;

        CachedPlayerData(PlayerData data) {
            this.data = data;
            this.timestamp = System.currentTimeMillis();
        }

        boolean isExpired() {
            return System.currentTimeMillis() - timestamp > CACHE_DURATION;
        }
    }

    public PlayerDataResponseHandler() {
        this.pendingRequests = new ConcurrentHashMap<>();
        this.dataCache = new ConcurrentHashMap<>();
        startCacheCleanupTask();
    }

    private void startCacheCleanupTask() {
        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread t = new Thread(r, "PlayerDataCache-Cleanup");
            t.setDaemon(true);
            return t;
        });

        executor.scheduleWithFixedDelay(() -> {
            try {
                cleanupCache();
            } catch (Exception e) {
                GameLogger.error("Error during cache cleanup: " + e.getMessage());
            }
        }, CACHE_DURATION, CACHE_DURATION, TimeUnit.MILLISECONDS);
    }

    private void cleanupCache() {
        dataCache.entrySet().removeIf(entry -> entry.getValue().isExpired());

        // If still too many entries, remove oldest ones
        if (dataCache.size() > MAX_CACHE_SIZE) {
            dataCache.entrySet().stream()
                .sorted((e1, e2) -> Long.compare(e1.getValue().timestamp, e2.getValue().timestamp))
                .limit(dataCache.size() - MAX_CACHE_SIZE)
                .forEach(entry -> dataCache.remove(entry.getKey()));
        }
    }

    public CompletableFuture<PlayerData> createRequest(UUID uuid) {
        // Check cache first
        CachedPlayerData cached = dataCache.get(uuid);
        if (cached != null && !cached.isExpired()) {
            return CompletableFuture.completedFuture(cached.data);
        }

        // Create new request
        CompletableFuture<PlayerData> future = new CompletableFuture<>();
        pendingRequests.put(uuid, future);
        return future;
    }

    public void handleGetResponse(NetworkProtocol.GetPlayerDataResponse response) {
        CompletableFuture<PlayerData> future = pendingRequests.remove(response.uuid);
        if (future != null) {
            if (response.success && response.playerData != null) {
                // Cache the data
                dataCache.put(response.uuid, new CachedPlayerData(response.playerData));
                future.complete(response.playerData);
            } else {
                future.completeExceptionally(new RuntimeException(response.message));
            }
        }
    }

    public void handleSaveResponse(NetworkProtocol.SavePlayerDataResponse response) {
        if (response.success) {
            // Clear cache for this UUID to ensure fresh data on next load
            dataCache.remove(response.uuid);
            GameLogger.info("Player data saved successfully for UUID: " + response.uuid);
        } else {
            GameLogger.error("Failed to save player data for UUID: " + response.uuid + " - " + response.message);
        }
    }

    public void clearCache() {
        dataCache.clear();
    }

    public void cancelRequest(UUID uuid) {
        CompletableFuture<PlayerData> future = pendingRequests.remove(uuid);
        if (future != null && !future.isDone()) {
            future.cancel(true);
        }
    }

    public void shutdown() {
        // Cancel all pending requests
        pendingRequests.forEach((uuid, future) -> {
            if (!future.isDone()) {
                future.cancel(true);
            }
        });
        pendingRequests.clear();
        dataCache.clear();
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/network/NetworkProtocol.java
================
package io.github.pokemeetup.multiplayer.network;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import com.esotericsoftware.kryonet.FrameworkMessage;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.system.data.BlockSaveData;
import io.github.pokemeetup.system.data.ItemData;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.PokemonData;
import io.github.pokemeetup.system.gameplay.inventory.ItemEntity;
import io.github.pokemeetup.system.gameplay.overworld.WeatherSystem;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;

import java.io.Serializable;
import java.util.*;

public class NetworkProtocol {// In NetworkProtocol.java (or a new file in the same package)

    public static void registerClasses(Kryo kryo) {
        // Basic and commonly used classes
        kryo.register(Vector2.class);
        kryo.register(PlayerInfo.class);
        kryo.register(PingRequest.class);
        kryo.register(PingResponse.class);
        kryo.register(ArrayList.class);
        kryo.register(BuildingPlacement.class);
        kryo.register(CompressedChunkData.class);
        kryo.register(List.class);
        kryo.register(int[][].class); // For the tileData 2D array
        kryo.register(HashMap.class);
        kryo.register(Map.class);
        kryo.register(java.util.concurrent.ConcurrentHashMap.class);
        kryo.register(PokemonData.Stats.class);
        kryo.register(PlayerAction.class);
        kryo.register(BlockPlacement.class);
        kryo.register(BlockAction.class);

        kryo.register(WorldData.class);
        kryo.register(WorldObjectData.class);
        kryo.register(io.github.pokemeetup.system.data.WorldData.class);
        kryo.register(io.github.pokemeetup.system.data.WorldData.WorldObjectData.class);
        kryo.register(io.github.pokemeetup.system.data.WorldData.WorldConfig.class);

        // Enums
        kryo.register(NetworkObjectUpdateType.class);
        kryo.register(ChatType.class);
        kryo.register(ForceDisconnect.class);

        // Request and response classes
        kryo.register(LoginRequest.class);
        kryo.register(LoginResponse.class);
        kryo.register(RegisterRequest.class);
        kryo.register(RegisterResponse.class);
        kryo.register(ItemData.class);
        kryo.register(ItemData[].class);
        kryo.register(UUID.class);
        kryo.register(InventoryUpdate.class);
        kryo.register(ChunkData.class);
        kryo.register(BiomeType.class);
        kryo.register(PlayerInfoUpdate.class);
        // Game state and network classes
        kryo.register(PlayerPosition.class);
        kryo.register(PlayerUpdate.class);
        kryo.register(InventoryUpdate.class);
        kryo.register(PlayerJoined.class);
        kryo.register(PlayerLeft.class);
        kryo.register(WorldObjectUpdate.class);
        kryo.register(BlockSaveData.BlockData.class);
        // Register PlaceableBlock.BlockType
        kryo.register(PlaceableBlock.BlockType.class);
        kryo.register(Keepalive.class);
        // Complex data models and entities
        kryo.register(WorldState.class);
        kryo.register(PlayerState.class);
        kryo.register(ChunkUpdate.class);
        kryo.register(ChunkRequest.class);
        kryo.register(EntityUpdate.class);
        registerPokemonClasses(kryo);
        // Networked entities
        kryo.register(WorldStateUpdate.class);
        kryo.register(ConnectionResponse.class);
        kryo.register(ConnectionRequest.class);
        kryo.register(PokemonData.class);
        kryo.register(ConnectionStatus.class);
        kryo.register(Logout.class);
        kryo.register(UsernameCheckRequest.class);
        kryo.register(UsernameCheckResponse.class);
        kryo.register(BlockPlacement.class);
        kryo
            .register(io.github.pokemeetup.system.data.WorldData.class);
        kryo.register(PlayerData.class);
        kryo.register(PlayerData[].class);
        // Miscellaneous
        kryo.register(io.github.pokemeetup.system.data.WorldData.WorldConfig.class);

        kryo.register(TeamCreate.class);
        kryo.register(ItemPickup.class);
        kryo.register(ServerShutdown.class);
        kryo.register(TeleportRequest.class);
        kryo.register(TeleportResponse.class);
        kryo.register(World.WorldObjectData.class);
        kryo.register(World.ChunkData.class);
        kryo.register(ChatMessage.class);
        kryo.register(TeamInvite.class);
        kryo.register(TeamHQUpdate.class);
        kryo.register(ChunkDataFragment.class);
        kryo.register(ChunkDataComplete.class);
        kryo.register(WorldInitData.class);
        kryo.register(ServerInfoRequest.class);
        kryo.register(ServerInfoResponse.class);
        kryo.register(SavePlayerDataRequest.class);
        kryo.register(ChestUpdate.class);
        kryo.register(SavePlayerDataResponse.class);
        kryo.register(GetPlayerDataRequest.class);
        kryo.register(GetPlayerDataResponse.class);
        kryo.register(FrameworkMessage.KeepAlive.class);
        kryo.register(FrameworkMessage.Ping.class);
        kryo.register(FrameworkMessage.RegisterTCP.class);
        kryo.register(FrameworkMessage.RegisterUDP.class);
        kryo.register(ServerInfo.class);
        kryo.register(WorldObject.class);
        kryo.register(PlayerList.class);
        kryo.register(WorldObject.ObjectType.class);
        kryo.register(ItemEntity.class);
        kryo.register(ItemEntityRemove.class);
        kryo.register(ForceDisconnect.class);
        kryo.register(ForceLogout.class);
        kryo.register(Object.class);
        kryo.register(ReliableUpdate.class);
        kryo.register(ClientMessage.class);
        kryo.register(ServerResponse.class);
        kryo.register(ItemDrop.class);
        kryo.register(ConnectionValidation.class);
        kryo.register(UUID.class, new com.esotericsoftware.kryo.Serializer<UUID>() {

            @Override
            public void write(Kryo kryo, Output output, UUID uuid) {
                output.writeLong(uuid.getMostSignificantBits());
                output.writeLong(uuid.getLeastSignificantBits());
            }

            @Override
            public UUID read(Kryo kryo, Input input, Class<UUID> type) {
                return new UUID(input.readLong(), input.readLong());
            }
        });
        kryo.setReferences(false);  // Disable object references
        kryo.setRegistrationRequired(false);  // Require class registration
    }

    public static void registerPokemonClasses(Kryo kryo) {
        kryo.register(PokemonUpdate.class);
        kryo.register(PokemonSpawn.class);
        kryo.register(PokemonDespawn.class);
        kryo.register(PokemonSpawnRequest.class);
        kryo.register(PartyUpdate.class);
        kryo.register(WildPokemonSpawn.class);
        kryo.register(WildPokemonDespawn.class);
        kryo.register(PokemonData.class);
        kryo.register(Pokemon.Stats.class);
        kryo.register(PokemonBatchUpdate.class);
        kryo.register(Pokemon.PokemonType.class);
        kryo.register(ArrayList.class);
        kryo.register(int[].class);
    }

    public enum ActionType {
        CHOP_START,
        CHOP_STOP,
        CHEST_OPEN,
        CHEST_CLOSE,
        PUNCH_START,
        PUNCH_STOP,
        PICKUP_ITEM,
        CHOP_COMPLETE,
        PUNCH_COMPLETE
    }

    public enum BlockAction {
        PLACE,
        REMOVE
    }

    public enum ChatType {
        NORMAL,
        SYSTEM,
        WHISPER,
        TEAM
    }

    public enum NetworkObjectUpdateType {
        ADD,
        UPDATE,
        REMOVE

    }

    public static class BuildingPlacement implements Serializable {
        public String username;
        public int startX;
        public int startY;
        public int width;
        public int height;
        public String[][] blockTypeIds;  // For each block position, the block type id (e.g. "wooden_planks")
        public boolean[][] flippedFlags; // For each block position, whether it is flipped
        public long timestamp;
    }

    public static class ChunkData {
        public int chunkX;
        public int chunkY;
        public BiomeType primaryBiomeType;
        public BiomeType secondaryBiomeType;   // Can be null
        public float biomeTransitionFactor;    // 0.0 to 1.0
        public int[][] tileData;
        public BiomeManager.BiomeData biomeData;
        public List<BlockSaveData.BlockData> blockData;
        public List<HashMap<String, Object>> worldObjects = new ArrayList<>();

        public long generationSeed;
        public long timestamp;
    }

    public static class CompressedChunkData {
        public int chunkX;
        public int chunkY;
        public BiomeType primaryBiomeType;
        public BiomeType secondaryBiomeType;
        public float biomeTransitionFactor;
        public byte[] data;
        public int originalLength;
        public long generationSeed;
    }

    public static class ItemPickup {
        public UUID entityId;
        public String username;
        public long timestamp;
    }

    public static class ItemEntitySpawn {
        public UUID entityId;
        public ItemData itemData;
        public float x;
        public float y;
    }

    public static class ItemEntityRemove {
        public UUID entityId;
    }

    public static class WorldObjectData {
        public float x;
        public float y;
        public WorldObject.ObjectType type;
    }

    // In NetworkProtocol.java, add:
    public static class WorldInitData {
        public long seed;
        public double worldTimeInMinutes;
        public float dayLength;
    }

    public static class ChunkRequest {
        public int chunkX;
        public int chunkY;
        public long timestamp;
    }

    public static class ItemDrop {
        public ItemData itemData;
        public float x;
        public float y;
        public String username;
        public long timestamp;
    }

    public static class ChunkDataFragment {
        public int chunkX;
        public int chunkY;
        public int startX;
        public int startY;
        public int fragmentSize;
        public int[][] tileData;
        public BiomeType biomeType;
        public int fragmentIndex;
        public int totalFragments;
    }

    public static class ChunkDataComplete {
        public int chunkX;
        public int chunkY;
    }

    public static
    class LogoutResponse {
        public boolean success;
        public String message;
    }

    public static class ConnectionValidation {
        public String username;
        public long timestamp;
        public String sessionId; // Add a unique session ID for each connection
    }

    public static class ClientMessage {
        public static final int TYPE_LOGOUT = 1;

        public int type;
        public String username;
        public long timestamp;
        public Map<String, Object> data;
    }

    public static class ServerResponse {
        public boolean success;
        public String message;
        public long timestamp;
        public Map<String, Object> data;
    }

    public static class Logout {
        public String username;
        public long timestamp;
    }

    public static class ForceLogout {
        public String reason;
        public boolean serverShutdown;
    }

    public static class ServerInfo {
        public String name;
        public String motd; // Message of the day
        public String iconBase64; // Base64 encoded server icon
        public int playerCount;
        public int maxPlayers;
        public long ping;
        public String version;
    }

    public static class ServerInfoRequest {
        public long timestamp;
    }

    public static class ServerInfoResponse {
        public ServerInfo serverInfo;
        public long timestamp;
    }

    public static class ConnectionResponse {
        public boolean success;
        public String message;
        public String username;
        public String token;
    }

    public static class ConnectionRequest {
        public String version;
        public long timestamp;
    }

    public static class ConnectionStatus {
        public int connectionId;
        public String status;
        public long timestamp;
    }

    public static class PokemonUpdate implements Serializable {
        public UUID uuid;
        public float x;
        public float y;
        public String direction;
        public boolean isMoving;
        public boolean isAttacking;
        public PokemonData data;
        public long timestamp;
        public String status;  // e.g., "NORMAL", "FAINTED", "SLEEPING"
        public Map<String, Object> extraData = new HashMap<>();  // For extensibility
        public int level;
        public float currentHp;
    }

    public static class PokemonSpawnRequest implements Serializable {
        public UUID uuid;
        public long timestamp = System.currentTimeMillis();
        public String requestingPlayer; // Username of requesting client
    }

    public static class ChunkUpdate {
        public Vector2 position;
        public World.ChunkData chunkData;
        public List<World.WorldObjectData> objects;
    }

    public static class LoginResponse {
        public boolean success;
        public double worldTimeInMinutes;
        public float dayLength;
        public long seed;               // World seed
        public String message;
        public String username;
        public int x;
        public int y;
        public String worldName;
        public long timestamp;
        public long worldSeed;
        public PlayerData playerData;
        public io.github.pokemeetup.system.data.WorldData worldData;  // Add serializable world data
    }

    public static class WorldData implements Serializable {
        // Add fields that need to be synced to clients
        public long seed;
        public String name;
        public Map<String, Object> worldProperties;
        // Add other necessary world data
    }

    public static class UsernameCheckRequest {
        public String username;
        public long timestamp;
    }

    public static class UsernameCheckResponse {
        public String username;
        public boolean available;
        public String message;
    }

    public static class ServerShutdown {
        public String reason;
    }

    public static class PlayerJoined {
        public String username;
        public float x;
        public float y;
        public String direction = "down";
        public boolean isMoving = false;
        public ItemData[] inventoryItems;
        public long timestamp;
        public ItemData[] hotbarItems;
    }

    public static class PlayerLeft {
        public String username;
        public long timestamp;
    }

    public static class ReliableUpdate {
        public int sequence;
        public long timestamp;
        public NetworkProtocol.PlayerUpdate playerUpdate;
    }

    public static class ForceDisconnect {
        public String reason;
    }

    public static class Keepalive {
        public long timestamp;
    }

    public static class PlayerUpdate {
        public String username;
        public float x;
        public float y;public String characterType; // "boy", "girl", etc.

        public String direction;
        public List<PokemonData> partyPokemon;
        public boolean isMoving;
        // Add velocity for smoother movement
        public float velocityX;
        public float velocityY;
        public boolean wantsToRun;
        public ItemData[] inventoryItems;
        public ItemData[] hotbarItems;
        public long timestamp = System.currentTimeMillis();
    }

    // Add validation methods to request classes
    public static class LoginRequest {
        public String username;
        public String password;
        public long timestamp;
        public io.github.pokemeetup.system.data.WorldData worldData;

        @Override
        public String toString() {
            return "LoginRequest{" +
                "username='" + username + '\'' +
                ", hasPassword=" + (password != null && !password.isEmpty()) +
                ", timestamp=" + timestamp +
                '}';
        }
    }

    public static class RegisterRequest {
        public String username;
        public String password;
    }

    public static class InventoryUpdate {
        public String username;
        public ItemData[] inventoryItems;
    }

    public static class PlayerPosition {
        public HashMap<String, PlayerUpdate> players = new HashMap<>();
    }

    public static class ChatMessage {
        public String sender;
        public String content;
        public long timestamp;
        public ChatType type;
        public String recipient; // Add this field for private messages
    }

    public static class WeatherUpdate implements Serializable {
        public String weatherType;  // e.g., "RAIN", "CLEAR", "SNOW"
        public float intensity;     // 0.0 to 1.0
        public long duration;       // in milliseconds
        public long timestamp;
    }

    public static class ChestUpdate implements Serializable {
        public String username;       // The player making the update
        public UUID chestId;           // (Assuming your ChestData has an integer id)
        public List<ItemData> items;  // The new list of items in the chest
        public long timestamp;
    }

    public static class SavePlayerDataRequest {
        public UUID uuid;
        public PlayerData playerData;
        public long timestamp;
    }

    public static class SavePlayerDataResponse {
        public UUID uuid;
        public boolean success;
        public String message;
        public long timestamp;
    }
    // Update the PlayerUpdate class in NetworkProtocol.java

    public static class GetPlayerDataRequest {
        public UUID uuid;
        public long timestamp;
    }

    public static class GetPlayerDataResponse {
        public UUID uuid;
        public PlayerData playerData;
        public boolean success;
        public String message;
        public long timestamp;
    }

    public static class TimeSync implements Serializable {
        public double worldTimeInMinutes;
        public long playedTime;
        public float dayLength;
        public long timestamp;
    }


    public static class WorldStateUpdate {
        public long seed;                    // world generation seed
        public double worldTimeInMinutes;    // current world time in minutes
        public float dayLength;              // length of a day in minutes (or seconds, as you require)

        // Optionally include weather parameters:
        public WeatherSystem.WeatherType currentWeather;
        public float intensity;
        public float accumulation;

        public long timestamp;
    }

    public static class TeamCreate {
        public String name;
        public String tag;
        public String leader;
        public long timestamp = System.currentTimeMillis();
    }

    public static class TeamInvite {
        public String teamName;
        public String inviter;
        public String invitee;
        public long timestamp = System.currentTimeMillis();
    }

    public static class TeamHQUpdate {
        public String teamName;
        public int x;
        public int y;
        public long timestamp = System.currentTimeMillis();
    }

    public static class PokemonSpawn {
        public UUID uuid;
        public String name;
        public int level;
        public float x;
        public float y;
        public PokemonData data;
        public long timestamp;
    }

    public static class PokemonDespawn {
        public UUID uuid;
        public long timestamp;
    }

    public static class PartyUpdate {
        public String username;
        public List<PokemonData> party;
        public long timestamp;
    }

    // Add to NetworkProtocol.java
    public static class TeleportRequest {
        public TeleportType type;
        public String player;
        public String target;  // For player teleports
        public String homeName;  // For home teleports
        public long timestamp;

        public enum TeleportType {
            SPAWN, HOME, PLAYER
        }
    }

    public static class WildPokemonSpawn {
        public UUID uuid;
        public float x;
        public float y;
        public PokemonData data;
        public long timestamp;
    }

    public static class WildPokemonDespawn {
        public UUID uuid;
        public long timestamp;
    }

    public static class RegisterResponse {
        public boolean success;
        public String message;
        public int x;
        public int y;
        public long worldSeed;  // Add this field
        public String username; // Added username field
    }

    public static class WorldObjectUpdate {
        public String objectId;
        public NetworkObjectUpdateType type;
        public float x;
        public float y;
        public String textureName;
        public Map<String, Object> data;
    }

    public static class PokemonBatchUpdate {
        // A list of update objects, each containing the state for one wild Pokémon.
        public List<PokemonUpdate> updates;
    }
    // World State Classes
    public static class WorldState {
        public long timestamp;
        public List<EntityUpdate> entities;
        public List<PlayerState> players;
    }

    public static class PlayerState {
        public String username;
        public float x;
        public float y;
        public String direction;
        public boolean isMoving;
        public List<ItemData> inventory;
    }

    public static class EntityUpdate {
        public UUID entityId;
        public float x;
        public float y;
        public Vector2 velocity;
        public String entityType;
    }

    public static class PlayerAction {
        public String playerId;
        public ActionType actionType;
        public Vector2 targetPosition;
        public String objectId;
        public int tileX;
        public int tileY;
        public String direction;
    }

    public static class BlockPlacement {
        public String username;
        public String blockTypeId;
        public int tileX;
        public int tileY;
        public BlockAction action; // PLACE or REMOVE
    }

    public static class TeleportResponse {
        public String from;
        public String to;
        public boolean accepted;
        public long timestamp;
    }

    public static class PingRequest {
        public long timestamp;  // when the ping was sent
    }

    public static class PingResponse {
        public long timestamp;  // echoed timestamp
    }

    // A simple container for one player’s info:
    public static class PlayerInfo {
        public String username;
        public int ping; // in milliseconds
    }

    // When a client wants to update its own info…
    public static class PlayerInfoUpdate {
        public String username;
        public int ping;
    }

    // When the server broadcasts the full list…
    public static class PlayerList {
        public List<PlayerInfo> players;
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/OtherPlayer.java
================
package io.github.pokemeetup.multiplayer;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.*;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.FootstepEffect;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.Positionable;
import io.github.pokemeetup.system.gameplay.PlayerAnimations;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.concurrent.atomic.AtomicBoolean;

public class OtherPlayer implements Positionable {

    @Override
    public boolean wasOnWater() {
        return wasOnWater;
    }

    @Override
    public void setWasOnWater(boolean onWater) {
        this.wasOnWater = onWater;
    }

    @Override
    public float getWaterSoundTimer() {
        return waterSoundTimer;
    }

    @Override
    public void setWaterSoundTimer(float timer) {
        this.waterSoundTimer = timer;
    }

    @Override
    public void updateWaterSoundTimer(float delta) {
        if (this.waterSoundTimer > 0) {
            this.waterSoundTimer -= delta;
        }
    }
    private boolean wasOnWater = false;
    private float waterSoundTimer = 0f;
    private static final float ANIMATION_SPEED_MULTIPLIER = 0.75f;
    // Basic player data.
    private final String username;
    private final Inventory inventory;
    private PlayerAnimations animations;
    private final AtomicBoolean isMoving;
    // Positioning and interpolation.
    private final Object positionLock = new Object();
    private final Vector2 startPosition = new Vector2();
    private final Vector2 targetPosition = new Vector2();
    private boolean wantsToRun;
    private Vector2 position;
    private float interpolationProgress; // From 0 to 1.
    private float stateTime; // Used both for movement and action animations.
    private String direction;
    // For footstep effect (tracking tile changes).
    private int prevTileX;
    private int prevTileY;
    // For rendering text.
    private BitmapFont font;
    private int ping;
    private float animationTime = 0f;

    public OtherPlayer(String username, float x, float y) {
        this.username = (username != null && !username.isEmpty()) ? username : "Unknown";
        this.position = new Vector2(x, y);
        // Initialize start and target positions as the current position.
        this.startPosition.set(x, y);
        this.targetPosition.set(x, y);
        this.inventory = new Inventory();
        this.direction = "down";
        this.isMoving = new AtomicBoolean(false);
        this.wantsToRun = false;
        this.stateTime = 0f;
        this.interpolationProgress = 0f;
        // Default animations (for example, “boy” animations)
        this.animations = new PlayerAnimations();
        GameLogger.info("Created OtherPlayer: " + this.username + " at (" + x + ", " + y + ")");
        prevTileX = pixelToTileX(position.x);
        prevTileY = pixelToTileY(position.y);
    }

    /**
     * Update from a network update. When a new target position is received,
     * if it differs from the current target, we reset the interpolation.
     */
    public void updateFromNetwork(NetworkProtocol.PlayerUpdate update) {
        synchronized (this) {
            if (update == null) return;

            // If the target position changes, reset the interpolation.
            if (!targetPosition.epsilonEquals(update.x, update.y, 0.1f)) {
                synchronized (positionLock) {
                    startPosition.set(position);
                    interpolationProgress = 0f;
                }
            }
            targetPosition.set(update.x, update.y);
            this.direction = update.direction;
            this.isMoving.set(update.isMoving);
            this.wantsToRun = update.wantsToRun;

            // *** NEW: Check for character type update ***
            if (update.characterType != null) {
                // Suppose our PlayerAnimations class exposes a getter for its character type:
                if (!update.characterType.equalsIgnoreCase(animations.getCharacterType())) {
                    // Reinitialize animations with the new character type.
                    animations.dispose();
                    // Now create a new instance using the network-sent character type.
                    // (This requires that your PlayerAnimations(String) constructor is available.)
                    // Also, you might want to store the current character type in a field.
                    this.animations = new PlayerAnimations(update.characterType);
                }
            }
            // (Optionally, update a network–provided stateTime if available.)
        }
    }


    /**
     * The smoothstep function to ease the interpolation.
     */
    private float smoothstep(float x) {
        x = MathUtils.clamp(x, 0f, 1f);
        return x * x * (3 - 2 * x);
    }

    // Helper methods to convert between tile and pixel coordinates.
    private float tileToPixelX(int tileX) {
        return tileX * World.TILE_SIZE + (World.TILE_SIZE / 2f);
    }

    private float tileToPixelY(int tileY) {
        return tileY * World.TILE_SIZE;
    }

    private int pixelToTileX(float pixelX) {
        return (int) Math.floor(pixelX / World.TILE_SIZE);
    }

    private int pixelToTileY(float pixelY) {
        return (int) Math.floor(pixelY / World.TILE_SIZE);
    }

    /**
     * Update method called each frame.
     * This method interpolates the remote player’s position toward the latest network target.
     * It also updates the internal stateTime even when the player is performing an action
     * (such as chopping or punching) so that the proper frame advances.
     */
    public void update(float deltaTime) {
        float clampedDelta = Math.min(deltaTime, 1f / 60f);
        updateWaterSoundTimer(deltaTime);
        synchronized (positionLock) {
            float moveDuration = wantsToRun
                ? PlayerAnimations.SLOW_RUN_ANIMATION_DURATION
                : PlayerAnimations.SLOW_WALK_ANIMATION_DURATION;

            // If the position is not yet at the target, interpolate movement.
            if (!position.epsilonEquals(targetPosition, 0.1f)) {
                interpolationProgress = Math.min(1f, interpolationProgress + deltaTime / moveDuration);
                float smoothProgress = smoothstep(interpolationProgress);
                position.x = MathUtils.lerp(startPosition.x, targetPosition.x, smoothProgress);
                position.y = MathUtils.lerp(startPosition.y, targetPosition.y, smoothProgress);
                isMoving.set(true);

                // Update stateTime for actions (if any)
                stateTime += clampedDelta;
                // **Update animationTime for movement frame selection**
                animationTime += clampedDelta * ANIMATION_SPEED_MULTIPLIER;

                // If we have reached (or nearly reached) the target...
                if (interpolationProgress >= 1f) {
                    position.set(targetPosition);
                    interpolationProgress = 0f;
                    // Reset both timers when movement completes.
                    stateTime = 0f;
                    animationTime = 0f;
                    startPosition.set(position);
                    isMoving.set(false);
                    // --- Extrapolation for continuous movement (if applicable) ---
                    int currentTileX = pixelToTileX(position.x);
                    int currentTileY = pixelToTileY(position.y);
                    int nextTileX = currentTileX;
                    int nextTileY = currentTileY;
                    switch (direction.toLowerCase()) {
                        case "up":
                            nextTileY++;
                            break;
                        case "down":
                            nextTileY--;
                            break;
                        case "left":
                            nextTileX--;
                            break;
                        case "right":
                            nextTileX++;
                            break;
                    }
                    if (GameContext.get().getWorld().isPassable(nextTileX, nextTileY)) {
                        startPosition.set(position);
                        targetPosition.set(tileToPixelX(nextTileX), tileToPixelY(nextTileY));
                        interpolationProgress = 0f;
                        isMoving.set(true);
                    }
                }
            } else {
                // Not moving: if currently in an action (chopping or punching), still update stateTime.
                if (animations.isChopping() || animations.isPunching()) {
                    stateTime += clampedDelta;
                }
                isMoving.set(false);
                interpolationProgress = 0f;
                animationTime = 0f;  // Reset animationTime when not moving.
                startPosition.set(position);
            }

            // (Optional) Spawn footstep effects when the tile changes.
            int currentTileX = pixelToTileX(position.x);
            int currentTileY = pixelToTileY(position.y);
            if (currentTileX != prevTileX || currentTileY != prevTileY) {
                int tileType = GameContext.get().getWorld().getTileTypeAt(currentTileX, currentTileY);
                if (tileType == TileType.SAND ||
                    tileType == TileType.SNOW ||
                    tileType == TileType.DESERT_GRASS ||
                    tileType == TileType.DESERT_SAND ||
                    tileType == TileType.SNOW_2 ||
                    tileType == TileType.SNOW_3 ||
                    tileType == TileType.SNOW_TALL_GRASS) {
                    GameContext.get().getWorld().getFootstepEffectManager()
                        .addEffect(new FootstepEffect(new Vector2(position.x, position.y), direction, 1.0f));
                }
                prevTileX = currentTileX;
                prevTileY = currentTileY;
            }
        }
    }

    /**
     * Render the OtherPlayer.
     * Now the method checks if an action is active (chopping or punching) and uses the appropriate frame.
     */
    public void render(SpriteBatch batch) {
        TextureRegion currentFrame;
        synchronized (positionLock) {
            // First priority: if chopping, use the chopping animation.
            if (animations.isChopping()) {
                currentFrame = animations.getCurrentFrame(direction, false, false, stateTime);
            }
            // Second priority: if punching, use the punching animation.
            else if (animations.isPunching()) {
                currentFrame = animations.getCurrentFrame(direction, false, false, stateTime);
            }
            // Third: if moving, use the movement animation based on animationTime.
            else if (isMoving.get()) {
                currentFrame = animations.getCurrentFrame(direction, true, isWantsToRun(), animationTime);
            }
            // Otherwise, use the standing frame.
            else {
                currentFrame = animations.getStandingFrame(direction);
            }
            if (currentFrame == null) {
                GameLogger.error("OtherPlayer " + username + " has null currentFrame");
                return;
            }
            float regionW = currentFrame.getRegionWidth();
            float regionH = currentFrame.getRegionHeight();
            float drawX = position.x - (regionW / 2f);
            float drawY = position.y; // bottom-center anchoring
            batch.draw(currentFrame, drawX, drawY, regionW, regionH);
            renderUsername(batch, drawX, regionW, drawY, regionH);
        }
    }


    private void renderUsername(SpriteBatch batch, float drawX, float regionW, float drawY, float regionH) {
        if (username == null || username.isEmpty()) return;
        ensureFontLoaded();
        GlyphLayout layout = new GlyphLayout(font, username);
        float textWidth = layout.width;
        float nameX = drawX + (regionW - textWidth) / 2f;
        float nameY = drawY + regionH + 15;
        font.draw(batch, username, nameX, nameY);
    }

    private void ensureFontLoaded() {
        if (font == null) {
            try {
                font = new BitmapFont(Gdx.files.internal("Skins/default.fnt"));
                font.getData().setScale(0.8f);
                GameLogger.info("Loaded font for OtherPlayer: " + username);
            } catch (Exception e) {
                GameLogger.error("Failed to load font for OtherPlayer: " + username + " - " + e.getMessage());
                font = new BitmapFont();
            }
        }
    }

    /**
     * Called when an action message is received from the network.
     * These calls trigger the appropriate animations.
     */
    public void updateAction(NetworkProtocol.PlayerAction action) {
        switch (action.actionType) {
            case CHOP_START:
                animations.startChopping();
                break;
            case CHOP_STOP:
                animations.stopChopping();
                stateTime = 0f;
                break;
            case PUNCH_START:
                animations.startPunching();
                break;
            case PUNCH_STOP:
                animations.stopPunching();
                stateTime = 0f;
                break;
            default:
                GameLogger.error("Unhandled action type: " + action.actionType);
                break;
        }
    }

    // Synchronized getters and setters.
    public Vector2 getPosition() {
        synchronized (positionLock) {
            return new Vector2(position);
        }
    }

    public void setPosition(Vector2 position) {
        synchronized (positionLock) {
            this.position = position;
            this.startPosition.set(position);
            this.targetPosition.set(position);
        }
    }

    public Inventory getInventory() {
        return inventory;
    }

    public String getUsername() {
        return username;
    }

    public String getDirection() {
        synchronized (positionLock) {
            return direction;
        }
    }

    public boolean isMoving() {
        return isMoving.get();
    }

    @Override
    public void setCharacterType(String characterType) {

    }

    public boolean isWantsToRun() {
        return wantsToRun;
    }

    public void setWantsToRun(boolean wantsToRun) {
        this.wantsToRun = wantsToRun;
    }

    public float getX() {
        synchronized (positionLock) {
            return position.x;
        }
    }

    public void setX(float x) {
        synchronized (positionLock) {
            this.position.x = x;
        }
    }

    public float getY() {
        synchronized (positionLock) {
            return position.y;
        }
    }

    public void setY(float y) {
        synchronized (positionLock) {
            this.position.y = y;
        }
    }

    public void setPing(int ping) {
        this.ping = ping;
    }

    public void dispose() {
        animations.dispose();
        GameLogger.info("Disposed animations for OtherPlayer: " + username);
        if (font != null) {
            font.dispose();
            font = null;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/PlayerManager.java
================
package io.github.pokemeetup.multiplayer;

import io.github.pokemeetup.multiplayer.server.ServerStorageSystem;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.utils.GameLogger;

import java.util.Collection;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class PlayerManager {
    private final Map<String, ServerPlayer> onlinePlayers = new ConcurrentHashMap<>();
    private final Map<UUID, String> uuidToUsername = new ConcurrentHashMap<>();
    private final ServerStorageSystem storage;

    public PlayerManager(ServerStorageSystem storage) {
        this.storage = storage;
        GameLogger.info("PlayerManager initialized with ServerStorageSystem");
    }


    public ServerPlayer getPlayer(String username) {
        return onlinePlayers.get(username);
    }


    public Collection<ServerPlayer> getOnlinePlayers() {
        return onlinePlayers.values();
    }

    public void removePlayer(String username) {
        ServerPlayer player = onlinePlayers.get(username);
        if (player != null) {
            try {
                UUID playerUUID = player.getUUID();
                // Get fresh copy of data
                PlayerData finalState = player.getData();

                // Save player data before removing
                storage.getPlayerDataManager().savePlayerData(playerUUID, finalState);
                storage.getPlayerDataManager().flush(); // Force immediate save

                // Remove after successful save
                onlinePlayers.remove(username);
                uuidToUsername.remove(playerUUID);

                GameLogger.info("Saved and removed player: " + username + " (UUID: " + playerUUID + ")");
            } catch (Exception e) {
                GameLogger.error("Error saving player data for " + username + ": " + e.getMessage());
            }
        }
    }



    public void dispose() {
        GameLogger.info("Starting PlayerManager disposal...");

        // Save each player's data
        for (Map.Entry<String, ServerPlayer> entry : onlinePlayers.entrySet()) {
            try {
                String username = entry.getKey();
                ServerPlayer player = entry.getValue();
                UUID playerUUID = player.getUUID();

                // Get fresh copy of data
                PlayerData finalState = player.getData();

                // Save with immediate flush
                storage.getPlayerDataManager().savePlayerData(playerUUID, finalState);
                storage.getPlayerDataManager().flush();

                GameLogger.info("Saved final state for: " + username + " (UUID: " + playerUUID + ")");
            } catch (Exception e) {
                GameLogger.error("Error saving player during dispose: " + e.getMessage());
            }
        }

        // Force final storage flush
        storage.flushPlayerData();

        // Clear collections
        onlinePlayers.clear();
        uuidToUsername.clear();

        GameLogger.info("PlayerManager disposal complete");
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/server/config/ServerConfigManager.java
================
package io.github.pokemeetup.multiplayer.server.config;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonWriter;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.JsonConfig;


public class ServerConfigManager {
    private static final String CONFIG_DIR = "configs";
    private static final String CONFIG_FILE = "servers.json";
    private static ServerConfigManager instance;
    private Array<ServerConnectionConfig> servers;

    public static ServerConnectionConfig getDefaultServerConfig() {
        return new ServerConnectionConfig(
            "localhost",
            54555,
            54556,
            "Default Server",
            true,
            100
        );
    }
    private ServerConfigManager() {
        servers = new Array<>();
        ensureConfigDirectory();
        loadServers();
        if (servers.isEmpty()) {
            addDefaultServer();
            saveServers();
        }
    }

    public static synchronized ServerConfigManager getInstance() {
        if (instance == null) {
            instance = new ServerConfigManager();
        }
        return instance;
    }


    public Array<ServerConnectionConfig> getServers() {
        return servers;
    }

    public void addServer(ServerConnectionConfig config) {
        if (!servers.contains(config, false)) {
            servers.add(config);
            saveServers();
            GameLogger.info("Added server: " + config.getServerName());
        }
    }

    private void ensureConfigDirectory() {
        try {
            FileHandle dir = Gdx.files.local(CONFIG_DIR);
            if (!dir.exists()) {
                dir.mkdirs();
            }
        } catch (Exception e) {
            GameLogger.info("Failed to create config directory: " + e.getMessage());
        }
    }

    private void loadServers() {
        try {
            FileHandle file = Gdx.files.local(CONFIG_DIR + "/" + CONFIG_FILE);
            if (file.exists()) {
                Json json = new Json();
                String fileContent = file.readString();
                GameLogger.info("Loading servers from: " + file.path());
                GameLogger.info("File content: " + fileContent);

                @SuppressWarnings("unchecked")
                Array<ServerConnectionConfig> loadedServers = json.fromJson(Array.class,
                    ServerConnectionConfig.class, fileContent);

                if (loadedServers != null && loadedServers.size > 0) {
                    servers = loadedServers;
                    GameLogger.info("Loaded " + servers.size + " servers");
                }
            }
        } catch (Exception e) {
            GameLogger.info("Error loading servers: " + e.getMessage());
            e.printStackTrace();
        }
    }


    private void addDefaultServer() {
        servers.add(new ServerConnectionConfig(
            "170.64.156.89",
            54555,
            54556,
            "Local Server",
            true,
            100
        ));
    }



    public void removeServer(ServerConnectionConfig server) {
        if (servers.removeValue(server, false)) {
            saveServers();
            GameLogger.info("Removed server: " + server.getServerName());
        }
    }

    private void saveServers() {
        try {
            FileHandle file = Gdx.files.local(CONFIG_DIR + "/" + CONFIG_FILE);

            Json json = JsonConfig.getInstance();
            json.setOutputType(JsonWriter.OutputType.json);

            // Create parent directories if they don't exist
            file.parent().mkdirs();

            String jsonStr = json.prettyPrint(servers);
            file.writeString(jsonStr, false);
            GameLogger.info("Saved " + servers.size + " servers to: " + file.path());
            GameLogger.info("Content: " + jsonStr);
        } catch (Exception e) {
            GameLogger.info("Error saving servers: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/server/config/ServerConnectionConfig.java
================
package io.github.pokemeetup.multiplayer.server.config;

import java.io.IOException;

public class ServerConnectionConfig {
    private static ServerConnectionConfig instance;
    private String serverIP;
    private int tcpPort;
    private int maxPlayers;
    private String iconPath;
    private String motd;
    private String version;
    private String dataDirectory;

    public void setIcon(String path) {
        this.iconPath = path;
    }

    public void setMotd(String motd) {
        this.motd = motd;
    }

    public String getIconPath() {
        return iconPath;
    }

    public void setIconPath(String iconPath) {
        this.iconPath = iconPath;
    }

    public String getMotd() {
        return motd;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    private int udpPort;
    private String serverName;
    private boolean isDefault;

    public ServerConnectionConfig(String serverIP, int tcpPort, int udpPort, String serverName, boolean isDefault, int maxPlayers) {
        this.serverIP = serverIP;
        this.tcpPort = tcpPort;
        this.udpPort = udpPort;
        this.maxPlayers = maxPlayers;
        this.serverName = serverName;
        this.isDefault = isDefault;
        setDataDirectory("worlds");
    }

    public ServerConnectionConfig() {
        setDataDirectory("worlds");
    }

    public static ServerConnectionConfig getInstance() {
        if (instance == null) {
            synchronized (ServerConnectionConfig.class) {
                if (instance == null) {
                    instance = new ServerConnectionConfig(
                        "170.64.156.89",
                        54555,
                        54556,
                        "Default Server",
                        false,
                        100
                    );
                }
            }
        }


        return instance;
    }

    private static void validateServerConnection(ServerConnectionConfig config) throws IOException {
        // Check if server is running
        try (java.net.Socket socket = new java.net.Socket()) {
            // Set a short timeout
            socket.connect(
                new java.net.InetSocketAddress(config.getServerIP(), config.getTcpPort()),
                2000
            );
        } catch (IOException e) {
            throw new IOException("Cannot connect to server at " +
                config.getServerIP() + ":" + config.getTcpPort() +
                " - " + e.getMessage());
        }
    }

    public void validate() {
        if (serverIP == null || serverIP.isEmpty()) {
            throw new IllegalArgumentException("Server IP cannot be empty");
        }
        if (tcpPort <= 0 || tcpPort > 65535) {
            throw new IllegalArgumentException("Invalid TCP port: " + tcpPort);
        }
        if (udpPort <= 0 || udpPort > 65535) {
            throw new IllegalArgumentException("Invalid UDP port: " + udpPort);
        }
        if (serverName == null || serverName.isEmpty()) {
            throw new IllegalArgumentException("Server name cannot be empty");
        }
        if (maxPlayers <= 0) {
            throw new IllegalArgumentException("Max players must be greater than 0");
        }
    }

    public static synchronized void setInstance(ServerConnectionConfig config) {
        instance = config;
    }

    public static ServerConnectionConfig getDefault() {
        return new ServerConnectionConfig("localhost", 55555, 55556, "Local Server", true, 100);
    }


    public int getMaxPlayers() {
        return maxPlayers;
    }

    public void setMaxPlayers(int maxPlayers) {
        this.maxPlayers = maxPlayers;
    }

    public String getDataDirectory() {
        return dataDirectory;
    }

    public void setDataDirectory(String dataDirectory) {
        this.dataDirectory = dataDirectory;
    }

    public String getServerIP() {
        return serverIP;
    }

    public void setServerIP(String serverIP) {
        this.serverIP = serverIP;
    }

    public int getTcpPort() {
        return tcpPort;
    }


    public void setTcpPort(int tcpPort) {
        this.tcpPort = tcpPort;
    }

    public int getUdpPort() {
        return udpPort;
    }


    public void setUdpPort(int udpPort) {
        this.udpPort = udpPort;
    }

    public String getServerName() {
        return serverName;
    }


    public void setServerName(String serverName) {
        this.serverName = serverName;
    }

    public boolean isDefault() {
        return isDefault;
    }

    public void setDefault(boolean aDefault) {
        isDefault = aDefault;
    }


    @Override
    public String toString() {
        return serverName + " (" + serverIP + ":" + tcpPort + ")";
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/server/events/BaseServerEvent.java
================
package io.github.pokemeetup.multiplayer.server.events;

public abstract class BaseServerEvent implements ServerEvent {
    private final long timestamp;

    protected BaseServerEvent() {
        this.timestamp = System.currentTimeMillis();
    }

    @Override
    public long getTimestamp() {
        return timestamp;
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/server/events/blocks/BlockPlaceEvent.java
================
package io.github.pokemeetup.multiplayer.server.events.blocks;

import io.github.pokemeetup.multiplayer.server.events.BaseServerEvent;

public class BlockPlaceEvent extends BaseServerEvent {
    private final String username;
    private final int tileX;
    private final int tileY;
    private final String blockTypeId;


    public BlockPlaceEvent(String username, int tileX, int tileY, String blockTypeId) {
        super();
        this.username = username;
        this.tileX = tileX;
        this.tileY = tileY;
        this.blockTypeId = blockTypeId;
    }

    public String getUsername() {
        return username;
    }

    public int getTileX() {
        return tileX;
    }

    public int getTileY() {
        return tileY;
    }

    public String getBlockTypeId() {
        return blockTypeId;
    }

    @Override
    public String getEventName() {
        return "";
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/server/events/EventListener.java
================
package io.github.pokemeetup.multiplayer.server.events;

public interface EventListener<T extends ServerEvent> {
    void onEvent(T event);
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/server/events/EventManager.java
================
package io.github.pokemeetup.multiplayer.server.events;

import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.*;


    public class EventManager {
        private final Map<Class<? extends ServerEvent>, List<EventListener<?>>> listeners;
        private final ExecutorService eventExecutor;
        private volatile boolean isShuttingDown = false;

        public EventManager() {
            this.listeners = new ConcurrentHashMap<>();
            this.eventExecutor = Executors.newFixedThreadPool(2);
        }



        public void fireEvent(ServerEvent event) {
            if (isShuttingDown) {
                GameLogger.info("Dropping event during shutdown: " + event.getEventName());
                return;
            }

            Class<? extends ServerEvent> eventClass = event.getClass();
            List<EventListener<?>> eventListeners = listeners.get(eventClass);

            if (eventListeners != null) {
                eventExecutor.submit(() -> {
                    for (EventListener<?> listener : eventListeners) {
                        try {
                            @SuppressWarnings("unchecked")
                            EventListener<ServerEvent> typedListener = (EventListener<ServerEvent>) listener;
                            typedListener.onEvent(event);
                        } catch (Exception e) {
                            GameLogger.info("Error handling event " + event.getEventName() + ": " + e.getMessage());
                            e.printStackTrace();
                        }
                    }
                });
            }
        }


    public void shutdown() {
        isShuttingDown = true;

        // Stop accepting new events
        eventExecutor.shutdown();

        try {
            // Wait for existing events to complete
            if (!eventExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                // Force shutdown if events don't complete in time
                List<Runnable> pendingEvents = eventExecutor.shutdownNow();
                GameLogger.info("Force-terminated " + pendingEvents.size() + " pending events");
            }
        } catch (InterruptedException e) {
            eventExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        } finally {
            // Clear all listeners
            listeners.clear();
        }
    }
    public <T extends ServerEvent> void registerListener(Class<T> eventClass, EventListener<T> listener) {
        listeners.computeIfAbsent(eventClass, k -> new ArrayList<>()).add(listener);
    }


}

================
File: src/main/java/io/github/pokemeetup/multiplayer/server/events/player/PlayerJoinEvent.java
================
package io.github.pokemeetup.multiplayer.server.events.player;

import io.github.pokemeetup.multiplayer.server.events.BaseServerEvent;
import io.github.pokemeetup.system.data.PlayerData;

public class PlayerJoinEvent extends BaseServerEvent {
    private final String username;
    private PlayerData playerData;

    public PlayerJoinEvent(String username, PlayerData playerData) {
        super();
        this.playerData = playerData;
        this.username = username;
    }

    public String getUsername() {
        return username;
    }

    public PlayerData getPlayerData() {
        return playerData;
    }

    @Override
    public String getEventName() {
        return "PLAYER_JOIN";
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/server/events/ServerEvent.java
================
package io.github.pokemeetup.multiplayer.server.events;

public interface ServerEvent {
    String getEventName();
    long getTimestamp();
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/server/GameStateHandler.java
================
package io.github.pokemeetup.multiplayer.server;

import com.badlogic.gdx.Screen;

public interface GameStateHandler {
    void returnToLogin(String message);
    boolean isMultiplayerMode();
    void setScreen(Screen screen);
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/server/PlayerDataManager.java
================
package io.github.pokemeetup.multiplayer.server;

import com.badlogic.gdx.utils.Json;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.GameFileSystem;
import io.github.pokemeetup.utils.storage.JsonConfig;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class PlayerDataManager {
    private static final String PLAYER_DATA_DIR = "players/";
    public final Map<UUID, PlayerData> playerCache;
    private final GameFileSystem fs;
    private final Json json;
    private volatile boolean isFlushInProgress = false;

    public PlayerDataManager() {
        this.playerCache = new ConcurrentHashMap<>();
        this.fs = GameFileSystem.getInstance();
        this.json = JsonConfig.getInstance();
        initializeDirectory();
    }

    private void initializeDirectory() {
        try {
            fs.createDirectory(PLAYER_DATA_DIR);
            GameLogger.info("Player data directory initialized at: " + PLAYER_DATA_DIR);
        } catch (Exception e) {
            GameLogger.error("Failed to create player data directory: " + e.getMessage());
            throw new RuntimeException("Player data storage initialization failed", e);
        }
    }

    public synchronized PlayerData loadPlayerData(UUID uuid) {
        PlayerData cached = playerCache.get(uuid);
        if (cached != null) {
            return cached.copy(); // Return copy to prevent direct cache modification
        }

        try {
            String path = getPlayerDataPath(uuid);
            if (!fs.exists(path)) {
                GameLogger.info("No existing data found for UUID: " + uuid);
                return null;
            }

            String jsonData = fs.readString(path);
            PlayerData playerData = json.fromJson(PlayerData.class, jsonData);

            if (playerData != null) {
                // Validate and repair if needed
                if (playerData.validateAndRepairState()) {
                    GameLogger.info("Repaired loaded player data for UUID: " + uuid);
                    savePlayerData(uuid, playerData); // Save repaired data
                }
                playerCache.put(uuid, playerData.copy());
                GameLogger.info("Successfully loaded player data for UUID: " + uuid);
                return playerData.copy();
            }
            return null;
        } catch (Exception e) {
            GameLogger.error("Failed to load player data for UUID: " + uuid + " - " + e.getMessage());
            return null;
        }
    }
    public synchronized void savePlayerData(UUID uuid, PlayerData playerData) {
        if (uuid == null || playerData == null) {
            GameLogger.error("Invalid save attempt with null UUID or PlayerData");
            return;
        }

        try {
            // Validate data before saving
            if (!playerData.validateAndRepairState()) {
                GameLogger.error("Player data validation failed for UUID: " + uuid);
                return;
            }

            String tempPath = getPlayerDataPath(uuid) + ".temp";
            String finalPath = getPlayerDataPath(uuid);
            fs.writeString(tempPath, json.toJson(playerData));

            // Verify temp file exists and is valid
            if (!fs.exists(tempPath)) {
                throw new RuntimeException("Failed to write temporary player data file");
            }

            // Atomic move to final location
            fs.moveFile(tempPath, finalPath);

            // Update cache with a deep copy
            playerCache.put(uuid, playerData.copy());

        } catch (Exception e) {
            GameLogger.error("Failed to save player data for UUID: " + uuid + " - " + e.getMessage());
            throw new RuntimeException("Player data save failed", e);
        }
    }
    private String getPlayerDataPath(UUID uuid) {
        return PLAYER_DATA_DIR + uuid.toString() + ".json";
    }


    public synchronized void flush() {
        if (isFlushInProgress) {
            return; // Prevent recursive flush
        }

        try {
            isFlushInProgress = true;
            Map<UUID, PlayerData> dataToSave = new HashMap<>(playerCache);

            for (Map.Entry<UUID, PlayerData> entry : dataToSave.entrySet()) {
                try {
                    savePlayerData(entry.getKey(), entry.getValue());
                } catch (Exception e) {
                    GameLogger.error("Failed to flush player data for UUID " +
                        entry.getKey() + ": " + e.getMessage());
                }
            }


        } finally {
            isFlushInProgress = false;
        }
    }


    public void deletePlayerData(UUID uuid) {
        try {
            String path = getPlayerDataPath(uuid);
            if (fs.exists(path)) {
                fs.deleteFile(path);
                playerCache.remove(uuid);
                GameLogger.info("Deleted player data for UUID: " + uuid);
            }
        } catch (Exception e) {
            GameLogger.error("Failed to delete player data for UUID: " + uuid + " - " + e.getMessage());
        }
    }

    public void shutdown() {
        try {
            GameLogger.info("Starting PlayerDataManager shutdown...");
            flush(); // Ensure all cached data is saved
            playerCache.clear();
            GameLogger.info("PlayerDataManager shutdown complete");
        } catch (Exception e) {
            GameLogger.error("Error during PlayerDataManager shutdown: " + e.getMessage());
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/server/ServerStorageSystem.java
================
package io.github.pokemeetup.multiplayer.server;

import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonWriter;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.GameFileSystem;
import io.github.pokemeetup.utils.storage.JsonConfig;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class ServerStorageSystem {
    public static final String SERVER_BASE_DIR = "";
    public static final String SERVER_WORLD_DIR = SERVER_BASE_DIR + "worlds/";
    private final Json json;
    private final Map<String, WorldData> worldCache;
    private final GameFileSystem fs;
    private final PlayerDataManager playerDataManager;
    public synchronized void flushPlayerData() {
        try {
            GameLogger.info("Flushing player data to disk...");
            playerDataManager.flush();
        } catch (Exception e) {
            GameLogger.error("Failed to flush player data: " + e.getMessage());
        }
    }
    public ServerStorageSystem() {
        this.json = JsonConfig.getInstance();
        this.json.setOutputType(JsonWriter.OutputType.json);
        this.worldCache = new ConcurrentHashMap<>();
        this.fs = GameFileSystem.getInstance();
        this.playerDataManager = new PlayerDataManager();
        initializeDirectories();
    }

    public GameFileSystem getFileSystem() {
        return fs;
    }

    public boolean worldExists(String name) {
        try {
            String worldPath = SERVER_WORLD_DIR + name + "/world.json";
            return fs.exists(worldPath);
        } catch (Exception e) {
            GameLogger.error("Error checking world existence: " + e.getMessage());
            return false;
        }
    }

    private void initializeDirectories() {
        try {
            fs.createDirectory(SERVER_BASE_DIR);
            fs.createDirectory(SERVER_WORLD_DIR);
            fs.createDirectory(SERVER_WORLD_DIR + "backups/");

            GameLogger.info("Server storage directories initialized");
        } catch (Exception e) {
            GameLogger.error("Failed to create server storage directories: " + e.getMessage());
            throw new RuntimeException("Server storage initialization failed", e);
        }
    }

    public synchronized WorldData loadWorld(String name) {
        // Check cache first
        WorldData cached = worldCache.get(name);
        if (cached != null) {
            return cached;
        }

        try {
            String worldPath = SERVER_WORLD_DIR + name + "/world.json";
            if (!fs.exists(worldPath)) {
                GameLogger.info("World file not found: " + name);
                return null;
            }

            String content = fs.readString(worldPath);
            WorldData world = json.fromJson(WorldData.class, content);

            if (world != null) {
                worldCache.put(name, world);
                GameLogger.info("Loaded world from server storage: " + name);
            }

            return world;
        } catch (Exception e) {
            GameLogger.error("Failed to load world: " + name + " - " + e.getMessage());
            return null;
        }
    }

    public synchronized void saveWorld(WorldData world) {
        if (world == null) return;

        try {
            String worldPath = SERVER_WORLD_DIR + world.getName() + "/";
            fs.createDirectory(worldPath);


            // Save using temporary file
            String tempPath = worldPath + "world.json.temp";
            String finalPath = worldPath + "world.json";

            String jsonData = json.prettyPrint(world);
            fs.writeString(tempPath, jsonData);

            // If temporary file was written successfully, move it to the actual file
            if (fs.exists(finalPath)) {
                fs.deleteFile(finalPath);
            }
            fs.moveFile(tempPath, finalPath);

            // Update cache
            worldCache.put(world.getName(), world);

            GameLogger.info("Saved world to server storage: " + world.getName());
        } catch (Exception e) {
            GameLogger.error("Failed to save world: " + world.getName() + " - " + e.getMessage());
            throw new RuntimeException("World save failed", e);
        }
    }

    public void savePlayerData(String username, PlayerData data) {
        UUID playerUUID = UUID.nameUUIDFromBytes(username.getBytes());
        playerDataManager.savePlayerData(playerUUID, data);
    }


    public Map<String, WorldData> getAllWorlds() {
        String[] worldDirs = fs.list(SERVER_WORLD_DIR);
        Map<String, WorldData> worlds = new HashMap<>();

        if (worldDirs != null) {
            for (String dir : worldDirs) {
                WorldData world = loadWorld(dir);
                if (world != null) {
                    worlds.put(world.getName(), world);
                }
            }
        }

        return worlds;
    }


    public void deletePlayerData(UUID uuid) {
        playerDataManager.deletePlayerData(uuid);
    }



    public void deleteWorld(String name) {
        String worldPath = SERVER_WORLD_DIR + name;
        if (fs.exists(worldPath)) {
            fs.deleteDirectory(worldPath);
            worldCache.remove(name);
            GameLogger.info("Deleted world from server storage: " + name);
        }
    }

    public PlayerDataManager getPlayerDataManager() {
        return playerDataManager;
    }

    public void shutdown() throws InterruptedException {
        // Save all cached data
        for (WorldData world : worldCache.values()) {
            saveWorld(world);
        }
        Thread.sleep(1000);
        GameLogger.info("Storage system shutdown complete");
    }
}

================
File: src/main/java/io/github/pokemeetup/multiplayer/ServerPlayer.java
================
// ... inside file: src/main/java/io/github/pokemeetup/multiplayer/ServerPlayer.java

package io.github.pokemeetup.multiplayer;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.PokemonData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager; // Added import
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class ServerPlayer {
    private final String username;
    private final UUID uuid;
    private final Inventory inventory;
    private final List<PokemonData> partyPokemon;
    private final Object inventoryLock = new Object();
    private final Object positionLock = new Object();
    private final Object dataLock = new Object();
    private PlayerData playerData;
    private WorldObject choppingObject;
    private PlaceableBlock breakingBlock; // This field was added in the previous step

    public ServerPlayer(String username, PlayerData playerData) {
        List<PokemonData> partyPokemon1;
        this.username = username;
        this.uuid = UUID.nameUUIDFromBytes(username.getBytes());
        this.playerData = playerData;

        this.inventory = new Inventory();
        partyPokemon1 = new ArrayList<>();
        if (playerData.getInventoryItems() != null) {
            this.inventory.setAllItems(playerData.getInventoryItems());
        }
        if (playerData.getPartyPokemon() != null) {
            partyPokemon1 = playerData.getPartyPokemon();
        }

        this.partyPokemon = partyPokemon1;
        GameLogger.info("Created ServerPlayer: " + username + " (UUID: " + uuid + ") " +
            "at position (" + playerData.getX() + ", " + playerData.getY() + ")");
    }

    public WorldObject getChoppingObject() {
        return choppingObject;
    }

    public void setChoppingObject(WorldObject object) {
        this.choppingObject = object;
    }

    public PlaceableBlock getBreakingBlock() {
        return breakingBlock;
    }

    public void setBreakingBlock(PlaceableBlock block) {
        this.breakingBlock = block;
    }

    /**
     * Checks if the player has a functional wooden axe in their inventory.
     * @return true if a non-broken axe is found, false otherwise.
     */
    public boolean hasAxe() {
        synchronized (inventoryLock) {
            for (ItemData item : inventory.getAllItems()) {
                if (item != null && item.getItemId().equals(ItemManager.ItemIDs.WOODEN_AXE)) {
                    // Also check if the axe has durability left
                    if (item.getDurability() > 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public UUID getUUID() {
        return uuid;
    }

    public PlayerData getData() {
        synchronized (dataLock) {
            // Create a fresh copy with current state
            PlayerData currentData = playerData.copy();

            // Ensure inventory is synced
            synchronized (inventoryLock) {
                currentData.setInventoryItems(new ArrayList<>(inventory.getAllItems()));
            }

            // Ensure pokemon party is synced
            synchronized (partyPokemon) {
                currentData.setPartyPokemon(new ArrayList<>(partyPokemon));
            }

            return currentData;
        }
    }

    public void setData(PlayerData newData) {
        synchronized (dataLock) {
            if (newData == null) {
                GameLogger.error("Attempted to set null PlayerData for " + username);
                return;
            }

            try {
                // Create deep copy and validate
                PlayerData validatedData = newData.copy();

                this.playerData = validatedData;

                // Update inventory atomically
                synchronized (inventoryLock) {
                    if (validatedData.getInventoryItems() != null) {
                        this.inventory.clear();
                        for (ItemData item : validatedData.getInventoryItems()) {
                            if (item != null) {
                                this.inventory.addItem(item.copy());
                            }
                        }
                    }
                }

                // Update party atomically
                synchronized (partyPokemon) {
                    this.partyPokemon.clear();
                    if (validatedData.getPartyPokemon() != null) {
                        for (PokemonData pokemon : validatedData.getPartyPokemon()) {
                            if (pokemon != null) {
                                this.partyPokemon.add(pokemon.copy());
                            }
                        }
                    }
                }

            } catch (Exception e) {
                GameLogger.error("Failed to update player data for " + username + ": " + e.getMessage());
            }
        }
    }

    public void setPosition(float x, float y) {
        synchronized (positionLock) {
            playerData.setX(x);
            playerData.setY(y);
        }
    }

    public int getTileX() {
        return (int) (playerData.getX() / World.TILE_SIZE);
    }

    public int getTileY() {
        return (int) (playerData.getY() / World.TILE_SIZE);
    }

    public Vector2 getPosition() {
        synchronized (positionLock) {
            return new Vector2(playerData.getX(), playerData.getY());
        }
    }

    public List<ItemData> getInventoryItems() {
        synchronized (inventoryLock) {
            return inventory.getAllItems();
        }
    }

    public String getUsername() {
        return username;
    }

    public String getDirection() {
        synchronized (positionLock) {
            return playerData.getDirection();
        }
    }

    public void setDirection(String direction) {
        synchronized (positionLock) {
            playerData.setDirection(direction);
        }
    }

    public boolean isMoving() {
        synchronized (positionLock) {
            return playerData.isMoving();
        }
    }

    public void setMoving(boolean moving) {
        synchronized (positionLock) {
            playerData.setMoving(moving);
        }
    }

    public boolean isRunning() {
        return playerData.isWantsToRun();
    }

    public void setRunning(boolean running) {
        playerData.setWantsToRun(running);
    }

    public Inventory getInventory() {
        return inventory;
    }
}

================
File: src/main/java/io/github/pokemeetup/pokemon/attacks/LearnableMove.java
================
package io.github.pokemeetup.pokemon.attacks;

import io.github.pokemeetup.pokemon.Pokemon;

public class LearnableMove {
    private String moveName;
    private int levelLearned;
    private boolean isStartingMove;
    private Pokemon.PokemonType moveType;
    private int power;
    private int accuracy;
    private int pp;
    private String description;

    public LearnableMove() {
    }

    public String getMoveName() {
        return moveName;
    }

    public void setMoveName(String moveName) {
        this.moveName = moveName;
    }

    public int getLevelLearned() {
        return levelLearned;
    }

    public void setLevelLearned(int levelLearned) {
        this.levelLearned = levelLearned;
    }

    public boolean isStartingMove() {
        return isStartingMove;
    }

    public void setStartingMove(boolean startingMove) {
        isStartingMove = startingMove;
    }

    public Pokemon.PokemonType getMoveType() {
        return moveType;
    }

    public void setMoveType(Pokemon.PokemonType moveType) {
        this.moveType = moveType;
    }

    public int getPower() {
        return power;
    }

    public void setPower(int power) {
        this.power = power;
    }

    public int getAccuracy() {
        return accuracy;
    }

    public void setAccuracy(int accuracy) {
        this.accuracy = accuracy;
    }

    public int getPp() {
        return pp;
    }

    public void setPp(int pp) {
        this.pp = pp;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}

================
File: src/main/java/io/github/pokemeetup/pokemon/attacks/Move.java
================
package io.github.pokemeetup.pokemon.attacks;

import io.github.pokemeetup.pokemon.Pokemon;

import java.util.HashMap;
import java.util.Map;

public class Move {
    private String name;
    private Pokemon.PokemonType type;
    private int power;
    private int accuracy;
    private int pp;
    private int maxPp;

    public void setName(String name) {
        this.name = name;
    }

    public void setType(Pokemon.PokemonType type) {
        this.type = type;
    }

    public void setPower(int power) {
        this.power = power;
    }

    public void setAccuracy(int accuracy) {
        this.accuracy = accuracy;
    }

    public void setPp(int pp) {
        this.pp = pp;
    }

    public void setMaxPp(int maxPp) {
        this.maxPp = maxPp;
    }

    public void setSpecial(boolean special) {
        isSpecial = special;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public void setEffect(MoveEffect effect) {
        this.effect = effect;
    }

    public void setCanFlinch(boolean canFlinch) {
        this.canFlinch = canFlinch;
    }

    private boolean isSpecial;
    private String description;

    private MoveEffect effect;
    private boolean canFlinch;

    // Constructors, Getters, and Setters

    public Move() {
        // Default constructor
    }

    public String getName() {
        return name;
    }

    public Pokemon.PokemonType getType() {
        return type;
    }

    public int getPower() {
        return power;
    }

    public int getAccuracy() {
        return accuracy;
    }

    public int getPp() {
        return pp;
    }

    public int getMaxPp() {
        return maxPp;
    }

    public boolean isSpecial() {
        return isSpecial;
    }

    public String getDescription() {
        return description;
    }

    public MoveEffect getEffect() {
        return effect;
    }

    public boolean canFlinch() {
        return canFlinch;
    }

    public static class MoveEffect {
        private Pokemon.Status statusEffect;
        private Map<String, Integer> statModifiers;
        private String effectType;
        private float chance;
        private String animation;
        private String sound;
        private int duration;       // Added duration field

        public MoveEffect() {
            this.statModifiers = new HashMap<>();
        }
        public int getDuration() {
            return duration;
        }

        public void setDuration(int duration) {
            this.duration = duration;
        }


        // Getters and Setters

        public Pokemon.Status getStatusEffect() {
            return statusEffect;
        }

        public void setStatusEffect(Pokemon.Status statusEffect) {
            this.statusEffect = statusEffect;
        }

        public Map<String, Integer> getStatModifiers() {
            return statModifiers;
        }

        public void setStatModifiers(Map<String, Integer> statModifiers) {
            this.statModifiers = statModifiers;
        }

        public String getEffectType() {
            return effectType;
        }

        public void setEffectType(String effectType) {
            this.effectType = effectType;
        }

        public float getChance() {
            return chance;
        }

        public void setChance(float chance) {
            this.chance = chance;
        }

        public String getAnimation() {
            return animation;
        }

        public void setAnimation(String animation) {
            this.animation = animation;
        }

        public String getSound() {
            return sound;
        }

        public void setSound(String sound) {
            this.sound = sound;
        }
    }

    // Builder pattern for move creation
    public static class Builder {
        private final Move move;

        public Builder(String name, Pokemon.PokemonType type) {
            move = new Move();
            move.name = name;
            move.type = type;
        }

        public Builder power(int power) {
            move.power = power;
            return this;
        }

        public Builder accuracy(int accuracy) {
            move.accuracy = accuracy;
            return this;
        }

        public Builder pp(int pp) {
            move.pp = pp;
            move.maxPp = pp;
            return this;
        }

        public Builder special(boolean isSpecial) {
            move.isSpecial = isSpecial;
            return this;
        }

        public Builder description(String description) {
            move.description = description;
            return this;
        }

        public Builder effect(MoveEffect effect) {
            move.effect = effect;
            return this;
        }

        public Builder canFlinch(boolean canFlinch) {
            move.canFlinch = canFlinch;
            return this;
        }

        public Move build() {
            return move;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/pokemon/attacks/MoveLoader.java
================
package io.github.pokemeetup.pokemon.attacks;

import com.google.gson.*;
import io.github.pokemeetup.pokemon.Pokemon;

import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.*;

public class MoveLoader {
    public static Map<String, Move> loadMovesFromJson(String jsonContent) {
        Gson gson = new GsonBuilder().create();
        Map<String, Move> moves = new HashMap<>();

        try {
            // Parse the JSON string
            JsonObject jsonObject = JsonParser.parseString(jsonContent).getAsJsonObject();

            // Get the "moves" object
            JsonObject movesJson = jsonObject.getAsJsonObject("moves");

            // Iterate over each move
            for (Map.Entry<String, JsonElement> entry : movesJson.entrySet()) {
                String moveName = entry.getKey();
                JsonObject moveJson = entry.getValue().getAsJsonObject();

                Move move = parseMove(moveName, moveJson);
                moves.put(moveName, move);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse moves JSON: " + e.getMessage());
        }

        return moves;
    }
    public static Map<String, Move> loadMoves(String jsonFilePath) throws IOException {
        Gson gson = new GsonBuilder().create();
        Map<String, Move> moves = new HashMap<>();

        // Read the JSON file
        JsonObject jsonObject;
        try (FileReader reader = new FileReader(jsonFilePath)) {
            jsonObject = JsonParser.parseReader(reader).getAsJsonObject();
        }

        // Get the "moves" object
        JsonObject movesJson = jsonObject.getAsJsonObject("moves");

        // Iterate over each move
        for (Map.Entry<String, JsonElement> entry : movesJson.entrySet()) {
            String moveName = entry.getKey();
            JsonObject moveJson = entry.getValue().getAsJsonObject();

            Move move = parseMove(moveName, moveJson);
            moves.put(moveName, move);
        }

        return moves;
    }

    private static Move parseMove(String moveName, JsonObject moveJson) {
        // Extract basic fields
        String typeStr = moveJson.get("type").getAsString();
        int power = moveJson.get("power").getAsInt();
        int accuracy = moveJson.get("accuracy").getAsInt();
        int pp = moveJson.get("pp").getAsInt();
        boolean isSpecial = moveJson.get("isSpecial").getAsBoolean();
        String description = moveJson.get("description").getAsString();

        // Convert type string to enum
        Pokemon.PokemonType type = Pokemon.PokemonType.valueOf(typeStr);

        // Initialize the builder
        Move.Builder builder = new Move.Builder(moveName, type)
            .power(power)
            .accuracy(accuracy)
            .pp(pp)
            .special(isSpecial)
            .description(description);

        // Parse effects if present
        if (moveJson.has("effects")) {
            JsonObject effectsJson = moveJson.getAsJsonObject("effects");
            Move.MoveEffect effect = parseMoveEffect(effectsJson);
            builder.effect(effect);
        }

        return builder.build();
    }

    private static Move.MoveEffect parseMoveEffect(JsonObject effectsJson) {
        Move.MoveEffect effect = new Move.MoveEffect();

        // Set effect type
        if (effectsJson.has("type")) {
            effect.setEffectType(effectsJson.get("type").getAsString());
        }

        // Set chance
        if (effectsJson.has("chance")) {
            effect.setChance(effectsJson.get("chance").getAsFloat());
        } else {
            effect.setChance(1.0f);  // Default chance
        }

        // Set status effect
        if (effectsJson.has("status")) {
            String statusStr = effectsJson.get("status").getAsString();
            Pokemon.Status status = Pokemon.Status.valueOf(statusStr);
            effect.setStatusEffect(status);
        }

        // Set stat modifiers
        if (effectsJson.has("statChanges")) {
            JsonObject statChangesJson = effectsJson.getAsJsonObject("statChanges");
            Map<String, Integer> statModifiers = new HashMap<>();
            for (Map.Entry<String, JsonElement> statEntry : statChangesJson.entrySet()) {
                String stat = statEntry.getKey();
                int change = statEntry.getValue().getAsInt();
                statModifiers.put(stat, change);
            }
            effect.setStatModifiers(statModifiers);
        }

        // Set animation and sound
        if (effectsJson.has("animation")) {
            effect.setAnimation(effectsJson.get("animation").getAsString());
        }
        if (effectsJson.has("sound")) {
            effect.setSound(effectsJson.get("sound").getAsString());
        }

        return effect;
    }
}

================
File: src/main/java/io/github/pokemeetup/pokemon/data/PokemonDatabase.java
================
package io.github.pokemeetup.pokemon.data;

import com.badlogic.gdx.utils.JsonReader;
import com.badlogic.gdx.utils.JsonValue;
import io.github.pokemeetup.FileSystemDelegate;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.pokemon.attacks.MoveLoader;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.GameFileSystem;

import java.util.*;

public class PokemonDatabase {
    private static final String POKEMON_DATA_FILE = "Data/pokemon.json";
    private static final String MOVE_DATA_FILE = "Data/moves.json";
    private static final Map<String, PokemonTemplate> pokemonTemplates = new HashMap<>();
    private static final Map<String, BaseStats> pokemonStats = new HashMap<>();
    private static boolean isInitialized = false;
    private static final Map<String, Move> allMoves = new HashMap<>();

    public static PokemonTemplate getTemplate(String name) {
        if (!isInitialized) {
            initialize();
        }
        return pokemonTemplates.get(name.toLowerCase());
    }


    public static void initialize() {
        if (isInitialized) {
            return;
        }
        try {
            GameLogger.info("Initializing Pokemon Database...");
            FileSystemDelegate delegate = GameFileSystem.getInstance().getDelegate();

            // Load moves first
            try {
                String movesJson = delegate.readString(MOVE_DATA_FILE);
                GameLogger.info("Loaded moves.json content (length: " + movesJson.length() + ")");
                allMoves.putAll(MoveLoader.loadMovesFromJson(movesJson));
                GameLogger.info("Successfully loaded " + allMoves.size() + " moves");
                int count = 0;
                for (Map.Entry<String, Move> entry : allMoves.entrySet()) {
                    if (count++ < 3) {
                        GameLogger.info("Loaded move: " + entry.getKey() + " (" +
                            entry.getValue().getType() + ", Power: " +
                            entry.getValue().getPower() + ")");
                    }
                }
            } catch (Exception e) {
                GameLogger.error("Failed to load moves: " + e.getMessage());
                throw e;
            }

            // Then load Pokémon data
            try {
                String pokemonJson = delegate.readString(POKEMON_DATA_FILE);
                GameLogger.info("Loaded pokemon.json content (length: " + pokemonJson.length() + ")");
                JsonReader reader = new JsonReader();
                JsonValue root = reader.parse(pokemonJson);
                JsonValue pokemonArray = root.get("pokemon");
                if (pokemonArray == null) {
                    throw new RuntimeException("Invalid pokemon.json format - missing 'pokemon' array");
                }
                int pokemonCount = 0;
                for (JsonValue pokemonValue = pokemonArray.child; pokemonValue != null; pokemonValue = pokemonValue.next) {
                    try {
                        String name = pokemonValue.getString("name");
                        if (name == null || name.isEmpty()) {
                            continue;
                        }
                        Pokemon.PokemonType primaryType = Pokemon.PokemonType.valueOf(
                            pokemonValue.getString("primaryType").toUpperCase());
                        Pokemon.PokemonType secondaryType = getSecondaryType(pokemonValue);
                        List<MoveEntry> moves = loadPokemonMoves(pokemonValue.get("moves"));
                        BaseStats stats = new BaseStats(
                            name,
                            pokemonValue.getInt("baseHp"),
                            pokemonValue.getInt("baseAttack"),
                            pokemonValue.getInt("baseDefense"),
                            pokemonValue.getInt("baseSpAtk"),
                            pokemonValue.getInt("baseSpDef"),
                            pokemonValue.getInt("baseSpeed"),
                            primaryType,
                            secondaryType,
                            moves
                        );
                        pokemonStats.put(name, stats);

                        // Create template and load growth rate
                        PokemonTemplate template = new PokemonTemplate();
                        template.name = name;
                        template.primaryType = primaryType;
                        template.secondaryType = secondaryType;
                        template.baseStats = stats;
                        template.moves = moves;
                        template.width = pokemonValue.getFloat("width", 1.0f);
                        template.height = pokemonValue.getFloat("height", 1.0f);
                        template.growthRate = pokemonValue.getString("growthRate", "Medium Fast");
                        pokemonTemplates.put(name.toLowerCase(), template);

                        pokemonCount++;
                        if (pokemonCount <= 3) {
                            GameLogger.info("Loaded Pokemon: " + name + " (" +
                                primaryType + (secondaryType != null ? "/" + secondaryType : "") +
                                ") with " + moves.size() + " moves");
                        }
                    } catch (Exception e) {
                        GameLogger.error("Error loading Pokemon entry: " + e.getMessage());
                    }
                }
                GameLogger.info("Successfully loaded " + pokemonCount + " Pokemon");
                isInitialized = true;
            } catch (Exception e) {
                GameLogger.error("Failed to load Pokemon data: " + e.getMessage());
                throw e;
            }
        } catch (Exception e) {
            GameLogger.error("Pokemon database initialization failed: " + e.getMessage());
            e.printStackTrace();
            throw new RuntimeException("Failed to initialize Pokemon database", e);
        }
    }

    public static BaseStats getStats(String name) {
        if (!isInitialized) {
            initialize();
        }
        BaseStats stats = pokemonStats.get(name);
        if (stats == null) {
            GameLogger.error("No stats found for Pokemon: " + name);
            return new BaseStats(
                name,
                45, 45, 45, 45, 45, 45,
                Pokemon.PokemonType.NORMAL,
                null,
                new ArrayList<>()
            );
        }
        return stats;
    }

    private static List<MoveEntry> loadPokemonMoves(JsonValue movesArray) {
        List<MoveEntry> moves = new ArrayList<>();
        if (movesArray != null && movesArray.isArray()) {
            for (JsonValue moveValue = movesArray.child; moveValue != null; moveValue = moveValue.next) {
                try {
                    String moveName = moveValue.getString("name");
                    int level = moveValue.getInt("level");
                    moves.add(new MoveEntry(moveName, level));
                } catch (Exception e) {
                    GameLogger.error("Error loading move: " + e.getMessage());
                }
            }
        }
        return moves;
    }

    private static Pokemon.PokemonType getSecondaryType(JsonValue pokemonValue) {
        try {
            if (pokemonValue.has("secondaryType")) {
                String secondaryType = pokemonValue.getString("secondaryType", "").trim();
                if (!secondaryType.isEmpty()) {
                    return Pokemon.PokemonType.valueOf(secondaryType.toUpperCase());
                }
            }
        } catch (Exception e) {
            GameLogger.info("No secondary type for Pokemon: " + pokemonValue.getString("name", "unknown"));
        }
        return null;
    }

    public static Pokemon createPokemon(String name, int level) {
        if (!isInitialized) {
            initialize();
        }
        PokemonTemplate template = pokemonTemplates.get(name);
        if (template == null) {
            GameLogger.error("Pokemon template not found: " + name);
            return null;
        }
        try {
            Pokemon.Builder builder = new Pokemon.Builder(name, level)
                .withType(template.primaryType, template.secondaryType);
            int hp = calculateStat(template.baseStats.baseHp, level, true);
            int attack = calculateStat(template.baseStats.baseAttack, level, false);
            int defense = calculateStat(template.baseStats.baseDefense, level, false);
            int spAtk = calculateStat(template.baseStats.baseSpAtk, level, false);
            int spDef = calculateStat(template.baseStats.baseSpDef, level, false);
            int speed = calculateStat(template.baseStats.baseSpeed, level, false);
            builder.withStats(hp, attack, defense, spAtk, spDef, speed);
            List<Move> startingMoves = getMovesForLevel(template.moves, level);
            builder.withMoves(startingMoves);
            return builder.build();
        } catch (Exception e) {
            GameLogger.error("Error creating Pokemon: " + e.getMessage());
            return null;
        }
    }

    public static List<Move> getMovesForLevel(List<MoveEntry> moveEntries, int level) {
        List<Move> moves = new ArrayList<>();
        try {
            Map<String, Move> moveMap = new HashMap<>();
            for (Map.Entry<String, Move> entry : allMoves.entrySet()) {
                moveMap.put(entry.getKey().toLowerCase(), entry.getValue());
            }
            List<MoveEntry> learnedMoves = new ArrayList<>();
            for (MoveEntry entry : moveEntries) {
                if (entry.level <= level) {
                    learnedMoves.add(entry);
                }
            }
            learnedMoves.sort(Comparator.comparingInt(e -> e.level));
            int movesToAdd = Math.min(learnedMoves.size(), 4);
            for (int i = learnedMoves.size() - movesToAdd; i < learnedMoves.size(); i++) {
                MoveEntry moveEntry = learnedMoves.get(i);
                String moveName = moveEntry.name.toLowerCase();
                Move move = moveMap.get(moveName);
                if (move != null) {
                    moves.add(cloneMove(move));
                    GameLogger.info("Added move: " + moveEntry.name + " (Level " + moveEntry.level + ")");
                } else {
                    GameLogger.error("Move not found: " + moveEntry.name);
                    GameLogger.error("Available moves: " + String.join(", ", moveMap.keySet()));
                }
            }
        } catch (Exception e) {
            GameLogger.error("Error loading moves: " + e.getMessage());
            e.printStackTrace();
        }
        return moves;
    }

    public static Move cloneMove(Move move) {
        Move.MoveEffect clonedEffect = null;
        if (move.getEffect() != null) {
            clonedEffect = cloneMoveEffect(move.getEffect());
        }
        return new Move.Builder(move.getName(), move.getType())
            .power(move.getPower())
            .accuracy(move.getAccuracy())
            .pp(move.getPp())
            .special(move.isSpecial())
            .description(move.getDescription())
            .effect(clonedEffect)
            .build();
    }

    private static Move.MoveEffect cloneMoveEffect(Move.MoveEffect effect) {
        Move.MoveEffect clonedEffect = new Move.MoveEffect();
        clonedEffect.setEffectType(effect.getEffectType());
        clonedEffect.setChance(effect.getChance());
        clonedEffect.setAnimation(effect.getAnimation());
        clonedEffect.setSound(effect.getSound());
        clonedEffect.setStatusEffect(effect.getStatusEffect());
        clonedEffect.setDuration(effect.getDuration());
        clonedEffect.setStatModifiers(new HashMap<>(effect.getStatModifiers()));
        return clonedEffect;
    }

    public static Move getMoveByName(String moveName) {
        return allMoves.get(moveName);
    }

    private static int calculateStat(int base, int level, boolean isHp) {
        int iv = 15;
        int ev = 0;
        if (isHp) {
            return ((2 * base + iv + (ev / 4)) * level / 100) + level + 10;
        } else {
            return ((2 * base + iv + (ev / 4)) * level / 100) + 5;
        }
    }

    public static class MoveEntry {
        public final String name;
        public final int level;
        public MoveEntry(String name, int level) {
            this.name = name;
            this.level = level;
        }
    }

    public static class PokemonTemplate {
        public Pokemon.PokemonType primaryType;
        public Pokemon.PokemonType secondaryType;
        public BaseStats baseStats;
        public List<MoveEntry> moves;
        public String name;
        public float width;
        public float height;
        // NEW: growthRate field
        public String growthRate;
    }

    public static class BaseStats {
        public final String name;
        public final int baseHp;
        public final int baseAttack;
        public final int baseDefense;
        public final int baseSpAtk;
        public final int baseSpDef;
        public final int baseSpeed;
        public final Pokemon.PokemonType primaryType;
        public final Pokemon.PokemonType secondaryType;
        public final List<MoveEntry> moves;
        public BaseStats(String name, int baseHp, int baseAttack, int baseDefense,
                         int baseSpAtk, int baseSpDef, int baseSpeed,
                         Pokemon.PokemonType primaryType, Pokemon.PokemonType secondaryType,
                         List<MoveEntry> moves) {
            this.name = name;
            this.baseHp = baseHp;
            this.baseAttack = baseAttack;
            this.baseDefense = baseDefense;
            this.baseSpAtk = baseSpAtk;
            this.baseSpDef = baseSpDef;
            this.baseSpeed = baseSpeed;
            this.primaryType = primaryType;
            this.secondaryType = secondaryType;
            this.moves = moves != null ? moves : new ArrayList<>();
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/pokemon/Pokemon.java
================
package io.github.pokemeetup.pokemon;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.pokemon.data.PokemonDatabase;
import io.github.pokemeetup.screens.otherui.BattleTable;
import io.github.pokemeetup.system.gameplay.PokemonAnimations;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.*;

public class Pokemon {
    private static Weather currentWeather = Weather.CLEAR;
    private static int weatherTurns = 0;
    public String name;
    public int level;
    public Stats stats;
    public List<Move> moves;
    public PokemonType primaryType;
    public PokemonType secondaryType;
    public float currentHp;
    private Status status = Status.NONE;
    private int sleepTurns = 0;
    private int toxicCounter = 1;
    private boolean flinched = false;
    private int confusedTurns = 0;
    private String nature;
    // NEW: Stat stage tracking (-6 to +6)
    private Map<String, Integer> statStages; // "attack", "defense", "spAtk", "spDef", "speed", "accuracy", "evasion"

    // NEW: Status duration counters
    private int paralysisTurns = 0; // Example, may not be needed depending on paralysis implementation
    private int confusionTurns = 0;
    private boolean confused = false; // Separate flag for confusion state
    private boolean isShiny;
    private UUID uuid;
    private int currentExperience;
    private TextureRegion iconSprite;
    private TextureRegion frontSprite;
    private TextureRegion backSprite;
    private TextureRegion frontShinySprite;
    private TextureRegion backShinySprite;
    private PokemonAnimations animations;
    private int speciesBaseHp;
    private int speciesBaseAttack;
    private int speciesBaseDefense;
    private int speciesBaseSpAtk;
    private int speciesBaseSpDef;
    private int speciesBaseSpeed;
    private Vector2 position;
    private String direction;
    private boolean isMoving;
    private String growthRate;
    private TextureRegion[] iconFrames; // Array to hold both frames
    private int currentIconFrame;       // Index to track the current frame
    private float frameDuration = 0.5f; // Duration each frame is shown in seconds
    private float frameTimer = 0;

    public Pokemon(String name, int level,
                   int speciesBaseHp, int speciesBaseAttack, int speciesBaseDefense,
                   int speciesBaseSpAtk, int speciesBaseSpDef, int speciesBaseSpeed) {
        // Save species base stats for later use
        this.speciesBaseHp = speciesBaseHp;
        this.speciesBaseAttack = speciesBaseAttack;
        this.speciesBaseDefense = speciesBaseDefense;
        this.speciesBaseSpAtk = speciesBaseSpAtk;
        this.speciesBaseSpDef = speciesBaseSpDef;
        this.speciesBaseSpeed = speciesBaseSpeed;

        this.uuid = UUID.randomUUID();
        this.name = name;
        this.level = level;
        this.nature = generateNature();
        this.isShiny = calculateShinyStatus();
        this.stats = new Stats();
        this.moves = new ArrayList<>();
        this.statStages = new HashMap<>();
        resetStatStages(); // Initialize all stages to 0
        TextureRegion iconSheet = TextureManager.getPokemonicon().findRegion(name.toUpperCase() + "_icon");
        iconFrames = new TextureRegion[2];
        iconFrames[0] = new TextureRegion(iconSheet, 0, 0, iconSheet.getRegionWidth() / 2, iconSheet.getRegionHeight());
        iconFrames[1] = new TextureRegion(iconSheet, iconSheet.getRegionWidth() / 2, 0, iconSheet.getRegionWidth() / 2, iconSheet.getRegionHeight());
        PokemonDatabase.PokemonTemplate template = PokemonDatabase.getTemplate(name);
        if (template != null && template.growthRate != null && !template.growthRate.isEmpty()) {
            this.growthRate = template.growthRate;
        } else {
            this.growthRate = "Medium Fast"; // default growth rate
        }
        this.position = new Vector2();
        this.direction = "down";
        this.isMoving = false;
        this.currentHp = stats.getHp();
        loadIcons(TextureManager.getPokemonicon());
        loadFront(TextureManager.getPokemonfront());
        loadBack(TextureManager.getPokemonback());
        loadOverworld(TextureManager.getPokemonoverworld());
        calculateStats();
        this.currentHp = stats.getHp();
    }
    public void resetStatStages() {
        statStages.put("attack", 0);
        statStages.put("defense", 0);
        statStages.put("spAtk", 0);
        statStages.put("spDef", 0);
        statStages.put("speed", 0);
        statStages.put("accuracy", 0); // Often handled differently, but include for completeness
        statStages.put("evasion", 0);  // Often handled differently
    }
    protected Pokemon(boolean noTexture) {
        // We assume 'noTexture' is true
        this.uuid = UUID.randomUUID();
        this.statStages = new HashMap<>(); // Initialize stages here too
        this.name = "";         // Will be set later by the subclass
        this.level = 1;         // Will be overwritten later
        this.nature = generateNature();
        this.isShiny = calculateShinyStatus();
        this.stats = new Stats();
        this.moves = new ArrayList<>();
        this.growthRate = "Medium Fast"; // default (or you can load from the database if needed)
        this.position = new Vector2();
        this.direction = "down";
        this.isMoving = false;
        this.currentHp = 0; // will be set later
    }

    public Pokemon(String name, int level) {
        this(name, level,
            getBaseStat(name, "hp"),
            getBaseStat(name, "attack"),
            getBaseStat(name, "defense"),
            getBaseStat(name, "spAtk"),
            getBaseStat(name, "spDef"),
            getBaseStat(name, "speed"));
    }

    public static Pokemon createServerPokemon(String name, int level) {
        Pokemon p = new Pokemon(true);
        p.name = name;
        p.level = level;
        // Optionally, if you want to load base stats from your database template:
        PokemonDatabase.PokemonTemplate template = PokemonDatabase.getTemplate(name);
        if (template != null) {
            p.growthRate = template.growthRate != null ? template.growthRate : "Medium Fast";
            // You might assign speciesBase* values here if needed.
        }
        // Then calculate stats:
        p.calculateStats();
        p.currentHp = p.stats.getHp();
        return p;
    }

    /**
     * Helper method to look up a given stat for a Pokémon by name.
     *
     * @param name The Pokémon’s name.
     * @param stat A string identifying the stat (“hp”, “attack”, “defense”, “spAtk”, “spDef”, or “speed”)
     * @return The value from the template if found; otherwise a default value.
     */
    private static int getBaseStat(String name, String stat) {
        PokemonDatabase.PokemonTemplate template = PokemonDatabase.getTemplate(name);
        if (template != null) {
            switch (stat) {
                case "hp":
                    return template.baseStats.baseHp;
                case "attack":
                    return template.baseStats.baseAttack;
                case "defense":
                    return template.baseStats.baseDefense;
                case "spAtk":
                    return template.baseStats.baseSpAtk;
                case "spDef":
                    return template.baseStats.baseSpDef;
                case "speed":
                    return template.baseStats.baseSpeed;
                default:
                    return 45; // fallback default
            }
        }
        return 45; // fallback default if template not found
    }

    public static void applyWeatherEffects(Pokemon pokemon) {
        if (weatherTurns > 0) {
            switch (currentWeather) {
                case SANDSTORM:
                    if (pokemon.primaryType != PokemonType.ROCK &&
                        pokemon.primaryType != PokemonType.GROUND &&
                        pokemon.primaryType != PokemonType.STEEL) {
                        pokemon.currentHp -= pokemon.stats.getHp() / 16;
                    }
                    break;

                case HAIL:
                    if (pokemon.primaryType != PokemonType.ICE) {
                        pokemon.currentHp -= pokemon.stats.getHp() / 16;
                    }
                    break;
            }
            weatherTurns--;
            if (weatherTurns <= 0) {
                currentWeather = Weather.CLEAR;
            }
        }
    }

    private int totalExpForLevel(int L) {
        double exp;
        switch (growthRate.toLowerCase()) {
            case "fast":
                exp = (4.0 * Math.pow(L, 3)) / 5.0;
                break;
            case "medium slow":
                exp = ((6.0 / 5.0) * Math.pow(L, 3)) - (15 * Math.pow(L, 2)) + (100 * L) - 140;
                break;
            case "slow":
                exp = (5.0 * Math.pow(L, 3)) / 4.0;
                break;
            case "medium fast":
            default:
                exp = Math.pow(L, 3);
                break;
        }
        return (int) exp;
    }

    public int getExperienceForNextLevel() {
        return totalExpForLevel(level + 1) - totalExpForLevel(level);
    }

    public int getSpeciesBaseHp() {
        return speciesBaseHp;
    }

    public int getSpeciesBaseAttack() {
        return speciesBaseAttack;
    }

    public int getSpeciesBaseDefense() {
        return speciesBaseDefense;
    }

    public int getSpeciesBaseSpAtk() {
        return speciesBaseSpAtk;
    }

    public int getSpeciesBaseSpDef() {
        return speciesBaseSpDef;
    }

    public int getSpeciesBaseSpeed() {
        return speciesBaseSpeed;
    }

    public int getCurrentExperience() {
        return currentExperience;
    }


    public void heal() {
        this.currentHp = this.stats.getHp();
        this.status = Status.NONE;
        this.toxicCounter = 1;
        this.flinched = false;
        this.confused = false;
        this.confusionTurns = 0;
        this.sleepTurns = 0;
        resetStatStages(); // Reset stat stages on heal
        calculateStats(); // Recalculate stats after resetting stages
    }
    public void heal(int amount) {
        this.currentHp = this.currentHp+amount;
        this.status = Status.NONE;
        this.toxicCounter = 1;
        this.flinched = false;
        this.confused = false;
        this.confusionTurns = 0;
        this.sleepTurns = 0;
        resetStatStages(); // Reset stat stages on heal
        calculateStats(); // Recalculate stats after resetting stages
    }

    public boolean hasStatus() {
        return status != Status.NONE;
    }

    public Status getStatus() {
        return status;
    }
    public void setStatus(Status newStatus) {
        if (newStatus == null || this.status != Status.NONE) {
            if (newStatus == Status.ASLEEP && this.status == Status.ASLEEP) {
                // Allow refreshing sleep duration maybe? Or just ignore.
            } else if (newStatus != Status.NONE) {
                GameLogger.info(name + " is already " + this.status + ", cannot apply " + newStatus);
            }
            return;
        }

        // Check type immunities
        if ((newStatus == Status.POISONED || newStatus == Status.BADLY_POISONED) &&
            (primaryType == PokemonType.POISON || secondaryType == PokemonType.POISON ||
                primaryType == PokemonType.STEEL || secondaryType == PokemonType.STEEL)) {
            GameLogger.info(name + " is immune to poison!");
            return;
        }
        if (newStatus == Status.BURNED &&
            (primaryType == PokemonType.FIRE || secondaryType == PokemonType.FIRE)) {
            GameLogger.info(name + " is immune to burn!");
            return;
        }
        if (newStatus == Status.PARALYZED &&
            (primaryType == PokemonType.ELECTRIC || secondaryType == PokemonType.ELECTRIC)) {
            GameLogger.info(name + " is immune to paralysis!");
            return;
        }
        if (newStatus == Status.FROZEN &&
            (primaryType == PokemonType.ICE || secondaryType == PokemonType.ICE)) {
            GameLogger.info(name + " is immune to freeze!");
            return;
        }

        this.status = newStatus;

        if (GameContext.get() != null && GameContext.get().getBattleTable() != null) {
            GameContext.get().getBattleTable().queueMessage(name + " was " + newStatus.name().toLowerCase() + "!");
        } else {
            GameLogger.info(name + " is now " + newStatus);
        }

        // Initialize status-specific counters
        switch (newStatus) {
            case ASLEEP:
                sleepTurns = MathUtils.random(1, 3); // Standard sleep 1-3 turns
                break;
            case BADLY_POISONED:
                toxicCounter = 1;
                break;
            default:
                break;
        }
        // Recalculate stats if status affects them (e.g., paralysis, burn)
        calculateStats();
    }

    /**
     * Modifies a specific stat stage, clamped between -6 and +6.
     * @param statName "attack", "defense", "spAtk", "spDef", "speed", "accuracy", "evasion"
     * @param change Amount to change by (e.g., -1 for Growl, +2 for Swords Dance)
     * @return True if the stage was changed, false if it was already at the limit.
     */
    public boolean modifyStatStage(String statName, int change) {
        String key = statName.toLowerCase();
        if (!statStages.containsKey(key)) {
            GameLogger.error("Attempted to modify unknown stat stage: " + statName);
            return false;
        }

        int currentStage = statStages.get(key);
        int newStage = MathUtils.clamp(currentStage + change, -6, 6);

        if (newStage == currentStage) {
            // Already at max or min, stage didn't change
            GameLogger.info(name + "'s " + statName + " won't go any " + (change > 0 ? "higher!" : "lower!"));
            return false;
        }

        statStages.put(key, newStage);
        // Recalculate stats potentially affected by the stage change (like speed for paralysis)
        calculateStats();
        GameLogger.info(name + "'s " + statName + (change > 0 ? " rose!" : " fell!"));
        // TODO: Add BattleTable message display here
        return true;
    }

    /**
     * Gets the multiplier for a stat based on its current stage.
     * Formula: stage > 0 ? (2 + stage) / 2 : 2 / (2 - stage)
     * Accuracy/Evasion use a different formula: stage > 0 ? (3 + stage) / 3 : 3 / (3 - stage)
     * @param statName "attack", "defense", "spAtk", "spDef", "speed", "accuracy", "evasion"
     * @return The multiplier (e.g., 1.0 for stage 0, 1.5 for stage +1, 0.66 for stage -1)
     */
    public float getStatModifier(String statName) {
        String key = statName.toLowerCase();
        int stage = statStages.getOrDefault(key, 0);

        if (key.equals("accuracy") || key.equals("evasion")) {
            if (stage > 0) {
                return (3.0f + stage) / 3.0f;
            } else if (stage < 0) {
                return 3.0f / (3.0f - stage); // Note: stage is negative here
            } else {
                return 1.0f;
            }
        } else { // Attack, Defense, SpAtk, SpDef, Speed
            if (stage > 0) {
                return (2.0f + stage) / 2.0f;
            } else if (stage < 0) {
                return 2.0f / (2.0f - stage); // Note: stage is negative here
            } else {
                return 1.0f;
            }
        }
    }
    public boolean canAttack() {
        if (currentHp <= 0) {
            return false;
        }

        // Flinch has highest priority
        if (flinched) {
            flinched = false; // Flinch lasts only one turn
            GameContext.get().getBattleTable().queueMessage(name + " flinched!");
            return false;
        }

        // Check major status conditions
        switch (status) {
            case ASLEEP:
                sleepTurns--;
                if (sleepTurns <= 0) {
                    GameContext.get().getBattleTable().queueMessage(name + " woke up!");
                    cureStatus(); // Clears sleep status
                    return true; // Can attack this turn
                } else {
                    GameContext.get().getBattleTable().queueMessage(name + " is fast asleep.");
                    return false;
                }
            case FROZEN:
                if (MathUtils.random() < 0.20f) { // 20% chance to thaw
                    GameContext.get().getBattleTable().queueMessage(name + " thawed out!");
                    cureStatus(); // Clears frozen status
                    return true; // Can attack this turn
                } else {
                    GameContext.get().getBattleTable().queueMessage(name + " is frozen solid!");
                    return false;
                }
            case PARALYZED:
                if (MathUtils.random() < 0.25f) { // 25% chance of full paralysis
                    GameContext.get().getBattleTable().queueMessage(name + " is fully paralyzed!");
                    return false;
                }
                break;
            default:
                break;
        }

        // Check confusion (handled after major statuses)
        if (confused) {
            GameContext.get().getBattleTable().queueMessage(name + " is confused!");
            confusionTurns--;
            if (confusionTurns <= 0) {
                GameContext.get().getBattleTable().queueMessage(name + " snapped out of its confusion!", 1.0f, () -> this.confused = false);
            } else {
                if (MathUtils.random() < 0.33f) { // 33% chance to hit self
                    GameContext.get().getBattleTable().queueMessage("It hurt itself in its confusion!");
                    float damage = calculateConfusionDamage();
                    GameContext.get().getBattleTable().applyDamage(this, damage);
                    if (currentHp <= 0) {
                        setStatus(Status.FAINTED);
                    }
                    return false; // Cannot attack this turn
                }
            }
        }

        return true;
    }

    private float calculateConfusionDamage() {
        int level = this.getLevel();
        float attackStat = this.getStats().getAttack();
        float defenseStat = this.getStats().getDefense();
        int basePower = 40;

        float baseDamage = (((2 * level) / 5f + 2) * basePower * attackStat / defenseStat) / 50f + 2;
        return baseDamage * MathUtils.random(0.85f, 1.0f);
    }

    public void setConfused(boolean confused) {
        if (confused && !this.confused) {
            this.confused = true;
            this.confusionTurns = MathUtils.random(1, 4);
            GameLogger.info(name + " became confused!");
        } else if (!confused) {
            this.confused = false;
            this.confusionTurns = 0;
        }
    }

    public void applyEndOfTurnEffects() {
        if (currentHp <= 0) return;

        BattleTable battleTable = GameContext.get().getBattleTable();
        switch (status) {
            case POISONED:
                battleTable.queueMessage(name + " was hurt by poison!");
                battleTable.applyDamage(this, stats.getHp() / 8f);
                break;
            case BADLY_POISONED:
                battleTable.queueMessage(name + " was badly hurt by poison!");
                battleTable.applyDamage(this, (stats.getHp() * toxicCounter) / 16f);
                toxicCounter = Math.min(toxicCounter + 1, 15);
                break;
            case BURNED:
                battleTable.queueMessage(name + " was hurt by its burn!");
                battleTable.applyDamage(this, stats.getHp() / 16f);
                break;
            default:
                break;
        }

        if (currentHp <= 0) {
            status = Status.FAINTED;
            battleTable.queueMessage(name + " fainted!");
        }
    }



    public void cureStatus() {
        this.status = Status.NONE;
        this.sleepTurns = 0;
        this.toxicCounter = 1;
        this.flinched = false;
        this.confusedTurns = 0;
    }

    public float getStatusModifier(Move move) {
        if (status == Status.BURNED && !move.isSpecial()) {
            return 0.5f; // Burn halves physical attack
        }
        if (status == Status.PARALYZED) {
            return 0.5f; // Paralysis halves speed (implement in speed calculations)
        }
        return 1.0f;
    }

    private void checkLevelUp() {
        int currentLevel = level;
        int expNeeded = getExperienceForNextLevel();

        while (currentExperience >= expNeeded) {
            levelUp();
            GameLogger.info(String.format("%s gained %d experience points!",
                getName(), currentExperience - expNeeded));

            // Update experience for next level check
            currentExperience -= expNeeded;
            expNeeded = getExperienceForNextLevel();
        }
    }

    public void addExperience(int exp) {
        currentExperience += exp;
        checkLevelUp();
    }

    private void levelUp() {
        level++;
        GameLogger.info(getName() + " leveled up to " + level + "!");

        // Use the ChatSystem for a level-up message.
        GameContext.get().getChatSystem().addSystemMessage(getName() + " leveled up to " + level + "!");

        // Save old stats for comparison...
        int oldHp = stats.getHp();
        int oldAttack = stats.getAttack();
        int oldDefense = stats.getDefense();
        int oldSpAtk = stats.getSpecialAttack();
        int oldSpDef = stats.getSpecialDefense();
        int oldSpeed = stats.getSpeed();

        // Recalculate stats...
        calculateStats();

        // Optionally, show stat increases (you might log these or add additional system messages)
        showStatIncrease("HP", oldHp, stats.getHp());
        showStatIncrease("Attack", oldAttack, stats.getAttack());
        showStatIncrease("Defense", oldDefense, stats.getDefense());
        showStatIncrease("Sp. Atk", oldSpAtk, stats.getSpecialAttack());
        showStatIncrease("Sp. Def", oldSpDef, stats.getSpecialDefense());
        showStatIncrease("Speed", oldSpeed, stats.getSpeed());

        calculateStats();
        int hpIncrease = stats.getHp() - oldHp;
        currentHp += hpIncrease; // Also increase current HP

        // Check for new moves
        learnNewMovesAtLevel(level);
    }


    public int getBaseExperience() {
        switch (name.toUpperCase()) {
            case "CHARMANDER":
            case "BULBASAUR":
            case "SQUIRTLE":
                return 64;
            case "PIDGEY":
            case "RATTATA":
                return 50;
            case "PIKACHU":
                return 112;
            default:
                return 60;
        }
    }

    public TextureRegion getCurrentIconFrame(float delta) {
        // Update the timer
        frameTimer += delta;
        if (frameTimer >= frameDuration) {
            frameTimer = 0;
            currentIconFrame = (currentIconFrame + 1) % iconFrames.length; // Toggle between frames
        }
        return iconFrames[currentIconFrame];
    }

    private void loadIcons(TextureAtlas atlas) {
        String baseName = name.toUpperCase();
//        GameLogger.info("Loading sprites for: " + baseName);
        // Load battle and icon sprites
        iconSprite = atlas.findRegion(baseName + "_icon");
        // Load overworld sprite sheet
    }

    private void loadOverworld(TextureAtlas atlas) {
        String baseName = name.toUpperCase();
        TextureRegion overworldSheet = atlas.findRegion(baseName + "_overworld");
        if (overworldSheet != null) {
            animations = new PokemonAnimations(overworldSheet);
        } else {
            GameLogger.error("Failed to load overworld sprite sheet for: " + name);
        }
    }


    private void showStatIncrease(String statName, int oldValue, int newValue) {
        int increase = newValue - oldValue;
        if (increase > 0) {
            GameLogger.info(getName() + "'s " + statName + " increased by " + increase + "!");
        }
    }

    private void learnNewMovesAtLevel(int level) {
        // Get the list of move entries from the Pokémon Database
        List<PokemonDatabase.MoveEntry> moveEntries = PokemonDatabase.getTemplate(name).moves;
        for (PokemonDatabase.MoveEntry entry : moveEntries) {
            if (entry.level == level) {
                // Learn the new move:
                Move newMove = PokemonDatabase.getMoveByName(entry.name);
                if (newMove != null) {
                    Move clonedMove = PokemonDatabase.cloneMove(newMove);
                    // If fewer than 4 moves, simply add the new move.
                    if (moves.size() < 4) {
                        moves.add(clonedMove);
                        GameLogger.info(name + " learned " + entry.name + "!");
                        if (GameContext.get().getBattleTable() != null) {
                            GameContext.get().getBattleTable().displayMessage(name + " learned " + entry.name + "!");
                        }
                    } else {
                        // Otherwise, prompt the user to choose which move to replace.
                        if (GameContext.get().getBattleTable() != null) {
                            GameContext.get().getBattleTable().showMoveReplacementDialog(clonedMove);
                        } else {
                            // Fallback: auto–replace the first move.
                            moves.remove(0);
                            moves.add(clonedMove);
                            GameLogger.info(name + " learned " + entry.name + " by replacing an old move!");
                            if (GameContext.get().getBattleTable() != null) {
                                GameContext.get().getBattleTable().displayMessage(name + " learned " + entry.name + " by replacing an old move!");
                            }
                        }
                    }
                }
            }
        }
    }


    private void loadFront(TextureAtlas atlas) {
        String baseName = name.toUpperCase();
        // Load battle and icon sprites
        frontSprite = atlas.findRegion(baseName + "_front");
        frontShinySprite = atlas.findRegion(baseName + "_front_shiny");
        // Load overworld sprite sheet

    }

    private void loadBack(TextureAtlas atlas) {
        String baseName = name.toUpperCase();
        // Load battle and icon sprites
        backSprite = atlas.findRegion(baseName + "_back");
        backShinySprite = atlas.findRegion(baseName + "_back_shiny");

    }

    public void update(float delta) {
        if (animations != null) {
            animations.update(delta);
        }
    }

    public TextureRegion getIconSprite() {
        return iconSprite;
    }

    public void setIconSprite(TextureRegion iconSprite) {
        this.iconSprite = iconSprite;
    }

    public TextureRegion getFrontSprite() {
        return frontSprite;
    }

    public void setFrontSprite(TextureRegion frontSprite) {
        this.frontSprite = frontSprite;
    }

    public TextureRegion getBackSprite() {
        return backSprite;
    }

    public void setBackSprite(TextureRegion backSprite) {
        this.backSprite = backSprite;
    }

    public TextureRegion getFrontShinySprite() {
        return frontShinySprite;
    }

    public void setFrontShinySprite(TextureRegion frontShinySprite) {
        this.frontShinySprite = frontShinySprite;
    }

    public TextureRegion getBackShinySprite() {
        return backShinySprite;
    }

    public void setBackShinySprite(TextureRegion backShinySprite) {
        this.backShinySprite = backShinySprite;
    }

    public Vector2 getPosition() {
        return position;
    }

    public void setPosition(Vector2 position) {
        this.position = position;
    }

    public String getDirection() {
        return direction;
    }

    public void setDirection(String direction) {
        this.direction = direction;
    }

    public boolean isMoving() {
        return isMoving;
    }

    public void setMoving(boolean moving) {
        isMoving = moving;
    }

    public void render(SpriteBatch batch) {
        if (animations != null) {
            TextureRegion currentFrame = animations.getCurrentFrame(direction, isMoving);
            batch.draw(currentFrame, position.x, position.y);
//            GameLogger.info("Rendering Pokémon: " + name + " at position: " + position);
        }
    }

    private String generateNature() {
        String[] natures = {"Hardy", "Lonely", "Brave", "Adamant", "Naughty", "Bold", "Docile",
            "Relaxed", "Impish", "Lax", "Timid", "Hasty", "Serious", "Jolly",
            "Naive", "Modest", "Mild", "Quiet", "Bashful", "Rash", "Calm",
            "Gentle", "Sassy", "Careful", "Quirky"};
        return natures[new Random().nextInt(natures.length)];
    }

    private boolean calculateShinyStatus() {
        return new Random().nextInt(4096) == 0; // 1/4096 chance in modern games
    }

    // Getters and setters
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getLevel() {
        return level;
    }

    public void setLevel(int level) {
        this.level = level;
    }

    public String getNature() {
        return nature;
    }

    public void setNature(String nature) {
        this.nature = nature;
    }

    public boolean isShiny() {
        return isShiny;
    }

    public void setShiny(boolean shiny) {
        isShiny = shiny;
    }

    public UUID getUuid() {
        return uuid;
    }

    public void setUuid(UUID uuid) {
        this.uuid = uuid;
    }

    public Stats getStats() {
        return stats;
    }

    public void setStats(Stats stats) {
        this.stats = stats;
    }

    public List<Move> getMoves() {
        return moves;
    }

    public void setMoves(List<Move> moves) {
        this.moves = moves;
    }

    public PokemonType getPrimaryType() {
        return primaryType;
    }

    public void setPrimaryType(PokemonType type) {
        this.primaryType = type;
    }

    public PokemonType getSecondaryType() {
        return secondaryType;
    }

    public void setSecondaryType(PokemonType type) {
        this.secondaryType = type;
    }

    public int getCurrentHp() {
        return (int) currentHp;
    }

    public void setCurrentHp(float hp) {
        this.currentHp = hp;
    }

    public PokemonAnimations getAnimations() {
        return animations;
    }

    public void setAnimations(PokemonAnimations animations) {
        this.animations = animations;
    }

    public int getToxicCounter() {
        return toxicCounter;
    }

    public void incrementToxicCounter() {
        toxicCounter = Math.min(toxicCounter + 1, 15); // Cap at 15
    }

    public void resetToxicCounter() {
        toxicCounter = 1;
    }


    int calculateStat(int base, int iv, int ev) {
        // Example uses a nature modifier with ±10% random variation.
        float natureModifier = 1.0f + (new Random().nextFloat() * 0.2f - 0.1f);
        return (int) (((2 * base + iv + (float) ev / 4) * level / 100f + 5) * natureModifier);
    }

    // --- Modified calculateStats ---
    // Apply stat stage modifiers AND status modifiers
    public void calculateStats() {
        // Calculate base stats from IVs/EVs/Level/Nature (keep existing logic)
        stats.setHp(((2 * speciesBaseHp + stats.ivs[0] + stats.evs[0] / 4) * level / 100) + level + 10);
        int baseAttack = calculateStat(speciesBaseAttack, stats.ivs[1], stats.evs[1]);
        int baseDefense = calculateStat(speciesBaseDefense, stats.ivs[2], stats.evs[2]);
        int baseSpAtk = calculateStat(speciesBaseSpAtk, stats.ivs[3], stats.evs[3]);
        int baseSpDef = calculateStat(speciesBaseSpDef, stats.ivs[4], stats.evs[4]);
        int baseSpeed = calculateStat(speciesBaseSpeed, stats.ivs[5], stats.evs[5]);

        // Apply stat stage modifiers
        stats.setAttack(Math.max(1, (int) (baseAttack * getStatModifier("attack"))));
        stats.setDefense(Math.max(1, (int) (baseDefense * getStatModifier("defense"))));
        stats.setSpecialAttack(Math.max(1, (int) (baseSpAtk * getStatModifier("spAtk"))));
        stats.setSpecialDefense(Math.max(1, (int) (baseSpDef * getStatModifier("spDef"))));
        stats.setSpeed(Math.max(1, (int) (baseSpeed * getStatModifier("speed"))));

        // Apply status condition modifiers (e.g., paralysis halves speed)
        if (status == Status.PARALYZED) {
            stats.setSpeed(stats.getSpeed() / 2);
        }
        // Apply burn attack reduction (halves physical attack)
        if (status == Status.BURNED) {
            stats.setAttack(stats.getAttack() / 2);
        }
        // Ensure stats don't drop below 1
        stats.setAttack(Math.max(1, stats.getAttack()));
        stats.setDefense(Math.max(1, stats.getDefense()));
        stats.setSpecialAttack(Math.max(1, stats.getSpecialAttack()));
        stats.setSpecialDefense(Math.max(1, stats.getSpecialDefense()));
        stats.setSpeed(Math.max(1, stats.getSpeed()));
    }

    public enum Status {
        NONE,
        PARALYZED,
        POISONED,
        BADLY_POISONED,
        BURNED,
        FROZEN,
        ASLEEP,
        LEECH_SEED,  // NEW!
        FAINTED
    }


    public enum Weather {
        CLEAR,
        RAIN,
        SUNNY,
        SANDSTORM,
        HAIL
    }

    public enum PokemonType {
        NORMAL, FIRE, WATER, ELECTRIC, GRASS, ICE, FIGHTING, POISON, GROUND, FLYING,
        PSYCHIC, BUG, ROCK, GHOST, DRAGON, DARK, STEEL, FAIRY, UNKNOWN
    }

    public static class Stats {
        public int[] ivs;
        public int[] evs;
        private int hp;
        private int attack;
        private int defense;
        private int specialAttack;
        private int specialDefense;
        private int speed;

        public Stats() {
            this.ivs = generateIVs();
            this.evs = new int[6];
        }

        private int[] generateIVs() {
            int[] ivs = new int[6];
            Random random = new Random();
            for (int i = 0; i < 6; i++) {
                ivs[i] = random.nextInt(32);
            }
            return ivs;
        }

        public int getHp() {
            return hp;
        }

        public void setHp(int hp) {
            this.hp = hp;
        }

        public int getAttack() {
            return attack;
        }

        public void setAttack(int attack) {
            this.attack = attack;
        }

        public int getDefense() {
            return defense;
        }

        public void setDefense(int defense) {
            this.defense = defense;
        }

        public int getSpecialAttack() {
            return specialAttack;
        }

        public void setSpecialAttack(int specialAttack) {
            this.specialAttack = specialAttack;
        }

        public int getSpecialDefense() {
            return specialDefense;
        }

        public void setSpecialDefense(int specialDefense) {
            this.specialDefense = specialDefense;
        }

        public int getSpeed() {
            return speed;
        }

        public void setSpeed(int speed) {
            this.speed = speed;
        }
    }

    public static class Builder {
        private final Pokemon pokemon;

        public Builder(String name, int level) {
            pokemon = new Pokemon(name, level);
        }

        public Builder withType(PokemonType primary, PokemonType secondary) {
            pokemon.setPrimaryType(primary);
            pokemon.setSecondaryType(secondary);
            return this;
        }

        public Builder withStats(int hp, int attack, int defense, int spAtk, int spDef, int speed) {
            pokemon.getStats().setHp(hp);
            pokemon.getStats().setAttack(attack);
            pokemon.getStats().setDefense(defense);
            pokemon.getStats().setSpecialAttack(spAtk);
            pokemon.getStats().setSpecialDefense(spDef);
            pokemon.getStats().setSpeed(speed);
            pokemon.setCurrentHp(hp);
            return this;
        }

        public Builder withMoves(List<Move> moves) {
            pokemon.setMoves(new ArrayList<>(moves));
            return this;
        }

        public Builder withStatus(Status status) {
            pokemon.setStatus(status);
            return this;
        }

        public Pokemon build() {
            if (pokemon.getMoves().isEmpty()) {
            }
            return pokemon;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/pokemon/PokemonCaptureAnimation.java
================
package io.github.pokemeetup.pokemon;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.*;
import com.badlogic.gdx.math.Interpolation;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Array;

public class PokemonCaptureAnimation extends Actor {
    private final Animation<TextureRegion> throwAnimation;
    private final float throwDuration;
    private final TextureRegion openRegion;
    private final CaptureListener listener;
    private final Vector2 startPos;
    private final Vector2 targetPos;
    private final float captureChance; // Value between 0 and 1
    private float stateTime;
    private boolean reachedTarget;
    private boolean wiggleStarted;
    // This field will store the outcome once decided (null = not decided yet)
    private Boolean captureSuccess = null;

    // New field for the enemy Pokémon actor (e.g. its Image) that will be animated.
    private final Actor enemyPokemonActor;
    // Store the enemy actor’s original position so we can restore it on failure.
    private final float enemyOrigX, enemyOrigY;

    // Constant for arc height – adjust this value to suit your scene.
    private final float ARC_HEIGHT = 50f;

    /**
     * Updated constructor includes an enemy actor parameter.
     */
    public PokemonCaptureAnimation(TextureAtlas capsuleThrowAtlas, Vector2 startPos, Vector2 targetPos,
                                   float throwDuration, float captureChance, CaptureListener listener,
                                   Actor enemyPokemonActor) {
        this.startPos = new Vector2(startPos);
        this.targetPos = new Vector2(targetPos);
        this.throwDuration = throwDuration;
        this.listener = listener;
        this.stateTime = 0f;
        this.reachedTarget = false;
        this.wiggleStarted = false;
        this.captureChance = captureChance;
        this.enemyPokemonActor = enemyPokemonActor;
        // Store original enemy position so we can restore it if capture fails.
        if (enemyPokemonActor != null) {
            this.enemyOrigX = enemyPokemonActor.getX();
            this.enemyOrigY = enemyPokemonActor.getY();
        } else {
            this.enemyOrigX = 0;
            this.enemyOrigY = 0;
        }

        // Retrieve throw frames from atlas.
        Array<TextureRegion> throwFrames = new Array<>();
        Array<? extends TextureRegion> regions = capsuleThrowAtlas.findRegions("ball_POKEBALL");
        if (regions != null && regions.size > 1) {
            throwFrames.addAll(regions, 0, regions.size);
        } else {
            TextureRegion region = capsuleThrowAtlas.findRegion("ball_POKEBALL");
            if (region != null) {
                int frameCount = 8;
                for (int i = 0; i < frameCount; i++) {
                    // Slice region into 8 frames (each 32x64)
                    TextureRegion frame = new TextureRegion(region, i * 32, 0, 32, 64);
                    throwFrames.add(frame);
                }
            } else {
                throw new IllegalArgumentException("Pokéball throw region not found in capsuleThrow atlas.");
            }
        }
        float frameDuration = throwDuration / throwFrames.size;
        throwAnimation = new Animation<>(frameDuration, throwFrames, Animation.PlayMode.LOOP);

        // The open ball image (could be used for an extra flourish)
        openRegion = capsuleThrowAtlas.findRegion("ball_POKEBALL_open");
        if (openRegion == null) {
            throw new IllegalArgumentException("Pokéball open region not found in capsuleThrow atlas.");
        }

        setSize(32, 64);
        // Adjust position so that the actor’s center matches the provided start position.
        setPosition(startPos.x - getWidth() / 2, startPos.y - getHeight() / 2);
    }

    @Override
    public void act(float delta) {
        super.act(delta);

        // If we haven’t reached the enemy yet, update our position along an arc.
        if (!reachedTarget) {
            stateTime += delta;
            float progress = Math.min(stateTime / throwDuration, 1f);
            // Compute an arcing trajectory: linear interpolation plus a sine-based vertical offset.
            float x = MathUtils.lerp(startPos.x, targetPos.x, progress);
            float baseY = MathUtils.lerp(startPos.y, targetPos.y, progress);
            float y = baseY + ARC_HEIGHT * MathUtils.sin(MathUtils.PI * progress);
            setPosition(x - getWidth() / 2, y - getHeight() / 2);

            if (progress >= 1f) {
                reachedTarget = true;
                stateTime = 0f;
                // Snap to the closed ball frame and reset rotation.
                clearActions();
                setRotation(0);
                // Begin the wiggle sequence, then suck in the enemy, and finally decide outcome.
                addAction(Actions.sequence(
                    Actions.delay(0.1f),
                    wiggleSequence(),
                    Actions.run(this::suckInEnemy),
                    Actions.delay(0.3f),
                    Actions.run(this::decideOutcome)
                ));
            }
        }
    }

    @Override
    public void draw(Batch batch, float parentAlpha) {
        TextureRegion frame;
        // Use the throwing animation while en route.
        if (!reachedTarget) {
            frame = throwAnimation.getKeyFrame(stateTime, true);
        } else {
            // Once reached, display the closed Pokéball (first frame).
            frame = throwAnimation.getKeyFrame(0);
        }
        // Draw using the center as the origin.
        batch.draw(frame, getX(), getY(), getWidth() / 2, getHeight() / 2,
            getWidth(), getHeight(), getScaleX(), getScaleY(), getRotation());
    }

    /**
     * Creates a sequence of three wiggles using rotation actions.
     */
    private com.badlogic.gdx.scenes.scene2d.Action wiggleSequence() {
        // One wiggle: rotate right, then left, then back to center.
        com.badlogic.gdx.scenes.scene2d.Action wiggle = Actions.sequence(
            Actions.rotateBy(10, 0.1f, Interpolation.sine),
            Actions.rotateBy(-20, 0.2f, Interpolation.sine),
            Actions.rotateBy(10, 0.1f, Interpolation.sine)
        );
        return Actions.sequence(wiggle, wiggle, wiggle);
    }

    /**
     * Animates the enemy Pokémon actor being sucked into the center of the ball.
     */
    private void suckInEnemy() {
        if (enemyPokemonActor != null && enemyPokemonActor.getParent() != null) {
            enemyPokemonActor.clearActions();
            // Ensure the enemy actor's origin is centered.
            enemyPokemonActor.setOrigin(Align.center);
            // Get the center of the ball in stage coordinates.
            Vector2 ballCenterStage = new Vector2(getX() + getWidth() / 2, getY() + getHeight() / 2);
            // Convert the ball center into the enemy actor's parent's coordinate system.
            Vector2 targetPos = enemyPokemonActor.getParent().stageToLocalCoordinates(ballCenterStage);
            // Move the enemy actor to the target, offsetting so that its center matches.
            enemyPokemonActor.addAction(Actions.parallel(
                Actions.moveTo(targetPos.x - enemyPokemonActor.getWidth() / 2,
                    targetPos.y - enemyPokemonActor.getHeight() / 2,
                    0.3f, Interpolation.fade),
                Actions.scaleTo(0, 0, 0.3f, Interpolation.fade),
                Actions.fadeOut(0.3f)
            ));
        }
    }




    /**
     * Animates the enemy Pokémon actor breaking out of the ball (only called on capture failure).
     */
    private void enemyBreakOut() {
        if (enemyPokemonActor != null) {
            enemyPokemonActor.clearActions();
            // Reset enemy actor properties to start the breakout animation.
            enemyPokemonActor.setColor(1, 1, 1, 0); // start transparent
            enemyPokemonActor.setScale(0);
            enemyPokemonActor.addAction(Actions.sequence(
                Actions.delay(0.1f),
                Actions.parallel(
                    Actions.fadeIn(0.3f),
                    Actions.scaleTo(1, 1, 0.3f, Interpolation.fade),
                    Actions.moveTo(enemyOrigX, enemyOrigY, 0.3f, Interpolation.sineOut)
                )
            ));
        }
    }

    /**
     * Decides the outcome of the capture (success/failure) after the enemy has been sucked in.
     * On success, the ball shrinks (keeping the enemy hidden). On failure, the enemy breaks out and the ball bounces.
     */
    private void decideOutcome() {
        // Determine capture outcome based on chance.
        boolean success = MathUtils.random() < captureChance;
        captureSuccess = success;
        clearActions();
        if (success) {
            // On success, animate the ball shrinking.
            addAction(Actions.sequence(
                Actions.scaleTo(0, 0, 0.3f, Interpolation.fade),
                Actions.run(() -> {
                    if (listener != null) listener.onCaptureComplete(true);
                    remove();
                })
            ));
        } else {
            // On failure, animate the enemy breaking out.
            enemyBreakOut();
            // Also animate the ball bouncing upward.
            addAction(Actions.sequence(
                Actions.moveBy(0, 20, 0.2f, Interpolation.sineOut),
                Actions.moveBy(0, -20, 0.2f, Interpolation.sineIn),
                Actions.run(() -> {
                    if (listener != null) listener.onCaptureComplete(false);
                    remove();
                })
            ));
        }
    }

    public interface CaptureListener {
        void onCaptureComplete(boolean success);
    }
}

================
File: src/main/java/io/github/pokemeetup/pokemon/PokemonDespawnAnimation.java
================
package io.github.pokemeetup.pokemon;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;

public class PokemonDespawnAnimation {
    private final float duration;
    private float timer;
    private final float x, y;
    private final float frameWidth, frameHeight;

    public PokemonDespawnAnimation(float x, float y, float frameWidth, float frameHeight) {
        this.duration = 2.0f;
        this.timer = 0f;
        this.x = x;
        this.y = y;
        this.frameWidth = frameWidth;
        this.frameHeight = frameHeight;
    }

    public boolean update(float delta) {
        timer += delta;
        return timer >= duration;
    }

    /**
     * Renders the current frame of the animation with a fading effect,
     * correctly preserving the day/night color tint from the SpriteBatch.
     */
    public void render(SpriteBatch batch, TextureRegion currentFrame) {
        // Save the batch's current color, which includes the day/night tint.
        Color originalColor = batch.getColor().cpy();

        // Calculate the fading alpha for the despawn effect.
        float despawnAlpha = MathUtils.clamp(1 - (timer / duration), 0, 1);

        // Modulate the batch's current alpha with our despawn alpha.
        float finalAlpha = originalColor.a * despawnAlpha;
        batch.setColor(originalColor.r, originalColor.g, originalColor.b, finalAlpha);

        // Draw the pokemon frame with the new faded color.
        if (currentFrame != null) {
            batch.draw(currentFrame, x, y, frameWidth, frameHeight);
        }

        // IMPORTANT: Restore the batch color to its original state.
        batch.setColor(originalColor);
    }
}

================
File: src/main/java/io/github/pokemeetup/pokemon/PokemonParty.java
================
package io.github.pokemeetup.pokemon;

import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class PokemonParty {
    public static final int MAX_PARTY_SIZE = 6;
    private final List<Pokemon> party;
    public final Object partyLock = new Object();
    private int activePokemonIndex = 0; // Track which Pokemon is currently active in battle

    public PokemonParty() {
        this.party = new ArrayList<>(MAX_PARTY_SIZE);
    }

    /**
     * Add a Pokemon to the party if there's room
     * @param pokemon The Pokemon to add
     * @return true if added successfully, false if party is full
     */
    public boolean addPokemon(Pokemon pokemon) {
        synchronized (partyLock) {
            if (party.size() >= MAX_PARTY_SIZE) {
                GameLogger.info("Party is full, cannot add " + pokemon.getName());
                return false;
            }
            party.add(pokemon);
            GameLogger.info(pokemon.getName() + " was added to the party!");
            return true;
        }
    }

    /**
     * Get the first healthy Pokemon in the party
     * @return The first Pokemon with HP > 0, or null if none
     */
    public Pokemon getFirstHealthyPokemon() {
        synchronized (partyLock) {
            for (Pokemon pokemon : party) {
                if (pokemon.getCurrentHp() > 0) {
                    return pokemon;
                }
            }
            return null; // No healthy Pokemon found
        }
    }

    /**
     * Get the first Pokemon in the party
     * @return The first Pokemon, or null if party is empty
     */
    public Pokemon getFirstPokemon() {
        synchronized (partyLock) {
            return party.isEmpty() ? null : party.get(0);
        }
    }

    /**
     * Get the currently active Pokemon for battle
     * @return The active Pokemon, or null if none
     */
    public Pokemon getActivePokemon() {
        synchronized (partyLock) {
            if (activePokemonIndex >= 0 && activePokemonIndex < party.size()) {
                return party.get(activePokemonIndex);
            }
            // Fallback: reset to first healthy Pokemon
            Pokemon healthy = getFirstHealthyPokemon();
            if (healthy != null) {
                activePokemonIndex = party.indexOf(healthy);
                return healthy;
            }
            return null;
        }
    }

    /**
     * Set a Pokemon as the active one for battle
     * @param index The index of the Pokemon to set as active
     * @return true if successful, false if index is invalid
     */
    public boolean setActivePokemon(int index) {
        synchronized (partyLock) {
            if (index >= 0 && index < party.size() && party.get(index).getCurrentHp() > 0) {
                activePokemonIndex = index;
                GameLogger.info(party.get(index).getName() + " is now the active Pokemon!");
                return true;
            }
            return false;
        }
    }

    /**
     * Clear all Pokemon from the party
     */
    public void clearParty() {
        synchronized (partyLock) {
            party.clear();
            activePokemonIndex = 0;
        }
    }

    /**
     * Remove a Pokemon from the party
     * @param index The index of the Pokemon to remove
     * @return The removed Pokemon, or null if index is invalid
     */
    public Pokemon removePokemon(int index) {
        synchronized (partyLock) {
            if (index >= 0 && index < party.size()) {
                Pokemon removed = party.remove(index);

                // Update active Pokemon index if necessary
                if (index == activePokemonIndex) {
                    activePokemonIndex = 0; // Reset to first Pokemon
                } else if (index < activePokemonIndex) {
                    activePokemonIndex--; // Adjust index if removed Pokemon was before active one
                }

                return removed;
            }
            return null;
        }
    }

    /**
     * Swap the positions of two Pokemon in the party
     * @param index1 The index of the first Pokemon
     * @param index2 The index of the second Pokemon
     */
    public void swapPositions(int index1, int index2) {
        synchronized (partyLock) {
            if (index1 >= 0 && index1 < party.size() &&
                index2 >= 0 && index2 < party.size()) {

                // Update active Pokemon index if necessary
                if (activePokemonIndex == index1) {
                    activePokemonIndex = index2;
                } else if (activePokemonIndex == index2) {
                    activePokemonIndex = index1;
                }

                Collections.swap(party, index1, index2);
                GameLogger.info("Swapped " + party.get(index2).getName() +
                    " with " + party.get(index1).getName());
            }
        }
    }

    /**
     * Get a Pokemon by index
     * @param index The index of the Pokemon to get
     * @return The Pokemon, or null if index is invalid
     */
    public Pokemon getPokemon(int index) {
        synchronized (partyLock) {
            if (index >= 0 && index < party.size()) {
                return party.get(index);
            }
            return null;
        }
    }

    /**
     * Get a shallow copy of all Pokemon in the party
     * @return A list containing all Pokemon in the party
     */
    public List<Pokemon> getParty() {
        synchronized (partyLock) {
            return new ArrayList<>(party);
        }
    }

    /**
     * Get the number of Pokemon in the party
     * @return The party size
     */
    public int getSize() {
        synchronized (partyLock) {
            return party.size();
        }
    }

    /**
     * Check if the party is full
     * @return true if the party has reached MAX_PARTY_SIZE
     */
    public boolean isFull() {
        synchronized (partyLock) {
            return party.size() >= MAX_PARTY_SIZE;
        }
    }

    /**
     * Get the number of healthy Pokemon in the party
     * @return The number of Pokemon with HP > 0
     */
    public int getHealthyPokemonCount() {
        synchronized (partyLock) {
            int count = 0;
            for (Pokemon pokemon : party) {
                if (pokemon.getCurrentHp() > 0) {
                    count++;
                }
            }
            return count;
        }
    }

    /**
     * Heal all Pokemon in the party to full health and cure status conditions
     */
    public void healAllPokemon() {
        synchronized (partyLock) {
            for (Pokemon pokemon : party) {
                pokemon.heal(); // Using the Pokemon class heal method
            }
            GameLogger.info("All Pokemon have been healed!");
        }
    }

    /**
     * Check if at least one Pokemon in the party is alive
     * @return true if any Pokemon has HP > 0
     */
    public boolean hasAlivePokemon() {
        synchronized (partyLock) {
            for (Pokemon pokemon : party) {
                if (pokemon.getCurrentHp() > 0) {
                    return true;
                }
            }
            return false;
        }
    }

    /**
     * Award experience to the active Pokemon
     * @param amount The amount of experience to award
     * @return true if the active Pokemon leveled up, false otherwise
     */
    public boolean awardExperienceToActive(int amount) {
        synchronized (partyLock) {
            Pokemon active = getActivePokemon();
            if (active != null) {
                int oldLevel = active.getLevel();
                active.addExperience(amount);
                GameLogger.info(active.getName() + " gained " + amount + " experience points!");
                return active.getLevel() > oldLevel; // Return true if leveled up
            }
            return false;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/pokemon/server/PokemonNetworkSyncComponent.java
================
package io.github.pokemeetup.pokemon.server;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.pokemon.WildPokemon;

/**
 * Handles network synchronization for WildPokemon entities,
 * providing smooth interpolation between server updates.
 */
public class PokemonNetworkSyncComponent {
    private final WildPokemon pokemon;

    // Interpolation settings
    private static final float INTERPOLATION_SPEED = 5.0f; // Lower for smoother but slower adjustments
    private static final float POSITION_THRESHOLD = 0.1f; // Distance threshold to consider positions equal

    // Network state
    private Vector2 serverPosition = new Vector2();
    private String serverDirection = "down";
    private boolean serverMoving = false;
    private long lastUpdateTime = 0;

    // Interpolation state
    private Vector2 interpolationStart = new Vector2();
    private Vector2 interpolationTarget = new Vector2();
    private float interpolationProgress = 1.0f;

    // Smoothing state
    private boolean isInterpolating = false;

    public PokemonNetworkSyncComponent(WildPokemon pokemon) {
        this.pokemon = pokemon;
        this.serverPosition.set(pokemon.getX(), pokemon.getY());
        this.interpolationStart.set(pokemon.getX(), pokemon.getY());
        this.interpolationTarget.set(pokemon.getX(), pokemon.getY());
    }

    /**
     * Process a network update received from the server
     */
    public void processNetworkUpdate(float x, float y, String direction, boolean isMoving, long timestamp) {
        // Ignore outdated updates
        if (timestamp <= lastUpdateTime) {
            return;
        }

        lastUpdateTime = timestamp;
        serverPosition.set(x, y);
        serverDirection = direction;
        serverMoving = isMoving;

        // If we're more than POSITION_THRESHOLD away from the target, start interpolating
        if (Vector2.dst(pokemon.getX(), pokemon.getY(), x, y) > POSITION_THRESHOLD) {
            startInterpolation(x, y);
        }

        // Always update the direction and movement state immediately
        pokemon.setDirection(direction);
        pokemon.setMoving(isMoving);
    }

    /**
     * Start interpolating to a new position
     */
    private void startInterpolation(float x, float y) {
        interpolationStart.set(pokemon.getX(), pokemon.getY());
        interpolationTarget.set(x, y);
        interpolationProgress = 0.0f;
        isInterpolating = true;
    }

    /**
     * Update the interpolation (called every frame)
     */
    public void update(float deltaTime) {
        if (!isInterpolating) {
            return;
        }

        // Advance interpolation progress
        interpolationProgress += deltaTime * INTERPOLATION_SPEED;

        // Apply smooth step function for more natural movement
        float t = calculateSmoothStep(interpolationProgress);

        // Calculate interpolated position
        float x = interpolationStart.x + (interpolationTarget.x - interpolationStart.x) * t;
        float y = interpolationStart.y + (interpolationTarget.y - interpolationStart.y) * t;

        // Apply the interpolated position to the Pokemon
        pokemon.setX(x);
        pokemon.setY(y);

        // If we're done interpolating, snap to final position
        if (interpolationProgress >= 1.0f) {
            pokemon.setX(interpolationTarget.x);
            pokemon.setY(interpolationTarget.y);
            isInterpolating = false;
        }

        // Update the bounding box with the new position
        pokemon.updateBoundingBox();
    }

    /**
     * Calculate a smooth step function for more natural movement
     */
    private float calculateSmoothStep(float x) {
        x = Math.min(1.0f, Math.max(0.0f, x));
        return x * x * (3 - 2 * x);
    }

    /**
     * Returns true if this Pokemon is currently being interpolated
     */
    public boolean isInterpolating() {
        return isInterpolating;
    }

    /**
     * Gets the server's canonical position of this Pokemon
     */
    public Vector2 getServerPosition() {
        return serverPosition;
    }
}

================
File: src/main/java/io/github/pokemeetup/pokemon/WildPokemon.java
================
package io.github.pokemeetup.pokemon;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.pokemon.data.PokemonDatabase;
import io.github.pokemeetup.pokemon.server.PokemonNetworkSyncComponent;
import io.github.pokemeetup.system.Positionable;
import io.github.pokemeetup.system.gameplay.PokemonAnimations;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.PokemonSpawnManager;

import java.util.ArrayList;
import java.util.List;

import static io.github.pokemeetup.system.gameplay.PokemonAnimations.IDLE_BOUNCE_DURATION;

public class WildPokemon extends Pokemon implements Positionable {
    private static final float SCALE = 2.0f;
    private static final float TILE_SIZE = 32f;
    private static final float MOVEMENT_DURATION = 0.75f;
    // FIX: Adjusted collision scale to be more accurate, similar to the player's.
    private static final float COLLISION_SCALE = 0.6f;
    private static final float COLLISION_HEIGHT_SCALE = 0.4f;
    private static final float FRAME_WIDTH = World.TILE_SIZE;
    private static final float FRAME_HEIGHT = World.TILE_SIZE;
    private static final float IDLE_BOUNCE_HEIGHT = 2f;

    // Enhanced AI and behavior
    private PokemonAI enhancedAI;
    private Object legacyAI; // Keep for backward compatibility

    // Core properties
    private final PokemonAnimations animations;
    private Rectangle boundingBox;
    private PokemonNetworkSyncComponent networkSync;
    private boolean isNetworkControlled = false;

    // Position and movement
    private float width;
    private float height;
    private float pixelX;
    private float pixelY;
    private float x;
    private float y;
    private boolean isMoving;
    private Vector2 startPosition;
    private Vector2 targetPosition;
    private float movementProgress;
    private float currentMoveTime = 0f;
    private boolean isInterpolating = false;
    private float lastUpdateX;
    private float lastUpdateY;

    // Game state
    private World world;
    private long spawnTime;
    private String direction;
    private boolean isExpired = false;
    private boolean isAddedToParty = false;
    private boolean isDespawning = false;
    private PokemonDespawnAnimation despawnAnimation;
    private float idleAnimationTime = 0;
    private boolean isIdling = false;

    // Constructors
    public WildPokemon(String name, int level) {
        super(name, level);
        this.pixelX = 0;
        this.pixelY = 0;
        this.networkSync = new PokemonNetworkSyncComponent(this);
        this.isNetworkControlled = false;
        this.x = 0;
        this.y = 0;
        this.startPosition = new Vector2(0, 0);
        this.targetPosition = new Vector2(0, 0);
        this.direction = "down";
        this.currentMoveTime = 0;
        this.width = 0;
        this.height = 0;
        this.boundingBox = new Rectangle(0, 0, 0, 0);
        this.animations = null;

        initializePokemonData(name, level);
    }

    public WildPokemon(String name, int level, int pixelX, int pixelY, boolean noTexture) {
        super(noTexture);

        // Snap position to tile grid
        int tileX = MathUtils.floor((float) pixelX / World.TILE_SIZE);
        int tileY = MathUtils.floor((float) pixelY / World.TILE_SIZE);
        // FIX: Align position to the bottom-center of the tile, just like the player.
        this.pixelX = tileX * World.TILE_SIZE + (World.TILE_SIZE / 2f);
        this.pixelY = tileY * World.TILE_SIZE;
        this.x = this.pixelX;
        this.y = this.pixelY;

        this.level = level;
        this.name = name;
        this.isNetworkControlled = true;
        this.animations = null;

        setSpawnTime(System.currentTimeMillis() / 1000L);
        initializePokemonData(name, level);
        initializeBoundingBox();

        this.direction = "down";
        this.isMoving = false;
    }

    public WildPokemon(String name, int level, int pixelX, int pixelY, TextureRegion overworldSprite) {
        super(name, level);
        // FIX: Align position to the bottom-center of the tile.
        this.pixelX = pixelX + (World.TILE_SIZE / 2f);
        this.pixelY = pixelY;
        this.x = this.pixelX;
        this.y = this.pixelY;
        this.networkSync = new PokemonNetworkSyncComponent(this);
        this.isNetworkControlled = false;
        this.startPosition = new Vector2(this.x, this.y);
        this.targetPosition = new Vector2(this.x, this.y);
        this.direction = "down";
        this.animations = new PokemonAnimations(overworldSprite);
        this.width = World.TILE_SIZE * SCALE;
        this.height = World.TILE_SIZE * SCALE;

        setSpawnTime((long) (System.currentTimeMillis() / 1000f));
        initializePokemonData(name, level);

        // Enhanced AI will be set by the spawn manager
    }

    private void initializePokemonData(String name, int level) {
        PokemonDatabase.PokemonTemplate template = PokemonDatabase.getTemplate(name);
        if (template != null) {
            setPrimaryType(template.primaryType);
            setSecondaryType(template.secondaryType);

            if (animations != null) {
                this.width *= template.width;
                this.height *= template.height;
            }

            // Calculate stats
            int baseHp = template.baseStats.baseHp;
            int baseAtk = template.baseStats.baseAttack;
            int baseDef = template.baseStats.baseDefense;
            int baseSpAtk = template.baseStats.baseSpAtk;
            int baseSpDef = template.baseStats.baseSpDef;
            int baseSpd = template.baseStats.baseSpeed;

            Stats stats = getStats();
            boolean isHpStat = true;
            stats.setHp(calculateStat(baseHp, stats.ivs[0], stats.evs[0], level, isHpStat));
            stats.setAttack(calculateStat(baseAtk, stats.ivs[1], stats.evs[1], level, false));
            stats.setDefense(calculateStat(baseDef, stats.ivs[2], stats.evs[2], level, false));
            stats.setSpecialAttack(calculateStat(baseSpAtk, stats.ivs[3], stats.evs[3], level, false));
            stats.setSpecialDefense(calculateStat(baseSpDef, stats.ivs[4], stats.evs[4], level, false));
            stats.setSpeed(calculateStat(baseSpd, stats.ivs[5], stats.evs[5], level, false));

            setCurrentHp(stats.getHp());

            if (template.moves != null && !template.moves.isEmpty()) {
                List<Move> moves = PokemonDatabase.getMovesForLevel(template.moves, level);
                setMoves(moves);
            }
        }
    }

    private void initializeBoundingBox() {
        // FIX: Collision box is now sized relative to a tile and centered on the Pokemon's position.
        float collisionWidth = World.TILE_SIZE * COLLISION_SCALE;
        float collisionHeight = World.TILE_SIZE * COLLISION_HEIGHT_SCALE;
        float bboxX = this.x - collisionWidth / 2f;
        float bboxY = this.y;
        this.boundingBox = new Rectangle(bboxX, bboxY, collisionWidth, collisionHeight);
    }

    private int calculateStat(int base, int iv, int ev, int level, boolean isHp) {
        if (isHp) {
            return ((2 * base + iv + ev / 4) * level / 100) + level + 10;
        } else {
            return ((2 * base + iv + ev / 4) * level / 100) + 5;
        }
    }

    // AI Management
    public void setAi(Object ai) {
        if (ai instanceof PokemonAI) {
            this.enhancedAI = (PokemonAI) ai;
            this.legacyAI = null;
        } else {
            this.legacyAI = ai;
            this.enhancedAI = null;
        }
    }  public Rectangle getBoundingBox() {
        return new Rectangle(
            (float)getTileX() * World.TILE_SIZE,
            (float)getTileY() * World.TILE_SIZE,
            World.TILE_SIZE,
            World.TILE_SIZE
        );
    }


    public Object getAi() {
        return enhancedAI != null ? enhancedAI : legacyAI;
    }

    public PokemonAI getEnhancedAI() {
        return enhancedAI;
    }

    // Network and synchronization
    public void setNetworkControlled(boolean networkControlled) {
        this.isNetworkControlled = networkControlled;
    }

    public void applyNetworkUpdate(float x, float y, String direction, boolean isMoving, long timestamp) {
        if (networkSync != null) {
            networkSync.processNetworkUpdate(x, y, direction, isMoving, timestamp);
        }
    }

    public PokemonNetworkSyncComponent getNetworkSync() {
        return networkSync;
    }

    // Update method with enhanced AI support
    public void update(float delta, World world) {
        if (world == null) return;

        if (isDespawning) {
            if (despawnAnimation != null && despawnAnimation.update(delta)) {
                isExpired = true;
            }
            return;
        }

        // Handle network synchronization first
        if (isNetworkControlled && networkSync != null) {
            networkSync.update(delta);

            if (networkSync.isInterpolating()) {
                if (animations != null) {
                    animations.update(delta);
                }
                return;
            }
        }

        // Use enhanced AI if available, otherwise fall back to legacy
        if (!isNetworkControlled) {
            if (enhancedAI != null) {
                enhancedAI.update(delta, world);
            } else if (legacyAI != null) {
                // Legacy AI update would go here
                // For now, we'll use enhanced AI as the default
            }
        }

        // Update movement and animations
        if (isMoving) {
            updateMovement(delta);
            idleAnimationTime = 0;
        } else {
            updateIdleAnimation(delta);
        }

        if (animations != null) {
            animations.update(delta);
            if (isMoving != animations.isMoving()) {
                if (isMoving) {
                    animations.startMoving(direction);
                } else {
                    animations.stopMoving();
                }
            }
        }

        updateWaterSoundTimer(delta);
        updateBoundingBox();
    }

    private void updateIdleAnimation(float delta) {
        idleAnimationTime = (idleAnimationTime + delta) % IDLE_BOUNCE_DURATION;
    }

    private void updateMovement(float delta) {
        if (!isMoving || !isInterpolating) return;

        currentMoveTime += delta;
        movementProgress = Math.min(currentMoveTime / MOVEMENT_DURATION, 1.0f);

        // Smooth interpolation
        float smoothProgress = calculateSmoothProgress(movementProgress);

        float newX = MathUtils.lerp(startPosition.x, targetPosition.x, smoothProgress);
        float newY = MathUtils.lerp(startPosition.y, targetPosition.y, smoothProgress);

        if (newX != lastUpdateX || newY != lastUpdateY) {
            setX(newX);
            setY(newY);
            lastUpdateX = newX;
            lastUpdateY = newY;
            updateBoundingBox();
        }

        if (movementProgress >= 1.0f) {
            completeMovement();
        }
    }

    private float calculateSmoothProgress(float progress) {
        return progress * progress * (3 - 2 * progress);
    }

    private void completeMovement() {
        isInterpolating = false;
        isMoving = false;
        currentMoveTime = 0f;

        setX(targetPosition.x);
        setY(targetPosition.y);

        if (animations != null) {
            animations.stopMoving();
        }

        updateBoundingBox();
    }

    public void moveToTile(int targetTileX, int targetTileY, String newDirection) {
        if (!isMoving) {
            startPosition.set(x, y);
            lastUpdateX = x;
            lastUpdateY = y;

            // FIX: Calculate target pixel coordinates to be bottom-center of the tile.
            float targetPixelX = targetTileX * World.TILE_SIZE + (World.TILE_SIZE / 2f);
            float targetPixelY = targetTileY * World.TILE_SIZE;
            targetPosition.set(targetPixelX, targetPixelY);

            this.direction = newDirection;
            this.isMoving = true;
            this.isInterpolating = true;
            this.currentMoveTime = 0f;
            this.movementProgress = 0f;

            if (animations != null) {
                animations.startMoving(direction);
            }
        }
    }


    public void updateBoundingBox() {
        if (boundingBox != null) {
            // FIX: Update bounding box to be centered horizontally on the Pokemon's position.
            float collisionWidth = World.TILE_SIZE * COLLISION_SCALE;
            float collisionHeight = World.TILE_SIZE * COLLISION_HEIGHT_SCALE;
            float newX = x - collisionWidth / 2f;
            float newY = y;
            boundingBox.setPosition(newX, newY);
            boundingBox.setSize(collisionWidth, collisionHeight);
        }
    }
    private boolean wasOnWater = false;
    private float waterSoundTimer = 0f;
    @Override
    public boolean wasOnWater() {
        return wasOnWater;
    }

    @Override
    public void setWasOnWater(boolean onWater) {
        this.wasOnWater = onWater;
    }

    @Override
    public float getWaterSoundTimer() {
        return waterSoundTimer;
    }

    @Override
    public void setWaterSoundTimer(float timer) {
        this.waterSoundTimer = timer;
    }

    @Override
    public void updateWaterSoundTimer(float delta) {
        if (this.waterSoundTimer > 0) {
            this.waterSoundTimer -= delta;
        }
    }

    public int getTileX() {
        return (int) (x / TILE_SIZE);
    }

    public int getTileY() {
        return (int) (y / TILE_SIZE);
    }

    @Override
    public void render(SpriteBatch batch) {
        if (isDespawning) {
            if (despawnAnimation != null) {
                despawnAnimation.render(batch, getCurrentFrame());
            }
            return;
        }

        TextureRegion frame = getCurrentFrame();
        if (frame != null) {
            float renderWidth = this.width;
            float renderHeight = this.height;
            // FIX: The render logic now correctly centers the sprite based on the new position anchor.
            float offsetX = renderWidth / 2f;
            float renderY = y;

            // Apply idle bounce animation
            if (!isMoving) {
                float bounceOffset = IDLE_BOUNCE_HEIGHT *
                    MathUtils.sin(idleAnimationTime * MathUtils.PI2 / IDLE_BOUNCE_DURATION);
                renderY += bounceOffset;
            }

            // Apply world lighting
            Color originalColor = batch.getColor().cpy();
            if (world != null) {
                Color baseColor = world.getCurrentWorldColor();
                int tileX = (int) (x / World.TILE_SIZE);
                int tileY = (int) (y / World.TILE_SIZE);
                Vector2 tilePos = new Vector2(tileX, tileY);
                Float lightLevel = world.getLightLevelAtTile(tilePos);
                if (lightLevel != null && lightLevel > 0) {
                    Color lightColor = new Color(1f, 0.9f, 0.7f, 1f);
                    baseColor = baseColor.cpy().lerp(lightColor, lightLevel);
                }
                batch.setColor(baseColor);
            }

            batch.draw(frame, x - offsetX, renderY, renderWidth, renderHeight);
            batch.setColor(originalColor);
        }
    }
    public TextureRegion getCurrentFrame() {
        if (animations != null) {
            return animations.getCurrentFrame(direction, isMoving);
        }
        return null;
    }

    // Expiration and despawning
    public boolean isExpired() {
        if (isExpired) return true;
        float currentTime = System.currentTimeMillis() / 1000f;
        return currentTime - spawnTime > PokemonSpawnManager.POKEMON_DESPAWN_TIME;
    }

    public boolean isDespawning() {
        return isDespawning;
    }

    public void startDespawnAnimation() {
        if (!isDespawning) {
            isDespawning = true;
            despawnAnimation = new PokemonDespawnAnimation(getX(), getY(), FRAME_WIDTH, FRAME_HEIGHT);
        }
    }

    // Getters and setters
    public World getWorld() { return world; }
    public void setWorld(World world) { this.world = world; }

    public float getX() { return x; }


    public float getY() { return y; }
    public void setX(float x) {
        this.pixelX = x;
        this.x = x;
    }

    public void setY(float y) {
        this.pixelY = y;
        this.y = y;
    }

    @Override
    public String getDirection() { return direction; }
    public void setDirection(String direction) { this.direction = direction; }

    @Override
    public boolean isMoving() { return isMoving; }

    @Override
    public void setCharacterType(String characterType) {

    }

    public void setMoving(boolean moving) { this.isMoving = moving; }

    public boolean isAddedToParty() { return isAddedToParty; }
    public void setAddedToParty(boolean addedToParty) { isAddedToParty = addedToParty; }


    @Override
    public PokemonAnimations getAnimations() { return animations; }

    public float getWidth() { return width; }
    public float getHeight() { return height; }

    public void setSpawnTime(long spawnTime) { this.spawnTime = spawnTime; }
}

================
File: src/main/java/io/github/pokemeetup/screens/ChestScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.screens.otherui.InventorySlotUI;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingSystem;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.InventoryConverter;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;

public class ChestScreen implements Screen, InventoryScreenInterface {
    private static final int SLOT_SIZE = 40;
    private final ChestData chestData;
    private final SpriteBatch batch;
    private final Vector2 chestPosition;
    private final GameScreen gameScreen;
    private final Stage stage;
    private final Skin skin;
    private final Table inventoryTable;
    private final Table mainTable;
    private final Table chestTable;
    private final Table closeButtonTable;
    private boolean isVisible = false;
    private Item heldItem = null;
    private Group heldItemGroup;
    private Image heldItemImage;
    private Label heldItemCountLabel;
    private boolean isClosing = false;

    public ChestScreen(Skin skin, ChestData chestData, Vector2 chestPosition, GameScreen gameScreen) {
        this.skin = skin;
        this.chestData = ensureChestData(chestPosition, chestData);
        this.chestPosition = chestPosition;
        this.stage = new Stage(new ScreenViewport());
        this.batch = new SpriteBatch();
        this.gameScreen = gameScreen;
        this.mainTable = new Table();
        this.chestTable = new Table();
        this.inventoryTable = new Table();
        this.closeButtonTable = new Table();
        setupHeldItemDisplay();
        setupUI();
    }
    public Stage getStage() {
        return stage;
    }

    @Override
    public Inventory getInventory() {
        return GameContext.get().getPlayer().getInventory();
    }

    @Override
    public Player getPlayer() {
        return GameContext.get().getPlayer();
    }

    @Override
    public ItemData getHeldItem() {
        return InventoryConverter.itemToItemData(heldItem);
    }

    @Override
    public void setHeldItem(Item item) {
        this.heldItem = item;
        updateHeldItemDisplay();
    }

    @Override
    public CraftingSystem getCraftingSystem() {
        return null; // Chest doesn't use crafting
    }

    @Override
    public ChestData getChestData() {
        return chestData;
    }

    private void createChestInventoryGrid() {
        chestTable.clear();
        chestTable.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        chestTable.pad(10);

        Label titleLabel = new Label("Storage", skin);
        chestTable.add(titleLabel).colspan(9).pad(5).row();

        int cols = 9;
        for (int i = 0; i < chestData.getSize(); i++) {
            InventorySlotData slotData = chestData.getSlotData(i);
            InventorySlotUI slot = new InventorySlotUI(slotData, skin, this, SLOT_SIZE);
            chestTable.add(slot).size(SLOT_SIZE);
            if ((i + 1) % cols == 0) {
                chestTable.row();
            }
        }
    }private ChestData ensureChestData(Vector2 chestPos, ChestData incomingData) {
        PlaceableBlock block = GameContext.get().getWorld().getBlockManager().getBlockAt((int) chestPos.x, (int) chestPos.y);
        if (block != null) {
            ChestData data = block.getChestData();
            if (data != null) {
                return data; // Use the already–assigned unique ChestData
            } else {
                // No chest data exists; create one now
                ChestData newData = new ChestData((int) chestPos.x, (int) chestPos.y);
                block.setChestData(newData);
                // Immediately notify the server of the new chest state.
                GameContext.get().getGameClient().sendChestUpdate(newData);
                return newData;
            }
        }
        // If no block was found, return incomingData (or create a new one as a last resort)
        return incomingData != null ? incomingData : new ChestData((int) chestPos.x, (int) chestPos.y);
    }



    @Override
    public Item getHeldItemObject() {
        return heldItem;
    }

    private void createPlayerInventoryGrid() {
        inventoryTable.clear();
        inventoryTable.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        inventoryTable.pad(10);

        // Title
        Label titleLabel = new Label("Inventory", skin);
        inventoryTable.add(titleLabel).colspan(9).pad(5).row();

        // Grid of slots
        Table grid = new Table();
        grid.defaults().space(4);

        int cols = 9;
        for (int i = 0; i < GameContext.get().getPlayer().getInventory().getSize(); i++) {
            InventorySlotData slotData = new InventorySlotData(i, InventorySlotData.SlotType.INVENTORY, GameContext.get().getPlayer().getInventory());
// No need to set slotType again

            InventorySlotUI slot = new InventorySlotUI(slotData, skin, this, SLOT_SIZE);


            grid.add(slot).size(SLOT_SIZE);
            if ((i + 1) % cols == 0) {
                grid.row();
            }
        }
        inventoryTable.add(grid);
    }

    public void updateUI() {
        createChestInventoryGrid();
        createPlayerInventoryGrid();
    }

    private void setupHeldItemDisplay() {
        heldItemImage = new Image();
        heldItemImage.setSize(32, 32);
        heldItemImage.setVisible(false);

        heldItemCountLabel = new Label("", skin);
        heldItemCountLabel.setVisible(false);

        heldItemGroup = new Group();
        heldItemGroup.addActor(heldItemImage);
        heldItemGroup.addActor(heldItemCountLabel);

        heldItemGroup.setTouchable(Touchable.disabled);
        stage.addActor(heldItemGroup); // Add heldItemGroup to the stage
    }

    private void setupUI() {
        stage.clear();
        mainTable.clear();

        mainTable.setFillParent(true);
        mainTable.center();

        // Set mainTable as touchable
        mainTable.setTouchable(Touchable.enabled);

        // Add a listener to consume input events
        mainTable.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                // Consume the event to prevent it from propagating
                event.stop();
            }
        });

        // Set up background
        Pixmap bgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(0, 0, 0, 0.5f);
        bgPixmap.fill();
        Texture bgTexture = new Texture(bgPixmap);
        mainTable.setBackground(new TextureRegionDrawable(bgTexture) {
            @Override
            public void draw(com.badlogic.gdx.graphics.g2d.Batch batch, float x, float y, float width, float height) {
                batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);
                super.draw(batch, x, y, width, height);
            }
        });
        bgPixmap.dispose();

        Label titleLabel = new Label("Chest", skin);
        titleLabel.setFontScale(1.5f);
        mainTable.add(titleLabel).pad(20).row();

        chestTable.clear();
        inventoryTable.clear();
        chestTable.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        chestTable.pad(10);
        createChestInventoryGrid();
        mainTable.add(chestTable).pad(10).row();
        inventoryTable.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        inventoryTable.pad(10);
        createPlayerInventoryGrid();
        mainTable.add(inventoryTable).pad(10).row();
        TextButton closeButton = new TextButton("Close", skin);
        closeButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (gameScreen != null) {
                    gameScreen.closeChestScreen();
                }
            }
        });

        closeButtonTable.clear();
        closeButtonTable.add(closeButton).size(100, 40).pad(10);
        mainTable.add(closeButtonTable).row();
        mainTable.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                event.stop();
                return true;
            }

            @Override
            public boolean keyUp(InputEvent event, int keycode) {
                event.stop();
                return true;
            }

            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
                event.stop();
                return true;
            }
        });

        stage.addActor(mainTable);
        stage.addActor(heldItemGroup);
    }

    @Override
    public void show() {
        if (isVisible) return;
        isVisible = true;
        isClosing = false;

        try {
            this.heldItem = null; // Clear any previously held item
            updateHeldItemDisplay(); // Update the UI accordingly
            setupUI();
            updateUI();

            if (stage != null) {
                stage.getViewport().update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
            }

            GameLogger.info("Chest screen shown successfully");
        } catch (Exception e) {
            GameLogger.error("Error showing chest screen: " + e.getMessage());
            isVisible = false;
        }
    }

    @Override
    public void hide() {
        if (isClosing) return; // Prevent multiple hide() calls
        isClosing = true;
        if (!isVisible) {
            isClosing = false;
            return;
        }

        // Transfer any held item (if present) to the player's inventory
        ItemData heldItemData = InventoryConverter.itemToItemData(this.heldItem);
        isVisible = false;
        try {
            if (heldItemData != null) {
                GameContext.get().getPlayer().getInventory().addItem(heldItemData);
                this.heldItem = null;
                updateHeldItemDisplay();
            }

            // Save the chest state – note that saveChestState() should simply send the current chestData to the server
            saveChestState();

            // Clean up the UI elements
            if (stage != null) {
                stage.clear();
            }
            if (gameScreen != null && gameScreen.getChestHandler() != null) {
                gameScreen.getChestHandler().setChestOpen(false);
                gameScreen.getChestHandler().reset();
            }
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.CHEST_CLOSE);
        } catch (Exception e) {
            GameLogger.error("Error during chest close: " + e.getMessage());
        } finally {
            isClosing = false;
        }
    }

    private void saveChestState() {
        // Play the chest close sound
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.CHEST_CLOSE);

        // Save final chest state locally.
        if (GameContext.get().getPlayer() != null && GameContext.get().getWorld() != null) {
            PlaceableBlock block = GameContext.get().getPlayer().getWorld().getBlockManager().getBlockAt(
                (int) chestPosition.x, (int) chestPosition.y);
            if (block != null) {
                block.setChestOpen(false);
                block.setChestData(chestData); // Update block with the current chest data

                // Force-save the chunk containing the chest.
                int chunkX = Math.floorDiv((int) chestPosition.x, World.CHUNK_SIZE);
                int chunkY = Math.floorDiv((int) chestPosition.y, World.CHUNK_SIZE);
                Vector2 chunkPos = new Vector2(chunkX, chunkY);

                Chunk chunk = GameContext.get().getWorld().getChunks().get(chunkPos);
                if (chunk != null) {
                    GameContext.get().getWorld().saveChunkData(chunkPos, chunk);
                }
            }
        }

        // *** NEW: Send a chest update to the server ***
        GameContext.get().getGameClient().sendChestUpdate(chestData);

        // Reset the chest handler state (client–side cleanup)
        if (gameScreen != null && gameScreen.getChestHandler() != null) {
            gameScreen.getChestHandler().setChestOpen(false);
            gameScreen.getChestHandler().reset();
        }
    }


    @Override
    public void render(float delta) {
        if (!isVisible) return;

        // Don't clear the screen - we want to see the game world behind
        Gdx.gl.glEnable(GL20.GL_BLEND);
        Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        // Update the UI
        stage.act(delta);
        stage.draw();
        updateHeldItemPosition();
        Gdx.gl.glDisable(GL20.GL_BLEND);
    }

    public void updateHeldItemDisplay() {
        if (heldItem != null) {
            TextureRegion texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase() + "_item");
            if (texture == null) {
                texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase());
            }

            if (texture != null) {
                heldItemImage.setDrawable(new TextureRegionDrawable(texture));
                heldItemImage.setVisible(true);

                if (heldItem.getCount() > 1) {
                    heldItemCountLabel.setText(String.valueOf(heldItem.getCount()));
                    heldItemCountLabel.setVisible(true);
                } else {
                    heldItemCountLabel.setVisible(false);
                }
                heldItemGroup.setVisible(true); // Make the group visible
            } else {
                heldItemImage.setVisible(false);
                heldItemCountLabel.setVisible(false);
                heldItemGroup.setVisible(false);
            }
        } else {
            heldItemImage.setVisible(false);
            heldItemCountLabel.setVisible(false);
            heldItemGroup.setVisible(false); // Hide the group when no held item
        }
    }

    private void updateHeldItemPosition() {
        if (heldItemGroup != null && heldItemGroup.isVisible()) {
            float x = Gdx.input.getX() - 16;
            float y = Gdx.graphics.getHeight() - Gdx.input.getY() - 16;
            heldItemGroup.setPosition(x, y);
        }
    }


    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        updateUI();
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void dispose() {
        if (stage != null) {
            stage.dispose();
        }
        if (batch != null) {
            batch.dispose();
        }
    }

    public boolean isVisible() {
        return isVisible;
    }

    public void setVisible(boolean visible) {
        this.isVisible = visible;
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/CraftingTableScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.InputMultiplexer;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.screens.otherui.InventorySlotUI;
import io.github.pokemeetup.system.InputManager;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingGrid;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingSystem;
import io.github.pokemeetup.system.gameplay.inventory.crafting.RecipeGlossaryUI;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventoryObserver;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.InventoryConverter;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.ArrayList;
import java.util.List;

public class CraftingTableScreen implements Screen, InventoryScreenInterface, InventoryObserver, CraftingSystem.CraftingSystemObserver {
    public static final int SLOT_SIZE = 32;
    private static final int GRID_SIZE = 3;
    private final Stage stage;
    private final Player player;
    private final World world;
    private final GameClient gameClient;
    private final Inventory inventory;
    private final CraftingSystem craftingSystem;
    private final Skin skin;
    private final List<InventorySlotUI> inventorySlots = new ArrayList<>();
    private final GameScreen gameScreen;
    private final InputManager inputManager;
    private Vector2 craftingTablePosition;
    private List<InventorySlotUI> craftingSlots;
    private InventorySlotUI resultSlot;
    private boolean isVisible = false;
    private Item heldItem = null;
    private InventorySlotData[] inventorySlotData;
    private Group heldItemGroup;
    private Image heldItemImage;
    private Label heldItemCountLabel;
    private CraftingGrid craftingGrid; // New field

    public CraftingTableScreen(Player player, Skin skin, World world, GameClient gameClient, GameScreen screen, InputManager inputManager) {
        if (player == null) {
            throw new IllegalArgumentException("Player cannot be null");
        }
        this.player = player;
        this.world = world;
        this.gameClient = gameClient;
        this.stage = new Stage(new ScreenViewport());
        this.skin = skin;
        this.inventory = player.getInventory();
        this.craftingSlots = new ArrayList<>();
        this.gameScreen = screen;
        this.inputManager = inputManager;
        this.craftingGrid = new CraftingGrid(GRID_SIZE * GRID_SIZE);

        this.craftingSystem = new CraftingSystem(inventory, GRID_SIZE, craftingGrid); // 3x3 grid
        craftingSystem.addObserver(this);

        initializeInventoryData();
        setupHeldItemDisplay();

        // First initialize the crafting grid
        initializeCraftingGrid();

        // Then setup the UI which uses the initialized slots
        setupUI(skin);

        inventory.addObserver(this);
    }

    @Override
    public Item getHeldItemObject() {
        return heldItem;
    }

    @Override
    public CraftingSystem getCraftingSystem() {
        return craftingSystem;
    }

    @Override
    public ChestData getChestData() {
        return null;
    }

    private Table createInventorySection() {
        Table container = new Table();
        container.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        container.pad(10);

        Table gridTable = new Table();
        gridTable.defaults().space(4);

        inventorySlots.clear();
        int cols = 9;

        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            InventorySlotUI slot = new InventorySlotUI(inventorySlotData[i], skin, this, SLOT_SIZE);
            inventorySlots.add(slot);

            gridTable.add(slot).size(SLOT_SIZE);
            if ((i + 1) % cols == 0) {
                gridTable.row();
            }
        }

        container.add(gridTable);
        return container;
    }

    private void initializeCraftingGrid() {
        craftingSlots.clear();

        for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            InventorySlotData slotData = new InventorySlotData(i, InventorySlotData.SlotType.EXPANDED_CRAFTING, craftingGrid);
            InventorySlotUI slot = new InventorySlotUI(slotData, skin, this, SLOT_SIZE);
            craftingSlots.add(slot);

            // Register slot observer with crafting system
            craftingSystem.addSlotObserver(i, slot);
        }
    }

    public Stage getStage() {
        return stage;
    }

    public World getWorld() {
        return world;
    }

    public GameClient getGameClient() {
        return gameClient;
    }


    public Skin getSkin() {
        return skin;
    }


    // Add validation method
    private void validateInitialization() {
        if (craftingSlots == null || craftingSlots.isEmpty()) {
            GameLogger.error("Crafting slots not properly initialized!");
            throw new IllegalStateException("CraftingTableScreen not properly initialized");
        }
    }


    private Table createCraftingSection() {
        Table container = new Table();
        container.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        container.pad(10);

        Table craftingGridTable = new Table();
        craftingGridTable.defaults().size(SLOT_SIZE).pad(2);

        // Create crafting slots and add them to the grid
        for (int row = 0; row < GRID_SIZE; row++) {
            for (int col = 0; col < GRID_SIZE; col++) {
                int index = row * GRID_SIZE + col;
                InventorySlotUI slotUI = craftingSlots.get(index);
                craftingGridTable.add(slotUI);
            }
            craftingGridTable.row();
        }

        // Create result slot
        InventorySlotData resultSlotData = new InventorySlotData(-1, InventorySlotData.SlotType.CRAFTING_RESULT, craftingGrid);
        resultSlotData.setSlotType(InventorySlotData.SlotType.CRAFTING_RESULT);
        resultSlot = new InventorySlotUI(resultSlotData, skin, this, SLOT_SIZE);

        // Create the crafting table layout
        Table craftingTable = new Table();
        craftingTable.add(craftingGridTable);
        craftingTable.add(new Image(TextureManager.ui.findRegion("arrow"))).padLeft(10).padRight(10);
        craftingTable.add(resultSlot).size(SLOT_SIZE);

        container.add(craftingTable);
        return container;
    }
    private void setupUI(Skin skin) {
        float screenWidth = Gdx.graphics.getWidth();
        float screenHeight = Gdx.graphics.getHeight();

        // Calculate relative sizes
        float baseSize = Math.min(screenWidth * 0.04f, screenHeight * 0.07f);
        float SLOT_SIZE = Math.max(baseSize, 40); // Minimum size of 40
        float containerPadding = SLOT_SIZE * 0.25f;

        Table mainTable = new Table();
        mainTable.setFillParent(true);
        mainTable.center();

        // Semi-transparent background
        Pixmap bgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(0, 0, 0, 0.2f);
        bgPixmap.fill();
        mainTable.setBackground(new TextureRegionDrawable(new TextureRegion(new Texture(bgPixmap))));
        bgPixmap.dispose();

        // Content container for better centering
        Table contentContainer = new Table();

        // Split container for crafting and recipes side by side
        Table splitContainer = new Table();

        // Crafting section (left side)
        Table craftingContainer = createCraftingSection();
        craftingContainer.pad(containerPadding);

        // Recipe section (right side)
        RecipeGlossaryUI recipeGlossary = new RecipeGlossaryUI(stage, skin, this, craftingSystem);
        ScrollPane recipeScroll = recipeGlossary.getRecipeScroll();

        // Recipe container with proper sizing
        Table recipeContainer = new Table();
        recipeContainer.add(new Label("Available Recipes", skin)).pad(containerPadding).row();
        recipeContainer.add(recipeScroll)
            .width(screenWidth * 0.25f)  // 25% of screen width
            .minWidth(SLOT_SIZE * 6)     // Minimum width to show recipes properly
            .height(screenHeight * 0.4f)  // 40% of screen height
            .pad(containerPadding);

        // Add both to split container
        splitContainer.add(craftingContainer).padRight(SLOT_SIZE * 0.5f);
        splitContainer.add(recipeContainer);

        contentContainer.add(splitContainer).pad(containerPadding).row();

        // Inventory section
        Table inventoryContainer = createInventorySection();
        contentContainer.add(inventoryContainer).padTop(SLOT_SIZE * 0.5f).row();

        // Close button
        TextButton closeButton = new TextButton("Close", skin);
        closeButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                gameScreen.closeExpandedCrafting();
            }
        });

        contentContainer.add(closeButton)
            .size(SLOT_SIZE * 2.5f, SLOT_SIZE)
            .pad(SLOT_SIZE * 0.5f);

        mainTable.add(contentContainer);
        stage.addActor(mainTable);
    }


    @Override
    public void resize(int width, int height) {
        if (stage != null) {
            stage.getViewport().update(width, height, true);

            // Completely rebuild UI on significant size changes
            stage.clear();
            setupUI(skin);
        }
    }
    private void initializeInventoryData() {
        this.inventorySlotData = new InventorySlotData[Inventory.INVENTORY_SIZE];
        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            inventorySlotData[i] = new InventorySlotData(i, InventorySlotData.SlotType.INVENTORY, inventory);
            inventorySlotData[i].setSlotType(InventorySlotData.SlotType.INVENTORY);
        }

        // Load current inventory state
        List<ItemData> items = inventory.getAllItems();
        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            if (i < items.size() && items.get(i) != null) {
                ItemData item = items.get(i);
                inventorySlotData[i].setItem(item.getItemId(), item.getCount(), item.getUuid());
            }
        }
    }

    private void returnItemsToInventory() {
        // Only return items when closing the crafting table
        if (!isVisible) {
            if (heldItem != null) {
                inventory.addItem(new ItemData(heldItem.getName(), heldItem.getCount(), heldItem.getUuid()));
                setHeldItem(null);
            }
            craftingSystem.returnItemsToInventory();
        }
    }

    @Override
    public void onCraftingResultChanged(ItemData newResult) {
        GameLogger.info("Crafting result changed - updating result slot");
        resultSlot.updateSlot();
    }


    @Override
    public void show() {
        isVisible = true;
        setupInputProcessors();
        updateInventorySlots(); // Refresh inventory display
    }

    private void updateInventorySlots() {
        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            InventorySlotData slotData = inventorySlotData[i];
            ItemData item = inventory.getItemAt(i);
            if (item != null) {
                slotData.setItem(item.getItemId(), item.getCount(), item.getUuid());
            } else {
                slotData.clear();
            }
        }

        for (InventorySlotUI slot : inventorySlots) {
            slot.forceUpdate();
        }
    }


    private void setupInputProcessors() {
        InputMultiplexer multiplexer = new InputMultiplexer();
        multiplexer.addProcessor(stage);
        Gdx.input.setInputProcessor(multiplexer);
    }

    @Override
    public void render(float delta) {
        if (!isVisible) return;

        // Check if player is still in range
        if (!isPlayerInRange()) {
            close();
            return;
        }

        Gdx.gl.glClearColor(0, 0, 0, 0.5f);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        stage.act(delta);
        stage.draw();

        // Update held item position if any
        updateHeldItemPosition();
    }

    private void close() {
        GameLogger.info("Closing crafting table screen");
        hide();  // This will handle cleanup properly
        setupInputProcessors(); // Reset input handling
    }


    private void returnHeldItemToInventory() {
        if (heldItem != null) {
            ItemData itemData = new ItemData(heldItem.getName(), heldItem.getCount(), heldItem.getUuid());
            if (inventory.addItem(itemData)) {
                setHeldItem(null);
                GameLogger.info("Returned held item to inventory: " + itemData.getItemId());
            }
        }
    }


    private void setupHeldItemDisplay() {
        heldItemImage = new Image();
        heldItemImage.setSize(SLOT_SIZE, SLOT_SIZE);
        heldItemImage.setVisible(false);

        heldItemCountLabel = new Label("", skin);
        heldItemCountLabel.setVisible(false);

        heldItemGroup = new Group();
        heldItemGroup.addActor(heldItemImage);
        heldItemGroup.addActor(heldItemCountLabel);

        stage.addActor(heldItemGroup);

        heldItemGroup.setTouchable(Touchable.disabled);
    }

    private void cleanupHeldItemResources() {
        if (heldItemGroup != null) {
            heldItemGroup.clear();
            heldItemGroup.remove();
            heldItemGroup = null;
        }
    }



    @Override
    public void onInventoryChanged() {
        GameLogger.info("Inventory changed - updating inventory slots");

    }


    @Override
    public void dispose() {
        GameLogger.info("Disposing CraftingTableScreen resources");

        try {
            // Return any held items to inventory first
            if (heldItem != null) {
                returnHeldItemToInventory();
            }

            // Return crafting grid items to inventory
            returnItemsToInventory();

            // Dispose of stage and resources
            if (stage != null) {
                stage.dispose();
            }

            // Clear all slots
            if (craftingSlots != null) {
                craftingSlots.clear();
            }

            // Dispose of textures and other resources
            if (heldItemGroup != null) {
                heldItemGroup.remove();
                heldItemGroup = null;
            }

            // Clear references
            craftingSlots = null;
            resultSlot = null;
            heldItem = null;

            GameLogger.info("CraftingTableScreen disposed successfully");

        } catch (Exception e) {
            GameLogger.error("Error during CraftingTableScreen disposal: " + e.getMessage());
        }
    }


    @Override
    public void pause() {

    }

    @Override
    public void resume() {

    }


    public void updateHeldItemDisplay() {
        if (heldItemGroup == null) {
            setupHeldItemDisplay();
        }

        heldItemGroup.clear();

        if (heldItem != null) {
            // Load texture
            TextureRegion texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase() + "_item");
            if (texture == null) {
                texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase());
            }

            if (texture != null) {
                heldItemImage = new Image(texture);
                heldItemImage.setSize(32, 32);
                heldItemGroup.addActor(heldItemImage);

                if (heldItem.getCount() > 1) {
                    heldItemCountLabel = new Label(String.valueOf(heldItem.getCount()), skin);
                    heldItemCountLabel.setPosition(24, 0);
                    heldItemGroup.addActor(heldItemCountLabel);
                }

                heldItemGroup.setVisible(true);
                heldItemGroup.toFront();
            }
        } else {
            heldItemGroup.setVisible(false);
        }
    }

    @Override
    public void hide() {
        isVisible = false;
        if (heldItem != null) {
            returnHeldItemToInventory();
        }
        returnItemsToInventory();
        cleanupHeldItemResources();
        GameLogger.info("CraftingTableScreen hidden");
    }

    private boolean isPlayerInRange() {
        if (craftingTablePosition == null) return false;
        float distance = Vector2.dst(
            player.getTileX(), player.getTileY(),
            craftingTablePosition.x, craftingTablePosition.y
        );
        return distance <= 2; // Within 2 tiles
    }

    @Override
    public Inventory getInventory() {
        return inventory;
    }

    @Override
    public Player getPlayer() {
        return player;
    }

    @Override
    public ItemData getHeldItem() {
        return InventoryConverter.itemToItemData(heldItem);
    }

    @Override
    public void setHeldItem(Item item) {
        this.heldItem = item;
        updateHeldItemDisplay();
    }

    public boolean isVisible() {
        return isVisible;
    }

    public void updatePosition(Vector2 newPosition) {
        this.craftingTablePosition = newPosition;
    }

    private void updateHeldItemPosition() {
        if (heldItem != null && heldItemGroup != null) {
            float x = Gdx.input.getX() - SLOT_SIZE / 2f;
            float y = Gdx.graphics.getHeight() - Gdx.input.getY() - SLOT_SIZE / 2f;

            heldItemGroup.setPosition(x, y);
            heldItemGroup.toFront();
        }
    }


}

================
File: src/main/java/io/github/pokemeetup/screens/DisconnectionScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Timer;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.DisconnectionManager;
import io.github.pokemeetup.utils.GameLogger;

public class DisconnectionScreen implements Screen {
    private static final float RETRY_INTERVAL = 5f; // 5 seconds between retries
    private static final int MAX_RETRY_ATTEMPTS = 3;
    private static final float BUTTON_WIDTH = 200f;
    private static final float BUTTON_HEIGHT = 50f;

    private final CreatureCaptureGame game;
    private final Stage stage;
    private final Skin skin;
    private final Table mainTable;
    private final Label statusLabel;
    private final Label countdownLabel;
    private final TextButton retryButton;
    private final TextButton exitButton;
    private final DisconnectionManager disconnectionManager;

    private int retryAttempts = 0;
    private float countdownTime = RETRY_INTERVAL;
    private boolean isRetrying = false;
    private boolean disposed = false;
    private String disconnectReason;

    private final Timer.Task countdownTask = new Timer.Task() {
        @Override
        public void run() {
            if (countdownTime > 0) {
                countdownTime -= 1;
                updateCountdownLabel();
            } else {
                stopCountdown();
                attemptReconnection();
            }
        }
    };

    public DisconnectionScreen(CreatureCaptureGame game, String reason, DisconnectionManager manager) {
        this.game = game;
        this.disconnectReason = reason;
        this.disconnectionManager = manager;
        this.stage = new Stage(new ScreenViewport());
        this.skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));

        // Create main table for layout
        mainTable = new Table();
        mainTable.setFillParent(true);

        // Create UI components with custom styling
        Label titleLabel = new Label("Connection Lost", createLabelStyle());
        titleLabel.setFontScale(2f);

        statusLabel = new Label(reason, createLabelStyle());
        countdownLabel = new Label("", createLabelStyle());

        retryButton = createButton("Retry Connection", new Color(0.2f, 0.6f, 1f, 1f));
        exitButton = createButton("Exit to Menu", new Color(1f, 0.3f, 0.3f, 1f));

        // Layout components
        mainTable.add(titleLabel).pad(20).row();
        mainTable.add(statusLabel).pad(10).row();
        mainTable.add(countdownLabel).pad(10).row();

        // Button table for horizontal layout
        Table buttonTable = new Table();
        buttonTable.add(retryButton).pad(10).width(BUTTON_WIDTH).height(BUTTON_HEIGHT);
        buttonTable.add(exitButton).pad(10).width(BUTTON_WIDTH).height(BUTTON_HEIGHT);

        mainTable.add(buttonTable).pad(20).row();

        // Add overlay shadow effect
        Table overlayTable = new Table();
        overlayTable.setFillParent(true);
        overlayTable.setBackground(skin.newDrawable("white", new Color(0f, 0f, 0f, 0.8f)));

        // Add tables to stage
        stage.addActor(overlayTable);
        stage.addActor(mainTable);

        // Set up input processing
        Gdx.input.setInputProcessor(stage);

        // Add button listeners
        setupButtonListeners();

        GameLogger.info("DisconnectionScreen initialized with reason: " + reason);
    }

    private Label.LabelStyle createLabelStyle() {
        return new Label.LabelStyle(skin.getFont("default-font"), Color.WHITE);
    }

    private TextButton createButton(String text, Color color) {
        TextButton.TextButtonStyle style = new TextButton.TextButtonStyle();
        style.font = skin.getFont("default-font");
        style.fontColor = Color.WHITE;
        style.up = skin.newDrawable("default-round", color);
        style.down = skin.newDrawable("default-round-down", color.cpy().mul(0.8f));
        style.over = skin.newDrawable("default-round", color.cpy().mul(1.2f));

        TextButton button = new TextButton(text, style);
        button.pad(10);
        return button;
    }

    private void setupButtonListeners() {
        retryButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                if (!isRetrying) {
                    startRetryCountdown();
                }
            }
        });

        exitButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                exitToMenu();
            }
        });
    }

    @Override
    public void render(float delta) {
        // Clear screen with dark background
        Gdx.gl.glClearColor(0.1f, 0.1f, 0.15f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        // Update countdown if active
        if (isRetrying) {
            countdownTime -= delta;
            if (countdownTime <= 0) {
                stopCountdown();
                attemptReconnection();
            }
            updateCountdownLabel();
        }

        // Update and draw stage
        stage.act(delta);
        stage.draw();
    }

    private void startRetryCountdown() {
        if (retryAttempts >= MAX_RETRY_ATTEMPTS) {
            statusLabel.setText("Maximum retry attempts reached");
            retryButton.setDisabled(true);
            return;
        }

        isRetrying = true;
        countdownTime = RETRY_INTERVAL;
        retryButton.setDisabled(true);
        updateCountdownLabel();
        GameLogger.info("Starting retry countdown");
    }

    private void stopCountdown() {
        isRetrying = false;
        countdownTime = RETRY_INTERVAL;
        retryButton.setDisabled(false);
        countdownLabel.setText("");

        if (countdownTask.isScheduled()) {
            countdownTask.cancel();
        }
    }

    private void updateCountdownLabel() {
        countdownLabel.setText(String.format("Retrying in %.0f seconds...", Math.max(0, countdownTime)));
        countdownLabel.setAlignment(Align.center);
    }

    private void attemptReconnection() {
        if (disconnectionManager != null) {
            disconnectionManager.attemptReconnect();
        }
    }

    private void exitToMenu() {
        if (disconnectionManager != null) {
            disconnectionManager.cleanup();
        }
        game.setScreen(new LoginScreen(game));
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        mainTable.invalidate(); // Reflow the UI
    }

    @Override
    public void show() {
        Gdx.input.setInputProcessor(stage);
    }
    @Override
    public void dispose() {
        if (!disposed) {
            stage.dispose();
            disposed = true;
            GameLogger.info("DisconnectionScreen disposed");
        }
    }

    @Override
    public void hide() {
        // Remove input processor when screen is hidden
        if (Gdx.input.getInputProcessor() == stage) {
            Gdx.input.setInputProcessor(null);
        }
    }

    @Override
    public void pause() {
        // Pause any active countdowns or animations
        if (isRetrying) {
            stopCountdown();
        }
    }

    @Override
    public void resume() {
        // Ensure input processor is set when screen resumes
        Gdx.input.setInputProcessor(stage);
    }

    public void onReconnectionSuccess() {
        Gdx.app.postRunnable(() -> {
            stopCountdown();
            statusLabel.setText("Connection restored!");
            // Add success animation or feedback here if desired
            Timer.schedule(new Timer.Task() {
                @Override
                public void run() {
                    if (disconnectionManager != null) {
                        disconnectionManager.onReconnectionSuccess();
                    }
                }
            }, 1); // Wait 1 second before returning to game
        });
    }

    public void onReconnectionFailure(String reason) {
        Gdx.app.postRunnable(() -> {
            stopCountdown();
            statusLabel.setText("Reconnection failed: " + reason);
            if (retryAttempts >= MAX_RETRY_ATTEMPTS) {
                retryButton.setDisabled(true);
                Timer.schedule(new Timer.Task() {
                    @Override
                    public void run() {
                        exitToMenu();
                    }
                }, 2); // Wait 2 seconds before exiting to menu
            }
        });
    }

    public void updateStatus(String status) {
        Gdx.app.postRunnable(() -> {
            statusLabel.setText(status);
        });
    }

    private void fadeOut(Runnable onComplete) {
        mainTable.addAction(com.badlogic.gdx.scenes.scene2d.actions.Actions.sequence(
            com.badlogic.gdx.scenes.scene2d.actions.Actions.fadeOut(0.5f),
            com.badlogic.gdx.scenes.scene2d.actions.Actions.run(onComplete)
        ));
    }

    private void fadeIn() {
        mainTable.getColor().a = 0;
        mainTable.addAction(com.badlogic.gdx.scenes.scene2d.actions.Actions.fadeIn(0.5f));
    }

    public boolean isRetrying() {
        return isRetrying;
    }

    public int getRetryAttempts() {
        return retryAttempts;
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/GameScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.*;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.*;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.profiling.GLProfiler;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Scaling;
import com.badlogic.gdx.utils.Timer;
import com.badlogic.gdx.utils.viewport.FitViewport;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.CommandManager;
import io.github.pokemeetup.chat.commands.*;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.context.UIManager;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.multiplayer.OtherPlayer;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.client.GameClientSingleton;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.PokemonParty;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.screens.otherui.*;
import io.github.pokemeetup.system.*;
import io.github.pokemeetup.system.battle.BattleInitiationHandler;
import io.github.pokemeetup.system.battle.BattleSystemHandler;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.gameplay.inventory.ChestInteractionHandler;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.*;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.InventoryConverter;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.List;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

import static io.github.pokemeetup.system.gameplay.overworld.World.INITIAL_LOAD_RADIUS;
import static io.github.pokemeetup.system.gameplay.overworld.World.TILE_SIZE;

public class GameScreen implements Screen, PickupActionHandler, BattleInitiationHandler {
    public static final boolean DEBUG_MODE = false;
    private static final float TARGET_VIEWPORT_WIDTH_TILES = 24f;
    private static final float UPDATE_INTERVAL = 0.1f;
    private static final float CAMERA_LERP = 5.0f;
    private static final float BATTLE_UI_FADE_DURATION = 0.5f;
    private static final float BATTLE_SCREEN_WIDTH = 800;
    private static final float BATTLE_SCREEN_HEIGHT = 480;
    private static final float MOVEMENT_REPEAT_DELAY = 0.1f;
    public static boolean SHOW_DEBUG_INFO = false;
    private final CreatureCaptureGame game;
    private final ScheduledExecutorService screenInitScheduler = Executors.newSingleThreadScheduledExecutor();
    private final AtomicBoolean initializationComplete = new AtomicBoolean(false);
    private final AtomicBoolean starterSelectionInProgress = new AtomicBoolean(false);
    private final CommandManager commandManager;
    public boolean isMultiplayer;
    Actor aButton;
    Actor zButton;
    Actor xButton;
    Actor yButton;
    Actor startButton;
    Actor selectButton;
    private ChestInteractionHandler chestHandler = new ChestInteractionHandler();
    private float ACTION_BUTTON_SIZE;
    private float DPAD_SIZE;
    private float BUTTON_PADDING;
    private Vector2 joystickCenter = new Vector2();
    private Vector2 joystickCurrent = new Vector2();
    private float initializationTimer = 0f;
    private Stage pokemonPartyStage;
    private Table partyDisplay;
    private float updateTimer = 0;
    private BitmapFont font;
    private OrthographicCamera camera;
    private InputHandler inputHandler;
    private String username;
    private Rectangle inventoryButton;
    private Rectangle menuButton;
    private ShapeRenderer shapeRenderer;
    private Skin skin;
    private Skin uiSkin;
    private Stage stage;
    private FitViewport cameraViewport;
    private boolean transitioning = false;
    private boolean controlsInitialized = false;
    private StarterSelectionTable starterTable;
    private boolean inputBlocked = false;
    private float debugTimer = 0;
    private boolean initializedworld = false;
    private volatile boolean isDisposing = false;
    private BattleTable battleTable;
    private Skin battleSkin;
    private boolean inBattle = false;
    private Stage battleStage;
    private boolean battleInitialized = false;
    private boolean battleUIFading = false;
    private Table androidControlsTable;
    private Table closeButtonTable;
    private Table dpadTable;
    private Rectangle upButton, downButton, leftButton, rightButton;
    private String currentDpadDirection = null;
    private float movementTimer = 0f;
    private boolean isHoldingDirection = false;
    private boolean isRunPressed = false;
    private AndroidMovementController movementController;
    private Runnable pendingStarterInit = null;
    private volatile boolean awaitingStarterSelection = false;
    private BattleSystemHandler battleSystem;
    private boolean commandsEnabled = false;
    private InputManager inputManager;
    private ChestScreen chestScreen;
    private Actor houseToggleButton;
    private GLProfiler glProfiler;
    private boolean initialChunksLoadedOnce = false;

    public GameScreen(CreatureCaptureGame game, String username, GameClient gameClient) {
        this.game = game;
        this.username = username;
        GameContext.get().setGameClient(gameClient);
        this.commandManager = new CommandManager();
        registerAllCommands();
        this.isMultiplayer = GameContext.get().isMultiplayer();

        GameContext.get().setUiStage(new Stage(new ScreenViewport()));
        this.battleSystem = new BattleSystemHandler();
        try {
            // Initialize basic UI first
            initializeBasicResources();

            initializeWorldAndPlayer(CreatureCaptureGame.MULTIPLAYER_WORLD_NAME);
            this.inputManager = new InputManager(this);
            Player player = GameContext.get().getPlayer();
            // Check if new player needs starter
            if (player != null && player.getPokemonParty().getSize() == 0) {
                GameLogger.info("New player detected - handling starter selection");
                handleNewPlayer();
            } else {
                completeInitialization();
            }
            this.inputManager.updateInputProcessors();

        } catch (Exception e) {
            GameLogger.error("GameScreen initialization failed: " + e.getMessage());
            throw new RuntimeException("Failed to initialize game screen", e);
        }
    }

    public GameScreen(CreatureCaptureGame game, String username, GameClient gameClient, boolean commandsEnabled, String worldName) {
        this.game = game;
        this.username = username;
        this.commandsEnabled = commandsEnabled;
        this.commandManager = new CommandManager();
        registerAllCommands();
        GameContext.get().setGameClient(gameClient);
        this.isMultiplayer = GameContext.get().isMultiplayer();
        GameContext.get().setUiStage(new Stage(new ScreenViewport()));

        this.battleSystem = new BattleSystemHandler();
        try {
            initializeBasicResources();

            initializeWorldAndPlayer(worldName);
            this.inputManager = new InputManager(this);
            Player player = GameContext.get().getPlayer();

            // Check if new player needs starter
            if (player != null && player.getPokemonParty().getSize() == 0) {
                GameLogger.info("New player detected - handling starter selection");
                handleNewPlayer();
            } else {
                // Complete normal initialization
                completeInitialization();
            }

        } catch (Exception e) {
            GameLogger.error("GameScreen initialization failed: " + e.getMessage());
            throw new RuntimeException("Failed to initialize game screen", e);
        }
    }

    public void updatePartyDisplay() {
        if (partyDisplay != null) {
            partyDisplay.remove();
        }
        createPartyDisplay();
    }

    public Table getPartyDisplay() {
        return partyDisplay;
    }

    public Skin getBattleSkin() {
        return battleSkin;
    }

    public Skin getSkin() {
        return skin;
    }

    public InputManager getInputManager() {
        return inputManager;
    }

    public CreatureCaptureGame getGame() {
        return game;
    }

    public StarterSelectionTable getStarterTable() {
        return starterTable;
    }

    public InputHandler getInputHandler() {
        return inputHandler;
    }

    public Stage getUiStage() {
        return GameContext.get().getUiStage();
    }

    public CraftingTableScreen getCraftingScreen() {
        return GameContext.get().getCraftingScreen();
    }

    public void setCraftingScreen(CraftingTableScreen craftingScreen) {
        GameContext.get().setCraftingScreen(craftingScreen);
    }


    public GameMenu getGameMenu() {
        return GameContext.get().getGameMenu();
    }

    public void setGameMenu(GameMenu gameMenu) {
        GameContext.get().setGameMenu(gameMenu);
    }

    public Stage getBattleStage() {
        return battleStage;
    }

    public InventoryScreen getInventoryScreen() {
        return GameContext.get().getInventoryScreen();
    }

    public BuildModeUI getBuildModeUI() {
        return GameContext.get().getBuildModeUI();
    }

    public ChestInteractionHandler getChestHandler() {
        return chestHandler;
    }

    public OrthographicCamera getCamera() {
        return camera;
    }

    public void openChestScreen(Vector2 chestPosition, ChestData chestData) {
        if (chestScreen != null) {
            chestScreen.dispose();  // or hide() and then remove references if appropriate
        }
        chestScreen = new ChestScreen(skin, chestData, chestPosition, this);
        chestScreen.show();
        inputManager.setUIState(InputManager.UIState.CHEST_SCREEN);
    }

    public void closeChestScreen() {
        if (chestScreen != null) {
            chestScreen.hide();
        }
        inputManager.setUIState(InputManager.UIState.NORMAL);
    }

    public void openExpandedCrafting(Vector2 craftingTablePosition) {
        if (GameContext.get().getCraftingScreen() == null) {
            GameContext.get().setCraftingScreen(new CraftingTableScreen(
                GameContext.get().getPlayer(),
                skin,
                GameContext.get().getWorld(),
                GameContext.get().getGameClient(), this, inputManager
            ));
        }
        GameContext.get().getCraftingScreen().updatePosition(craftingTablePosition);
        inputManager.setUIState(InputManager.UIState.CRAFTING);
    }

    public void closeExpandedCrafting() {
        inputManager.setUIState(InputManager.UIState.NORMAL);
        if (GameContext.get().getCraftingScreen() != null) {
            GameContext.get().getCraftingScreen().hide();
        }
    }

    private void handleMultiplayerInitialization(boolean success) {
        if (success) {
            try {
                initializeWorldAndPlayer(CreatureCaptureGame.MULTIPLAYER_WORLD_NAME);
                if (GameContext.get().getPlayer() != null &&
                    GameContext.get().getPlayer().getPokemonParty().getSize() == 0 &&
                    starterTable == null) {
                    GameLogger.info("New player detected – initiating starter selection");
                    awaitingStarterSelection = true;
                    starterSelectionInProgress.set(true);
                    initializationComplete.set(false);
                    Gdx.app.postRunnable(() -> {
                        try {
                            if (starterTable != null) {
                                starterTable.remove();
                            }
                            GameLogger.info("Creating StarterSelectionTable");
                            starterTable = new StarterSelectionTable(skin);
                            starterTable.setSelectionListener(new StarterSelectionTable.SelectionListener() {
                                @Override
                                public void onStarterSelected(Pokemon starter) {
                                    handleStarterSelection(starter);
                                }

                                @Override
                                public void onSelectionStart() {
                                    inputBlocked = true;
                                }
                            });
                            starterTable.setFillParent(true);
                            stage.addActor(starterTable);
                            starterTable.toFront();
                            GameLogger.info("Starter selection UI initialized");
                        } catch (Exception e) {
                            GameLogger.error("Failed to create starter selection: " + e.getMessage());
                            handleInitializationFailure();
                        }
                    });
                    return;
                }
                completeInitialization();
            } catch (Exception e) {
                GameLogger.error("Failed to initialize multiplayer: " + e.getMessage());
                handleInitializationFailure();
            }
        } else {
            handleInitializationFailure();
        }
    }

    @Override
    public void show() {
        GameLogger.info("GameScreen show() called. Setting up UI and input.");

        // Re-establish a valid UI Stage from the persistent GameContext
        Stage uiStage = GameContext.get().getUiStage();
        if (uiStage == null) {
            GameLogger.error("UI Stage is null in GameScreen.show(), re-creating.");
            uiStage = new Stage(new ScreenViewport(), new SpriteBatch());
            GameContext.get().setUiStage(uiStage);
        }

        // --- Re-initialize or re-attach all UI components ---

        // 1. Hotbar System
        // If it's null or belongs to a disposed stage, create a new one.
        HotbarSystem hotbar = GameContext.get().getHotbarSystem();
        if (hotbar == null || hotbar.getHotbarTable().getStage() == null) {
            GameLogger.info("Re-initializing HotbarSystem.");
            hotbar = new HotbarSystem(uiStage, skin);
            GameContext.get().setHotbarSystem(hotbar);
        } else if (hotbar.getHotbarTable().getStage() != uiStage) {
            // Re-add to the current stage if it was detached
            hotbar.getHotbarTable().remove();
            uiStage.addActor(hotbar.getHotbarTable().getParent());
        }

        // 2. Chat System
        if (GameContext.get().getChatSystem() != null && GameContext.get().getChatSystem().getStage() != null) {
            GameContext.get().getChatSystem().remove(); // Remove from old stage if it exists
        }
        initializeChatSystem();
        if(GameContext.get().getChatSystem().getStage() != uiStage) {
            uiStage.addActor(GameContext.get().getChatSystem());
        }


        // 3. Game Menu
        if (GameContext.get().getGameMenu() != null) {
            GameContext.get().getGameMenu().dispose();
        }
        GameContext.get().setGameMenu(new GameMenu(game, skin, inputManager));

        // 4. Build Mode UI
        if (GameContext.get().getBuildModeUI() != null) {
            GameContext.get().getBuildModeUI().remove();
        }
        initializeBuildMode();
        if(GameContext.get().getBuildModeUI().getStage() != uiStage) {
            uiStage.addActor(GameContext.get().getBuildModeUI());
        }
        GameContext.get().getBuildModeUI().setVisible(false);


        // 5. Party Display
        updatePartyDisplay();

        // 6. Android Controls
        if (Gdx.app.getType() == Application.ApplicationType.Android) {
            if (movementController == null) {
                movementController = new AndroidMovementController(GameContext.get().getPlayer(), inputHandler);
            }
            if (!controlsInitialized) {
                initializeAndroidControls();
            }
        }

        // 7. Starter Selection (if applicable)
        if (GameContext.get().getPlayer() != null && GameContext.get().getPlayer().getPokemonParty().getSize() == 0) {
            if (starterTable == null) {
                handleNewPlayer();
            }
            inputManager.setUIState(InputManager.UIState.STARTER_SELECTION);
        } else {
            inputManager.setUIState(InputManager.UIState.NORMAL);
        }

        // Finally, update the input processors to reflect the new state
        inputManager.updateInputProcessors();
        GameLogger.info("GameScreen show() completed successfully.");
    }


    private void handleNewPlayer() {
        // Only create the starter table if one is not already present
        if (starterTable != null) {
            GameLogger.info("Starter table already exists; skipping creation.");
            return;
        }
        starterSelectionInProgress.set(true);
        Gdx.app.postRunnable(() -> {
            // Use the static factory method so that only one instance exists.
            starterTable = StarterSelectionTable.getInstance(skin);
            starterTable.setSelectionListener(new StarterSelectionTable.SelectionListener() {
                @Override
                public void onStarterSelected(Pokemon starter) {
                    handleStarterSelection(starter);
                }

                @Override
                public void onSelectionStart() {
                    inputBlocked = true;
                }
            });
            starterTable.setFillParent(true);
            starterTable.setTouchable(Touchable.enabled);
            GameContext.get().getUiStage().addActor(starterTable);
            Gdx.input.setInputProcessor(GameContext.get().getUiStage());
            GameContext.get().getUiStage().setKeyboardFocus(starterTable);
            inputManager.setUIState(InputManager.UIState.STARTER_SELECTION);
            inputManager.updateInputProcessors();
            GameLogger.info("Starter selection UI initialized.");
        });
    }

    private void handleStarterSelection(Pokemon starter) {
        try {
            GameLogger.info("Processing starter selection: " + starter.getName());
            // Add the chosen starter to the player's party and update data
            GameContext.get().getPlayer().getPokemonParty().addPokemon(starter);
            GameContext.get().getPlayer().updatePlayerData();
            if (!GameContext.get().getGameClient().isSinglePlayer()) {
                GameContext.get().getGameClient().savePlayerState(GameContext.get().getPlayer().getPlayerData());
            }
            // Remove the starter selection UI and clear focus
            if (starterTable != null) {
                starterTable.remove();
                starterTable = null;
            }
            inputBlocked = false;
            inputManager.setUIState(InputManager.UIState.NORMAL);
            inputManager.updateInputProcessors();
            if (GameContext.get().getUiStage() != null) {
                GameContext.get().getUiStage().setKeyboardFocus(null);
                GameContext.get().getUiStage().unfocusAll();
            }
            completeInitialization();
            GameLogger.info("Starter selection complete - proceeding with initialization");
        } catch (Exception e) {
            GameLogger.error("Failed to process starter selection: " + e.getMessage() + e);
        }
    }

    private void createStarterSelectionTable() {
        if (starterTable != null) {
            // Already exists, but if you want to force recreation, remove the old one:
            starterTable.remove();
            starterTable = null;
        }

        // Create a new StarterSelectionTable
        starterTable = new StarterSelectionTable(skin);

        // Set up the listener that handles selection events
        starterTable.setSelectionListener(new StarterSelectionTable.SelectionListener() {
            @Override
            public void onStarterSelected(Pokemon starter) {
                // Called when user confirms the chosen starter
                handleStarterSelection(starter);
            }

            @Override
            public void onSelectionStart() {
                // Called right when user first clicks a Pokémon.
                // For example, block other input while the user is making a choice:
                inputBlocked = true;
            }
        });

        // Fill entire stage, if that’s what you want:
        starterTable.setFillParent(true);

        // Add to the current UI Stage
        Stage uiStage = GameContext.get().getUiStage();
        if (uiStage != null) {
            uiStage.addActor(starterTable);
            starterTable.toFront();
        }

        // Switch the input manager state so it focuses on starter selection
        inputManager.setUIState(InputManager.UIState.STARTER_SELECTION);
        inputManager.updateInputProcessors();

        GameLogger.info("StarterSelectionTable created and added to UI stage.");
    }

    private void registerAllCommands() {
        GameLogger.info("Registering commands...");
        commandManager.registerCommand(new GiveCommand());
        commandManager.registerCommand(new SpawnCommand());
        commandManager.registerCommand(new SetWorldSpawnCommand());
        commandManager.registerCommand(new TeleportPositionCommand());
        commandManager.registerCommand(new TimeCommand());
        commandManager.registerCommand(new WeatherCommand());
    }

    private void completeInitialization() {
        try {
            initializeGameSystems();
            inputManager.updateInputProcessors();
            initializationComplete.set(true);
            GameLogger.info("Game initialization complete");

        } catch (Exception e) {
            GameLogger.error("Failed to complete initialization: " + e.getMessage());
            game.setScreen(new LoginScreen(game));
        }
    }

    public boolean isInitialized() {
        boolean isInitComplete = initializationComplete.get();
        boolean isStarterInProgress = starterSelectionInProgress.get();
        GameLogger.info("isInitialized() called - initializationComplete: " + isInitComplete +
            ", starterSelectionInProgress: " + isStarterInProgress);
        return isInitComplete || isStarterInProgress;
    }

    public void setInitialized(boolean initialized) {
        this.initializedworld = initialized;
    }

    public GameClient getGameClient() {
        return GameContext.get().getGameClient();
    }

    private void initializeBasicResources() {
        GameLogger.info("Initializing basic resources");

        try {
            // 1. Graphics resources
            GameContext.get().setBatch(new SpriteBatch());
            SpriteBatch uiBatch = new SpriteBatch();
            this.shapeRenderer = new ShapeRenderer();

            // 2. Camera and viewport setup - CRITICAL: Do this first
            this.camera = new OrthographicCamera();
            float baseWidth = TARGET_VIEWPORT_WIDTH_TILES * TILE_SIZE;
            float baseHeight = baseWidth * ((float) Gdx.graphics.getHeight() / Gdx.graphics.getWidth());
            this.cameraViewport = new FitViewport(baseWidth, baseHeight, camera);
            camera.position.set(baseWidth / 2f, baseHeight / 2f, 0); // Set initial position
            camera.update();
            cameraViewport.update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);

            // 3. UI resources
            this.skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));
            GameContext.get().setSkin(this.skin);
            this.uiSkin = this.skin;
            this.font = new BitmapFont(Gdx.files.internal("Skins/default.fnt"));

            // 4. Stages with viewports
            GameContext.get().setUiStage(new Stage(new ScreenViewport(), uiBatch));
            this.pokemonPartyStage = new Stage(new ScreenViewport());
            this.stage = new Stage(new ScreenViewport());
            this.battleStage = new Stage(new FitViewport(BATTLE_SCREEN_WIDTH, BATTLE_SCREEN_HEIGHT));

            Stage uiStage = new Stage(new ScreenViewport(), new SpriteBatch());
            GameContext.get().setUiStage(uiStage);
            UIManager uiManager = new UIManager(uiStage, skin);
            GameContext.get().setUiManager(uiManager);
            GameContext.get().setSkin(skin);
            GameLogger.info("Basic resources initialized successfully");
        } catch (Exception e) {
            GameLogger.error("Failed to initialize basic resources: " + e.getMessage());
            throw new RuntimeException("Failed to initialize basic resources", e);
        }
    }

    private void initializeChatSystem() {
        if (GameContext.get().getChatSystem() != null) {
            return; // Already initialized
        }

        float screenW = Gdx.graphics.getWidth();
        float screenH = Gdx.graphics.getHeight();
        // Use 25% of the screen width for the chat so it doesn't overlap the Pokémon party display.
        float chatWidth = Math.max(ChatSystem.MIN_CHAT_WIDTH, screenW * 0.25f);
        float chatHeight = Math.max(ChatSystem.MIN_CHAT_HEIGHT, screenH * 0.3f);

        ChatSystem chatSystem = new ChatSystem(
            GameContext.get().getUiStage(),
            skin,
            GameContext.get().getGameClient(),
            username,
            commandManager,
            commandsEnabled
        );
        chatSystem.setSize(chatWidth, chatHeight);
        // Position the chat in the top left corner (origin is bottom left)
        chatSystem.setPosition(
            ChatSystem.CHAT_PADDING,
            screenH - chatHeight - ChatSystem.CHAT_PADDING
        );
        chatSystem.setVisible(true);
        chatSystem.setTouchable(Touchable.enabled);

        GameContext.get().getUiStage().addActor(chatSystem);
        GameContext.get().setChatSystem(chatSystem);
        GameLogger.info("ChatSystem created at: " + chatSystem.getX() + ", " + chatSystem.getY());
    }

    private void initializeWorldAndPlayer(String worldName) {
        GameLogger.info("Initializing world and player");

        try {
            // For singleplayer, if the GameClient is null, reinitialize it.
            if (!isMultiplayer && GameContext.get().getGameClient() == null) {
                GameContext.get().setGameClient(GameClientSingleton.getSinglePlayerInstance());
                GameLogger.info("Reinitialized singleplayer GameClient");
            }

            // 1. Initialize or create world
            if (GameContext.get().getWorld() == null) {
                if (isMultiplayer) {
                    // Multiplayer: grab the world from the GameClient
                    GameContext.get().setWorld(GameContext.get().getGameClient().getCurrentWorld());
                    if (GameContext.get().getWorld() == null) {
                        throw new IllegalStateException("No world available from GameClient");
                    }
                } else {
                    // Singleplayer: create a new world with a new seed
                    long seed = System.currentTimeMillis();
                    GameContext.get().getBiomeManager().setBaseSeed(seed);
                    GameContext.get().setWorld(new World(worldName, seed));
                }
            }

            // 2. Set up the Player
            if (isMultiplayer) {
                // Use the active (already–created) player from the server
                GameContext.get().setPlayer(GameContext.get().getGameClient().getActivePlayer());
                if (GameContext.get().getPlayer() == null) {
                    throw new IllegalStateException("No player available from GameClient");
                }
            } else {
                // Singleplayer:
                GameContext.get().setPlayer(game.getPlayer());
                if (GameContext.get().getPlayer() == null) {
                    // Need to create a new singleplayer player
                    World currentWorld = GameContext.get().getWorld();
                    BiomeManager bm = currentWorld.getBiomeManager();
                    // We'll pick a safe spawn tile from the islands
                    Random rng = new Random(currentWorld.getWorldData().getConfig().getSeed());
                    Vector2 safeTile = bm.findSafeSpawnLocation(currentWorld, rng);

                    Player newPlayer = new Player(
                        (int) safeTile.x,
                        (int) safeTile.y,
                        currentWorld,
                        username
                    );
                    GameContext.get().setPlayer(newPlayer);
                }
            }

            // 3. Initialize world data and components (if multiplayer)
            if (isMultiplayer) {
                GameContext.get().getWorld().initializeFromServer(
                    GameContext.get().getGameClient().getWorldSeed(),
                    GameContext.get().getWorld().getWorldData().getWorldTimeInMinutes(),
                    GameContext.get().getWorld().getWorldData().getDayLength()
                );
            }

            // 4. Player resources & hooking up the world
            GameContext.get().getPlayer().initializeResources();
            GameContext.get().getPlayer().initializeInWorld(GameContext.get().getWorld());
            GameContext.get().getWorld().setPlayer(GameContext.get().getPlayer());

            // Set the player's render position to their actual location
            float px = GameContext.get().getPlayer().getX();
            float py = GameContext.get().getPlayer().getY();
            GameContext.get().getPlayer().setRenderPosition(new Vector2(px, py));

            // 5. Load initial chunks around the player
            //    The player's tile coords / chunk coords:
            Vector2 playerPos = new Vector2(
                (float) GameContext.get().getPlayer().getTileX() / World.CHUNK_SIZE,
                (float) GameContext.get().getPlayer().getTileY() / World.CHUNK_SIZE
            );
            GameContext.get().getWorld().loadChunksAroundPositionSynchronously(playerPos, INITIAL_LOAD_RADIUS);

            if (!GameContext.get().getWorld().areAllChunksLoaded()) {
                GameLogger.info("Forcing load of missing chunks...");
                GameContext.get().getWorld().forceLoadMissingChunks();
            }

            // Optionally, set camera to center on player
            if (camera != null) {
                camera.position.set(
                    GameContext.get().getPlayer().getX() + Player.FRAME_WIDTH / 2f,
                    GameContext.get().getPlayer().getY() + Player.FRAME_HEIGHT / 2f,
                    0
                );
                camera.update();
            }

        } catch (Exception e) {
            GameLogger.error("Failed to initialize world and player: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    private void initializeGameSystems() {

        // 1. Camera and viewport
        setupCamera();
        if (GameContext.get().getChatSystem() == null) {
            initializeChatSystem();
        }
        // 2. Input handling
        this.chestHandler = new ChestInteractionHandler();
        this.inputHandler = new InputHandler(this, this, this, chestHandler, inputManager);

        createPartyDisplay();

        // 5. Battle assets
        initializeBattleAssets();

        if (Gdx.app.getType() == Application.ApplicationType.Android) {
            this.movementController = new AndroidMovementController(GameContext.get().getPlayer(), inputHandler);
            initializeAndroidControls();
        }

        GameLogger.info("Game systems initialized successfully");
    }

    private void initializeBattleAssets() {
        try {


            try {
                FileHandle skinFile = Gdx.files.internal("atlas/ui-gfx-atlas.json");
                if (skinFile.exists()) {
                    battleSkin = new Skin(skinFile);
                    battleSkin.addRegions(TextureManager.getUi());
                    GameLogger.info("Battle skin loaded successfully");
                } else {
                    GameLogger.info("No battle skin found - using default styles");
                    // Continue without skin - will use direct texture regions
                }
            } catch (Exception skinEx) {
                GameLogger.error("Could not load battle skin: " + skinEx.getMessage() + " - continuing without skin");
                // Continue without skin
                if (battleSkin != null) {
                    battleSkin.dispose();
                    battleSkin = null;
                }
            }

        } catch (Exception e) {
            GameLogger.error("Failed to initialize battle assets: " + e.getMessage());
            cleanup();
            throw new RuntimeException("Battle initialization failed", e);
        }
    }

    private void handleInitializationFailure() {
        Gdx.app.postRunnable(() -> {
            Dialog dialog = new Dialog("Initialization Error", skin) {
                @Override
                protected void result(Object obj) {
                    if ((Boolean) obj) {
                        handleMultiplayerInitialization(true);
                    } else {
                        // Return to login screen
                        game.setScreen(new LoginScreen(game));
                    }
                }
            };

            dialog.text("Failed to initialize game. Would you like to retry?");
            dialog.button("Retry", true);
            dialog.button("Cancel", false);
            dialog.show(stage);
        });
    }

    public void toggleInventory() {
        if (inputManager.getCurrentState() == InputManager.UIState.INVENTORY) {
            inputManager.setUIState(InputManager.UIState.NORMAL);
            if (GameContext.get().getInventoryScreen() != null) {
                GameContext.get().getInventoryScreen().hide();
            }
        } else {
            inputManager.setUIState(InputManager.UIState.INVENTORY);
            if (GameContext.get().getInventoryScreen() == null) {
                GameContext.get().setInventoryScreen(new InventoryScreen(GameContext.get().getPlayer(), skin, GameContext.get().getPlayer().getInventory(), inputManager));
            }
            GameContext.get().getInventoryScreen().show();
            inputManager.updateInputProcessors();
        }
    }

    public void toggleGameMenu() {
        if (inputManager.getCurrentState() == InputManager.UIState.MENU) {
            inputManager.setUIState(InputManager.UIState.NORMAL);
        } else {
            inputManager.setUIState(InputManager.UIState.MENU);
        }
    }

    private void initializeBattleComponents(Pokemon validPokemon, WildPokemon nearestPokemon) {
        // Lock Pokemon in place
        battleSystem.lockPokemonForBattle(nearestPokemon);

        battleStage = new Stage(new FitViewport(800, 480));
        battleStage.getViewport().update(
            Gdx.graphics.getWidth(),
            Gdx.graphics.getHeight(),
            true
        );

        battleTable = new BattleTable(
            battleStage,
            battleSkin,
            validPokemon,
            nearestPokemon
        );
        GameContext.get().setBattleTable(battleTable);

        battleTable.setFillParent(true);
        battleTable.setVisible(true);
        battleStage.addActor(battleTable);

        setupBattleCallbacks(nearestPokemon);
        battleInitialized = true;
    }


    private void initiateStarterSelection() {
        GameLogger.info("CRITICAL - Initiating starter selection");
        starterSelectionInProgress.set(true);

        try {

            if (GameContext.get().getUiStage() == null) {
                GameContext.get().setUiStage(new Stage(new ScreenViewport()));
            }

            inputManager.updateInputProcessors();

            if (starterTable == null) {
                starterTable = new StarterSelectionTable(skin);
                starterTable.setSelectionListener(new StarterSelectionTable.SelectionListener() {
                    @Override
                    public void onStarterSelected(Pokemon starter) {
                        handleStarterSelection(starter);
                    }

                    @Override
                    public void onSelectionStart() {
                        inputBlocked = true;
                    }
                });

                starterTable.setFillParent(true);
                GameContext.get().getUiStage().addActor(starterTable);
                starterTable.toFront();
            }

            GameLogger.info("Starter selection UI initialized");

        } catch (Exception e) {
            GameLogger.error("Failed to initialize starter selection: " + e.getMessage());
            handleStarterSelectionError(e);
        }
    }

    private void handleStarterSelectionError(Exception e) {
        GameLogger.error("Starter selection error: " + e.getMessage());

        Gdx.app.postRunnable(() -> {
            // Clean up any partial state
            if (starterTable != null) {
                starterTable.remove();
                starterTable = null;
            }

            // Show error dialog
            Dialog dialog = new Dialog("Error", skin) {
                @Override
                protected void result(Object obj) {
                    if ((Boolean) obj) {
                        // Retry starter selection
                        initiateStarterSelection();
                    } else {
                        // Return to login screen
                        game.setScreen(new LoginScreen(game));
                    }
                }
            };

            dialog.text("Failed to process starter selection.\nWould you like to try again?");
            dialog.button("Retry", true);
            dialog.button("Back to Login", false);
            dialog.show(GameContext.get().getUiStage());
        });
    }

    private void createPartyDisplay() {
        partyDisplay = new Table();
        partyDisplay.setFillParent(true);
        partyDisplay.top();  // Position at top
        partyDisplay.padTop(20f); // Add top padding

        Table slotsTable = new Table();
        slotsTable.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        slotsTable.pad(4f);

        List<Pokemon> party = GameContext.get().getPlayer().getPokemonParty().getParty();

        for (int i = 0; i < PokemonParty.MAX_PARTY_SIZE; i++) {
            boolean isSelected = (i == 0);
            Pokemon pokemon = (party.size() > i) ? party.get(i) : null;
            PokemonPartySlot slot = new PokemonPartySlot(pokemon, isSelected, skin);
            slotsTable.add(slot).size(64).pad(2);
        }

        partyDisplay.add(slotsTable);
        GameContext.get().getUiStage().addActor(partyDisplay);
    }

    @Override
    public void hide() {

    }

    public World getWorld() {
        return GameContext.get().getWorld();
    }

    public Player getPlayer() {
        return GameContext.get().getPlayer();
    }

    public PlayerData getCurrentPlayerState() {
        PlayerData currentState = new PlayerData(GameContext.get().getPlayer().getUsername());
        // Use InventoryConverter to extract inventory data
        InventoryConverter.extractInventoryDataFromPlayer(GameContext.get().getPlayer(), currentState);
        return currentState;
    }

    private void updateAndroidControlPositions() {
        if (Gdx.app.getType() != Application.ApplicationType.Android) {
            return;
        }

        try {
            float screenWidth = Gdx.graphics.getWidth();
            float screenHeight = Gdx.graphics.getHeight();
            float buttonSize = screenHeight * 0.1f;
            float padding = buttonSize * 0.5f;

            if (joystickCenter == null) {
                joystickCenter = new Vector2(screenWidth * 0.15f, screenHeight * 0.2f);
            } else {
                joystickCenter.set(screenWidth * 0.15f, screenHeight * 0.2f);
            }

            if (joystickCurrent == null) {
                joystickCurrent = new Vector2(joystickCenter);
            } else {
                joystickCurrent.set(joystickCenter);
            }
            if (inventoryButton == null) {
                inventoryButton = new Rectangle(
                    screenWidth - (buttonSize * 2 + padding * 2),
                    screenHeight - (buttonSize + padding),
                    buttonSize,
                    buttonSize
                );
            } else {
                inventoryButton.set(
                    screenWidth - (buttonSize * 2 + padding * 2),
                    screenHeight - (buttonSize + padding),
                    buttonSize,
                    buttonSize
                );
            }

            if (menuButton == null) {
                menuButton = new Rectangle(
                    screenWidth - (buttonSize + padding),
                    screenHeight - (buttonSize + padding),
                    buttonSize,
                    buttonSize
                );
            } else {
                menuButton.set(
                    screenWidth - (buttonSize + padding),
                    screenHeight - (buttonSize + padding),
                    buttonSize,
                    buttonSize
                );
            }
            if (houseToggleButton != null) {
                // Place it above the D-pad (adjust offsets as needed)
                float houseX = joystickCenter.x - ACTION_BUTTON_SIZE / 2;
                float houseY = joystickCenter.y + DPAD_SIZE + padding;
                houseToggleButton.setPosition(houseX, houseY);
                // Show the button only if build mode is active
                houseToggleButton.setVisible(GameContext.get().getPlayer().isBuildMode());
            }

            GameLogger.info("Updated Android controls - Screen: " + screenWidth + "x" + screenHeight +
                ", Joystick at: " + joystickCenter.x + "," + joystickCenter.y);

        } catch (Exception e) {
            GameLogger.error("Error updating Android controls: " + e.getMessage());
            e.printStackTrace();

            initializeAndroidControlsSafe();
        }
    }

    private void initializeAndroidControlsSafe() {
        try {
            float screenWidth = Math.max(Gdx.graphics.getWidth(), 480); // Minimum safe width
            float screenHeight = Math.max(Gdx.graphics.getHeight(), 320); // Minimum safe height
            float buttonSize = Math.min(screenHeight * 0.1f, 64); // Limit maximum size
            float padding = buttonSize * 0.5f;

            joystickCenter = new Vector2(screenWidth * 0.15f, screenHeight * 0.2f);
            joystickCurrent = new Vector2(joystickCenter);

            inventoryButton = new Rectangle(
                screenWidth - (buttonSize * 2 + padding * 2),
                screenHeight - (buttonSize + padding),
                buttonSize,
                buttonSize
            );

            menuButton = new Rectangle(
                screenWidth - (buttonSize + padding),
                screenHeight - (buttonSize + padding),
                buttonSize,
                buttonSize
            );

            GameLogger.info("Initialized safe Android controls");
        } catch (Exception e) {
            GameLogger.error("Failed to initialize safe Android controls: " + e.getMessage());
        }
    }

    private void ensureAndroidControlsInitialized() {
        if (Gdx.app.getType() == Application.ApplicationType.Android &&
            (joystickCenter == null || joystickCurrent == null ||
                inventoryButton == null || menuButton == null)) {

            initializeAndroidControlsSafe();
        }
    }

    private boolean canInteract() {
        // Check if player is in battle or menu
        if (inBattle) {
            return false;
        }

        return !transitioning && !inputBlocked;
    }

    @Override
    public void handleBattleInitiation() {
        if (!canInteract()) {
            GameLogger.info("Cannot start battle - player is busy");
            return;
        }

        if (battleSystem.isInBattle()) {
            GameLogger.info("Battle already in progress");
            return;
        }

        WildPokemon nearestPokemon = GameContext.get().getWorld().getNearestInteractablePokemon(GameContext.get().getPlayer());
        if (nearestPokemon == null || nearestPokemon.isAddedToParty()) {
            return;
        }

        // Check for valid Pokemon
        if (GameContext.get().getPlayer().getPokemonParty() == null || GameContext.get().getPlayer().getPokemonParty().getSize() == 0) {
            if (GameContext.get().getChatSystem() != null) {
                NetworkProtocol.ChatMessage message = createSystemMessage(
                    "You need a Pokemon to battle!");
                GameContext.get().getChatSystem().handleIncomingMessage(message);
            }
            GameLogger.info("Cannot battle - player has no Pokemon");
            return;
        }

        Pokemon validPokemon = findFirstValidPokemon(GameContext.get().getPlayer().getPokemonParty());
        if (validPokemon == null) {
            if (GameContext.get().getChatSystem() != null) {
                NetworkProtocol.ChatMessage message = createSystemMessage(
                    "All your Pokemon need to be healed!");
                GameContext.get().getChatSystem().handleIncomingMessage(message);
            }
            GameLogger.info("Cannot battle - no healthy Pokemon");
            return;
        }
        if (GameContext.get().getPlayer().getAnimations().isChopping() ||
            GameContext.get().getPlayer().getAnimations().isPunching()) {
            GameContext.get().getPlayer().getAnimations().stopChopping();
            GameContext.get().getPlayer().getAnimations().stopPunching();
            if (inputHandler != null) {
                inputHandler.stopChopOrPunch();
            }
        }
        try {
            initializeBattleComponents(validPokemon, nearestPokemon);

            inputManager.setUIState(InputManager.UIState.BATTLE);

            battleSystem.startBattle();
            inBattle = true;

            GameLogger.info("Battle initialized successfully with " +
                validPokemon.getName() + " vs " + nearestPokemon.getName());

        } catch (Exception e) {
            GameLogger.error("Failed to initialize battle: " + e.getMessage());
            cleanup();
            battleSystem.endBattle();
        }
    }


    public void forceBattleInitiation(WildPokemon aggressor) {
        if (!canInteract() || battleSystem.isInBattle()) {
            GameLogger.info("Cannot start forced battle - player is busy or already in battle");
            return;
        }

        // aggressor is passed in, so we use it instead of finding the nearest one.
        if (aggressor == null || aggressor.isAddedToParty()) {
            return;
        }

        // Check for valid player Pokemon
        Pokemon validPokemon = findFirstValidPokemon(GameContext.get().getPlayer().getPokemonParty());
        if (validPokemon == null) {
            // Player has no healthy pokemon, maybe do nothing or show a message.
            return;
        }

        // Stop any other player actions
        if (GameContext.get().getPlayer().getAnimations().isChopping() ||
            GameContext.get().getPlayer().getAnimations().isPunching()) {
            GameContext.get().getPlayer().getAnimations().stopChopping();
            GameContext.get().getPlayer().getAnimations().stopPunching();
            if (inputHandler != null) {
                inputHandler.stopChopOrPunch();
            }
        }

        try {
            initializeBattleComponents(validPokemon, aggressor); // Use aggressor here

            inputManager.setUIState(InputManager.UIState.BATTLE);

            battleSystem.startBattle();
            inBattle = true;

            GameLogger.info("Forced battle initiated by " + aggressor.getName() + " with " + validPokemon.getName());

        } catch (Exception e) {
            GameLogger.error("Failed to initialize forced battle: " + e.getMessage());
            cleanup();
            battleSystem.endBattle();
        }
    }

    private Pokemon findFirstValidPokemon(PokemonParty party) {
        if (party == null) return null;

        for (Pokemon pokemon : party.getParty()) {
            if (pokemon != null && pokemon.getCurrentHp() > 0) {
                return pokemon;
            }
        }
        return null;
    }
// In GameScreen.java

    private void setupBattleCallbacks(WildPokemon wildPokemon) {
        if (battleTable == null) {
            GameLogger.error("Cannot setup callbacks - battleTable is null");
            return;
        }

        battleTable.setCallback(new BattleTable.BattleCallback() {
            @Override
            public void onBattleEnd(boolean playerWon) {
                if (playerWon) {
                    handleBattleVictory(wildPokemon);
                    Pokemon victoriousPokemon = GameContext.get().getPlayer().getPokemonParty().getFirstHealthyPokemon();
                    if (victoriousPokemon != null) {
                        NetworkProtocol.ChatMessage message = createSystemMessage(
                            "Victory! " + victoriousPokemon.getName() +
                                " defeated " + wildPokemon.getName() + "!"
                        );
                        GameContext.get().getChatSystem().handleIncomingMessage(message);
                    }
                } else {
                    handleBattleDefeat();
                    if (GameContext.get().getChatSystem() != null) {
                        // FIX: Use a safe message that doesn't rely on getting a Pokémon, preventing a crash.
                        NetworkProtocol.ChatMessage message = createSystemMessage(
                            GameContext.get().getPlayer().getUsername() + " has no more usable Pokémon and blacks out!"
                        );
                        GameContext.get().getChatSystem().handleIncomingMessage(message);
                    }
                }

                // Despawn the wild Pokemon regardless of win or loss.
                wildPokemon.startDespawnAnimation();
                Timer.schedule(new Timer.Task() {
                    @Override
                    public void run() {
                        if (GameContext.get().getWorld() != null && GameContext.get().getWorld().getPokemonSpawnManager() != null) {
                            GameContext.get().getWorld().getPokemonSpawnManager().removePokemon(wildPokemon.getUuid());
                        }
                    }
                }, 1.5f);

                // Clean up battle state and initiate the fade-out and cleanup sequence.
                battleSystem.endBattle();
                endBattle(playerWon, wildPokemon);
            }

            @Override
            public void onTurnEnd(Pokemon activePokemon) {
                GameLogger.info("Turn ended for: " + activePokemon.getName());

            }

            @Override
            public void onStatusChange(Pokemon pokemon, Pokemon.Status newStatus) {
                GameLogger.info("Status changed for " + pokemon.getName() + ": " + newStatus);

                // Show status message
                String statusMessage = pokemon.getName() + " is now " + newStatus.toString().toLowerCase() + "!";
                if (GameContext.get().getChatSystem() != null) {
                    GameContext.get().getChatSystem().handleIncomingMessage(createSystemMessage(statusMessage));
                }

                switch (newStatus) {
                    case BURNED:
                        AudioManager.getInstance().playSound(AudioManager.SoundEffect.DAMAGE);
                        break;
                    case PARALYZED:
                    case POISONED:
                    case BADLY_POISONED:
                        AudioManager.getInstance().playSound(AudioManager.SoundEffect.NOT_EFFECTIVE);
                        break;
                }
            }

            @Override
            public void onMoveUsed(Pokemon user, Move move, Pokemon target) {
                GameLogger.info(user.getName() + " used " + move.getName());

                // Play move sound
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.MOVE_SELECT);

                // Show move message
                String moveMessage = user.getName() + " used " + move.getName() + "!";
                if (GameContext.get().getChatSystem() != null) {
                    GameContext.get().getChatSystem().handleIncomingMessage(createSystemMessage(moveMessage));
                }
            }
        });
    }

    public void endBattle(boolean playerWon, WildPokemon wildPokemon) {
        if (battleTable != null && battleTable.hasParent()) {
            battleTable.addAction(Actions.sequence(
                Actions.fadeOut(BATTLE_UI_FADE_DURATION),
                Actions.run(() -> {
                    try {
                        cleanup();
                    } catch (Exception e) {
                        GameLogger.error("Error ending battle: " + e.getMessage());
                        cleanup();
                    }
                })
            ));
            battleUIFading = true;
        } else {
            cleanup();
        }
    }

    private void cleanup() {
        if (isDisposing) return;
        isDisposing = true;

        Gdx.app.postRunnable(() -> {
            try {
                if (battleTable != null) {
                    battleTable.clear();
                    // Ensure it is removed from the stage it was added to.
                    if (battleStage != null) {
                        battleTable.remove();
                    }
                }

                if (battleStage != null) {
                    battleStage.clear();
                    battleStage.dispose();
                    battleStage = null;
                }

                if (battleSystem != null) {
                    battleSystem.endBattle();
                }
                inBattle = false;
                transitioning = false;
                inputBlocked = false;
                battleInitialized = false;
                battleUIFading = false;
                isDisposing = false;

                // Reset the input UI state to NORMAL and update processors
                inputManager.setUIState(InputManager.UIState.NORMAL);
                inputManager.updateInputProcessors();

                GameLogger.info("Battle cleanup complete - battle Stage disposed and UI state reset");
            } catch (Exception e) {
                GameLogger.error("Error during battle cleanup: " + e.getMessage());
            }
        });
    }

    private void handleBattleVictory(WildPokemon wildPokemon) {
        // Award experience
        int expGain = calculateExperienceGain(wildPokemon);
        GameContext.get().getPlayer().getPokemonParty().getFirstPokemon().addExperience(expGain);

        // Show victory message and sound
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.BATTLE_WIN);
        if (GameContext.get().getChatSystem() != null) {
            GameContext.get().getChatSystem().handleIncomingMessage(createSystemMessage(
                "Victory! " + GameContext.get().getPlayer().getPokemonParty().getFirstPokemon().getName() +
                    " gained " + expGain + " experience!"
            ));
        }
    }

    private void teleportPlayerToSpawn(Player player, World world) {
        try {
            GameLogger.info("Teleporting player to spawn...");
            if (player == null || world == null) {
                GameLogger.error("Cannot teleport: player or world is null.");
                return;
            }

            // Get spawn coordinates from the world configuration.
            int tileX = world.getWorldData().getConfig().getTileSpawnX();
            int tileY = world.getWorldData().getConfig().getTileSpawnY();
            float pixelX = tileX * World.TILE_SIZE;
            float pixelY = tileY * World.TILE_SIZE;

            // Teleport the player.
            player.getPosition().set(pixelX, pixelY);
            player.setTileX(tileX);
            player.setTileY(tileY);
            player.setX(pixelX);
            player.setY(pixelY);
            player.setMoving(false);
            player.setRenderPosition(new Vector2(pixelX, pixelY));

            GameLogger.info("Player teleported to spawn: (" + pixelX + ", " + pixelY + ")");

            // Reset the chunk state to force a reload around the new position.
            world.clearChunks();
            world.loadChunksAroundPlayer();

            // If in multiplayer mode, update the server.
            if (GameContext.get().isMultiplayer()) {
                GameContext.get().getGameClient().sendPlayerUpdate();
                GameContext.get().getGameClient().savePlayerState(player.getPlayerData());
            }
        } catch (Exception e) {
            GameLogger.error("Teleport to spawn failed: " + e.getMessage());
        }
    }


    // Find the existing handleBattleDefeat() method and replace it with this new version.
    private void handleBattleDefeat() {
        Player player = GameContext.get().getPlayer();
        World world = GameContext.get().getWorld();

        if (player == null || world == null) {
            GameLogger.error("Cannot handle battle defeat: Player or World is null.");
            return;
        }

        // 1. Get player's location for dropping items
        float dropX = player.getX();
        float dropY = player.getY();

        // 2. Get a copy of all items from inventory to drop
        List<ItemData> itemsToDrop = new ArrayList<>();
        for (ItemData item : player.getInventory().getAllItems()) {
            if (item != null) {
                itemsToDrop.add(item.copy());
            }
        }

        // 3. Clear the player's inventory
        player.getInventory().clear();
        if (player.getHotbarSystem() != null) {
            player.getHotbarSystem().updateHotbar(); // Visually update the hotbar
        }

        // 4. Drop all items on the ground with a small random offset
        Random rand = new Random();
        for (ItemData item : itemsToDrop) {
            float offsetX = (rand.nextFloat() - 0.5f) * 64; // Scatter within one tile
            float offsetY = (rand.nextFloat() - 0.5f) * 64;
            world.getItemEntityManager().spawnItemEntity(item, dropX + offsetX, dropY + offsetY);
        }

        // 5. Heal the party so they are usable after respawning
        player.getPokemonParty().healAllPokemon();

        // 6. Play defeat sound and show a message
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.DAMAGE);
        if (GameContext.get().getChatSystem() != null) {
            GameContext.get().getChatSystem().handleIncomingMessage(createSystemMessage(
                player.getUsername() + " blacked out, dropped all items, and was teleported to spawn!"
            ));
        }

        // 7. Teleport the player to the world spawn
        teleportPlayerToSpawn(player, world);
    }
    private int calculateExperienceGain(WildPokemon wildPokemon) {
        // Basic experience calculation
        return wildPokemon.getBaseExperience() * wildPokemon.getLevel() / 7;
    }

    private NetworkProtocol.ChatMessage createSystemMessage(String content) {
        NetworkProtocol.ChatMessage message = new NetworkProtocol.ChatMessage();
        message.sender = "System";
        message.content = content;
        message.timestamp = System.currentTimeMillis();
        message.type = NetworkProtocol.ChatType.SYSTEM;
        return message;
    }

    private void setupCamera() {
        if (camera == null) {
            camera = new OrthographicCamera();
        }

        float baseWidth = TARGET_VIEWPORT_WIDTH_TILES * TILE_SIZE;
        float baseHeight = baseWidth * ((float) Gdx.graphics.getHeight() / Gdx.graphics.getWidth());

        if (cameraViewport == null) {
            cameraViewport = new FitViewport(baseWidth, baseHeight, camera);
        }

        cameraViewport.update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false);

        if (GameContext.get().getPlayer() != null) {
            camera.position.set(
                GameContext.get().getPlayer().getX() + Player.FRAME_WIDTH / 2f,
                GameContext.get().getPlayer().getY() + Player.FRAME_HEIGHT / 2f,
                0
            );
        } else {
            // Default position if no player
            camera.position.set(baseWidth / 2f, baseHeight / 2f, 0);
        }

        camera.update();
        GameLogger.info("Camera setup - viewport: " + baseWidth + "x" + baseHeight);
    }

    private void updateCamera() {
        if (GameContext.get().getPlayer() != null) {
            float targetX = GameContext.get().getPlayer().getX() + Player.FRAME_WIDTH / 2f;
            float targetY = GameContext.get().getPlayer().getY() + Player.FRAME_HEIGHT / 2f;
            float lerp = CAMERA_LERP * Gdx.graphics.getDeltaTime();
            camera.position.x += (targetX - camera.position.x) * lerp;
            camera.position.y += (targetY - camera.position.y) * lerp;

            camera.update();
        }
    }

    private void renderLoadingScreen() {
        GameContext.get().getBatch().begin();
        font.draw(GameContext.get().getBatch(), "Loading world...",
            (float) Gdx.graphics.getWidth() / 2 - 50,
            (float) Gdx.graphics.getHeight() / 2);
        GameContext.get().getBatch().end();
    }

    @Override
    public void render(float delta) {

        if (GameContext.get().getGameClient() != null && GameContext.get().getGameClient().isConnected()) {
            GameContext.get().getGameClient().tick();
            GameContext.get().getGameClient().update(delta);
        }
        if (DEBUG_MODE && glProfiler != null) {
            glProfiler.reset();
        }
        // (if using glProfiler.log only when draws are excessive)
        if (DEBUG_MODE && glProfiler != null) {
            int draws = glProfiler.getDrawCalls();
            if (draws > 200) {
                Gdx.app.log("GLProfiler", "Draw Calls: " + draws);
            }
        }
        if (camera != null && starterTable == null) {
            updateCamera();
        }
        if (GameContext.get().getPlayer() != null && GameContext.get().getPlayer().getPokemonParty().getSize() == 0) {
            GameContext.get().getUiStage().act(delta);
            GameContext.get().getUiStage().draw();
            return;
        }
        if (!initialChunksLoadedOnce) {
            // Just draw an overlay, but do NOT skip the rest of the logic
            renderLoadingOverlay();
        }

        if (GameContext.get().getWorld() == null) {
            return;
        }
        if (GameContext.get().getPlayer() != null) {
            if (!GameContext.get().getWorld().areInitialChunksLoaded()) {
                long elapsed = System.currentTimeMillis() - GameContext.get().getWorld().getInitialChunkRequestTime();
                if (elapsed > 5000) {
                    // Force synchronous load of the player's current chunk (this works for both singleplayer and multiplayer)
                    int playerTileX = GameContext.get().getPlayer().getTileX();
                    int playerTileY = GameContext.get().getPlayer().getTileY();
                    int playerChunkX = Math.floorDiv(playerTileX, World.CHUNK_SIZE);
                    int playerChunkY = Math.floorDiv(playerTileY, World.CHUNK_SIZE);
                } else {
                    GameContext.get().getWorld().requestInitialChunks();
                    renderLoadingScreen();
                    return;
                }
            }
        }


        // Clear screen
        Gdx.gl.glClearColor(0, 0, 0, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        if (movementController != null) {
            movementController.update();
        }
        if (GameContext.get().getPlayer() != null && GameContext.get().getPlayer().getPokemonParty().getSize() == 0) {
            Gdx.gl.glClearColor(0.1f, 0.1f, 0.2f, 1);
            Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

            GameContext.get().getUiStage().act(delta);
            GameContext.get().getUiStage().draw();

            debugTimer += delta;
            if (debugTimer >= 1.0f) {
                debugTimer = 0;
            }
            return;
        }
        GameContext.get().getBatch().begin();
        GameContext.get().getBatch().setProjectionMatrix(camera.combined);

        if (GameContext.get().getWorld() != null && GameContext.get().getPlayer() != null) {
            Rectangle viewBounds = new Rectangle(
                camera.position.x - (camera.viewportWidth * camera.zoom) / 2,
                camera.position.y - (camera.viewportHeight * camera.zoom) / 2,
                camera.viewportWidth * camera.zoom,
                camera.viewportHeight * camera.zoom
            );
            GameContext.get().getBatch().setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

            GameContext.get().getWorld().render(GameContext.get().getBatch(), viewBounds, GameContext.get().getPlayer(), this);


        }
        if (SHOW_DEBUG_INFO) {
            renderDebugInfo();

        }
        if (inputManager.getCurrentState() == InputManager.UIState.CRAFTING) {
            if (GameContext.get().getCraftingScreen() != null) {
                GameContext.get().getBatch().end();

                GameContext.get().getCraftingScreen().render(delta);

                GameContext.get().getBatch().begin();
            }
        }


        GameContext.get().getBatch().end();

        if (inputManager.getCurrentState() == InputManager.UIState.BUILD_MODE && GameContext.get().getBuildModeUI() != null) {
            GameContext.get().getBuildModeUI().renderPlacementPreview(GameContext.get().getBatch(), camera);
        }
        if (GameContext.get().getWorld() != null && !initializedworld) {
            if (GameContext.get().getWorld().areAllChunksLoaded()) {
                initializedworld = true;
                GameLogger.info("All chunks successfully loaded");
            }
        }

        if (isHoldingDirection && currentDpadDirection != null) {
            movementTimer += delta;
            if (movementTimer >= MOVEMENT_REPEAT_DELAY) {
                GameContext.get().getPlayer().move(currentDpadDirection);
                movementTimer = 0f;
            }
            GameContext.get().getPlayer().setRunning(isRunPressed);
        }

        // Enable blending for UI elements
        Gdx.gl.glEnable(GL20.GL_BLEND);
        Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        renderHotbar(delta);
        if (GameContext.get().getUiStage() != null) {
            GameContext.get().getUiStage().getViewport().apply();
            GameContext.get().getUiStage().act(delta);
            GameContext.get().getUiStage().draw();
        }


        if (Gdx.input.isKeyPressed(Input.Keys.TAB)) {
            renderPlayerListOverlay();
        }
        if (inBattle) {
            if (battleStage != null && !isDisposing) {
                battleStage.act(delta);
                if (battleTable != null && battleTable.hasParent()) {
                    battleStage.draw();
                }
            }
        }


        if (inputManager.getCurrentState() == InputManager.UIState.MENU) {
            if (GameContext.get().getGameMenu() != null) {
                GameContext.get().getGameMenu().render();
            }
        }
        if (inputManager.getCurrentState() == InputManager.UIState.INVENTORY) {
            if (GameContext.get().getInventoryScreen() != null) {
                Gdx.gl.glEnable(GL20.GL_BLEND);
                Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

                // Draw dark background
                shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
                shapeRenderer.setColor(0, 0, 0, 0.7f);
                shapeRenderer.rect(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
                shapeRenderer.end();

                // Render inventory
                GameContext.get().getInventoryScreen().render(delta);

                Gdx.gl.glDisable(GL20.GL_BLEND);
            }
        }


        if (chestScreen != null && chestScreen.isVisible()) {
            chestScreen.render(delta);
        }


        // Android controls
        if (Gdx.app.getType() == Application.ApplicationType.Android && controlsInitialized) {
            ensureAndroidControlsInitialized();
            renderAndroidControls();
        }

        Gdx.gl.glDisable(GL20.GL_BLEND);

        // Game state updates
        if (GameContext.get().getWorld() != null && GameContext.get().getPlayer() != null) {
            float deltaTime = Gdx.graphics.getDeltaTime();
            GameContext.get().getPlayer().update(deltaTime);
            // Camera update
            if (!inBattle && !transitioning) {
                updateCamera();
            }

            if (isMultiplayer) {
                // Other systems updates
                updateOtherPlayers(delta);
                if (GameContext.get().getWorld() != null) {
                    GameContext.get().getWorld().update(delta, new Vector2(GameContext.get().getPlayer().getTileX(), GameContext.get().getPlayer().getTileY()),
                        Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), this);
                }
            } else {
                GameContext.get().getPlayer().validateResources();
                float viewportWidthPixels = camera.viewportWidth * camera.zoom;
                float viewportHeightPixels = camera.viewportHeight * camera.zoom;
                GameContext.get().getWorld().update(delta,
                    new Vector2(GameContext.get().getPlayer().getTileX(), GameContext.get().getPlayer().getTileY()),
                    viewportWidthPixels,
                    viewportHeightPixels, this
                );
            }

            handleInput();
            if (inputHandler != null &&
                (inputManager.getCurrentState() == InputManager.UIState.NORMAL ||
                    inputManager.getCurrentState() == InputManager.UIState.BUILD_MODE)) {
                inputHandler.update(delta);
            }

            updateTimer += delta;

            if (isMultiplayer && updateTimer >= UPDATE_INTERVAL) {
                updateTimer = 0;
                NetworkProtocol.PlayerUpdate update = new NetworkProtocol.PlayerUpdate();
                update.username = GameContext.get().getPlayer().getUsername();
                update.x = GameContext.get().getPlayer().getX();
                update.y = GameContext.get().getPlayer().getY();
                update.characterType = GameContext.get().getPlayer().getCharacterType();

                update.direction = GameContext.get().getPlayer().getDirection();
                update.isMoving = GameContext.get().getPlayer().isMoving();
                update.wantsToRun = GameContext.get().getPlayer().isRunning();
                update.inventoryItems = GameContext.get().getPlayer().getInventory().getAllItems().toArray(new ItemData[0]);
                update.timestamp = System.currentTimeMillis();
                if (GameContext.get().getGameClient() == null) {
                    return;
                }
                GameContext.get().getGameClient().sendPlayerUpdate();
                // Handle incoming updates
                if (GameContext.get().getGameClient() != null) {
                    Map<String, NetworkProtocol.PlayerUpdate> updates = GameContext.get().getGameClient().getPlayerUpdates();
                    if (!updates.isEmpty()) {
                        synchronized (GameContext.get().getGameClient().getOtherPlayers()) {
                            for (NetworkProtocol.PlayerUpdate playerUpdate : updates.values()) {
                                if (!playerUpdate.username.equals(GameContext.get().getPlayer().getUsername())) {
                                    OtherPlayer op = GameContext.get().getGameClient().getOtherPlayers().get(playerUpdate.username);
                                    if (op == null) {
                                        op = new OtherPlayer(playerUpdate.username, playerUpdate.x, playerUpdate.y);
                                        GameContext.get().getGameClient().getOtherPlayers().put(playerUpdate.username, op);
                                        GameLogger.info("Created new player: " + playerUpdate.username);
                                    }
                                    op.updateFromNetwork(playerUpdate);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    private void renderLoadingOverlay() {
        // Just draw a big semi-transparent rectangle with “Loading…” text.
        GameContext.get().getBatch().begin();
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0, 0, 0, 0.5f);
        shapeRenderer.rect(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        shapeRenderer.end();

        // You can also draw text:
        font.draw(GameContext.get().getBatch(), "Loading world...",
            Gdx.graphics.getWidth() * 0.5f - 50,
            Gdx.graphics.getHeight() * 0.5f);
        GameContext.get().getBatch().end();
    }


    private void renderPlayerListOverlay() {
        // Create a table for the overlay
        Table table = new Table();
        table.setFillParent(true);
        table.center();

        // Use your skin (for example, from GameContext or your GameScreen)
        Skin skin = this.skin;

        // Create a semi-transparent background (or use a drawable from your skin)
        Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        pixmap.setColor(0, 0, 0, 0.6f); // 60% opaque black
        pixmap.fill();
        table.setBackground(new TextureRegionDrawable(new TextureRegion(new Texture(pixmap))));
        pixmap.dispose();

        // Add a header row
        Label header = new Label("Players Online", skin);
        table.add(header).colspan(2).padBottom(10);
        table.row();

        // Get the player list (including our own)
        GameClient client = GameContext.get().getGameClient();
        if (client == null) return;
        Map<String, Integer> pingMap = client.getPlayerPingMap();

        // Add the local player first
        String localName = client.getLocalUsername();
        int localPing = client.getLocalPing();
        Label localLabel = new Label(localName, skin);
        Label localPingLabel = new Label(localPing + " ms", skin);
        table.add(localLabel).pad(5);
        table.add(localPingLabel).pad(5);
        table.row();

        // Add other players
        for (Map.Entry<String, Integer> entry : pingMap.entrySet()) {
            String username = entry.getKey();
            if (username.equals(localName)) continue;  // already added
            Label nameLabel = new Label(username, skin);
            Label pingLabel = new Label(entry.getValue() + " ms", skin);
            table.add(nameLabel).pad(5);
            table.add(pingLabel).pad(5);
            table.row();
        }

        // Render the table using a temporary stage (alternatively, create the table once)
        Stage overlayStage = new Stage(new ScreenViewport());
        overlayStage.addActor(table);
        overlayStage.act();
        overlayStage.draw();
        overlayStage.dispose();
    }

    private void renderHotbar(float delta) {
        if (GameContext.get().getPlayer() != null &&
            GameContext.get().getPlayer().getHotbarSystem() != null) {
            GameContext.get().getPlayer().getHotbarSystem().updateHotbar();
        }
    }

    private String formatPlayedTime(long millis) {
        long seconds = millis / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;

        seconds = seconds % 60;
        minutes = minutes % 60;

        return String.format("%02dh %02dm %02ds", hours, minutes, seconds);
    }

    private void updateOtherPlayers(float delta) {
        if (isMultiplayer) {
            if (GameContext.get().getGameClient() == null) {
                return;
            }
            Map<String, OtherPlayer> others = GameContext.get().getGameClient().getOtherPlayers();
            if (!others.isEmpty()) {
                for (OtherPlayer otherPlayer : others.values()) {
                    try {
                        otherPlayer.update(delta);
                    } catch (Exception e) {
                        GameLogger.error("Error updating other player: " + e.getMessage());
                    }
                }
            }
        }
    }

    private void renderDebugInfo() {
        GameContext.get().getBatch().setProjectionMatrix(GameContext.get().getUiStage().getCamera().combined);
        font.setColor(Color.WHITE);

        float debugY = 25;

        // Add FPS display at the top
        int fps = Gdx.graphics.getFramesPerSecond();
        font.draw(GameContext.get().getBatch(), "FPS: " + fps, 10, debugY);
        debugY += 20;

        float pixelX = GameContext.get().getPlayer().getX();
        float pixelY = GameContext.get().getPlayer().getY();
        int tileX = (int) Math.floor(pixelX / TILE_SIZE);
        int tileY = (int) Math.floor(pixelY / TILE_SIZE);
        Biome currentBiome = GameContext.get().getWorld().getBiomeAt(tileX, tileY);
        // Use the primary biome's name from the result
        String biomeName = (currentBiome != null) ? currentBiome.getName() : "Unknown";
        font.draw(GameContext.get().getBatch(), String.format("Pixels: (%d, %d)", (int) pixelX, (int) pixelY), 10, debugY);
        debugY += 20;
        font.draw(GameContext.get().getBatch(), String.format("Tiles: (%d, %d)", tileX, tileY), 10, debugY);
        debugY += 20;
        font.draw(GameContext.get().getBatch(), "Direction: " + GameContext.get().getPlayer().getDirection(), 10, debugY);
        debugY += 20;
        font.draw(GameContext.get().getBatch(), "Biome: " + biomeName, 10, debugY); // Use the fetched name
        debugY += 20;

        font.draw(GameContext.get().getBatch(), "Active Pokemon: " + getTotalPokemonCount(), 10, debugY);
        debugY += 20;

        String timeString = DayNightCycle.getTimeString(GameContext.get().getWorld().getWorldData().getWorldTimeInMinutes());
        font.draw(GameContext.get().getBatch(), "Time: " + timeString, 10, debugY);
        debugY += 20;

        if (!GameContext.get().isMultiplayer()) {
            long playedTimeMillis = GameContext.get().getWorld().getWorldData().getPlayedTime();
            String playedTimeStr = formatPlayedTime(playedTimeMillis);
            font.draw(GameContext.get().getBatch(), "Total Time Played: " + playedTimeStr, 10, debugY);
        }
    }

    private void handleInput() {
        // Always check for F3 first, regardless of UI state:
        if (Gdx.input.isKeyJustPressed(Input.Keys.F3)) {
            SHOW_DEBUG_INFO = !SHOW_DEBUG_INFO;
        }

        // Then process other inputs only if no UI is active that should block game input:
        if (GameContext.get().getChatSystem() != null && GameContext.get().getChatSystem().isActive()) {
            return;
        }
        if (inBattle) {
            return;
        }
        if (inputManager.getCurrentState() == InputManager.UIState.NORMAL) {
            handleGameInput();
        }
    }

    public ChestScreen getChestScreen() {
        return chestScreen;
    }

    public void setChestScreen(ChestScreen chestScreen) {
        this.chestScreen = chestScreen;
    }

    private void handleGameInput() {
        if (inBattle) {
            return;
        }
        if (inputBlocked) {
            return;
        }


    }

    public void initializeBuildMode() {
        if (GameContext.get().getBuildModeUI() == null) {
            BuildModeUI buildUI = new BuildModeUI(skin);
            GameContext.get().setBuildModeUI(buildUI);
            GameContext.get().getUiStage().addActor(buildUI);
            buildUI.setVisible(false); // Initially hidden
        }
    }

    private int getTotalPokemonCount() {
        if (GameContext.get().getWorld() != null && GameContext.get().getWorld().getPokemonSpawnManager() != null) {
            return GameContext.get().getWorld().getPokemonSpawnManager().getAllWildPokemon().size();
        }
        return 0;
    }

    @Override
    public void resize(int width, int height) {
        if (GameContext.get().getPlayer() != null) {
            GameContext.get().getPlayer().validateResources();
        }
        if (starterTable != null) {
            starterTable.resize(width, height);
        }

        ACTION_BUTTON_SIZE = height * 0.12f;
        DPAD_SIZE = height * 0.3f;
        BUTTON_PADDING = width * 0.02f;

        if (controlsInitialized) {
            androidControlsTable.clearChildren();
            createDpad();
            createActionButtons();
        }


        if (dpadTable != null) {
            dpadTable.clear();
            createDpad();
        }

        cameraViewport.update(width, height, false);

        if (GameContext.get().getInventoryScreen() != null) {
            GameContext.get().getInventoryScreen().resize(width, height);

            if (closeButtonTable != null && closeButtonTable.getParent() != null) {
                closeButtonTable.invalidate();
            }
        }
        if (GameContext.get().getCraftingScreen() != null) {
            GameContext.get().getCraftingScreen().resize(width, height);
        }
        for (Actor actor : stage.getActors()) {
            if (actor instanceof StarterSelectionTable) {
                ((StarterSelectionTable) actor).resize(width, height);
                starterTable.resize(width, height);
                break;
            }
        }
        if (GameContext.get().getUiStage() != null) {
            GameContext.get().getUiStage().getViewport().update(width, height, true);
            GameLogger.info("Stage viewport updated to: " + width + "x" + height);

            if (starterTable != null && GameContext.get().getPlayer().getPokemonParty().getSize() == 0) {
                starterTable.setFillParent(true);
                GameLogger.info("Starter table position after resize: " +
                    starterTable.getX() + "," + starterTable.getY());
            }
        }
        if (battleStage != null) {
            battleStage.getViewport().update(width, height, true);
            if (battleTable != null) {
                battleTable.invalidate();
                battleTable.validate();
            }
        }
        if (GameContext.get().getUiStage() != null) {
            GameContext.get().getUiStage().getViewport().update(width, height, true);
        }
        if (GameContext.get().getGameMenu() != null && GameContext.get().getGameMenu().getStage() != null) {
            GameContext.get().getGameMenu().getStage().getViewport().update(width, height, true);
            GameContext.get().getGameMenu().resize(width, height);
        }
        if (pokemonPartyStage != null) {
            pokemonPartyStage.getViewport().update(width, height, true);
        }
        if (GameContext.get().getChatSystem() != null) {
            float chatWidth = Math.max(ChatSystem.MIN_CHAT_WIDTH, width * 0.25f);
            float chatHeight = Math.max(ChatSystem.MIN_CHAT_HEIGHT, height * 0.3f);

            GameContext.get().getChatSystem().setSize(chatWidth, chatHeight);
            GameContext.get().getChatSystem().setPosition(
                ChatSystem.CHAT_PADDING,
                height - chatHeight - ChatSystem.CHAT_PADDING
            );
            GameContext.get().getChatSystem().resize(width, height);
        }
        if (controlsInitialized) {
            joystickCenter.set(width * 0.2f, height * 0.25f);
            joystickCurrent.set(joystickCenter);

            if (androidControlsTable != null) {
                androidControlsTable.invalidateHierarchy();
            }
        }
        ensureAndroidControlsInitialized();
        updateAndroidControlPositions();

        updateCamera();
        GameLogger.info("Screen resized to: " + width + "x" + height);
    }

    private ItemData generateRandomItemData() {
        List<String> itemNames = new ArrayList<>(ItemManager.getAllFindableItemNames());
        if (itemNames.isEmpty()) {
            GameLogger.error("No items available in ItemManager to generate random item.");
            return null;
        }
        int index = MathUtils.random(itemNames.size() - 1);
        String itemName = itemNames.get(index);
        ItemData itemData = InventoryConverter.itemToItemData(ItemManager.getItem(itemName));
        if (itemData != null) {
            itemData.setCount(1);
            itemData.setUuid(UUID.randomUUID());
            return itemData;
        }
        GameLogger.error("Failed to retrieve ItemData for item: " + itemName);
        return null;
    }

    private NetworkProtocol.ChatMessage createPickupMessage(ItemData itemData) {
        NetworkProtocol.ChatMessage pickupMessage = new NetworkProtocol.ChatMessage();
        pickupMessage.sender = "System";
        pickupMessage.content = "You found: " + itemData.getItemId() + " (×" + itemData.getCount() + ")";
        pickupMessage.timestamp = System.currentTimeMillis();
        pickupMessage.type = NetworkProtocol.ChatType.SYSTEM;

        return pickupMessage;
    }

    public void handlePickupAction() {
        WorldObject nearestPokeball = GameContext.get().getWorld().getNearestPokeball();
        if (nearestPokeball == null) {
            return;
        }

        if (GameContext.get().getPlayer().canPickupItem(nearestPokeball.getPixelX(), nearestPokeball.getPixelY())) {
            GameContext.get().getWorld().removeWorldObject(nearestPokeball);

            ItemData randomItemData = generateRandomItemData();
            if (randomItemData == null) {
                return;
            }

            boolean added;
            try {
                added = InventoryConverter.addItemToInventory(GameContext.get().getPlayer().getInventory(), randomItemData);

                if (added) {
                    // Play pickup sound
                    AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);

                    NetworkProtocol.ChatMessage pickupMessage = createPickupMessage(randomItemData);
                    if (GameContext.get().getChatSystem() != null) {
                        GameContext.get().getChatSystem().handleIncomingMessage(pickupMessage);
                    }

                    if (GameContext.get().getGameClient() != null && !GameContext.get().getGameClient().isSinglePlayer()) {
                        // Update player data
                        PlayerData currentState = GameContext.get().getPlayer().getPlayerData();
                        currentState.updateFromPlayer(GameContext.get().getPlayer());

                        // Send to server
                        GameContext.get().getGameClient().savePlayerState(currentState);
                    }

                } else {
                    // Handle inventory full case
                    if (GameContext.get().getChatSystem() != null) {
                        NetworkProtocol.ChatMessage message = createSystemMessage(
                            "Inventory full! Couldn't pick up: " + randomItemData.getItemId());
                        GameContext.get().getChatSystem().handleIncomingMessage(message);
                    }
                }

            } catch (Exception e) {
                GameLogger.error("Error handling item pickup: " + e.getMessage());
            }
        }
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    public SpriteBatch getBatch() {
        return GameContext.get().getBatch();
    }

    @Override
    public void dispose() {
        if (isDisposing) return;
        isDisposing = true;

        GameLogger.info("Disposing GameScreen...");

        // Dispose of resources OWNED BY THIS SCREEN, not shared resources.
        if (shapeRenderer != null) {
            shapeRenderer.dispose();
            shapeRenderer = null;
        }

        if (battleStage != null) {
            battleStage.dispose();
            battleStage = null;
        }

        if (pokemonPartyStage != null) {
            pokemonPartyStage.dispose();
            pokemonPartyStage = null;
        }

        if (GameContext.get().getInventoryScreen() != null) {
            GameContext.get().getInventoryScreen().dispose();
            GameContext.get().setInventoryScreen(null);
        }

        if (GameContext.get().getCraftingScreen() != null) {
            GameContext.get().getCraftingScreen().dispose();
            GameContext.get().setCraftingScreen(null);
        }

        // The GameMenu will be disposed and recreated by the show() method, but we can clean it up here.
        if (GameContext.get().getGameMenu() != null) {
            GameContext.get().getGameMenu().dispose();
            GameContext.get().setGameMenu(null);
        }

        // The world and player are managed by CreatureCaptureGame, so we don't dispose them here.
        // The uiStage, skin, and batches are also managed by the main game/context.

        GameLogger.info("GameScreen disposed.");
    }

    private void initializeAndroidControls() {
        if (Gdx.app.getType() != Application.ApplicationType.Android || controlsInitialized) {
            return;
        }

        try {
            float screenWidth = Gdx.graphics.getWidth();
            float screenHeight = Gdx.graphics.getHeight();

            ACTION_BUTTON_SIZE = screenHeight * 0.12f;
            DPAD_SIZE = screenHeight * 0.3f;
            BUTTON_PADDING = screenWidth * 0.02f;
            androidControlsTable = new Table();
            androidControlsTable.setFillParent(true);

            // Create your D-pad and action buttons as usual
            createDpad();
            createActionButtons();

            // *** NEW CODE: Create the House Toggle Button ***
            houseToggleButton = createColoredButton("House", Color.ORANGE, ACTION_BUTTON_SIZE);
            // Initially hide it (only shown if build mode is active)
            houseToggleButton.setVisible(false);
            houseToggleButton.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    // Only act if build mode is active
                    if (GameContext.get().getPlayer().isBuildMode()) {
                        BuildModeUI buildUI = GameContext.get().getBuildModeUI();
                        if (buildUI != null) {
                            buildUI.toggleBuildingMode();
                        }
                    }
                }
            });
            // Add it to the stage (or to your controls table if you prefer)
            GameContext.get().getUiStage().addActor(houseToggleButton);
            // *** END NEW CODE ***

            createDpadHitboxes();

            controlsInitialized = true;
            GameLogger.info("Android controls initialized");

        } catch (Exception e) {
            GameLogger.error("Failed to initialize Android controls: " + e.getMessage());
        }
    }

    private Actor createColoredButton(String label, Color color, float size) {
        Pixmap pixmap = new Pixmap((int) size, (int) size, Pixmap.Format.RGBA8888);
        pixmap.setColor(color.r, color.g, color.b, 0.8f);
        pixmap.fillCircle((int) size / 2, (int) size / 2, (int) size / 2);
        TextureRegionDrawable drawable = new TextureRegionDrawable(new Texture(pixmap));
        pixmap.dispose();

        TextButton.TextButtonStyle style = new TextButton.TextButtonStyle();
        style.up = drawable;
        style.down = drawable.tint(Color.DARK_GRAY);
        style.font = skin.getFont("default-font");
        style.fontColor = Color.WHITE;

        TextButton button = new TextButton(label, style);
        Container<TextButton> buttonContainer = new Container<>(button);
        buttonContainer.setTransform(true);
        buttonContainer.size(size * 1.5f);
        buttonContainer.setOrigin(Align.center);
        buttonContainer.setTouchable(Touchable.enabled);
        float fontScale = size / 60f;
        button.getLabel().setFontScale(fontScale);

        button.getLabel().setAlignment(Align.center);

        button.setSize(size, size);

        return buttonContainer;
    }

    private void createActionButtons() {
        // Create buttons
        aButton = createColoredButton("A", Color.GREEN, ACTION_BUTTON_SIZE);
        xButton = createColoredButton("X", Color.BLUE, ACTION_BUTTON_SIZE);
        yButton = createColoredButton("Y", Color.YELLOW, ACTION_BUTTON_SIZE);
        zButton = createColoredButton("Z", Color.PURPLE, ACTION_BUTTON_SIZE);
        startButton = createColoredButton("Start", Color.WHITE, ACTION_BUTTON_SIZE);
        selectButton = createColoredButton("Select", Color.GRAY, ACTION_BUTTON_SIZE);

        // Set touchable
        aButton.setTouchable(Touchable.enabled);
        xButton.setTouchable(Touchable.enabled);
        yButton.setTouchable(Touchable.enabled);
        zButton.setTouchable(Touchable.enabled);
        startButton.setTouchable(Touchable.enabled);
        selectButton.setTouchable(Touchable.enabled);

        // Position action buttons
        Table actionButtonTable = new Table();
        actionButtonTable.setFillParent(true);
        actionButtonTable.bottom().right().pad(BUTTON_PADDING * 2);
        actionButtonTable.row();
        actionButtonTable.add(startButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);
        actionButtonTable.add(selectButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);
        actionButtonTable.row();
        actionButtonTable.add(yButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);
        actionButtonTable.add(zButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);
        actionButtonTable.row();
        actionButtonTable.add(xButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);
        actionButtonTable.add(aButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);

        GameContext.get().getUiStage().addActor(actionButtonTable);

        addButtonListeners();
    }

    private void addButtonListeners() {
        ((Container<TextButton>) aButton).getActor().addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                inputHandler.handleInteraction();
            }
        });

        ((Container<TextButton>) xButton).getActor().addListener(new InputListener() {
            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
                inputHandler.startChopOrPunch();
                return true;
            }

            @Override
            public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
                inputHandler.stopChopOrPunch();
            }
        });

        ((Container<TextButton>) yButton).getActor().addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                inputHandler.toggleBuildMode();
            }
        });

        ((Container<TextButton>) zButton).getActor().addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                toggleInventory();
            }
        });

        ((Container<TextButton>) startButton).getActor().addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                handleStartButtonPress();
            }
        });

        ((Container<TextButton>) selectButton).getActor().addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                handleSelectButtonPress();
            }
        });
    }

    public Actor getHouseToggleButton() {
        return houseToggleButton;
    }

    private void handleStartButtonPress() {
        toggleGameMenu();
    }

    private void handleSelectButtonPress() {

        SHOW_DEBUG_INFO = !SHOW_DEBUG_INFO;
    }

    private void createDpad() {

        float dpadSize = DPAD_SIZE;
        float paddingLeft = BUTTON_PADDING * 2;
        float paddingBottom = BUTTON_PADDING * 2;

        // Create D-pad touch area
        Image dpadTouchArea = new Image();
        dpadTouchArea.setSize(dpadSize, dpadSize);
        dpadTouchArea.setPosition(paddingLeft, paddingBottom);
        dpadTouchArea.setColor(1, 1, 1, 0);
        dpadTouchArea.setTouchable(Touchable.enabled);

        // Add touch listener to the D-pad area
        dpadTouchArea.addListener(new InputListener() {
            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
                float absoluteX = event.getStageX();
                float absoluteY = event.getStageY();
                if (movementController != null) {
                    movementController.handleTouchDown(absoluteX, absoluteY);
                } else {
                    GameLogger.error("movementController is null on touchDown!");
                }
                return true;
            }

            @Override
            public void touchDragged(InputEvent event, float x, float y, int pointer) {
                float absoluteX = event.getStageX();
                float absoluteY = event.getStageY();
                movementController.handleTouchDragged(absoluteX, absoluteY);
            }

            @Override
            public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
                movementController.handleTouchUp();
            }
        });

        GameContext.get().getUiStage().addActor(dpadTouchArea);
    }

    private void createDpadHitboxes() {
        float screenWidth = Gdx.graphics.getWidth();
        float screenHeight = Gdx.graphics.getHeight();
        float dpadCenterX = screenWidth * 0.15f;
        float dpadCenterY = screenHeight * 0.2f;
        float buttonSize = 145f;
        upButton = new Rectangle(
            dpadCenterX - buttonSize / 2,
            dpadCenterY + buttonSize / 4,
            buttonSize,
            buttonSize
        );

        downButton = new Rectangle(
            dpadCenterX - buttonSize / 2,
            dpadCenterY - buttonSize - buttonSize / 4,
            buttonSize,
            buttonSize
        );

        leftButton = new Rectangle(
            dpadCenterX - buttonSize - buttonSize / 4,
            dpadCenterY - buttonSize / 2,
            buttonSize,
            buttonSize
        );

        rightButton = new Rectangle(
            dpadCenterX + buttonSize / 4,
            dpadCenterY - buttonSize / 2,
            buttonSize,
            buttonSize
        );

    }

    private void renderAndroidControls() {
        if (!controlsInitialized || movementController == null) return;

        Gdx.gl.glEnable(GL20.GL_BLEND);
        Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);

        if (movementController.isActive()) {
            Vector2 center = movementController.getJoystickCenter();
            float maxRadius = movementController.getMaxRadius();

            // Base circle (lighter)
            shapeRenderer.setColor(0.3f, 0.3f, 0.3f, 0.3f);
            shapeRenderer.circle(center.x, center.y, maxRadius);

            // Draw joystick knob
            Vector2 current = movementController.getJoystickCurrent();
            float knobSize = maxRadius * 0.3f;

            // Knob shadow
            shapeRenderer.setColor(0.0f, 0.0f, 0.0f, 0.4f);
            shapeRenderer.circle(current.x, current.y, knobSize + 2);

            // Knob (brighter when moved further)
            float intensity = 0.5f + (movementController.getMagnitude() * 0.5f);
            shapeRenderer.setColor(1.0f, 1.0f, 1.0f, intensity);
            shapeRenderer.circle(current.x, current.y, knobSize);
        }

        shapeRenderer.end();
        Gdx.gl.glDisable(GL20.GL_BLEND);
    }

    private static class PokemonPartySlot extends Table {
        private final Pokemon pokemon;
        private final Label levelLabel;
        private final ProgressBar hpBar;

        public PokemonPartySlot(Pokemon pokemon, boolean isSelected, Skin skin) {
            this.pokemon = pokemon;

            // Set background based on whether this slot is selected
            TextureRegionDrawable slotBg = new TextureRegionDrawable(
                TextureManager.ui.findRegion(isSelected ? "slot_selected" : "slot_normal")
            );
            setBackground(slotBg);

            if (pokemon != null) {
                // Pokémon icon (you might want to update the icon periodically as well)
                Image pokemonIcon = new Image(pokemon.getCurrentIconFrame(Gdx.graphics.getDeltaTime()));
                pokemonIcon.setScaling(Scaling.fit);
                add(pokemonIcon).size(40).padTop(4).row();

                // Level label – this will be updated in act()
                levelLabel = new Label("Lv." + pokemon.getLevel(), skin);
                levelLabel.setFontScale(0.8f);
                add(levelLabel).padTop(2).row();

                // HP progress bar – also updated in act()
                hpBar = new ProgressBar(0, pokemon.getStats().getHp(), 1, false, skin);
                hpBar.setValue(pokemon.getCurrentHp());
                add(hpBar).width(40).height(4).padTop(2);
            } else {
                levelLabel = null;
                hpBar = null;
            }
        }

        @Override
        public void act(float delta) {
            super.act(delta);
            // If the Pokémon is not null, update the level and HP display
            if (pokemon != null) {
                levelLabel.setText("Lv." + pokemon.getLevel());
                hpBar.setValue(pokemon.getCurrentHp());
                // Optionally, if the icon might change (e.g. an animation frame),
                // you could update it here as well.
            }
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/InventoryScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.ParticleEffect;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.*;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.system.InputManager;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.*;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingGrid;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingSystem;
import io.github.pokemeetup.system.gameplay.inventory.crafting.RecipeGlossaryUI;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventoryObserver;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.screens.otherui.InventorySlotUI;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.InventoryConverter;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.*;
import java.util.List;

public class InventoryScreen implements Screen, InventoryObserver, CraftingSystem.CraftingSystemObserver, InventoryScreenInterface {
    private static int SLOT_SIZE = 40;

    private final Skin skin;
    private final Stage stage;
    private final SpriteBatch batch;
    private final ShapeRenderer shapeRenderer;
    private final Player player;
    private final Inventory inventory;
    private final CraftingSystem craftingSystem;
    private final List<InventorySlotUI> craftingSlotUIs;
    private final CraftingGrid craftingGrid;
    private List<InventorySlotData> inventorySlots;
    private Group heldItemGroup;
    private Image heldItemImage;
    private InputManager inputManager;
    private Label heldItemCountLabel;
    private Item heldItem = null;
    private InventorySlotUI craftingResultSlotUI;
    private boolean visible = false;

    public InventoryScreen(Player player, Skin skin, Inventory inventory, InputManager inputManager) {
        this.player = player;
        this.skin = skin;
        this.craftingGrid = new CraftingGrid(4); // 2x2 grid
        this.inventory = inventory;
        this.inputManager = inputManager;
        this.stage = new Stage(new ScreenViewport());
        this.batch = new SpriteBatch();
        this.shapeRenderer = new ShapeRenderer();

        this.craftingSystem = new CraftingSystem(inventory, 2, craftingGrid);
        this.craftingSystem.addObserver(this);

        setupHeldItemDisplay();
        initializeInventorySlots();
        this.craftingSlotUIs = new ArrayList<>();

        setupUI();
        inventory.addObserver(this);

        GameLogger.info("InventoryScreen initialized");
        // Removed stage listener that handled global touches.
        // Now rely solely on InventorySlotUI logic for item placement.
    }

    @Override
    public Item getHeldItemObject() {
        return heldItem;
    }

    @Override
    public void show() {
        if (!visible) {
            GameLogger.info("InventoryScreen show() called");
            visible = true;

            // If desired, we can ensure no items are incorrectly held by the player on show,
            // but let's just leave as-is to match the stable approach from CraftingTableScreen.

            // Reload inventory once on show
            reloadInventory();

            if (stage != null) {
                stage.setKeyboardFocus(null);
                stage.unfocusAll();
                stage.act(0);
            }
        }
    }

    @Override
    public void render(float delta) {
        if (!visible) return;
        Gdx.gl.glEnable(GL20.GL_BLEND);
        Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        stage.act(Math.min(delta, 1 / 30f));
        updateHeldItemPosition();
        stage.draw();

        Gdx.gl.glDisable(GL20.GL_BLEND);
    }

    private void updateHeldItemPosition() {
        if (heldItemGroup != null && heldItemGroup.isVisible()) {
            float x = Gdx.input.getX() - 16;
            float y = Gdx.graphics.getHeight() - Gdx.input.getY() - 16;
            heldItemGroup.setPosition(x, y);
        }
    }

    public Stage getStage() {
        return stage;
    }

    @Override
    public CraftingSystem getCraftingSystem() {
        return craftingSystem;
    }

    @Override
    public ChestData getChestData() {
        return null;
    }

    private void initializeInventorySlots() {
        inventorySlots = new ArrayList<>();
        List<ItemData> currentItems = inventory.getAllItems();
        GameLogger.info("InventoryScreen: Inventory has " + currentItems.size() + " slots.");
        int nonNullItemCount = 0;

        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            InventorySlotData slotData = new InventorySlotData(i, InventorySlotData.SlotType.INVENTORY, inventory);
            ItemData itemData = i < currentItems.size() ? currentItems.get(i) : null;

            if (itemData != null) {
                if (itemData.getMaxDurability() <= 0) {
                    Item itemTemplate = ItemManager.getItem(itemData.getItemId());
                    if (itemTemplate != null) {
                        itemData.setMaxDurability(itemTemplate.getMaxDurability());
                    }
                }
                if (itemData.getDurability() <= 0) {
                    itemData.setDurability(itemData.getMaxDurability());
                }

                slotData.setItemData(itemData);
                GameLogger.info("InventoryScreen: Loaded item into slot " + i + ": " +
                    itemData.getItemId() + " x" + itemData.getCount() +
                    ", durability: " + itemData.getDurability() + "/" + itemData.getMaxDurability());
                nonNullItemCount++;
            }

            inventorySlots.add(slotData);
        }

        GameLogger.info("InventoryScreen: Total non-null items loaded: " + nonNullItemCount);
    }
    private void setupUI() {
        float screenWidth = Gdx.graphics.getWidth();
        float screenHeight = Gdx.graphics.getHeight();

        // Calculate relative sizes
        float baseSize = Math.min(screenWidth * 0.04f, screenHeight * 0.07f); // Base size for slots
        SLOT_SIZE = (int) Math.max(baseSize, 40); // Minimum size of 40
        float containerPadding = SLOT_SIZE * 0.25f;

        Table mainTable = new Table();
        mainTable.setFillParent(true);
        mainTable.center();

        // Semi-transparent background
        Pixmap bgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(0, 0, 0, 0.2f);
        bgPixmap.fill();
        Texture bgTexture = new Texture(bgPixmap);
        TextureRegionDrawable background = new TextureRegionDrawable(new TextureRegion(bgTexture));
        mainTable.setBackground(background);
        bgPixmap.dispose();

        // Create a container for everything to ensure proper centering
        Table contentContainer = new Table();

        // Top section container (Crafting + Recipe)
        Table topContainer = new Table();

        // Crafting section
        Table craftingContainer = new Table();
        craftingContainer.setBackground(createBackground());
        craftingContainer.pad(containerPadding);

        // Crafting grid (2x2)
        Table craftingGrid1 = new Table();
        craftingGrid1.defaults().space(SLOT_SIZE * 0.1f);

        for (int y = 0; y < 2; y++) {
            for (int x = 0; x < 2; x++) {
                final int index = y * 2 + x;
                // FIX: Use the existing InventorySlotData from the CraftingGrid.
                InventorySlotData craftSlotData = craftingGrid.getSlotData(index);
                InventorySlotUI craftSlot = new InventorySlotUI(craftSlotData, skin, this, SLOT_SIZE);
                craftingSlotUIs.add(craftSlot);
                craftingSystem.addSlotObserver(index, craftSlot);

                craftingGrid1.add(craftSlot).size(SLOT_SIZE);
                if (x == 1) {
                    craftingGrid1.row();
                }
            }
        }

        // Arrow and result slot
        Image arrowImage = new Image(TextureManager.ui.findRegion("arrow"));
        InventorySlotData resultSlotData = new InventorySlotData(-1, InventorySlotData.SlotType.CRAFTING_RESULT, craftingGrid);
        craftingResultSlotUI = new InventorySlotUI(resultSlotData, skin, this, SLOT_SIZE);

        craftingContainer.add(craftingGrid1).padRight(SLOT_SIZE * 0.5f);
        craftingContainer.add(arrowImage).size(SLOT_SIZE * 0.8f).padRight(SLOT_SIZE * 0.5f);
        craftingContainer.add(craftingResultSlotUI).size(SLOT_SIZE);

        // --- NEW: Explicitly constrain the crafting container's cell ---
        topContainer.add(craftingContainer)
            .padRight(SLOT_SIZE * 0.5f)
            .minWidth(SLOT_SIZE * 3)     // At least enough to show the 2x2 grid plus some extra space
            .minHeight(SLOT_SIZE * 2)
            .align(Align.topLeft);
        // --------------------------------------------------------------

        // Recipe glossary section – layout remains unchanged
        RecipeGlossaryUI recipeGlossary = new RecipeGlossaryUI(stage, skin, this, craftingSystem);
        ScrollPane recipeScroll = recipeGlossary.getRecipeScroll();
        recipeScroll.setScrollingDisabled(true, false);

        Table recipeContainer = new Table();
        recipeContainer.setBackground(createBackground());
        Label recipesLabel = new Label("Recipes", skin);
        recipesLabel.setFontScale(SLOT_SIZE * 0.04f);
        recipeContainer.add(recipesLabel).padBottom(containerPadding).row();
        recipeContainer.add(recipeScroll)
            .width(screenWidth * 0.75f)
            .minWidth(SLOT_SIZE * 6)
            .height(screenHeight * 0.4f)
            .pad(containerPadding);

        topContainer.add(recipeContainer).expandX().fillX();

        contentContainer.add(topContainer).padBottom(SLOT_SIZE * 0.75f).row();

        // Inventory grid (unchanged)
        Table gridTable = new Table();
        gridTable.setName("gridTable");
        gridTable.setBackground(createBackground());
        gridTable.pad(containerPadding);
        int cols = 9;
        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            InventorySlotUI slotUI = createSlotUI(i);
            gridTable.add(slotUI).size(SLOT_SIZE).pad(SLOT_SIZE * 0.05f);
            if ((i + 1) % cols == 0) {
                gridTable.row();
            }
        }
        contentContainer.add(gridTable).row();

        // Close button (unchanged)
        TextButton closeButton = new TextButton("Close", skin);
        closeButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                hide();
            }
        });
        float buttonWidth = SLOT_SIZE * 2.5f;
        float buttonHeight = SLOT_SIZE * 1.0f;
        contentContainer.add(closeButton).size(buttonWidth, buttonHeight).pad(SLOT_SIZE * 0.5f);

        mainTable.add(contentContainer);mainTable.toFront();
        heldItemGroup.toFront();

        stage.addActor(mainTable);
        stage.addActor(heldItemGroup);
    }


    private Drawable createBackground() {
        return new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg"))
            .tint(new Color(0.2f, 0.2f, 0.2f, 0.85f));
    }

    @Override
    public void resize(int width, int height) {
        if (stage != null) {
            stage.getViewport().update(width, height, true);
            // Force a re-layout on all UI Tables in the stage.
            for (Actor actor : stage.getActors()) {
                if (actor instanceof Table) {
                    ((Table) actor).invalidateHierarchy();
                    ((Table) actor).layout();
                }
            }
            float baseSize = Math.min(width * 0.04f, height * 0.07f);
            SLOT_SIZE = (int) Math.max(baseSize, 40);
        }
    }


    public void reloadInventory() {
        GameLogger.info("Reloading inventory (only on show or controlled calls)...");
        if (inventory != null) {
            List<ItemData> currentItems = inventory.getAllItems();

            for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                InventorySlotData slotData = inventorySlots.get(i);
                ItemData item = i < currentItems.size() ? currentItems.get(i) : null;

                if (item != null) {
                    slotData.setItemData(item);
                } else {
                    slotData.clear();
                }
                slotData.notifyObservers();
            }
        }
    }

    @Override
    public void onCraftingResultChanged(ItemData newResult) {
        if (craftingResultSlotUI != null) {
            craftingResultSlotUI.forceUpdate();
        }
    }

    private void setupHeldItemDisplay() {
        heldItemImage = new Image();
        heldItemImage.setSize(32, 32);
        heldItemImage.setVisible(false);

        heldItemCountLabel = new Label("", skin);
        heldItemCountLabel.setVisible(false);

        heldItemGroup = new Group();
        heldItemGroup.addActor(heldItemImage);
        heldItemGroup.addActor(heldItemCountLabel);

        heldItemGroup.setTouchable(Touchable.disabled);
    }

    private InventorySlotUI createSlotUI(int index) {
        InventorySlotData slotData = inventorySlots.get(index);
        return new InventorySlotUI(slotData, skin, this, SLOT_SIZE);
    }


    @Override
    public void updateHeldItemDisplay() {
        if (heldItemGroup == null) return;

        heldItemImage.setVisible(false);
        heldItemCountLabel.setVisible(false);
        heldItemGroup.setVisible(false);

        if (heldItem != null) {
            TextureRegion texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase() + "_item");
            if (texture == null) {
                texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase());
            }

            if (texture != null) {
                heldItemImage.setDrawable(new TextureRegionDrawable(texture));
                heldItemImage.setVisible(true);
                if (heldItem.getCount() > 1) {
                    heldItemCountLabel.setText(String.valueOf(heldItem.getCount()));
                    heldItemCountLabel.setVisible(true);
                } else {
                    heldItemCountLabel.setVisible(false);
                }
                heldItemGroup.setVisible(true);
                heldItemGroup.toFront();
            }
        }
    }


    @Override
    public void pause() {
    }

    public void setVisible(boolean visible) {
        this.visible = visible;
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
        if (visible) {
            GameLogger.info("InventoryScreen hide() called");
            visible = false;

            // If there's still a held item, return it to the inventory now
            if (heldItem != null) {
                ItemData heldItemData = InventoryConverter.itemToItemData(heldItem);
                if (heldItemData != null) {
                    getInventory().addItem(heldItemData);
                }
                setHeldItem(null);
            }

            // Return crafting items
            craftingSystem.returnItemsToInventory();

            if (stage != null) {
                stage.setKeyboardFocus(null);
                stage.unfocusAll();
            }
            inputManager.setUIState(InputManager.UIState.NORMAL);
        }
    }

    @Override
    public void dispose() {
        stage.dispose();
        batch.dispose();
        shapeRenderer.dispose();
    }

    @Override
    public ItemData getHeldItem() {
        return InventoryConverter.itemToItemData(heldItem);
    }

    @Override
    public synchronized void setHeldItem(Item item) {
        if (item == null || item.getCount() <= 0) {
            this.heldItem = null;
        } else {
            Item newHeldItem = new Item(item.getName());
            newHeldItem.setCount(item.getCount());
            newHeldItem.setUuid(item.getUuid() != null ? item.getUuid() : UUID.randomUUID());
            newHeldItem.setDurability(item.getDurability());
            newHeldItem.setMaxDurability(item.getMaxDurability());
            this.heldItem = newHeldItem;
        }
        updateHeldItemDisplay();
    }

    @Override
    public Inventory getInventory() {
        return inventory;
    }

    @Override
    public void onInventoryChanged() {
    }

    @Override
    public Player getPlayer() {
        return player;
    }

    static class ParticleEffectActor extends Actor {
        private final ParticleEffect effect;

        public ParticleEffectActor(ParticleEffect effect) {
            this.effect = effect;
            effect.start();
        }

        @Override
        public void draw(Batch batch, float parentAlpha) {
            effect.setPosition(getX(), getY());
            effect.draw(batch, Gdx.graphics.getDeltaTime());
        }

        @Override
        public void act(float delta) {
            super.act(delta);
            effect.update(delta);
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/InventoryScreenInterface.java
================
package io.github.pokemeetup.screens;

import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingSystem;

public interface InventoryScreenInterface {
    Inventory getInventory();
    Player getPlayer();
    void updateHeldItemDisplay();
    Item getHeldItemObject();  // Add this method
    ItemData getHeldItem();
    void setHeldItem(Item item);
    CraftingSystem getCraftingSystem();
    ChestData getChestData();
}

================
File: src/main/java/io/github/pokemeetup/screens/LoadingScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.ProgressBar;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class LoadingScreen implements Screen {
    private static final float PROGRESS_BAR_WIDTH = 300;
    private static final float PROGRESS_BAR_HEIGHT = 20;
    private static final float UPDATE_INTERVAL = 0.1f; // Update every 100ms

    private final CreatureCaptureGame game;
    private Screen nextScreen;
    private final Stage stage;
    private final ProgressBar progressBar;
    private final Label statusLabel;
    private final Label progressLabel;
    private boolean disposed = false;
    private float progress = 0;
    private float elapsedTime = 0;
    private float updateTimer = 0;
    private String currentStatus = "Initializing...";

    public LoadingScreen(CreatureCaptureGame game, Screen nextScreen) {
        this.game = game;
        this.nextScreen = nextScreen;
        this.stage = new Stage(new ScreenViewport());
        Skin skin = new Skin(Gdx.files.internal("atlas/ui-gfx-atlas.json"));
        Table mainTable = new Table();
        mainTable.setFillParent(true);
        ProgressBar.ProgressBarStyle progressStyle = new ProgressBar.ProgressBarStyle();
        progressStyle.background = skin.getDrawable("progress-bar-bg");
        progressStyle.knob = skin.getDrawable("progress-bar-knob");
        progressStyle.knobBefore = skin.getDrawable("progress-bar-bg");

        progressBar = new ProgressBar(0, 1, 0.01f, false, progressStyle);
        progressBar.setSize(PROGRESS_BAR_WIDTH, PROGRESS_BAR_HEIGHT);

        // Labels
        Label.LabelStyle labelStyle = new Label.LabelStyle(skin.getFont("default-font"), Color.WHITE);
        statusLabel = new Label("", labelStyle);
        progressLabel = new Label("", labelStyle);

        // Layout
        mainTable.add(statusLabel).pad(10).row();
        mainTable.add(progressBar).width(PROGRESS_BAR_WIDTH).height(PROGRESS_BAR_HEIGHT).pad(10).row();
        mainTable.add(progressLabel).pad(10);

        stage.addActor(mainTable);

        GameLogger.info("Loading screen initialized");
    }

    public void setNextScreen(Screen screen) {
        this.nextScreen = screen;
        GameLogger.info("Next screen set: " + screen.getClass().getSimpleName());
    }

    @Override
    public void render(float delta) {
        elapsedTime += delta;
        updateTimer += delta;

        // Update status at intervals
        if (updateTimer >= UPDATE_INTERVAL) {
            updateTimer = 0;
            updateLoadingStatus();
        }

        // Clear screen
        Gdx.gl.glClearColor(0.1f, 0.1f, 0.1f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        // Check if next screen is ready
        if (nextScreen instanceof GameScreen) {
            GameScreen gameScreen = (GameScreen) nextScreen;

            if (gameScreen.isInitialized()) {
                GameLogger.info("Game screen initialized, transitioning...");
                progress = 1;
                updateUI();
                // Add small delay before transition
                if (elapsedTime > 0.5f) {
                    game.setScreen(nextScreen);
                    dispose();
                    return;
                }
            } else {
                updateProgress();
            }
        }

        stage.act(delta);
        stage.draw();
    }

    private void updateLoadingStatus() {
        if (nextScreen instanceof GameScreen) {
            GameScreen gameScreen = (GameScreen) nextScreen;
            String newStatus = getStatusMessage(gameScreen);

            if (!newStatus.equals(currentStatus)) {
                currentStatus = newStatus;
                statusLabel.setText(currentStatus);
                GameLogger.info("Loading status: " + currentStatus);
            }
        }
        updateUI();
    }

    private String getStatusMessage(GameScreen gameScreen) {
        if (progress < 0.3f) return "Initializing world...";
        if (progress < 0.6f) return "Loading chunks...";
        if (progress < 0.9f) return "Preparing game...";
        return "Starting game...";
    }

    private void updateProgress() {
        // Update progress based on actual loading state
        if (GameContext.get().getWorld() != null && GameContext.get().getWorld().getChunks() != null) {
            int totalRequired = (World.INITIAL_LOAD_RADIUS * 2 + 1) *
                (World.INITIAL_LOAD_RADIUS * 2 + 1);
            int loaded = GameContext.get().getWorld().getChunks().size();
            progress = Math.min(0.9f, (float) loaded / totalRequired);
        }
    }

    private void updateUI() {
        progressBar.setValue(progress);
        progressLabel.setText(String.format("%.0f%%", progress * 100));
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void dispose() {
        if (!disposed) {
            GameLogger.info("Disposing loading screen");
            stage.dispose();
            disposed = true;
        }
    }

    @Override
    public void show() {}

    @Override
    public void pause() {}

    @Override
    public void resume() {}

    @Override
    public void hide() {}
}

================
File: src/main/java/io/github/pokemeetup/screens/LoginScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.*;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.viewport.FitViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.screens.otherui.ServerManagementDialog;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;


public class LoginScreen implements Screen {

    // == Constants ==

    public static final String SERVERS_PREFS = "ServerPrefs";
    public static final float MIN_WIDTH = 300f;
    public static final float MAX_WIDTH = 500f;
    private static final String DEFAULT_SERVER_ICON = "ui/default-server-icon.png";
    private static final int MIN_HEIGHT = 600;
    private static final float CONNECTION_TIMEOUT = 30f;
    private static final int MAX_CONNECTION_ATTEMPTS = 3;

    // Virtual resolution (for the FitViewport)
    private static final float VIRTUAL_WIDTH = 800;
    private static final float VIRTUAL_HEIGHT = 600;

    // == Fields ==
    public final Stage stage;
    public final Skin skin;
    public final CreatureCaptureGame game;
    private final Preferences prefs;
    public Array<ServerConnectionConfig> servers;
    public TextField usernameField;
    public TextField passwordField;
    public CheckBox rememberMeBox;
    public Label feedbackLabel;
    public ServerConnectionConfig selectedServer;
    private Table serverListTable;
    private Table mainTable;
    private TextButton loginButton;
    private TextButton registerButton;
    private TextButton backButton;
    private ProgressBar connectionProgress;
    private Label statusLabel;
    private float connectionTimer;
    private boolean isConnecting = false;
    private int connectionAttempts = 0;
    private ScrollPane serverListScrollPane;
    private TextButton editServerButton;
    private TextButton deleteServerButton;

    // == Constructor ==
    public LoginScreen(CreatureCaptureGame game) {
        this.game = game;
        this.stage = new Stage(new FitViewport(VIRTUAL_WIDTH, VIRTUAL_HEIGHT));
        this.skin = new Skin(Gdx.files.internal("atlas/ui-gfx-atlas.json"));
        this.prefs = Gdx.app.getPreferences("LoginPrefs");
        loadServers();

        createUIComponents();
        setupListeners();
        initializeUI();
        setupInputHandling();
        loadSavedCredentials();

        Gdx.input.setInputProcessor(stage);
    }

    // == Screen Implementation ==

    @Override
    public void show() {
        GameContext.get().setMultiplayer(true);
    }

    @Override
    public void render(float delta) {
        if (isConnecting) {
            connectionTimer += delta;
            connectionProgress.setValue(connectionTimer / CONNECTION_TIMEOUT);

            if (connectionTimer >= CONNECTION_TIMEOUT) {
                handleConnectionTimeout();
                return;
            }
        }

        Gdx.gl.glClearColor(0.1f, 0.1f, 0.1f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        stage.act(delta);
        stage.draw();

        // <-- CHANGED: We do not call any "client.connect()" here
        if (GameContext.get().getGameClient() != null) {
            GameContext.get().getGameClient().tick();
        }
    }

    @Override
    public void resize(int width, int height) {
        width = (int) Math.max(width, MIN_WIDTH);
        height = Math.max(height, MIN_HEIGHT);

        stage.getViewport().update(width, height, true);
        mainTable.invalidateHierarchy();
        serverListScrollPane.invalidateHierarchy();
    }

    @Override
    public void pause() {
        // Not needed
    }

    @Override
    public void resume() {
        // Not needed
    }

    @Override
    public void hide() {
        // Not needed
    }

    @Override
    public void dispose() {
        stage.dispose();
    }

    // == UI Creation & Setup ==

    private void createUIComponents() {
        mainTable = new Table();
        mainTable.setFillParent(true);

        TextButton.TextButtonStyle buttonStyle = new TextButton.TextButtonStyle();
        buttonStyle.up = skin.getDrawable("button");
        buttonStyle.down = skin.getDrawable("button-pressed");
        buttonStyle.over = skin.getDrawable("button-over");
        buttonStyle.font = skin.getFont("default-font");

        loginButton = new TextButton("Login", buttonStyle);
        registerButton = new TextButton("Register", buttonStyle);
        backButton = new TextButton("Back", buttonStyle);

        TextField.TextFieldStyle textFieldStyle = new TextField.TextFieldStyle(
            skin.get(TextField.TextFieldStyle.class)
        );
        textFieldStyle.font = skin.getFont("default-font");
        textFieldStyle.fontColor = Color.WHITE;
        textFieldStyle.background = new TextureRegionDrawable(TextureManager.ui.findRegion("textfield"));
        textFieldStyle.cursor = skin.getDrawable("cursor");
        textFieldStyle.selection = skin.getDrawable("selection");
        textFieldStyle.messageFontColor = new Color(0.7f, 0.7f, 0.7f, 1f);

        usernameField = new TextField("", textFieldStyle);
        usernameField.setMessageText("Enter username");

        passwordField = new TextField("", textFieldStyle);
        passwordField.setMessageText("Enter password");
        passwordField.setPasswordMode(true);
        passwordField.setPasswordCharacter('*');

        rememberMeBox = new CheckBox(" Remember Me", skin);

        feedbackLabel = new Label("", skin);
        feedbackLabel.setWrap(true);

        statusLabel = new Label("", skin);
        statusLabel.setWrap(true);

        ProgressBar.ProgressBarStyle progressStyle = new ProgressBar.ProgressBarStyle();
        progressStyle.background = skin.getDrawable("progress-bar-bg");
        progressStyle.knob = skin.getDrawable("progress-bar-knob");
        progressStyle.knobBefore = skin.getDrawable("progress-bar-bg");
        connectionProgress = new ProgressBar(0, 1, 0.01f, false, progressStyle);
        connectionProgress.setVisible(false);

        serverListScrollPane = createServerList();

        editServerButton = new TextButton("Edit Server", buttonStyle);
        deleteServerButton = new TextButton("Delete Server", buttonStyle);

        editServerButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (selectedServer != null) {
                    showServerDialog(selectedServer);
                } else {
                    showError("No server selected.");
                }
            }
        });

        deleteServerButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (selectedServer != null) {
                    deleteServer(selectedServer);
                } else {
                    showError("No server selected.");
                }
            }
        });
    }

    private void initializeUI() {
        float screenWidth = stage.getWidth();
        float screenHeight = stage.getHeight();

        float contentWidth = Math.min(MAX_WIDTH, screenWidth * 0.9f);
        float contentHeight = Math.min(700, screenHeight * 0.9f);

        Table darkPanel = new Table();
        darkPanel.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("window")));
        darkPanel.pad(20);

        Label titleLabel = new Label("PokéMeetup", skin, "title");
        titleLabel.setFontScale(2f);
        darkPanel.add(titleLabel).padBottom(30).row();

        Table serverHeader = new Table();
        serverHeader.defaults().pad(5);
        Label serverLabel = new Label("Available Servers", skin, "title-small");
        serverHeader.add(serverLabel).expandX().left();

        TextButton addServerButton = new TextButton("Add Server", skin);
        addServerButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                showServerDialog(null);
            }
        });

        serverHeader.add(addServerButton).right();
        darkPanel.add(serverHeader).fillX().padBottom(10).row();

        darkPanel.add(serverListScrollPane)
            .width(contentWidth - 40)
            .height(Math.min(220, screenHeight * 0.25f))
            .padBottom(20)
            .row();

        Table loginForm = createLoginForm(contentWidth);
        darkPanel.add(loginForm).width(contentWidth - 40).row();

        Table serverActionTable = new Table();
        serverActionTable.defaults().width((contentWidth - 40) / 2f).height(40).padTop(10);
        serverActionTable.add(editServerButton).padRight(10);
        serverActionTable.add(deleteServerButton);
        darkPanel.add(serverActionTable).padBottom(20).row();

        Table statusSection = new Table();
        statusSection.add(statusLabel).width(contentWidth - 40).padBottom(5).row();
        statusSection.add(connectionProgress).width(contentWidth - 40).height(4).padBottom(5).row();
        statusSection.add(feedbackLabel).width(contentWidth - 40);
        darkPanel.add(statusSection).row();

        mainTable.clear();
        mainTable.setFillParent(true);
        mainTable.center().pad(10);
        mainTable.add(darkPanel);
        darkPanel.pack();
        stage.addActor(mainTable);

        // Place the back button at top-left
        Table topLeftTable = new Table();
        topLeftTable.setFillParent(true);
        topLeftTable.top().left();
        topLeftTable.add(backButton);
        stage.addActor(topLeftTable);
    }

    private Table createLoginForm(float width) {
        Table form = new Table();
        form.defaults().width(width - 40).padBottom(10);

        Table usernameRow = new Table();
        Label usernameLabel = new Label("Username:", skin);
        usernameRow.add(usernameLabel).width(80).right().padRight(10);
        usernameRow.add(usernameField).expandX().fillX().height(36);
        form.add(usernameRow).row();

        Table passwordRow = new Table();
        Label passwordLabel = new Label("Password:", skin);
        passwordRow.add(passwordLabel).width(80).right().padRight(10);
        passwordRow.add(passwordField).expandX().fillX().height(36);
        form.add(passwordRow).row();

        form.add(rememberMeBox).left().padTop(5).row();

        Table buttons = new Table();
        buttons.defaults().width((width - 60) / 2f).height(40);
        buttons.add(loginButton).padRight(10);
        buttons.add(registerButton);
        form.add(buttons).padTop(20);

        return form;
    }

    private ScrollPane createServerList() {
        serverListTable = new Table();
        serverListTable.top();

        for (ServerConnectionConfig server : servers) {
            Table serverEntry = createServerEntry(server);
            serverListTable.add(serverEntry).expandX().fillX().padBottom(2).row();
        }

        ScrollPane.ScrollPaneStyle scrollStyle = new ScrollPane.ScrollPaneStyle();
        scrollStyle.background = new TextureRegionDrawable(TextureManager.ui.findRegion("textfield"));
        scrollStyle.vScroll = skin.getDrawable("scrollbar-v");
        scrollStyle.vScrollKnob = skin.getDrawable("scrollbar-knob-v");

        ScrollPane scrollPane = new ScrollPane(serverListTable, scrollStyle);
        scrollPane.setFadeScrollBars(false);
        scrollPane.setScrollingDisabled(true, false);
        scrollPane.setForceScroll(false, true);
        scrollPane.setOverscroll(false, false);

        return scrollPane;
    }

    // == Server Management ==

    private void showServerDialog(ServerConnectionConfig editServer) {
        ServerManagementDialog dialog = new ServerManagementDialog(
            skin,
            editServer,
            config -> {
                if (editServer != null) {
                    servers.removeValue(editServer, true);
                }
                servers.add(config);
                saveServers();
                updateServerList();
            }
        );
        dialog.show(stage);
    }

    private void deleteServer(ServerConnectionConfig server) {
        if (server.isDefault()) {
            showError("Cannot delete default server");
            return;
        }
        Dialog confirm = new Dialog("Confirm Delete", skin) {
            @Override
            protected void result(Object obj) {
                if ((Boolean) obj) {
                    servers.removeValue(server, true);
                    saveServers();
                    updateServerList();
                }
            }
        };
        confirm.text("Are you sure you want to delete this server?");
        confirm.button("Yes", true);
        confirm.button("No", false);
        confirm.show(stage);
    }

    private void updateServerList() {
        serverListTable.clear();
        serverListTable.top();

        Label headerLabel = new Label("Available Servers", skin, "title-small");
        serverListTable.add(headerLabel).pad(10).row();

        boolean hasServers = false;
        for (ServerConnectionConfig server : servers) {
            Table serverEntry = createServerEntry(server);
            serverListTable.add(serverEntry).expandX().fillX().padBottom(2).row();
            hasServers = true;
        }

        if (!hasServers) {
            Label emptyLabel = new Label("No servers available.", skin);
            emptyLabel.setColor(Color.GRAY);
            serverListTable.add(emptyLabel).pad(20);
        }

        if (selectedServer == null && servers.size > 0) {
            selectedServer = servers.first();
            Cell<?> firstCell = serverListTable.getCells().first();
            if (firstCell != null && firstCell.getActor() instanceof Table) {
                updateServerSelection((Table) firstCell.getActor());
            }
        }

        serverListTable.invalidate();
        serverListScrollPane.invalidate();
        saveServers();

        GameLogger.info("Server list updated with " + servers.size + " servers");
    }

    private Table createServerEntry(final ServerConnectionConfig server) {
        Table entry = new Table();
        entry.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("textfield")));
        entry.pad(10);

        Table iconContainer = new Table();
        try {
            if (server.getIconPath() != null) {
                FileHandle iconFile = Gdx.files.internal(server.getIconPath());
                if (iconFile.exists()) {
                    Image icon = new Image(new Texture(iconFile));
                    icon.setSize(32, 32);
                    iconContainer.add(icon).size(32);
                } else {
                    addDefaultIcon(iconContainer);
                }
            } else {
                addDefaultIcon(iconContainer);
            }
        } catch (Exception e) {
            GameLogger.error("Failed to load server icon: " + e.getMessage());
            addDefaultIcon(iconContainer);
        }

        Table infoPanel = new Table();
        infoPanel.defaults().expandX().fillX().space(5);
        infoPanel.left();

        Label nameLabel = new Label(server.getServerName(), skin, "title-small");
        nameLabel.setEllipsis(true);
        infoPanel.add(nameLabel).left().expandX().fillX().height(24).row();

        Label motdLabel = new Label(server.getMotd() != null ? server.getMotd() : "Welcome!", skin, "default");
        motdLabel.setEllipsis(true);
        motdLabel.setColor(0.8f, 0.8f, 0.8f, 1f);
        infoPanel.add(motdLabel).left().expandX().fillX().height(24).row();

        Label addressLabel = new Label(server.getServerIP() + ":" + server.getTcpPort(), skin, "small");
        addressLabel.setEllipsis(true);
        addressLabel.setColor(0.7f, 0.7f, 0.7f, 1f);
        infoPanel.add(addressLabel).left().expandX().fillX().height(24).row();

        entry.add(iconContainer).padRight(10).width(40);
        entry.add(infoPanel).expandX().fillX();

        entry.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                selectedServer = server;
                updateServerSelection(entry);
            }

            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                if (selectedServer != server) {
                    entry.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("textfield-active")));
                }
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                if (selectedServer != server) {
                    entry.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("textfield")));
                }
            }
        });

        return entry;
    }

    private void addDefaultIcon(Table container) {
        if (TextureManager.ui.findRegion("default-server-icon") != null) {
            Image defaultIcon = new Image(TextureManager.ui.findRegion("default-server-icon"));
            defaultIcon.setSize(32, 32);
            container.add(defaultIcon).size(32);
        } else {
            FileHandle iconFile = Gdx.files.internal(DEFAULT_SERVER_ICON);
            if (iconFile.exists()) {
                Image defaultIcon = new Image(new Texture(iconFile));
                defaultIcon.setSize(32, 32);
                container.add(defaultIcon).size(32);
            }
        }
    }

    private void updateServerSelection(Table selectedEntry) {
        for (Cell<?> cell : serverListTable.getCells()) {
            Actor actor = cell.getActor();
            if (actor instanceof Table) {
                Table entry = (Table) actor;
                if (entry == selectedEntry) {
                    entry.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("textfield-active")));
                } else {
                    entry.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("textfield")));
                }
            }
        }
    }

    // == Listeners & Event Handling ==

    private void setupListeners() {
        if (loginButton != null) {
            loginButton.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    attemptLogin();
                }
            });
        }

        if (registerButton != null) {
            registerButton.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    attemptRegistration();
                }
            });
        }

        if (backButton != null) {
            backButton.addListener(new ChangeListener() {
                @Override
                public void changed(ChangeEvent event, Actor actor) {
                    if (!isConnecting) {
                        game.setScreen(new ModeSelectionScreen(game));
                    }
                }
            });
        }

        stage.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (keycode == Input.Keys.ENTER && !isConnecting) {
                    attemptLogin();
                    return true;
                }
                return false;
            }
        });
    }

    private void setupInputHandling() {
        boolean isMobile = Gdx.app.getType() == Application.ApplicationType.Android
            || Gdx.app.getType() == Application.ApplicationType.iOS;
        float touchPadding = isMobile ? 12 : 6;

        loginButton.padTop(touchPadding).padBottom(touchPadding);
        registerButton.padTop(touchPadding).padBottom(touchPadding);

        // If needed, you can add ripple effect here for mobile, etc.
        // ...
    }

    private void handleConnectionTimeout() {
        isConnecting = false;
        connectionTimer = 0;
        connectionProgress.setVisible(false);

        if (connectionAttempts < MAX_CONNECTION_ATTEMPTS) {
            showRetryDialog();
        } else {
            showError("Connection failed after multiple attempts. Please try again later.");
            setUIEnabled(true);
        }
    }

    private void showRetryDialog() {
        Dialog dialog = new Dialog("Connection Failed", skin) {
            @Override
            protected void result(Object obj) {
                if ((Boolean) obj) {
                    attemptLogin();
                } else {
                    setUIEnabled(true);
                }
            }
        };

        dialog.text("Would you like to try connecting again?");
        dialog.button("Retry", true);
        dialog.button("Cancel", false);
        dialog.show(stage);
    }

    // == Login Flow ==
    private void attemptLogin() {
        final String username = usernameField.getText().trim();
        final String password = passwordField.getText().trim();

        if (username.isEmpty() || password.isEmpty()) {
            showError("Username and password are required");
            return;
        }
        if (selectedServer == null) {
            showError("Please select a server");
            return;
        }

        setUIEnabled(false);
        statusLabel.setText("Connecting to server...");
        connectionProgress.setVisible(true);
        connectionProgress.setValue(0f);

        // <-- CHANGED: We always create exactly ONE GameClient here, no extra calls
        final GameClient client = new GameClient(selectedServer);
        GameContext.get().setGameClient(client);

        // Now use the single connectIfNeeded
        isConnecting = true;  // mark that we are mid-connection
        connectionTimer = 0;  // reset the local timer
        client.connectIfNeeded(
            // onSuccess
            () -> {
                Gdx.app.postRunnable(() -> {
                    statusLabel.setText("Connected. Logging in...");
                    // Now do the login request
                    client.sendLoginRequest(
                        username,
                        password,
                        (NetworkProtocol.LoginResponse lr) -> {
                            // This is your “onResponse”
                            isConnecting = false;
                            connectionProgress.setVisible(false);

                            if (lr.success) {
                                // Optionally store credentials if remember me is checked:
                                if (rememberMeBox.isChecked()) {
                                    saveCredentials(username, password);
                                }
                                setUIEnabled(true);
                                proceedToGame(lr);
                            } else {
                                setUIEnabled(true);
                                showError("Login failed: " + lr.message);
                            }
                        },
                        (String error) -> {
                            // onError from sendLoginRequest
                            isConnecting = false;
                            connectionProgress.setVisible(false);
                            setUIEnabled(true);
                            showError("Login request error: " + error);
                        }
                    );
                });
            },

            // onError
            (String errorMsg) -> {
                // Connection error
                Gdx.app.postRunnable(() -> {
                    isConnecting = false;
                    connectionProgress.setVisible(false);
                    setUIEnabled(true);
                    showError("Connection failed: " + errorMsg);
                });
            }
        , REGISTRATION_CONNECT_TIMEOUT_MS);
    }

    private void proceedToGame(NetworkProtocol.LoginResponse response) {
        try {
            LoadingScreen loadingScreen = new LoadingScreen(game, null);
            game.setScreen(loadingScreen);

            GameScreen gameScreen = new GameScreen(
                game,
                response.username,
                GameContext.get().getGameClient()
            );
            GameContext.get().setGameScreen(gameScreen);
            loadingScreen.setNextScreen(gameScreen);

            // Do not call dispose() on the login screen here.
        } catch (Exception e) {
            GameLogger.error("Failed to transition to game: " + e.getMessage());
            showError("Failed to start game: " + e.getMessage());
        }
    }

    // == Registration Flow ==

    private void attemptRegistration() {
        if (isConnecting) return;
        final String username = usernameField.getText().trim();
        final String password = passwordField.getText().trim();

        if (!validateRegistrationInput(username, password)) {
            return;
        }
        if (selectedServer == null) {
            showError("Please select a server");
            return;
        }
        isConnecting = true;
        connectionTimer = 0;
        setUIEnabled(false);
        statusLabel.setText("Creating account...");
        statusLabel.setColor(Color.WHITE);
        feedbackLabel.setText("");
        connectionProgress.setVisible(true);
        connectionProgress.setValue(0);

        // <-- CHANGED: Only create a single new GameClient
        final GameClient client = new GameClient(selectedServer);
        GameContext.get().setGameClient(client);

        // Connect asynchronously and then send registration request with callbacks
        client.connectIfNeeded(
            () -> {
                Gdx.app.postRunnable(() -> {
                    client.sendRegisterRequest(
                        username,
                        password,
                        (NetworkProtocol.RegisterResponse response) -> {
                            Gdx.app.postRunnable(() -> {
                                isConnecting = false;
                                connectionProgress.setVisible(false);

                                if (response.success) {
                                    showSuccessDialog(response.username);
                                } else {
                                    setUIEnabled(true);
                                    showError(response.message != null ? response.message : "Registration failed");
                                }
                            });
                        },
                        (String errorMsg) -> {
                            Gdx.app.postRunnable(() -> {
                                isConnecting = false;
                                connectionProgress.setVisible(false);
                                setUIEnabled(true);
                                showError("Registration failed: " + errorMsg);
                            });
                        }
                    );
                });
            },
            (String errorMsg) -> {
                Gdx.app.postRunnable(() -> {
                    isConnecting = false;
                    connectionProgress.setVisible(false);
                    setUIEnabled(true);
                    showError("Connection error: " + errorMsg);
                });
            }
        , REGISTRATION_CONNECT_TIMEOUT_MS);
    }
    private static final long REGISTRATION_CONNECT_TIMEOUT_MS = 10000; // 10 seconds

    private void showSuccessDialog(String createdUsername) {
        Dialog dialog = new Dialog("Registration Successful", skin) {
            @Override
            protected void result(Object obj) {
                if ((Boolean) obj) {
                    usernameField.setText(createdUsername);
                    passwordField.setText("");
                    statusLabel.setText("Ready to login");
                    statusLabel.setColor(Color.WHITE);
                    feedbackLabel.setText("");
                    setUIEnabled(true);
                }
            }
        };

        dialog.text("Your account has been created successfully!\nYou can now log in with your credentials.");
        dialog.button("OK", true);
        dialog.setMovable(false);
        dialog.setModal(true);
        dialog.show(stage);
    }

    // == Utility & Validation ==


    private boolean validateRegistrationInput(String username, String password) {
        if (username.isEmpty() || password.isEmpty()) {
            showErrorMessage("Invalid Input", "Username and password cannot be empty.");
            return false;
        }

        if (username.length() < 3 || username.length() > 20) {
            showErrorMessage("Invalid Username", "Username must be between 3 and 20 characters.");
            return false;
        }

        if (!username.matches("^[a-zA-Z0-9_]+$")) {
            showErrorMessage("Invalid Username", "Username can only contain letters, numbers, and underscores.");
            return false;
        }

        String passwordError = validatePassword(password);
        if (passwordError != null) {
            showErrorMessage("Invalid Password", passwordError);
            return false;
        }

        return true;
    }

    private String validatePassword(String password) {
        if (password.length() < 8) {
            return "Password must be at least 8 characters long.";
        }
        if (!password.matches(".*[A-Z].*")) {
            return "Password must contain at least one uppercase letter.";
        }
        if (!password.matches(".*[a-z].*")) {
            return "Password must contain at least one lowercase letter.";
        }
        if (!password.matches(".*\\d.*")) {
            return "Password must contain at least one number.";
        }
        if (!password.matches(".*[!@#$%^&*()\\[\\]{}_+=\\-.,].*")) {
            return "Password must contain at least one special character.";
        }
        return null;
    }

    private void showError(String message) {
        feedbackLabel.setColor(Color.RED);
        feedbackLabel.setText(message);
        stage.addAction(Actions.sequence(
            Actions.moveBy(5f, 0f, 0.05f),
            Actions.moveBy(-10f, 0f, 0.05f),
            Actions.moveBy(5f, 0f, 0.05f)
        ));
        GameLogger.error(message);
    }

    private void showErrorMessage(String title, String message) {
        Dialog dialog = new Dialog(title, skin) {
            @Override
            protected void result(Object obj) {
                feedbackLabel.setColor(Color.RED);
                feedbackLabel.setText(message);
            }
        };
        dialog.text(message);
        dialog.button("OK", true);
        dialog.show(stage);
    }

    private void setUIEnabled(boolean enabled) {
        float alpha = enabled ? 1f : 0.6f;

        usernameField.setDisabled(!enabled);
        passwordField.setDisabled(!enabled);
        rememberMeBox.setDisabled(!enabled);

        loginButton.setDisabled(!enabled);
        registerButton.setDisabled(!enabled);
        backButton.setDisabled(!enabled);

        usernameField.setColor(1, 1, 1, alpha);
        passwordField.setColor(1, 1, 1, alpha);
        loginButton.setColor(1, 1, 1, alpha);
        registerButton.setColor(1, 1, 1, alpha);
        backButton.setColor(1, 1, 1, alpha);
        rememberMeBox.setColor(1, 1, 1, alpha);

        if (serverListTable != null) {
            for (Cell<?> cell : serverListTable.getCells()) {
                Actor actor = cell.getActor();
                if (actor instanceof Table) {
                    actor.setTouchable(enabled ? Touchable.enabled : Touchable.disabled);
                    actor.setColor(1, 1, 1, alpha);
                }
            }
        }
    }

    private void saveCredentials(String username, String password) {
        prefs.putBoolean("rememberMe", true);
        prefs.putString("username", username);
        prefs.putString("password", password);
        prefs.flush();
        GameLogger.info("Credentials saved to preferences");
    }

    private void loadSavedCredentials() {
        boolean rememberMe = prefs.getBoolean("rememberMe", false);
        if (rememberMe) {
            String savedUsername = prefs.getString("username", "");
            String savedPassword = prefs.getString("password", "");
            usernameField.setText(savedUsername);
            passwordField.setText(savedPassword);
            rememberMeBox.setChecked(true);
        }
    }

    public void loadServers() {
        if (servers == null) {
            servers = new Array<>();
        }
        servers.clear();

        // Ensure we have a default server
        ServerConnectionConfig defaultServer = ServerConnectionConfig.getInstance();
        defaultServer.setIconPath(DEFAULT_SERVER_ICON);
        servers.add(defaultServer);

        Preferences serverPrefs = Gdx.app.getPreferences(SERVERS_PREFS);
        String savedServers = serverPrefs.getString("servers", "");

        if (!savedServers.isEmpty()) {
            Json json = new Json();
            for (String serverString : savedServers.split("\\|")) {
                try {
                    if (!serverString.trim().isEmpty()) {
                        ServerEntry entry = json.fromJson(ServerEntry.class, serverString);
                        if (entry != null && !isDefaultServer(entry)) {
                            ServerConnectionConfig config = getServerConnectionConfig(entry);
                            servers.add(config);
                        }
                    }
                } catch (Exception e) {
                    GameLogger.error("Error loading saved server: " + e.getMessage());
                }
            }
        }
    }

    private static ServerConnectionConfig getServerConnectionConfig(ServerEntry entry) {
        ServerConnectionConfig config = new ServerConnectionConfig(
            entry.ip,
            entry.tcpPort,
            entry.udpPort,
            entry.name,
            entry.isDefault,
            entry.maxPlayers
        );
        config.setMotd(entry.motd);
        config.setIconPath(entry.iconPath != null ? entry.iconPath : DEFAULT_SERVER_ICON);
        return config;
    }

    private boolean isDefaultServer(ServerEntry entry) {
        return entry.isDefault && "localhost".equals(entry.ip) && entry.tcpPort == 54555;
    }

    private void saveServers() {
        try {
            Json json = new Json();
            StringBuilder sb = new StringBuilder();
            for (ServerConnectionConfig server : servers) {
                ServerEntry entry = new ServerEntry(
                    server.getServerName(),
                    server.getServerIP(),
                    server.getTcpPort(),
                    server.getUdpPort(),
                    server.getMotd(),
                    server.isDefault(),
                    server.getMaxPlayers(),
                    server.getIconPath()
                );
                if (sb.length() > 0) sb.append("|");
                sb.append(json.toJson(entry));
            }
            Preferences prefs = Gdx.app.getPreferences(SERVERS_PREFS);
            prefs.putString("servers", sb.toString());
            prefs.flush();
        } catch (Exception e) {
            GameLogger.error("Failed to save servers: " + e.getMessage());
        }
    }

    // == Inner Class ==

    private static class ServerEntry {
        public String name;
        public String ip;
        public int tcpPort;
        public int udpPort;
        public String motd;
        public boolean isDefault;
        public int maxPlayers;
        public String iconPath;

        public ServerEntry() {}

        public ServerEntry(String name, String ip, int tcpPort, int udpPort,
                           String motd, boolean isDefault, int maxPlayers, String iconPath) {
            this.name = name;
            this.ip = ip;
            this.tcpPort = tcpPort;
            this.udpPort = udpPort;
            this.motd = motd;
            this.isDefault = isDefault;
            this.maxPlayers = maxPlayers;
            this.iconPath = iconPath;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/ModeSelectionScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.*;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.utils.textures.TextureManager;

public class ModeSelectionScreen implements Screen {
    private final CreatureCaptureGame game;
    private final Stage stage;
    private final Skin skin;
    private final Timer timer;
    private BitmapFont font;

    public ModeSelectionScreen(CreatureCaptureGame game) {
        this.game = game;
        this.stage = new Stage(new ScreenViewport());
        Gdx.input.setInputProcessor(stage);

        this.skin = new Skin();
        this.timer = new Timer();

        try {
            this.font = initializeSkin();
            Gdx.app.log("SkinSetup", "Successfully initialized the skin.");
        } catch (Exception e) {
            showError("Failed to initialize UI: " + e.getMessage());
            Gdx.app.error("SkinSetup", "Failed to initialize UI", e);
            return;
        }
        AudioManager.getInstance().setMusicEnabled(true);
        createUI();
    }

    private BitmapFont initializeSkin() {
        // Add BitmapFont with larger font size
        BitmapFont font = new BitmapFont(Gdx.files.internal("Skins/default.fnt")); // Use a larger font file
        skin.add("default", font);

        // Define Colors
        skin.add("white", Color.WHITE);
        skin.add("black", Color.BLACK);
        skin.add("gray", Color.GRAY);

        // Create drawables
        Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        pixmap.setColor(Color.WHITE);
        pixmap.fill();
        skin.add("white", new Texture(pixmap));

        // Clean up the pixmap
        pixmap.dispose();

        // Create styles
        TextButton.TextButtonStyle textButtonStyle = new TextButton.TextButtonStyle();
        textButtonStyle.up = skin.newDrawable("white", Color.DARK_GRAY);
        textButtonStyle.down = skin.newDrawable("white", Color.LIGHT_GRAY);
        textButtonStyle.over = skin.newDrawable("white", Color.GRAY);
        textButtonStyle.font = skin.getFont("default");
        textButtonStyle.fontColor = Color.WHITE;
        skin.add("default", textButtonStyle);

        Label.LabelStyle labelStyle = new Label.LabelStyle();
        labelStyle.font = skin.getFont("default");
        labelStyle.fontColor = Color.WHITE;
        skin.add("default", labelStyle);

        // Create and add WindowStyle
        Window.WindowStyle windowStyle = new Window.WindowStyle();
        windowStyle.titleFont = skin.getFont("default");
        windowStyle.background = skin.newDrawable("white", new Color(0.2f, 0.2f, 0.2f, 0.8f));
        windowStyle.titleFontColor = Color.WHITE;
        skin.add("default", windowStyle);

        return font;
    }

    private void createUI() {
        // Create root table
        Table rootTable = new Table();
        rootTable.setFillParent(true);

        Table mainTable = new Table();
        mainTable.setFillParent(true);
        TextureRegion backgroundRegion = new TextureRegionDrawable(TextureManager.ui.findRegion("ethereal")).getRegion();
        Image backgroundImage = new Image(backgroundRegion);
        backgroundImage.setFillParent(true);
        stage.addActor(backgroundImage);

        stage.addActor(backgroundImage);
        // Add root table on top
        stage.addActor(rootTable);

        // Title Label
        Label titleLabel = new Label("Capsule Story", skin);
        titleLabel.setFontScale(1.5f);

        // Version Label
        Label versionLabel = new Label("Version 1.0", skin);
        versionLabel.setFontScale(0.8f);

        // Buttons with styles
        TextButton.TextButtonStyle buttonStyle = skin.get("default", TextButton.TextButtonStyle.class);
        buttonStyle.font.getData().setScale(1.2f);

        TextButton singlePlayerButton = new TextButton("Single Player", buttonStyle);
        TextButton multiplayerButton = new TextButton("Multiplayer", buttonStyle);
        TextButton exitButton = new TextButton("Exit Game", buttonStyle);

        // Build the UI layout
        rootTable.pad(20);
        rootTable.defaults().pad(10).width(Value.percentWidth(0.6f, rootTable)).height(50);

        rootTable.add(titleLabel).expandX().center().row();
        rootTable.add(versionLabel).expandX().center().padBottom(30).row();
        rootTable.add(singlePlayerButton).row();
        rootTable.add(multiplayerButton).row();
        rootTable.add(exitButton).row();

        // Add button listeners
        singlePlayerButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                game.setScreen(new WorldSelectionScreen(game));
                dispose();
            }
        });

        multiplayerButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                game.setScreen(new LoginScreen(game));
                dispose();
            }
        });

        exitButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                Gdx.app.exit();
            }
        });
    }

    private void showError(String message) {
        Dialog dialog = new Dialog("Error", skin);
        dialog.text(message);
        dialog.button("OK");
        dialog.show(stage);
    }

    @Override
    public void render(float delta) {
        // Handle back button on Android
        if (Gdx.input.isKeyJustPressed(Input.Keys.BACK)) {
            Gdx.app.exit();
            return;
        }

        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        stage.act(delta);
        stage.draw();
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void dispose() {
        stage.dispose();
        skin.dispose();
        font.dispose();
        if (timer != null) {
            timer.clear();
        }
    }

    // Other required Screen methods...
    @Override
    public void show() {
        AudioManager.getInstance().playMenuMusic();
    }


    @Override
    public void hide() {
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/BagScreen.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.utils.Align;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class BagScreen extends Window {

    public interface BagSelectionListener {
        void onItemSelected(ItemData item);
    }

    private final Inventory inventory;
    private final BagSelectionListener listener;
    private Runnable onClose; // Callback to run when the bag is closed

    // Define explicit lists for filtering by category.
    private static final List<String> HEALING_ITEMS = Arrays.asList("potion", "elixir");
    private static final List<String> CATCHING_ITEMS = Arrays.asList("pokeball", "greatball", "ultraball");
    private static final List<String> BATTLE_ITEMS = List.of("wooden_axe"); // example for battle items
    private static final List<String> ACTION_ITEMS = List.of("action"); // adjust as needed

    public BagScreen(Skin skin, Inventory inventory, BagSelectionListener listener) {
        super("Bag", skin);
        this.inventory = inventory;
        this.listener = listener;
        setSize(600, 400);
        center();
        setModal(true);    // Make this window modal so it captures input
        setMovable(false); // Fixed position
        buildUI(skin);
    }

    public void setOnClose(Runnable onClose) {
        this.onClose = onClose;
    }

    @Override
    public boolean remove() {
        if (onClose != null) {
            onClose.run();
        }
        return super.remove();
    }

    private void buildUI(Skin skin) {
        // Create a tab header with four buttons.
        Table tabTable = new Table(skin);
        final TextButton healingTab = new TextButton("Healing", skin);
        final TextButton battleTab = new TextButton("Battle", skin);
        final TextButton catchingTab = new TextButton("Catching", skin);
        final TextButton actionTab = new TextButton("Action", skin);
        tabTable.add(healingTab).pad(5);
        tabTable.add(battleTab).pad(5);
        tabTable.add(catchingTab).pad(5);
        tabTable.add(actionTab).pad(5);
        add(tabTable).expandX().fillX().row();

        // Use a table to hold the content, wrapped in a scroll pane for better layout.
        final Table contentTable = new Table(skin);
        ScrollPane scrollPane = new ScrollPane(contentTable, skin);
        scrollPane.setFadeScrollBars(false);
        add(scrollPane).expand().fill().row();

        // Initially show the "Catching" section.
        populateSection(contentTable, "catching");

        healingTab.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                populateSection(contentTable, "healing");
            }
        });
        battleTab.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                populateSection(contentTable, "battle");
            }
        });
        catchingTab.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                populateSection(contentTable, "catching");
            }
        });
        actionTab.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                populateSection(contentTable, "action");
            }
        });

        // A close button at the bottom.
        TextButton closeButton = new TextButton("Close", skin);
        add(closeButton).pad(10).expandX().fillX();
        closeButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                remove();
            }
        });
    }

    private void populateSection(Table contentTable, String section) {
        contentTable.clear();
        List<ItemData> items = inventory.getAllItems();
        List<ItemData> filtered = new ArrayList<>();
        for (ItemData item : items) {
            if (item == null) continue;
            // Use the item ID directly (which is used for identification) and compare exactly.
            String normalizedId = item.getItemId().toLowerCase();
            switch (section) {
                case "healing":
                    if (HEALING_ITEMS.contains(normalizedId))
                        filtered.add(item);
                    break;
                case "battle":
                    if (BATTLE_ITEMS.contains(normalizedId))
                        filtered.add(item);
                    break;
                case "catching":
                    if (CATCHING_ITEMS.contains(normalizedId))
                        filtered.add(item);
                    break;
                case "action":
                    if (ACTION_ITEMS.contains(normalizedId))
                        filtered.add(item);
                    break;
            }
        }
        if (filtered.isEmpty()) {
            Label emptyLabel = new Label("No items in this section.", getSkin());
            emptyLabel.setAlignment(Align.center);
            contentTable.add(emptyLabel).expand().fill().center();
        } else {
            for (final ItemData item : filtered) {
                // Display the item name (or any other display property) along with its count.
                TextButton itemButton = new TextButton(item.getItemId() + " x" + item.getCount(), getSkin());
                itemButton.addListener(new ChangeListener() {
                    @Override
                    public void changed(ChangeEvent event, Actor actor) {
                        if (listener != null)
                            listener.onItemSelected(item);
                        remove();
                    }
                });
                contentTable.add(itemButton).pad(5).fillX().expandX();
                contentTable.row();
            }
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/BattleTable.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.actions.SequenceAction;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.ObjectMap;
import com.badlogic.gdx.utils.Scaling;
import com.badlogic.gdx.utils.viewport.FitViewport;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.PokemonCaptureAnimation;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;

public class BattleTable extends Table {
    private final Stage stage;
    private final Skin skin;
    private final Pokemon enemyPokemon;
    private Pokemon playerPokemon;

    // UI Elements
    private Image playerPokemonImage, enemyPokemonImage;
    private ProgressBar playerHPBar, enemyHPBar, expBar;
    private Label playerInfoLabel, enemyInfoLabel, battleText;
    private Image playerStatusIcon, enemyStatusIcon;
    private Table actionMenu, moveSelectionTable;
    private TextButton fightButton, bagButton, pokemonButton, runButton;

    // State Management
    private BattleState currentState;
    private BattleCallback callback;
    private boolean isAnimating = false;
    private boolean playerActionTaken = false;
    private final Queue<BattleMessage> messageQueue = new LinkedList<>();
    private boolean processingMessage = false;
    public static final int STATUS_ICON_WIDTH = 44;
    public static final int STATUS_ICON_HEIGHT = 16;
    private static final float BATTLE_SCREEN_WIDTH = 800f;
    private static final float BATTLE_SCREEN_HEIGHT = 480f;
    private static final float HP_BAR_WIDTH = 100f;
    private static final float DAMAGE_FLASH_DURATION = 0.1f;
    private static final float MOVE_EXECUTION_DELAY = 0.7f;
    private static final float POST_DAMAGE_DELAY = 0.8f;
    private static final float POST_EFFECT_DELAY = 1.0f;
    private static final float MULTI_HIT_DELAY = 0.3f;

    // Type effectiveness colors
    private static final HashMap<Pokemon.PokemonType, Color> TYPE_COLORS = new HashMap<Pokemon.PokemonType, Color>() {{
        put(Pokemon.PokemonType.FIRE, new Color(1, 0.3f, 0.3f, 1));
        put(Pokemon.PokemonType.WATER, new Color(0.2f, 0.6f, 1, 1));
        put(Pokemon.PokemonType.GRASS, new Color(0.2f, 0.8f, 0.2f, 1));
        put(Pokemon.PokemonType.NORMAL, new Color(0.8f, 0.8f, 0.8f, 1));
        put(Pokemon.PokemonType.ELECTRIC, new Color(1, 0.9f, 0.3f, 1));
        put(Pokemon.PokemonType.ICE, new Color(0.6f, 0.9f, 1, 1));
        put(Pokemon.PokemonType.FIGHTING, new Color(0.8f, 0.3f, 0.2f, 1));
        put(Pokemon.PokemonType.POISON, new Color(0.6f, 0.3f, 0.6f, 1));
        put(Pokemon.PokemonType.GROUND, new Color(0.9f, 0.7f, 0.3f, 1));
        put(Pokemon.PokemonType.FLYING, new Color(0.6f, 0.6f, 1, 1));
        put(Pokemon.PokemonType.PSYCHIC, new Color(1, 0.3f, 0.6f, 1));
        put(Pokemon.PokemonType.BUG, new Color(0.6f, 0.8f, 0.3f, 1));
        put(Pokemon.PokemonType.ROCK, new Color(0.7f, 0.6f, 0.3f, 1));
        put(Pokemon.PokemonType.GHOST, new Color(0.4f, 0.3f, 0.6f, 1));
        put(Pokemon.PokemonType.DRAGON, new Color(0.5f, 0.3f, 1, 1));
        put(Pokemon.PokemonType.DARK, new Color(0.4f, 0.3f, 0.3f, 1));
        put(Pokemon.PokemonType.STEEL, new Color(0.7f, 0.7f, 0.8f, 1));
        put(Pokemon.PokemonType.FAIRY, new Color(1, 0.6f, 0.8f, 1));
    }};

    private static ObjectMap<Pokemon.PokemonType, ObjectMap<Pokemon.PokemonType, Float>> typeEffectiveness = new ObjectMap<>();

    static {
        initializeTypeEffectiveness();
    }

    // Instance fields
    private TextureRegion platformTexture;
    private Image playerPlatform, enemyPlatform;
    private float stateTimer = 0;

    // Enhanced UI elements
    private Table weatherDisplay;
    private Label weatherLabel;
    private boolean moveSelectionActive = false;

    // Enhanced battle tracking
    private int turnCount = 0;
    private float criticalHitChance = 0.0625f; // Base 6.25% crit chance
    private Map<Pokemon, Integer> leechSeedTargets = new HashMap<>();

    // Message queue for better text flow

    private enum BattleState {
        INTRO,
        PLAYER_CHOICE,
        PLAYER_MOVE_SELECT,
        PLAYER_MOVE_EXECUTE,
        ENEMY_TURN,
        PLAYER_SWITCHING,
        ENEMY_SWITCHING,
        WAITING_FOR_FAINT,
        PLAYER_PARTY_SCREEN,
        BAG_SCREEN,
        BATTLE_OVER_VICTORY,
        BATTLE_OVER_DEFEAT,
        RUN_ATTEMPT,
        CATCH_ATTEMPT,
        FORCED_SWITCH,
        CATCHING,
        MESSAGE_DISPLAY
    }

    // Message class for queue
    private static class BattleMessage {
        String text;
        float duration;
        Runnable onComplete;

        BattleMessage(String text, float duration, Runnable onComplete) {
            this.text = text;
            this.duration = duration;
            this.onComplete = onComplete;
        }
    }    public BattleTable(Stage stage, Skin skin, Pokemon playerPokemon, Pokemon enemyPokemon) {
        super();
        this.stage = stage;
        this.currentState = BattleState.INTRO;
        this.skin = skin;
        this.playerPokemon = playerPokemon;
        this.enemyPokemon = enemyPokemon;
        setFillParent(true);
        setTouchable(Touchable.enabled);
        setZIndex(100);
        // stage.addActor(this); // REMOVED - GameScreen is responsible for adding this table.
        stage.setViewport(new FitViewport(BATTLE_SCREEN_WIDTH, BATTLE_SCREEN_HEIGHT));
        stage.getViewport().update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);

        ensureHPBarStyles();

        try {
            initializeTextures();
            initializeUIComponents();
            initializePlatforms();
            initializePokemonSprites();
            setupHPBars();
            setupWeatherDisplay();
            setupContainer();
            startBattleAnimation();
        } catch (Exception e) {
            GameLogger.error("Error initializing battle table: " + e.getMessage());
        }
    }

    private static void initializeTypeEffectiveness() {
        // Initialize all type effectiveness
        for (Pokemon.PokemonType type : Pokemon.PokemonType.values()) {
            typeEffectiveness.put(type, new ObjectMap<>());
            for (Pokemon.PokemonType defType : Pokemon.PokemonType.values()) {
                typeEffectiveness.get(type).put(defType, 1.0f);
            }
        }

        // Normal type
        initTypeEffectiveness(Pokemon.PokemonType.NORMAL, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.ROCK, 0.5f);
            put(Pokemon.PokemonType.GHOST, 0.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Fire type
        initTypeEffectiveness(Pokemon.PokemonType.FIRE, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.WATER, 0.5f);
            put(Pokemon.PokemonType.GRASS, 2.0f);
            put(Pokemon.PokemonType.ICE, 2.0f);
            put(Pokemon.PokemonType.BUG, 2.0f);
            put(Pokemon.PokemonType.ROCK, 0.5f);
            put(Pokemon.PokemonType.DRAGON, 0.5f);
            put(Pokemon.PokemonType.STEEL, 2.0f);
        }});

        // Water type
        initTypeEffectiveness(Pokemon.PokemonType.WATER, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 2.0f);
            put(Pokemon.PokemonType.WATER, 0.5f);
            put(Pokemon.PokemonType.GRASS, 0.5f);
            put(Pokemon.PokemonType.GROUND, 2.0f);
            put(Pokemon.PokemonType.ROCK, 2.0f);
            put(Pokemon.PokemonType.DRAGON, 0.5f);
        }});

        // Electric type
        initTypeEffectiveness(Pokemon.PokemonType.ELECTRIC, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.WATER, 2.0f);
            put(Pokemon.PokemonType.ELECTRIC, 0.5f);
            put(Pokemon.PokemonType.GRASS, 0.5f);
            put(Pokemon.PokemonType.GROUND, 0.0f);
            put(Pokemon.PokemonType.FLYING, 2.0f);
            put(Pokemon.PokemonType.DRAGON, 0.5f);
        }});

        // Grass type
        initTypeEffectiveness(Pokemon.PokemonType.GRASS, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.WATER, 2.0f);
            put(Pokemon.PokemonType.GRASS, 0.5f);
            put(Pokemon.PokemonType.POISON, 0.5f);
            put(Pokemon.PokemonType.GROUND, 2.0f);
            put(Pokemon.PokemonType.FLYING, 0.5f);
            put(Pokemon.PokemonType.BUG, 0.5f);
            put(Pokemon.PokemonType.ROCK, 2.0f);
            put(Pokemon.PokemonType.DRAGON, 0.5f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Ice type
        initTypeEffectiveness(Pokemon.PokemonType.ICE, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.WATER, 0.5f);
            put(Pokemon.PokemonType.GRASS, 2.0f);
            put(Pokemon.PokemonType.ICE, 0.5f);
            put(Pokemon.PokemonType.GROUND, 2.0f);
            put(Pokemon.PokemonType.FLYING, 2.0f);
            put(Pokemon.PokemonType.DRAGON, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Fighting type
        initTypeEffectiveness(Pokemon.PokemonType.FIGHTING, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.NORMAL, 2.0f);
            put(Pokemon.PokemonType.ICE, 2.0f);
            put(Pokemon.PokemonType.POISON, 0.5f);
            put(Pokemon.PokemonType.FLYING, 0.5f);
            put(Pokemon.PokemonType.PSYCHIC, 0.5f);
            put(Pokemon.PokemonType.BUG, 0.5f);
            put(Pokemon.PokemonType.ROCK, 2.0f);
            put(Pokemon.PokemonType.GHOST, 0.0f);
            put(Pokemon.PokemonType.DARK, 2.0f);
            put(Pokemon.PokemonType.STEEL, 2.0f);
            put(Pokemon.PokemonType.FAIRY, 0.5f);
        }});

        // Poison type
        initTypeEffectiveness(Pokemon.PokemonType.POISON, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.GRASS, 2.0f);
            put(Pokemon.PokemonType.POISON, 0.5f);
            put(Pokemon.PokemonType.GROUND, 0.5f);
            put(Pokemon.PokemonType.ROCK, 0.5f);
            put(Pokemon.PokemonType.GHOST, 0.5f);
            put(Pokemon.PokemonType.STEEL, 0.0f);
            put(Pokemon.PokemonType.FAIRY, 2.0f);
        }});

        // Ground type
        initTypeEffectiveness(Pokemon.PokemonType.GROUND, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 2.0f);
            put(Pokemon.PokemonType.ELECTRIC, 2.0f);
            put(Pokemon.PokemonType.GRASS, 0.5f);
            put(Pokemon.PokemonType.POISON, 2.0f);
            put(Pokemon.PokemonType.FLYING, 0.0f);
            put(Pokemon.PokemonType.BUG, 0.5f);
            put(Pokemon.PokemonType.ROCK, 2.0f);
            put(Pokemon.PokemonType.STEEL, 2.0f);
        }});

        // Flying type
        initTypeEffectiveness(Pokemon.PokemonType.FLYING, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.ELECTRIC, 0.5f);
            put(Pokemon.PokemonType.GRASS, 2.0f);
            put(Pokemon.PokemonType.FIGHTING, 2.0f);
            put(Pokemon.PokemonType.BUG, 2.0f);
            put(Pokemon.PokemonType.ROCK, 0.5f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Psychic type
        initTypeEffectiveness(Pokemon.PokemonType.PSYCHIC, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIGHTING, 2.0f);
            put(Pokemon.PokemonType.POISON, 2.0f);
            put(Pokemon.PokemonType.PSYCHIC, 0.5f);
            put(Pokemon.PokemonType.DARK, 0.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Bug type
        initTypeEffectiveness(Pokemon.PokemonType.BUG, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.GRASS, 2.0f);
            put(Pokemon.PokemonType.FIGHTING, 0.5f);
            put(Pokemon.PokemonType.POISON, 0.5f);
            put(Pokemon.PokemonType.FLYING, 0.5f);
            put(Pokemon.PokemonType.PSYCHIC, 2.0f);
            put(Pokemon.PokemonType.GHOST, 0.5f);
            put(Pokemon.PokemonType.DARK, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
            put(Pokemon.PokemonType.FAIRY, 0.5f);
        }});

        // Rock type
        initTypeEffectiveness(Pokemon.PokemonType.ROCK, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 2.0f);
            put(Pokemon.PokemonType.ICE, 2.0f);
            put(Pokemon.PokemonType.FIGHTING, 0.5f);
            put(Pokemon.PokemonType.GROUND, 0.5f);
            put(Pokemon.PokemonType.FLYING, 2.0f);
            put(Pokemon.PokemonType.BUG, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Ghost type
        initTypeEffectiveness(Pokemon.PokemonType.GHOST, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.NORMAL, 0.0f);
            put(Pokemon.PokemonType.PSYCHIC, 2.0f);
            put(Pokemon.PokemonType.GHOST, 2.0f);
            put(Pokemon.PokemonType.DARK, 0.5f);
        }});

        // Dragon type
        initTypeEffectiveness(Pokemon.PokemonType.DRAGON, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.DRAGON, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
            put(Pokemon.PokemonType.FAIRY, 0.0f);
        }});

        // Dark type
        initTypeEffectiveness(Pokemon.PokemonType.DARK, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIGHTING, 0.5f);
            put(Pokemon.PokemonType.PSYCHIC, 2.0f);
            put(Pokemon.PokemonType.GHOST, 2.0f);
            put(Pokemon.PokemonType.DARK, 0.5f);
            put(Pokemon.PokemonType.FAIRY, 0.5f);
        }});

        // Steel type
        initTypeEffectiveness(Pokemon.PokemonType.STEEL, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.WATER, 0.5f);
            put(Pokemon.PokemonType.ELECTRIC, 0.5f);
            put(Pokemon.PokemonType.ICE, 2.0f);
            put(Pokemon.PokemonType.ROCK, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
            put(Pokemon.PokemonType.FAIRY, 2.0f);
        }});

        // Fairy type
        initTypeEffectiveness(Pokemon.PokemonType.FAIRY, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.FIGHTING, 2.0f);
            put(Pokemon.PokemonType.POISON, 0.5f);
            put(Pokemon.PokemonType.DRAGON, 2.0f);
            put(Pokemon.PokemonType.DARK, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});
    }

    private static void initTypeEffectiveness(Pokemon.PokemonType attackType,
                                              ObjectMap<Pokemon.PokemonType, Float> effectiveness) {
        typeEffectiveness.get(attackType).putAll(effectiveness);
    }

    private static ProgressBar.ProgressBarStyle createHPBarStyle(float percentage) {
        ProgressBar.ProgressBarStyle style = new ProgressBar.ProgressBarStyle();

        // Background drawable
        Pixmap bgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(0.2f, 0.2f, 0.2f, 0.8f);
        bgPixmap.fill();
        Texture bgTexture = new Texture(bgPixmap);
        style.background = new TextureRegionDrawable(new TextureRegion(bgTexture));
        bgPixmap.dispose();

        // Foreground (knob) drawable
        Pixmap fgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        Color barColor;
        if (percentage > 0.5f) {
            barColor = new Color(0.2f, 0.8f, 0.2f, 1f); // Green
        } else if (percentage > 0.2f) {
            barColor = new Color(0.9f, 0.9f, 0.2f, 1f); // Yellow
        } else {
            barColor = new Color(0.8f, 0.2f, 0.2f, 1f); // Red
        }
        fgPixmap.setColor(barColor);
        fgPixmap.fill();
        Texture fgTexture = new Texture(fgPixmap);
        TextureRegionDrawable knobDrawable = new TextureRegionDrawable(new TextureRegion(fgTexture));
        style.knob = knobDrawable;
        style.knobBefore = knobDrawable;
        fgPixmap.dispose();

        return style;
    }

    // Enhanced message system
    public void queueMessage(String text, float duration, Runnable onComplete) {
        messageQueue.offer(new BattleMessage(text, duration, onComplete));
        if (!processingMessage) {
            processNextMessage();
        }
    }

    private void queueMessage(String text, float duration) {
        queueMessage(text, duration, null);
    }

    public void queueMessage(String text) {
        queueMessage(text, 1.5f, null);
    }

    private void processNextMessage() {
        if (messageQueue.isEmpty()) {
            processingMessage = false;
            return;
        }

        processingMessage = true;
        BattleMessage msg = messageQueue.poll();
        displayMessage(msg.text);

        addAction(Actions.sequence(
            Actions.delay(msg.duration),
            Actions.run(() -> {
                if (msg.onComplete != null) {
                    msg.onComplete.run();
                }
                processNextMessage();
            })
        ));
    }

    public void displayMessage(String message) {
        battleText.setText(message);
        battleText.clearActions();
        battleText.getColor().a = 1f;
    }

    // Enhanced move replacement dialog
    public void showMoveReplacementDialog(final Move newMove) {
        final Window replacementWindow = new Window("Learn New Move", skin);
        replacementWindow.setModal(true);
        replacementWindow.setMovable(false);
        replacementWindow.pad(20);

        Table content = new Table();

        Label promptLabel = new Label(playerPokemon.getName() + " wants to learn " + newMove.getName() + "!", skin);
        promptLabel.setWrap(true);
        promptLabel.setAlignment(Align.center);
        content.add(promptLabel).colspan(2).width(300).pad(10).row();

        Label instructionLabel = new Label("But " + playerPokemon.getName() + " already knows 4 moves.\nSelect a move to forget:", skin);
        instructionLabel.setAlignment(Align.center);
        content.add(instructionLabel).colspan(2).pad(10).row();

        // Display current moves with details
        final java.util.List<Move> currentMoves = playerPokemon.getMoves();
        Table movesTable = new Table();

        for (int i = 0; i < currentMoves.size(); i++) {
            final int index = i;
            Move move = currentMoves.get(i);

            Table moveInfo = new Table();
            moveInfo.setBackground(createTranslucentBackground(0.3f));
            moveInfo.pad(10);

            Label nameLabel = new Label(move.getName(), skin);
            nameLabel.setColor(TYPE_COLORS.get(move.getType()));
            moveInfo.add(nameLabel).expandX().left();

            Label ppLabel = new Label("PP: " + move.getPp() + "/" + move.getMaxPp(), skin);
            ppLabel.setFontScale(0.8f);
            moveInfo.add(ppLabel).padLeft(10).row();

            Label powerLabel = new Label("Power: " + (move.getPower() > 0 ? move.getPower() : "-"), skin);
            powerLabel.setFontScale(0.8f);
            moveInfo.add(powerLabel).expandX().left();

            Label accLabel = new Label("Acc: " + move.getAccuracy() + "%", skin);
            accLabel.setFontScale(0.8f);
            moveInfo.add(accLabel).padLeft(10);

            TextButton selectButton = new TextButton("Replace", skin);
            selectButton.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    currentMoves.set(index, newMove);
                    queueMessage(playerPokemon.getName() + " forgot " + move.getName() + " and learned " + newMove.getName() + "!");
                    AudioManager.getInstance().playSound(AudioManager.SoundEffect.MOVE_SELECT);
                    replacementWindow.remove();
                }
            });

            movesTable.add(moveInfo).width(250).pad(5);
            movesTable.add(selectButton).width(80).pad(5).row();
        }

        content.add(movesTable).colspan(2).row();

        // Option to not learn the move
        TextButton cancelButton = new TextButton("Don't learn " + newMove.getName(), skin);
        cancelButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                queueMessage(playerPokemon.getName() + " did not learn " + newMove.getName() + ".");
                replacementWindow.remove();
            }
        });
        content.add(cancelButton).colspan(2).width(200).height(40).padTop(10);

        replacementWindow.add(content);
        replacementWindow.pack();
        replacementWindow.setPosition(
            (stage.getWidth() - replacementWindow.getWidth()) / 2,
            (stage.getHeight() - replacementWindow.getHeight()) / 2
        );

        stage.addActor(replacementWindow);
    }

    private void ensureHPBarStyles() {
        if (!skin.has("hp-bar-green", ProgressBar.ProgressBarStyle.class)) {
            skin.add("hp-bar-green", createHPBarStyle(1.0f), ProgressBar.ProgressBarStyle.class);
        }
        if (!skin.has("hp-bar-yellow", ProgressBar.ProgressBarStyle.class)) {
            skin.add("hp-bar-yellow", createHPBarStyle(0.35f), ProgressBar.ProgressBarStyle.class);
        }
        if (!skin.has("hp-bar-red", ProgressBar.ProgressBarStyle.class)) {
            skin.add("hp-bar-red", createHPBarStyle(0.1f), ProgressBar.ProgressBarStyle.class);
        }
    }


    /**
     * Sets up the main layout of the battle screen, including backgrounds, platforms,
     * Pokémon sprites, and the info/action boxes. This creates the classic
     * "player on bottom-left, enemy on top-right" view.
     */
    private void setupLayout() {
        clear(); // Clear any previous actors from the table

        // 1. Background
        // A random battle background is selected.
        String bgName = "bg-grass"; // Default
        // You could add logic here to pick a background based on biome
        TextureRegion background = TextureManager.battlebacks.findRegion(bgName);
        if (background != null) {
            setBackground(new TextureRegionDrawable(background));
        }

        // 2. Platforms for the Pokémon
        // These are images that the Pokémon sprites will "stand" on.
        TextureRegion platformTexture = TextureManager.battlebacks.findRegion("battle_platform");
        Image playerPlatform = new Image(platformTexture);
        Image enemyPlatform = new Image(platformTexture);
        playerPlatform.setScaling(Scaling.fit);
        enemyPlatform.setScaling(Scaling.fit);

        // 3. Main container table to organize the screen
        Table mainContainer = new Table();
        mainContainer.setFillParent(true);

        // This Stack will hold the enemy's platform and sprite
        Stack enemyStack = new Stack();
        enemyStack.add(enemyPlatform);
        enemyStack.add(enemyPokemonImage);

        // This Stack will hold the player's platform and sprite
        Stack playerStack = new Stack();
        playerStack.add(playerPlatform);
        playerStack.add(playerPokemonImage);

        // The info boxes for HP, level, etc.
        Table enemyInfoBox = createInfoBox(enemyPokemon, enemyInfoLabel, enemyHPBar, enemyStatusIcon);
        Table playerInfoBox = createInfoBox(playerPokemon, playerInfoLabel, playerHPBar, playerStatusIcon);

        // Add the EXP bar to the player's info box
        playerInfoBox.row();
        playerInfoBox.add(expBar).colspan(2).width(HP_BAR_WIDTH).height(6).pad(2, 5, 5, 5).left();

        // Arrange the main components on the screen
        mainContainer.add(enemyInfoBox).expand().top().left().pad(20).width(250);
        mainContainer.add(enemyStack).expand().top().right().pad(20, 0, 0, 50).size(200, 100);
        mainContainer.row();
        mainContainer.add(playerStack).expand().bottom().left().pad(0, 50, 80, 0).size(200, 100);
        mainContainer.add(playerInfoBox).expand().bottom().right().pad(0, 0, 80, 20).width(250);

        addActor(mainContainer);

        // The message box at the bottom
        Table messageBox = new Table(skin);
        messageBox.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("battle_message_box")));
        battleText.setWrap(true);
        messageBox.add(battleText).expand().fill().pad(10, 20, 10, 20);

        // Use a separate Stack to layer the message box and action menu
        Stack bottomUI = new Stack();
        bottomUI.setFillParent(true);
        bottomUI.add(messageBox);
        bottomUI.add(actionMenu); // The action menu will sit on top

        addActor(bottomUI);

        // Position the action menu (initially invisible)
        actionMenu.pack();
        actionMenu.setPosition(
            getWidth() - actionMenu.getWidth() - 10,
            messageBox.getHeight() + 10 // Position it right above the message box
        );
    }

    /**
     * Creates the main action menu with FIGHT, BAG, POKEMON, and RUN buttons.
     * This menu is shown when it's the player's turn to choose an action.
     * @return A Table containing the configured action buttons.
     */
    private Table createActionMenu() {
        Table menu = new Table(skin);
        // Using a semi-transparent background for a modern feel
        menu.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("battle_choice_box")));

        // Button style for a cleaner look
        TextButton.TextButtonStyle buttonStyle = new TextButton.TextButtonStyle(skin.get("default", TextButton.TextButtonStyle.class));
        buttonStyle.fontColor = Color.BLACK;

        fightButton = new TextButton("FIGHT", buttonStyle);
        bagButton = new TextButton("BAG", buttonStyle);
        pokemonButton = new TextButton("POKEMON", buttonStyle);
        runButton = new TextButton("RUN", buttonStyle);

        // Arrange buttons in a 2x2 grid
        menu.add(fightButton).width(120).height(50).pad(5);
        menu.add(bagButton).width(120).height(50).pad(5).row();
        menu.add(pokemonButton).width(120).height(50).pad(5);
        menu.add(runButton).width(120).height(50).pad(5);

        // Add listeners to handle clicks
        fightButton.addListener(new ClickListener() { @Override public void clicked(InputEvent e, float x, float y) { if (!isAnimating) handleFightButton(); } });
        bagButton.addListener(new ClickListener() { @Override public void clicked(InputEvent e, float x, float y) { if (!isAnimating) handleBagButton(); } });
        pokemonButton.addListener(new ClickListener() { @Override public void clicked(InputEvent e, float x, float y) { if (!isAnimating) handlePokemonButton(); } });
        runButton.addListener(new ClickListener() { @Override public void clicked(InputEvent e, float x, float y) { if (!isAnimating) attemptRun(); } });

        menu.setVisible(false); // Start hidden
        return menu;
    }

    /**
     * Updates all dynamic UI elements to reflect the current state of the Pokémon in battle.
     * This includes names, levels, HP bars, and status icons.
     */
    private void updateUI() {
        if (playerPokemon == null || enemyPokemon == null) return;

        // Player UI Update
        playerInfoLabel.setText(String.format("%s Lv.%d", playerPokemon.getName(), playerPokemon.getLevel()));
        playerHPBar.setRange(0, playerPokemon.getStats().getHp());
        playerHPBar.setValue(playerPokemon.getCurrentHp());
        updateHPBarColor(playerHPBar, playerPokemon.getCurrentHp() / (float) playerPokemon.getStats().getHp(), skin);
        expBar.setRange(0, playerPokemon.getExperienceForNextLevel());
        expBar.setValue(playerPokemon.getCurrentExperience());
        updateStatusIcon(playerPokemon, playerStatusIcon);

        // Enemy UI Update
        enemyInfoLabel.setText(String.format("%s Lv.%d", enemyPokemon.getName(), enemyPokemon.getLevel()));
        enemyHPBar.setRange(0, enemyPokemon.getStats().getHp());
        enemyHPBar.setValue(enemyPokemon.getCurrentHp());
        updateHPBarColor(enemyHPBar, enemyPokemon.getCurrentHp() / (float) enemyPokemon.getStats().getHp(), skin);
        updateStatusIcon(enemyPokemon, enemyStatusIcon);
    }

    /**
     * Helper method to create a standardized info box for a Pokémon.
     */
    private Table createInfoBox(Pokemon pokemon, Label nameLabel, ProgressBar hpBar, Image statusIcon) {
        Table infoBox = new Table(skin);
        infoBox.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("battle_info_box")));

        // First row: Name and Level
        Table nameRow = new Table();
        nameRow.add(nameLabel).expandX().left();
        infoBox.add(nameRow).left().pad(8, 12, 0, 12).row();

        // Second row: Status icon and HP bar
        Table hpRow = new Table();
        hpRow.add(statusIcon).size(STATUS_ICON_WIDTH, STATUS_ICON_HEIGHT).left().padRight(5);
        hpRow.add(hpBar).width(HP_BAR_WIDTH).height(10).expandX().fillX();
        infoBox.add(hpRow).left().pad(0, 12, 8, 12);

        return infoBox;
    }

    /**
     * Sets the visibility and texture of a status icon based on the Pokémon's status.
     * @param pokemon The Pokémon to check.
     * @param statusIcon The Image widget to update.
     */
    private void updateStatusIcon(Pokemon pokemon, Image statusIcon) {
        Pokemon.Status status = pokemon.getStatus();
        if (status != null && status != Pokemon.Status.NONE) {
            TextureRegion iconRegion = TextureManager.getStatusIcon(status);
            if (iconRegion != null) {
                statusIcon.setDrawable(new TextureRegionDrawable(iconRegion));
                statusIcon.setVisible(true);
            } else {
                statusIcon.setVisible(false);
            }
        } else {
            statusIcon.setVisible(false);
        }
    }

    /**
     * Tints the progress bar's fill portion (knobBefore) to green, yellow, or red
     * based on the Pokémon's current HP percentage.
     * @param bar The ProgressBar to update.
     * @param percentage The current HP percentage (0.0 to 1.0).
     * @param skin The skin to use for styling.
     */
    private static void updateHPBarColor(ProgressBar bar, float percentage, Skin skin) {
        ProgressBar.ProgressBarStyle style = new ProgressBar.ProgressBarStyle(bar.getStyle());
        Drawable fill = style.knobBefore;

        if (fill instanceof TextureRegionDrawable) {
            Color color;
            if (percentage > 0.5f) {
                color = new Color(0.18f, 0.82f, 0.32f, 1f); // Green
            } else if (percentage > 0.2f) {
                color = new Color(0.98f, 0.82f, 0.2f, 1f); // Yellow
            } else {
                color = new Color(0.95f, 0.3f, 0.2f, 1f); // Red
            }
            ((TextureRegionDrawable) fill).tint(color);
        }
        bar.setStyle(style);
    }

    private void setBattleInterfaceEnabled(boolean enabled) {
        if (actionMenu != null) {
            actionMenu.setTouchable(enabled ? Touchable.enabled : Touchable.disabled);
            actionMenu.setVisible(enabled);
        }
        if (fightButton != null) {
            fightButton.setDisabled(!enabled);
            fightButton.setTouchable(enabled ? Touchable.enabled : Touchable.disabled);
        }
        if (bagButton != null) {
            bagButton.setDisabled(!enabled);
            bagButton.setTouchable(enabled ? Touchable.enabled : Touchable.disabled);
        }
        if (pokemonButton != null) {
            pokemonButton.setDisabled(!enabled);
            pokemonButton.setTouchable(enabled ? Touchable.enabled : Touchable.disabled);
        }
        if (runButton != null) {
            runButton.setDisabled(!enabled);
            runButton.setTouchable(enabled ? Touchable.enabled : Touchable.disabled);
        }
    }

    private void initializeTextures() {
        platformTexture = TextureManager.battlebacks.findRegion("battle_platform");
        if (platformTexture == null) {
            throw new RuntimeException("Failed to load battle platform texture");
        }
    }

    private void initializeUIComponents() {
        // Create battle text label
        battleText = new Label("", skin);
        battleText.setWrap(true);
        battleText.setAlignment(Align.center);
        battleText.setTouchable(Touchable.disabled);
        float tableWidth = (getWidth() > 0 ? getWidth() : BATTLE_SCREEN_WIDTH);
        float tableHeight = (getHeight() > 0 ? getHeight() : BATTLE_SCREEN_HEIGHT);
        battleText.setSize(tableWidth, 30);
        battleText.setPosition(0, tableHeight - 40);

        // Create info labels
        playerInfoLabel = new Label("", skin);
        enemyInfoLabel = new Label("", skin);
        updateInfoLabels();

        // Create action menu
        actionMenu = new Table(skin);
        actionMenu.setBackground(createTranslucentBackground(0.5f));
        actionMenu.defaults().space(10);

        // Create buttons with enhanced styling
        fightButton = new TextButton("FIGHT", skin);
        bagButton = new TextButton("BAG", skin);
        pokemonButton = new TextButton("POKEMON", skin);
        runButton = new TextButton("RUN", skin);

        // Add listeners
        fightButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                handleFightButton();
            }
        });

        bagButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                handleBagButton();
            }
        });

        pokemonButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                handlePokemonButton();
            }
        });

        runButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                attemptRun();
            }
        });

        // Arrange buttons in a 2x2 grid
        actionMenu.add(fightButton).width(180).height(50);
        actionMenu.add(bagButton).width(180).height(50);
        actionMenu.row();
        actionMenu.add(pokemonButton).width(180).height(50);
        actionMenu.add(runButton).width(180).height(50);
        actionMenu.pack();

        updateActionMenuPosition();

        // Initially hide the menu
        actionMenu.setVisible(false);
        actionMenu.setTouchable(Touchable.disabled);

        addActor(battleText);
        addActor(actionMenu);
    }

    private void handleBagButton() {
        if (actionMenu != null) {
            actionMenu.setVisible(false);
            actionMenu.setTouchable(Touchable.disabled);
        }

        currentState = BattleState.BAG_SCREEN;

        BagScreen bagScreen = new BagScreen(skin,
            GameContext.get().getPlayer().getInventory(),
            (ItemData selectedItem) -> {
                if (selectedItem.getItemId().toLowerCase().contains("pokeball")) {
                    handlePokeBallUse(selectedItem);
                } else if (selectedItem.getItemId().toLowerCase().contains("potion")) {
                    handlePotionUse(selectedItem);
                } else {
                    queueMessage("This item cannot be used in battle!");
                    currentState = BattleState.PLAYER_CHOICE;
                    showActionMenu(true);
                }
            }
        );

        bagScreen.setOnClose(() -> {
            currentState = BattleState.PLAYER_CHOICE;
            showActionMenu(true);
        });

        stage.addActor(bagScreen);
        bagScreen.pack();
        float w = stage.getWidth();
        float h = stage.getHeight();
        bagScreen.setPosition((w - bagScreen.getWidth()) / 2f, (h - bagScreen.getHeight()) / 2f);
        bagScreen.toFront();
        bagScreen.setZIndex(stage.getActors().size - 1);
    }
    private void handlePokeBallUse(ItemData pokeball) {
        pokeball.setCount(pokeball.getCount() - 1);
        if (pokeball.getCount() <= 0) {
            GameContext.get().getPlayer().getInventory().removeItem(pokeball);
        }

        float hpRatio = enemyPokemon.getCurrentHp() / (float) enemyPokemon.getStats().getHp();
        float captureChance = MathUtils.clamp(1 - hpRatio, 0.1f, 0.9f);

        // Adjust capture chance based on ball type
        if (pokeball.getItemId().toLowerCase().contains("great")) {
            captureChance *= 1.5f;
        } else if (pokeball.getItemId().toLowerCase().contains("ultra")) {
            captureChance *= 2.0f;
        }

        attemptCapture((WildPokemon) enemyPokemon, captureChance);
    }

    private void handlePotionUse(ItemData potion) {
        // Show party screen for potion use
        showPartyScreenForItem(potion);
    }

    private void showPartyScreenForItem(ItemData item) {
        PokemonPartyWindow partyScreen = new PokemonPartyWindow(
            skin,
            GameContext.get().getPlayer().getPokemonParty(),
            false, // Not in battle mode for item use
            (selectedIndex) -> {
                Pokemon selectedPokemon = GameContext.get().getPlayer().getPokemonParty().getPokemon(selectedIndex);
                if (selectedPokemon != null) {
                    useItemOnPokemon(item, selectedPokemon);
                }
            },
            () -> {
                currentState = BattleState.PLAYER_CHOICE;
                showActionMenu(true);
            }
        );

        stage.addActor(partyScreen);
        partyScreen.show(stage);
    }

    private void useItemOnPokemon(ItemData item, Pokemon pokemon) {
        if (item.getItemId().toLowerCase().contains("potion")) {
            int healAmount = 20; // Basic potion
            if (item.getItemId().toLowerCase().contains("super")) {
                healAmount = 50;
            } else if (item.getItemId().toLowerCase().contains("hyper")) {
                healAmount = 200;
            }

            int oldHp = pokemon.getCurrentHp();
            pokemon.heal(Math.min(healAmount, pokemon.getStats().getHp() - oldHp));
            updateHPBars();

            queueMessage(pokemon.getName() + " recovered HP!");

            item.setCount(item.getCount() - 1);
            if (item.getCount() <= 0) {
                GameContext.get().getPlayer().getInventory().removeItem(item);
            }

            playerActionTaken = true;
            transitionToState(BattleState.ENEMY_TURN);
        }
    }

    private void handlePokemonButton() {
        if (actionMenu != null) {
            actionMenu.setVisible(false);
            actionMenu.setTouchable(Touchable.disabled);
        }
        currentState = BattleState.PLAYER_PARTY_SCREEN;
        showPartyScreen();
    }

    private void showPartyScreen() {
        PokemonPartyWindow partyScreen = new PokemonPartyWindow(
            skin,
            GameContext.get().getPlayer().getPokemonParty(),
            true, // battle mode
            (selectedIndex) -> {
                Pokemon selectedPokemon = GameContext.get().getPlayer().getPokemonParty().getPokemon(selectedIndex);
                if (selectedPokemon != null && selectedPokemon.getCurrentHp() > 0 && selectedPokemon != playerPokemon) {
                    handleSwitchPokemon(selectedIndex);
                }
            },
            () -> {
                currentState = BattleState.PLAYER_CHOICE;
                showActionMenu(true);
            }
        );

        stage.addActor(partyScreen);
        partyScreen.show(stage);
    }

    private void setupWeatherDisplay() {
        weatherDisplay = new Table();
        weatherDisplay.setBackground(createTranslucentBackground(0.3f));
        weatherLabel = new Label("", skin);
        weatherLabel.setFontScale(0.8f);
        weatherDisplay.add(weatherLabel).pad(5);
        weatherDisplay.setVisible(false);
        addActor(weatherDisplay);
    }

    private void updateWeatherDisplay() {
        // This would be connected to a weather system if implemented
        weatherDisplay.setVisible(false);
    }

    private TextureRegionDrawable createTranslucentBackground(float alpha) {
        Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        pixmap.setColor(0, 0, 0, alpha);
        pixmap.fill();
        Texture texture = new Texture(pixmap);
        TextureRegion region = new TextureRegion(texture);
        pixmap.dispose();
        return new TextureRegionDrawable(region);
    }

    private void setupContainer() {
        Table mainContainer = new Table();
        mainContainer.setFillParent(true);
        mainContainer.top().padTop(10);
        mainContainer.setBackground(createTranslucentBackground(0.5f));

        // Enemy section
        Table enemySection = new Table();
        enemySection.add(enemyInfoLabel).expandX().right().pad(10).row();

        Table enemyHPContainer = new Table();
        enemyHPContainer.add(enemyHPBar).width(HP_BAR_WIDTH).height(8);
        enemyHPContainer.add(enemyStatusIcon).size(STATUS_ICON_WIDTH, STATUS_ICON_HEIGHT).padLeft(5);
        enemySection.add(enemyHPContainer).expandX().right().pad(10).row();

        Stack enemyStack = new Stack();
        enemyStack.add(enemyPlatform);
        enemyStack.add(enemyPokemonImage);
        enemySection.add(enemyStack).expand().right().padRight(stage.getWidth() * 0.1f).row();

        // Player section
        Table playerSection = new Table();
        playerSection.add(playerInfoLabel).expandX().left().pad(10).row();

        Table playerHPContainer = new Table();
        playerHPContainer.add(playerHPBar).width(HP_BAR_WIDTH).height(8);
        playerHPContainer.add(playerStatusIcon).size(STATUS_ICON_WIDTH, STATUS_ICON_HEIGHT).padLeft(5);
        playerSection.add(playerHPContainer).expandX().left().pad(10).row();

        playerSection.add(expBar).width(HP_BAR_WIDTH).height(4).padLeft(10).row();

        Stack playerStack = new Stack();
        playerStack.add(playerPlatform);
        playerStack.add(playerPokemonImage);
        playerSection.add(playerStack).expand().left().padLeft(stage.getWidth() * 0.1f).row();

        // Control section
        Table controlSection = new Table();
        controlSection.setBackground(createTranslucentBackground(0.7f));
        controlSection.add(battleText).expandX().fillX().pad(10).row();
        controlSection.setTouchable(Touchable.enabled);

        mainContainer.add(enemySection).expand().fill().row();
        mainContainer.add(playerSection).expand().fill().row();
        mainContainer.add(controlSection).expandX().fillX().bottom().padBottom(20f);

        addActor(mainContainer);
    }

    private void initializePlatforms() {
        playerPlatform = new Image(platformTexture);
        enemyPlatform = new Image(platformTexture);
        playerPlatform.setScaling(Scaling.none);
        enemyPlatform.setScaling(Scaling.none);
    }

    private float computeExpectedDamage(Move move, Pokemon attacker, Pokemon defender) {
        int level = attacker.getLevel();
        float attackStat = move.isSpecial() ? attacker.getStats().getSpecialAttack() : attacker.getStats().getAttack();
        float defenseStat = move.isSpecial() ? defender.getStats().getSpecialDefense() : defender.getStats().getDefense();

        float baseDamage = (((2 * level) / 5f + 2) * move.getPower() * attackStat / defenseStat) / 50f + 2;

        float stab = (attacker.getPrimaryType() == move.getType() ||
            attacker.getSecondaryType() == move.getType()) ? 1.5f : 1.0f;

        float typeMultiplier = getTypeEffectiveness(move.getType(), defender.getPrimaryType());
        if (defender.getSecondaryType() != null) {
            typeMultiplier *= getTypeEffectiveness(move.getType(), defender.getSecondaryType());
        }

        return baseDamage * stab * typeMultiplier;
    }

    private void initializePokemonSprites() {
        TextureRegion playerTexture = playerPokemon.getBackSprite();
        TextureRegion enemyTexture = enemyPokemon.getFrontSprite();
        if (playerTexture == null || enemyTexture == null) {
            throw new RuntimeException("Failed to load Pokémon sprites");
        }
        playerPokemonImage = new Image(playerTexture);
        enemyPokemonImage = new Image(enemyTexture);

        float playerAspect = (float) playerTexture.getRegionWidth() / playerTexture.getRegionHeight();
        float enemyAspect = (float) enemyTexture.getRegionWidth() / enemyTexture.getRegionHeight();
        float baseSize = 85f;
        playerPokemonImage.setSize(baseSize * playerAspect, baseSize);
        enemyPokemonImage.setSize(baseSize * enemyAspect, baseSize);
        playerPokemonImage.setScaling(Scaling.none);
        enemyPokemonImage.setScaling(Scaling.none);

        // Create status icon images
        playerStatusIcon = new Image();
        enemyStatusIcon = new Image();
        playerStatusIcon.setVisible(false);
        enemyStatusIcon.setVisible(false);
        playerStatusIcon.setSize(STATUS_ICON_WIDTH, STATUS_ICON_HEIGHT);
        enemyStatusIcon.setSize(STATUS_ICON_WIDTH, STATUS_ICON_HEIGHT);
    }

    private void setupHPBars() {
        playerHPBar = new ProgressBar(0, playerPokemon.getStats().getHp(), 1, false,
            createHPBarStyle(playerPokemon.getCurrentHp() / (float) playerPokemon.getStats().getHp()));
        playerHPBar.setSize(HP_BAR_WIDTH, 8);
        playerHPBar.setValue(playerPokemon.getCurrentHp());

        enemyHPBar = new ProgressBar(0, enemyPokemon.getStats().getHp(), 1, false,
            createHPBarStyle(enemyPokemon.getCurrentHp() / (float) enemyPokemon.getStats().getHp()));
        enemyHPBar.setSize(HP_BAR_WIDTH, 8);
        enemyHPBar.setValue(enemyPokemon.getCurrentHp());

        expBar = new ProgressBar(0, playerPokemon.getExperienceForNextLevel(), 1, false,
            skin.get("default-horizontal", ProgressBar.ProgressBarStyle.class));
        expBar.setSize(HP_BAR_WIDTH, 6);
        expBar.setValue(playerPokemon.getCurrentExperience());
    }

    public void updateExpBar() {
        int nextLevelExp = playerPokemon.getExperienceForNextLevel();
        expBar.setRange(0, nextLevelExp);
        expBar.setValue(playerPokemon.getCurrentExperience());
    }

    private void startBattleAnimation() {
        GameLogger.info("Starting battle animation");
        isAnimating = true;
        currentState = BattleState.INTRO;
        setBattleInterfaceEnabled(false);

        SequenceAction introSequence = Actions.sequence(
            Actions.run(() -> queueMessage("Wild " + enemyPokemon.getName() + " appeared!")),
            Actions.delay(1.5f),
            Actions.run(() -> {
                GameLogger.info("Battle intro complete – player turn begins");
                isAnimating = false;
                currentState = BattleState.PLAYER_CHOICE;
                battleText.setText("What will " + playerPokemon.getName() + " do?");
                setBattleInterfaceEnabled(true);
            })
        );
        addAction(introSequence);
    }

    public void updateHPBars() {
        float playerHPPercent = playerPokemon.getCurrentHp() / (float) playerPokemon.getStats().getHp();
        animateHPBar(playerHPBar, playerPokemon.getCurrentHp(), playerHPPercent);

        float enemyHPPercent = enemyPokemon.getCurrentHp() / (float) enemyPokemon.getStats().getHp();
        animateHPBar(enemyHPBar, enemyPokemon.getCurrentHp(), enemyHPPercent);
    }

    private void animateHPBar(ProgressBar bar, float targetValue, float percentage) {
        bar.clearActions();
        bar.addAction(Actions.sequence(
            Actions.run(() -> updateHPBarColor(bar, percentage,skin)),
            Actions.delay(0.1f),
            Actions.run(() -> {
                float currentValue = bar.getValue();
                bar.addAction(Actions.parallel(
                    Actions.run(() -> {
                        // Animate value change
                        bar.setValue(targetValue);
                    }),
                    Actions.alpha(0.8f, 0.1f),
                    Actions.alpha(1f, 0.1f)
                ));
            })
        ));
    }

    private void updateInfoLabels() {
        String playerInfo = playerPokemon.getName() + " Lv." + playerPokemon.getLevel() +
            " HP: " + playerPokemon.getCurrentHp() + "/" + playerPokemon.getStats().getHp();
        playerInfoLabel.setText(playerInfo);

        String enemyInfo = enemyPokemon.getName() + " Lv." + enemyPokemon.getLevel();
        enemyInfoLabel.setText(enemyInfo);
    }


    @Override
    public void act(float delta) {
        super.act(delta);
        if (isAnimating) return;

        stateTimer += delta;

        switch (currentState) {
            case INTRO:
                break;
            case PLAYER_CHOICE:
                if (!actionMenu.isVisible()) {
                    showActionMenu(true);
                    battleText.setText("What will " + playerPokemon.getName() + " do?");
                }
                break;
            case PLAYER_MOVE_SELECT:
                break;
            case PLAYER_MOVE_EXECUTE:
                break;
            case ENEMY_TURN:
                if (stateTimer > 0.5f) {
                    executeEnemyMove();
                    stateTimer = 0f;
                }
                break;
            case PLAYER_SWITCHING:
                break;
            default:
                break;
        }

        updateHPBars();
        updateExpBar();
        updateStatusIcon(playerPokemon, playerStatusIcon);
        updateStatusIcon(enemyPokemon, enemyStatusIcon);
        updateInfoLabels();
        updateWeatherDisplay();
    }

    private void handleEnemyFaint() {
        enemyPokemon.setStatus(Pokemon.Status.FAINTED);
        queueMessage(enemyPokemon.getName() + " fainted!");
        GameLogger.info(enemyPokemon.getName() + " fainted.");

        if (callback != null) {
            callback.onStatusChange(enemyPokemon, Pokemon.Status.FAINTED);
        }

        // Faint animation
        enemyPokemonImage.addAction(Actions.sequence(
            Actions.parallel(
                Actions.fadeOut(1.0f), Actions.moveBy(0, -20, 1.0f)
            ),
            Actions.run(() -> {
                int expGained = calculateExperienceGain((WildPokemon) enemyPokemon);
                playerPokemon.addExperience(expGained);
                queueMessage(playerPokemon.getName() + " gained " + expGained + " EXP!");
                updateExpBar();
                // Directly trigger the end of the battle after the EXP message.
                queueMessage("", 1.5f, this::finishBattle);
            })
        ));
    }

    private void handlePlayerFaint() {
        playerPokemon.setStatus(Pokemon.Status.FAINTED);
        queueMessage(playerPokemon.getName() + " fainted!");
        GameLogger.info(playerPokemon.getName() + " fainted.");

        if (callback != null) {
            callback.onStatusChange(playerPokemon, Pokemon.Status.FAINTED);
        }

        // Faint animation
        playerPokemonImage.addAction(Actions.sequence(
            Actions.parallel(
                Actions.fadeOut(1.0f), Actions.moveBy(0, -20, 1.0f)
            ),
            Actions.run(() -> {
                if (hasAvailablePokemon()) {
                    transitionToState(BattleState.FORCED_SWITCH); showForcedSwitchPartyScreen();
                } else {
                    finishBattle();
                }
            })
        ));
    }

    private void finishBattle() {
        isAnimating = true;
        boolean playerWon = playerPokemon.getCurrentHp() > 0 && enemyPokemon.getCurrentHp() <= 0;
        SequenceAction endSequence = Actions.sequence(
            // Add a small delay for final messages to be read
            Actions.delay(1.15f),
            Actions.run(() -> {
                if (callback != null) {
                    callback.onBattleEnd(playerWon);
                }
            })
        );
        addAction(endSequence);
    }
    @Override
    public void draw(Batch batch, float parentAlpha) {
        super.draw(batch, parentAlpha);
    }

    private void executeEnemyMove() {
        if (isAnimating || enemyPokemon.getCurrentHp() <= 0) return;

        Move selectedMove = null;
        float highestExpectedDamage = 0f;

        for (Move move : enemyPokemon.getMoves()) {
            if (move.getPp() <= 0) continue;

            float expectedDamage = computeExpectedDamage(move, enemyPokemon, playerPokemon);
            if (expectedDamage > highestExpectedDamage) {
                highestExpectedDamage = expectedDamage;
                selectedMove = move;
            }
        }

        if (selectedMove == null) {
            executeStruggle(enemyPokemon, playerPokemon);
            return;
        }

        executeMove(selectedMove, enemyPokemon, playerPokemon, false);
    }

    private void executeStruggle(Pokemon attacker, Pokemon defender) {
        float damage = attacker.getStats().getAttack() * 0.5f;
        float recoil = damage * 0.25f;
        applyDamage(defender, damage);
        applyDamage(attacker, recoil);
        queueMessage(attacker.getName() + " used Struggle!");
        finishMoveExecution(false);
    }

    private float getTypeEffectiveness(Pokemon.PokemonType attackType, Pokemon.PokemonType defendType) {
        if (attackType == null || defendType == null) {
            GameLogger.error("Null type encountered in getTypeEffectiveness: attackType=" + attackType + ", defendType=" + defendType);
            return 1.0f;
        }
        ObjectMap<Pokemon.PokemonType, Float> effectivenessMap = typeEffectiveness.get(attackType);
        if (effectivenessMap == null) return 1.0f;
        return effectivenessMap.get(defendType, 1.0f);
    }
    private void executeMove(Move move, Pokemon attacker, Pokemon defender, boolean isPlayerMove) {
        if (isAnimating) return;
        isAnimating = true;
        setBattleInterfaceEnabled(false);
        if (isPlayerMove) playerActionTaken = true;

        move.setPp(move.getPp() - 1);

        // Check if attacker can move
        if (!attacker.canAttack()) {
            queueMessage("", 0.5f, () -> finishMoveExecution(isPlayerMove));
            return;
        }

        // Build the sequence of events for the move
        SequenceAction moveSequence = Actions.sequence();

        // 1. Announce Move
        moveSequence.addAction(Actions.run(() -> queueMessage(attacker.getName() + " used " + move.getName() + "!")));
        moveSequence.addAction(Actions.delay(1.0f));

        // 2. Accuracy Check
        moveSequence.addAction(Actions.run(() -> {
            if (MathUtils.random() * 100 >= move.getAccuracy()) {
                queueMessage("The attack missed!", 1.0f, () -> finishMoveExecution(isPlayerMove));
                moveSequence.getActions().clear(); // Stop further actions in this sequence
            }
        }));

        // 3. Damage Calculation
        moveSequence.addAction(Actions.run(() -> {
            float damage = calculateDamage(move, attacker, defender);
            if (damage > 0) {
                applyDamage(defender, damage);
                float effectiveness = calculateTypeEffectiveness(move, defender);
                String effectivenessMessage = getEffectivenessMessage(effectiveness);
                if (!effectivenessMessage.isEmpty()) {
                    queueMessage(effectivenessMessage);
                }
            }
        }));
        moveSequence.addAction(Actions.delay(1.0f));

        // 4. Check for Faint
        moveSequence.addAction(Actions.run(() -> {
            if (checkFaintConditions()) {
                moveSequence.getActions().clear(); // Stop sequence if someone faints
            }
        }));

        // 5. Apply Secondary Effects
        moveSequence.addAction(Actions.run(() -> {
            if (move.getEffect() != null && MathUtils.random() < move.getEffect().getChance()) {
                applyMoveEffect(move.getEffect(), attacker, defender);
            }
        }));
        moveSequence.addAction(Actions.delay(1.0f));

        // 6. Finish Turn
        moveSequence.addAction(Actions.run(() -> finishMoveExecution(isPlayerMove)));

        addAction(moveSequence);
    }

    private void applyMoveEffect(Move.MoveEffect effect, Pokemon attacker, Pokemon target) {
        if (effect == null) return;

        // Apply Status Effect
        Pokemon.Status statusToApply = effect.getStatusEffect();
        if (statusToApply != null && statusToApply != Pokemon.Status.NONE) {
            Pokemon.Status previousStatus = target.getStatus();
            target.setStatus(statusToApply);

            if (target.getStatus() != previousStatus) {
                queueMessage(target.getName() + " became " + statusToApply.name().toLowerCase() + "!");

                // Play appropriate status sound effect
                switch (statusToApply) {
                    case PARALYZED:
                    case BURNED:
                    case FROZEN:
                    case POISONED:
                    case BADLY_POISONED:
                        AudioManager.getInstance().playSound(AudioManager.SoundEffect.DAMAGE);
                        break;
                    case ASLEEP:
                        // Add sleep sound if available
                        break;
                }

                GameLogger.info(target.getName() + " afflicted with " + statusToApply);
                updateStatusIcon(target, target == playerPokemon ? playerStatusIcon : enemyStatusIcon);

                if (callback != null) {
                    callback.onStatusChange(target, statusToApply);
                }
            } else {
                queueMessage("But it failed!");
            }
        }

        // Apply Stat Changes
        Map<String, Integer> statChanges = effect.getStatModifiers();
        if (statChanges != null && !statChanges.isEmpty()) {
            Pokemon effectTarget = target;

            for (Map.Entry<String, Integer> entry : statChanges.entrySet()) {
                String statName = entry.getKey();
                int change = entry.getValue();
                if (effectTarget.modifyStatStage(statName, change)) {
                    queueMessage(effectTarget.getName() + "'s " + formatStatName(statName) +
                        (change > 0 ? " rose!" : " fell!"));
                    AudioManager.getInstance().playSound(AudioManager.SoundEffect.CURSOR_MOVE);
                } else {
                    queueMessage(effectTarget.getName() + "'s " + formatStatName(statName) +
                        " won't go " + (change > 0 ? "higher!" : "lower!"));
                }
            }
        }
    }

    private String formatStatName(String statKey) {
        switch (statKey.toLowerCase()) {
            case "attack": return "Attack";
            case "defense": return "Defense";
            case "spatk": return "Special Attack";
            case "spdef": return "Special Defense";
            case "speed": return "Speed";
            case "accuracy": return "Accuracy";
            case "evasion": return "Evasion";
            default: return statKey;
        }
    }

    private void finishMoveExecution(boolean isPlayerMove) {
        isAnimating = false;

        if (checkFaintConditions()) {
            return;
        }

        if (!isPlayerMove) {
            applyEndOfTurnEffectsForTurn();
            if (checkFaintConditions()) {
                return;
            }
        }

        if (isPlayerMove) {
            transitionToState(BattleState.ENEMY_TURN);
        } else {
            if (callback != null) {
                callback.onTurnEnd(playerPokemon);
            }
            transitionToState(BattleState.PLAYER_CHOICE);
            turnCount++;
        }
    }

    private void handleFightButton() {
        if (currentState != BattleState.PLAYER_CHOICE) return;
        transitionToState(BattleState.PLAYER_MOVE_SELECT);
        showMoveSelection();
    }

    public void handleSwitchPokemon(int partyIndex) {
        if (currentState != BattleState.PLAYER_CHOICE && currentState != BattleState.FORCED_SWITCH) {
            GameLogger.error("Switch attempted in invalid state: " + currentState);
            return;
        }

        Pokemon newPokemon = GameContext.get().getPlayer().getPokemonParty().getPokemon(partyIndex);
        if (newPokemon == null || newPokemon == playerPokemon) {
            queueMessage("Cannot switch to this Pokemon!");
            return;
        }

        if (newPokemon.getCurrentHp() <= 0) {
            queueMessage(newPokemon.getName() + " is unable to battle!");
            if (currentState == BattleState.FORCED_SWITCH) {
                showForcedSwitchPartyScreen();
            }
            return;
        }

        isAnimating = true;
        setBattleInterfaceEnabled(false);
        transitionToState(BattleState.PLAYER_SWITCHING);

        SequenceAction switchSequence = Actions.sequence();

        switchSequence.addAction(Actions.run(() -> {
            queueMessage(playerPokemon.getName() + ", come back!");
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.POKEMON_RETURN);
            playerPokemonImage.addAction(Actions.scaleTo(0.1f, 0.1f, 0.3f));
        }));
        switchSequence.addAction(Actions.delay(0.5f));

        switchSequence.addAction(Actions.run(() -> {
            Pokemon oldPokemon = playerPokemon;
            playerPokemon = newPokemon;
            updatePlayerPokemonDisplay();
            playerPokemonImage.setScale(0.1f);
            playerPokemonImage.getColor().a = 1f;

            if (callback != null) {
                callback.onTurnEnd(oldPokemon);
            }
        }));

        switchSequence.addAction(Actions.run(() -> {
            queueMessage("Go! " + newPokemon.getName() + "!");
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.POKEMON_SENDOUT);
            playerPokemonImage.addAction(Actions.scaleTo(1.0f, 1.0f, 0.3f));
        }));
        switchSequence.addAction(Actions.delay(0.8f));

        switchSequence.addAction(Actions.run(() -> {
            isAnimating = false;
            playerActionTaken = true;
            applyEndOfTurnEffectsForTurn();
            if (checkFaintConditions()) return;
            transitionToState(BattleState.ENEMY_TURN);
        }));

        this.addAction(switchSequence);
    }

    private boolean checkFaintConditions() {
        if (enemyPokemon.getCurrentHp() <= 0) {
            handleEnemyFaint();
            return true;
        }
        if (playerPokemon.getCurrentHp() <= 0) {
            handlePlayerFaint();
            return true;
        }
        return false;
    }

    private float calculateDamage(Move move, Pokemon attacker, Pokemon defender) {
        if (move.getPower() <= 0) return 0;

        int level = attacker.getLevel();
        float attackStat = move.isSpecial() ? attacker.getStats().getSpecialAttack() : attacker.getStats().getAttack();
        float defenseStat = move.isSpecial() ? defender.getStats().getSpecialDefense() : defender.getStats().getDefense();

        // Apply Burn modifier to physical attack
        if (attacker.getStatus() == Pokemon.Status.BURNED && !move.isSpecial()) {
            attackStat *= 0.5f;
        }

        float baseDamage = (((2 * level) / 5f + 2) * move.getPower() * attackStat / defenseStat) / 50f + 2;

        // STAB (Same-Type Attack Bonus)
        float stab = (attacker.getPrimaryType() == move.getType() || attacker.getSecondaryType() == move.getType()) ? 1.5f : 1.0f;

        // Type Effectiveness
        float typeMultiplier = calculateTypeEffectiveness(move, defender);

        // Critical Hit
        boolean isCritical = MathUtils.random() < 0.0625f;
        if (isCritical) {
            queueMessage("A critical hit!");
            baseDamage *= 1.5f;
        }

        // Random variance
        float randomModifier = MathUtils.random(0.85f, 1.0f);

        return baseDamage * stab * typeMultiplier * randomModifier;
    }

    private float calculateTypeEffectiveness(Move move, Pokemon defender) {
        if (move.getType() == null || defender.getPrimaryType() == null) return 1.0f;

        float effectiveness = getTypeEffectiveness(move.getType(), defender.getPrimaryType());
        if (defender.getSecondaryType() != null) {
            effectiveness *= getTypeEffectiveness(move.getType(), defender.getSecondaryType());
        }
        return effectiveness;
    }

    private String getEffectivenessMessage(float multiplier) {
        if (multiplier >= 2.0f) {
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.SUPER_EFFECTIVE);
            return "It's super effective!";
        } else if (multiplier > 0f && multiplier < 1.0f) {
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.NOT_EFFECTIVE);
            return "It's not very effective...";
        } else if (multiplier == 0f) {
            return "It doesn't affect " + enemyPokemon.getName() + "...";
        }
        return "";
    }

    private void updatePlayerPokemonDisplay() {
        TextureRegion newTexture = playerPokemon.getBackSprite();
        if (newTexture != null) {
            playerPokemonImage.setDrawable(new TextureRegionDrawable(newTexture));
            float aspect = (float) newTexture.getRegionWidth() / newTexture.getRegionHeight();
            float baseSize = 85f;
            playerPokemonImage.setSize(baseSize * aspect, baseSize);
        }
        playerHPBar.setRange(0, playerPokemon.getStats().getHp());
        playerHPBar.setValue(playerPokemon.getCurrentHp());
        updateHPBarColor(playerHPBar, playerPokemon.getCurrentHp() / (float) playerPokemon.getStats().getHp(),skin);
        updateInfoLabels();
        expBar.setRange(0, playerPokemon.getExperienceForNextLevel());
        expBar.setValue(playerPokemon.getCurrentExperience());
        updateStatusIcon(playerPokemon, playerStatusIcon);
        invalidate();
        centerPlayerPokemon();
    }

    private void centerPlayerPokemon() {
        if (playerPlatform != null && playerPokemonImage != null) {
            float offsetX = (playerPlatform.getWidth() - playerPokemonImage.getWidth()) / 2f;
            float offsetY = (playerPlatform.getHeight() - playerPokemonImage.getHeight()) / 2f;
            playerPokemonImage.setPosition(offsetX, offsetY);
        }
    }

    private void updateActionMenuPosition() {
        actionMenu.pack();
        float tableWidth = getWidth() > 0 ? getWidth() : BATTLE_SCREEN_WIDTH;
        float tableHeight = getHeight() > 0 ? getHeight() : BATTLE_SCREEN_HEIGHT;
        float posX = (tableWidth - actionMenu.getWidth()) / 2f;
        float posY = tableHeight * 0.3f;
        actionMenu.setPosition(posX, posY);
        actionMenu.toFront();
    }

    @Override
    protected void sizeChanged() {
        super.sizeChanged();
        updateActionMenuPosition();
    }

    public void applyDamage(Pokemon target, float damage) {
        Image targetSprite = (target == playerPokemon) ? playerPokemonImage : enemyPokemonImage;
        targetSprite.addAction(Actions.sequence(
            Actions.color(Color.RED, 0.1f),
            Actions.color(Color.WHITE, 0.1f)
        ));

        float oldHP = target.getCurrentHp();
        float newHP = Math.max(0, oldHP - damage);
        target.setCurrentHp(newHP);

        // Animate the HP bar
        ProgressBar targetBar = (target == playerPokemon) ? playerHPBar : enemyHPBar;
        animateHPChange(targetBar, oldHP, newHP, target.getStats().getHp());
    }

    private void animateHPChange(ProgressBar bar, float fromValue, float toValue, float maxValue) {
        float duration = 0.5f;
        bar.addAction(new Action() {
            float time = 0;
            @Override
            public boolean act(float delta) {
                time += delta;
                float progress = Math.min(1f, time / duration);
                float currentValue = MathUtils.lerp(fromValue, toValue, progress);
                bar.setValue(currentValue);
                updateHPBarColor(bar, currentValue / maxValue,skin);
                return progress >= 1f;
            }
        });
    }


    private void applyEndOfTurnEffectsForTurn() {
        Pokemon.Status oldPlayerStatus = playerPokemon.getStatus();
        Pokemon.Status oldEnemyStatus = enemyPokemon.getStatus();

        playerPokemon.applyEndOfTurnEffects();
        enemyPokemon.applyEndOfTurnEffects();

        // Handle Leech Seed
        if (leechSeedTargets.containsKey(playerPokemon)) {
            int damage = playerPokemon.getStats().getHp() / 8;
            playerPokemon.setCurrentHp(Math.max(0, playerPokemon.getCurrentHp() - damage));
            enemyPokemon.heal(damage);
            queueMessage(playerPokemon.getName() + "'s health is sapped by Leech Seed!");
            updateHPBars();
        }

        if (leechSeedTargets.containsKey(enemyPokemon)) {
            int damage = enemyPokemon.getStats().getHp() / 8;
            enemyPokemon.setCurrentHp(Math.max(0, enemyPokemon.getCurrentHp() - damage));
            playerPokemon.heal(damage);
            queueMessage(enemyPokemon.getName() + "'s health is sapped by Leech Seed!");
            updateHPBars();
        }

        if (oldPlayerStatus != playerPokemon.getStatus() && callback != null) {
            callback.onStatusChange(playerPokemon, playerPokemon.getStatus());
        }

        if (oldEnemyStatus != enemyPokemon.getStatus() && callback != null) {
            callback.onStatusChange(enemyPokemon, enemyPokemon.getStatus());
        }

        updateHPBars();
        updateInfoLabels();
    }

    private void showForcedSwitchPartyScreen() {
        PokemonPartyWindow partyScreen = new PokemonPartyWindow(
            skin,
            GameContext.get().getPlayer().getPokemonParty(),
            true,
            (selectedIndex) -> {
                Pokemon selectedPokemon = GameContext.get().getPlayer().getPokemonParty().getPokemon(selectedIndex);
                if (selectedPokemon != null && selectedPokemon.getCurrentHp() > 0) {
                    handleSwitchPokemon(selectedIndex);
                }
            },
            null
        );
        stage.addActor(partyScreen);
        partyScreen.show(stage);
    }

    private boolean hasAvailablePokemon() {
        for (Pokemon poke : GameContext.get().getPlayer().getPokemonParty().getParty()) {
            if (poke != playerPokemon && poke.getCurrentHp() > 0) {
                return true;
            }
        }
        return false;
    }

    private void transitionToState(BattleState newState) {
        GameLogger.info("Transitioning from " + currentState + " to " + newState);
        currentState = newState;
        stateTimer = 0;
        playerActionTaken = false;

        switch (newState) {
            case PLAYER_CHOICE:
                showActionMenu(true);
                setBattleInterfaceEnabled(true);
                battleText.setText("What will " + playerPokemon.getName() + " do?");
                break;
            case PLAYER_MOVE_SELECT:
                setBattleInterfaceEnabled(false);
                break;
            case PLAYER_MOVE_EXECUTE:
            case ENEMY_TURN:
            case PLAYER_SWITCHING:
            case BATTLE_OVER_VICTORY:
            case BATTLE_OVER_DEFEAT:
                showActionMenu(false);
                setBattleInterfaceEnabled(false);
                break;
        }
    }

    private void showActionMenu(boolean show) {
        if (actionMenu != null) {
            actionMenu.setVisible(show);
            actionMenu.setTouchable(show ? Touchable.enabled : Touchable.disabled);
            actionMenu.toFront();
        }
    }

    private void showMoveSelection() {
        if (moveSelectionTable != null) {
            moveSelectionTable.remove();
        }

        moveSelectionTable = new Table(skin);
        moveSelectionTable.setBackground(createTranslucentBackground(0.8f));
        moveSelectionTable.defaults().pad(10).space(10);

        java.util.List<Move> moves = playerPokemon.getMoves();
        if (moves == null || moves.isEmpty()) {
            queueMessage(playerPokemon.getName() + " has no moves!");
            actionMenu.setVisible(true);
            actionMenu.setTouchable(Touchable.enabled);
            return;
        }

        Label titleLabel = new Label("Select a move:", skin);
        titleLabel.setFontScale(1.1f);
        moveSelectionTable.add(titleLabel).colspan(2).padBottom(10).row();

        // Display moves in a 2x2 grid with details
        int moveCount = 0;
        for (final Move move : moves) {
            Table moveButton = new Table();
            moveButton.setBackground(createTranslucentBackground(0.4f));
            moveButton.pad(8);

            Label nameLabel = new Label(move.getName(), skin);
            nameLabel.setColor(TYPE_COLORS.get(move.getType()));
            moveButton.add(nameLabel).expandX().left().row();

            Table detailsTable = new Table();
            Label ppLabel = new Label("PP: " + move.getPp() + "/" + move.getMaxPp(), skin);
            ppLabel.setFontScale(0.8f);
            Label powerLabel = new Label("Power: " + (move.getPower() > 0 ? move.getPower() : "-"), skin);
            powerLabel.setFontScale(0.8f);
            detailsTable.add(ppLabel).padRight(10);
            detailsTable.add(powerLabel);
            moveButton.add(detailsTable).expandX().left();

            moveButton.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    if (move.getPp() <= 0) {
                        queueMessage("No PP left for this move!");
                        return;
                    }
                    moveSelectionActive = false;
                    moveSelectionTable.remove();
                    executeMove(move, playerPokemon, enemyPokemon, true);
                }
            });

            moveSelectionTable.add(moveButton).width(200).height(60);

            moveCount++;
            if (moveCount % 2 == 0) {
                moveSelectionTable.row();
            }
        }

        if (moveCount % 2 != 0) {
            moveSelectionTable.add(); // Empty cell for alignment
            moveSelectionTable.row();
        }

        TextButton cancelButton = new TextButton("Cancel", skin);
        cancelButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                moveSelectionActive = false;
                moveSelectionTable.remove();
                currentState = BattleState.PLAYER_CHOICE;
                actionMenu.setVisible(true);
                actionMenu.setTouchable(Touchable.enabled);
                actionMenu.toFront();
            }
        });
        moveSelectionTable.add(cancelButton).colspan(2).width(150).height(40).padTop(10);

        moveSelectionTable.pack();
        float tableWidth = (getWidth() > 0 ? getWidth() : BATTLE_SCREEN_WIDTH);
        float tableHeight = (getHeight() > 0 ? getHeight() : BATTLE_SCREEN_HEIGHT);
        float posX = (tableWidth - moveSelectionTable.getWidth()) / 2f;
        float posY = (tableHeight - moveSelectionTable.getHeight()) / 2f;
        moveSelectionTable.setPosition(posX, posY);
        moveSelectionTable.toFront();
        addActor(moveSelectionTable);

        moveSelectionActive = true;
    }

    private void attemptRun() {
        if (isAnimating) return;

        float runChance = 0.8f;
        if (MathUtils.random() < runChance) {
            queueMessage("Got away safely!");
            SequenceAction escapeSequence = Actions.sequence(
                Actions.delay(1.0f),
                Actions.run(() -> {
                    if (callback != null) {
                        callback.onBattleEnd(false);
                    }
                    cleanup();
                    remove();
                })
            );
            addAction(escapeSequence);
            isAnimating = true;
        } else {
            queueMessage("Can't escape!");
            transitionToState(BattleState.ENEMY_TURN);
        }
    }

    public void attemptCapture(WildPokemon wildPokemon, float captureChance) {
        if (currentState == BattleState.CATCHING) return;

        currentState = BattleState.CATCHING;
        setBattleInterfaceEnabled(false);
        queueMessage("Throwing Pokéball...");

        Vector2 playerCenter = playerPokemonImage.localToStageCoordinates(new Vector2(
            playerPokemonImage.getWidth() / 2, playerPokemonImage.getHeight() / 2));
        Vector2 enemyCenter = enemyPokemonImage.localToStageCoordinates(new Vector2(
            enemyPokemonImage.getWidth() / 2, enemyPokemonImage.getHeight() / 2));

        float throwDuration = 0.8f;
        TextureAtlas capsuleThrowAtlas = TextureManager.capsuleThrow;

        PokemonCaptureAnimation captureAnimation = new PokemonCaptureAnimation(
            capsuleThrowAtlas, playerCenter, enemyCenter, throwDuration, captureChance,
            success -> {
                if (success) {
                    queueMessage("Gotcha! " + wildPokemon.getName() + " was caught!");
                    GameContext.get().getPlayer().getPokemonParty().addPokemon(wildPokemon);
                    if (GameContext.get().getGameScreen() != null) {
                        GameContext.get().getGameScreen().updatePartyDisplay();
                    }
                    addAction(Actions.sequence(
                        Actions.delay(1.0f),
                        Actions.run(() -> {
                            if (callback != null) callback.onBattleEnd(true);
                        })
                    ));
                } else {
                    queueMessage(wildPokemon.getName() + " broke free!");
                    transitionToState(BattleState.ENEMY_TURN);
                }
            },
            enemyPokemonImage);
        addActor(captureAnimation);
    }


    public void setCallback(BattleCallback callback) {
        this.callback = callback;
    }

    private void cleanup() {
        if (playerPokemonImage != null) playerPokemonImage.clear();
        if (enemyPokemonImage != null) enemyPokemonImage.clear();
        clearActions();
        messageQueue.clear();
        leechSeedTargets.clear();
    }

    private int calculateExperienceGain(WildPokemon defeatedPokemon) {
        float a = 1.0f;  // Wild battle
        float t = 1.0f;  // No modifiers
        int b = defeatedPokemon.getBaseExperience();
        int L = defeatedPokemon.getLevel();

        float levelRatio = Math.max(0.5f, Math.min(1.5f, (float)L / playerPokemon.getLevel()));

        int expGained = Math.round((a * t * b * L * levelRatio) / 7);
        GameLogger.info(String.format("Experience gained: %d (Base: %d, Level: %d)",
            expGained, b, L));

        return Math.max(1, expGained);
    }

    public Pokemon getPlayerPokemon() {
        return playerPokemon;
    }

    public interface BattleCallback {
        void onBattleEnd(boolean playerWon);
        void onTurnEnd(Pokemon activePokemon);
        void onStatusChange(Pokemon pokemon, Pokemon.Status newStatus);
        void onMoveUsed(Pokemon user, Move move, Pokemon target);
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/BuildingHotbar.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.FrameBuffer;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.utils.Scaling;
import io.github.pokemeetup.blocks.BuildingData;
import io.github.pokemeetup.blocks.BuildingTemplate;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.textures.BlockTextureManager;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.List;

public class BuildingHotbar extends Table {
    private static final float SLOT_SIZE = 50f;
    private static final float PADDING = 5f;
    private final List<BuildingData> buildingSlots = new ArrayList<>();
    private final ScrollPane scrollPane;
    private final Table slotsTable;
    private int selectedIndex = 0;

    public BuildingHotbar(Skin skin) {
        // Set background similar to the regular hotbar
        this.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        this.pad(PADDING);

        // Create the slots table (horizontal layout)
        slotsTable = new Table();

        // Scroll pane for horizontal scrolling if needed
        ScrollPane.ScrollPaneStyle scrollStyle = new ScrollPane.ScrollPaneStyle(
            skin.get(ScrollPane.ScrollPaneStyle.class));
        scrollStyle.hScrollKnob = new TextureRegionDrawable(TextureManager.ui.findRegion("scrollbar_knob"));
        scrollPane = new ScrollPane(slotsTable, scrollStyle);
        scrollPane.setScrollingDisabled(false, true);
        scrollPane.setFadeScrollBars(false);

        // Fit the hotbar width to screen width
        float totalWidth = Gdx.graphics.getWidth() - 20f;  // a margin from screen edges
        float totalHeight = SLOT_SIZE + PADDING * 2;

        this.add(scrollPane).width(totalWidth).height(totalHeight);

        // Initialize with a default building
        initializeBuildings();
        refreshSlots();

        GameLogger.info("BuildingHotbar initialized horizontally: " + totalWidth + "x" + totalHeight);
    }

    private void initializeBuildings() {
        // Example: Wooden House
        BuildingData woodenHouse = new BuildingData(
            "wooden_house",
            "Wooden House",
            BuildingTemplate.createWoodenHouse()
        );
        woodenHouse.addRequirement("wooden_planks", 128);
        buildingSlots.add(woodenHouse);

        GameLogger.info("Added wooden house template to building hotbar");
    }

    private void refreshSlots() {
        slotsTable.clear();

        for (int i = 0; i < buildingSlots.size(); i++) {
            final int index = i;
            BuildingData building = buildingSlots.get(i);

            // Create slot table
            Table slot = new Table();
            slot.setBackground(new TextureRegionDrawable(
                TextureManager.ui.findRegion(index == selectedIndex ? "slot_selected" : "slot_normal")));

            // Create preview image
            Table previewContainer = createBuildingPreview(building);
            slot.add(previewContainer).size(SLOT_SIZE).pad(PADDING);

            // Add click listener
            slot.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    selectSlot(index);
                }
            });

            slotsTable.add(slot).size(SLOT_SIZE).pad(PADDING);
        }
    }

    private Table createBuildingPreview(BuildingData building) {
        Table container = new Table();
        if (building != null) {
            // Use a predefined preview image from the buildings atlas
            // Adjust the region name if needed to match your actual texture name
            TextureRegion finalHouseTexture = TextureManager.buildings.findRegion(building.getId());
            if (finalHouseTexture != null) {
                Image previewImage = new Image(finalHouseTexture);
                previewImage.setScaling(Scaling.fit);
                container.add(previewImage).size(SLOT_SIZE, SLOT_SIZE).center();
            } else {
                // If no preview image is found, show a placeholder
                // Make sure to have a fallback in case the preview image doesn't exist
                Label label = new Label("No Preview", getSkin());
                container.add(label).center();
            }
        }
        return container;
    }



    @Override
    public void act(float delta) {
        super.act(delta);
        // If you want to handle keyboard scrolling:
        if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) {
            scroll(-5);
        } else if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) {
            scroll(5);
        }
    }

    public void selectSlot(int index) {
        if (index >= 0 && index < buildingSlots.size()) {
            selectedIndex = index;
            refreshSlots();
            GameLogger.info("Selected building slot: " + index);
        }
    }

    public BuildingData getSelectedBuilding() {
        if (selectedIndex >= 0 && selectedIndex < buildingSlots.size()) {
            return buildingSlots.get(selectedIndex);
        }
        return null;
    }

    public void scroll(int amount) {
        float currentX = scrollPane.getScrollX();
        scrollPane.setScrollX(currentX + amount);
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/BuildModeUI.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Scaling;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.blocks.BuildingData;
import io.github.pokemeetup.blocks.BuildingTemplate;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.blocks.SmartBuildingManager;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.BlockTextureManager;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.List;
import java.util.Map;
import java.util.UUID;

// Changed from Group to Table to handle layout and resizing automatically.
public class BuildModeUI extends Table {
    private static final float SLOT_SIZE = 40f;
    private static final int HOTBAR_SLOTS = 9;
    private static final Color VALID_PREVIEW_COLOR = new Color(0, 1, 0, 0.3f);
    private static final Color INVALID_PREVIEW_COLOR = new Color(1, 0, 0, 0.3f);

    private final Skin skin;
    private final Table hotbarTable;
    public final BuildingHotbar buildingHotbar;
    private final ShapeRenderer shapeRenderer;
    private final BlockTextureManager blockTextureManager;
    private final SmartBuildingManager smartBuildingManager;

    private boolean inBuildingMode = false;
    private int selectedSlot = 0;
    private final Vector2 previewPosition = new Vector2();
    private boolean canPlaceAtPreview;
    private float stateTime = 0;

    public BuildModeUI(Skin skin) {
        super(skin); // Use the Table(Skin) constructor
        this.skin = skin;
        this.blockTextureManager = new BlockTextureManager();
        this.shapeRenderer = new ShapeRenderer();
        this.smartBuildingManager = new SmartBuildingManager(GameContext.get().getWorld());

        // This ensures the table takes up the whole screen space,
        // allowing us to align its contents precisely.
        this.setFillParent(true);
        // Align all content in this table to the bottom edge.
        this.bottom();

        // This table will hold the block hotbar
        this.hotbarTable = new Table();

        // This is the hotbar for entire buildings
        this.buildingHotbar = new BuildingHotbar(skin);
        buildingHotbar.setVisible(false);

        // Add both hotbars to a Stack so they occupy the same space.
        // We will toggle their visibility to switch between them.
        Stack hotbarStack = new Stack(hotbarTable, buildingHotbar);

        // Add a "Build Mode" label that will appear above the hotbars.
        Label buildModeLabel = new Label("Build Mode", skin);
        buildModeLabel.setColor(Color.YELLOW);
        this.add(buildModeLabel).padBottom(5).row(); // .row() moves to the next line

        // Add the hotbar stack below the label.
        this.add(hotbarStack);

        GameContext.get().getPlayer().getInventory().addObserver(this::refreshBuildInventory);
        refreshBuildInventory();
    }


    public boolean isInBuildingMode() {
        return inBuildingMode;
    }

    @Override
    public void act(float delta) {
        super.act(delta);
        stateTime += delta;
    }

    public void renderPlacementPreview(SpriteBatch batch, OrthographicCamera camera) {
        if (!isVisible()) return;

        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();

        switch (GameContext.get().getPlayer().getDirection()) {
            case "up": targetY++; break;
            case "down": targetY--; break;
            case "left": targetX--; break;
            case "right": targetX++; break;
        }

        previewPosition.set(targetX, targetY);
        canPlaceAtPreview = canPlaceAt(targetX, targetY);

        renderPlacementIndicator(camera, targetX, targetY);

        if (canPlaceAtPreview) {
            renderPreview(batch, targetX, targetY);
        }
    }

    private boolean canPlaceAt(int tileX, int tileY) {
        if (inBuildingMode) {
            BuildingData building = buildingHotbar.getSelectedBuilding();
            return building != null && canPlaceBuilding(building.getTemplate(), tileX, tileY);
        } else {
            return canPlaceBlockAt(tileX, tileY);
        }
    }

    private void renderPlacementIndicator(OrthographicCamera camera, int targetX, int targetY) {
        Gdx.gl.glEnable(GL20.GL_BLEND);
        shapeRenderer.setProjectionMatrix(camera.combined);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);

        shapeRenderer.setColor(canPlaceAtPreview ? VALID_PREVIEW_COLOR : INVALID_PREVIEW_COLOR);

        Rectangle bounds;
        if(inBuildingMode) {
            BuildingData building = buildingHotbar.getSelectedBuilding();
            if (building != null) {
                BuildingTemplate template = building.getTemplate();
                bounds = new Rectangle(targetX * World.TILE_SIZE, targetY * World.TILE_SIZE, template.getWidth() * World.TILE_SIZE, template.getHeight() * World.TILE_SIZE);
            } else {
                bounds = new Rectangle(targetX * World.TILE_SIZE, targetY * World.TILE_SIZE, World.TILE_SIZE, World.TILE_SIZE);
            }
        } else {
            bounds = new Rectangle(targetX * World.TILE_SIZE, targetY * World.TILE_SIZE, World.TILE_SIZE, World.TILE_SIZE);
        }

        shapeRenderer.rect(bounds.x, bounds.y, bounds.width, bounds.height);
        shapeRenderer.end();
        Gdx.gl.glDisable(GL20.GL_BLEND);
    }

    private void renderPreview(SpriteBatch batch, int targetX, int targetY) {
        if (inBuildingMode) {
            renderBuildingPreview(batch, targetX, targetY);
        } else {
            renderBlockPreview(batch, targetX, targetY);
        }
    }

    private void renderBlockPreview(SpriteBatch batch, int targetX, int targetY) {
        ItemData selectedItem = GameContext.get().getPlayer().getBuildInventory().getItemAt(selectedSlot);
        if (selectedItem == null) return;
        PlaceableBlock.BlockType baseType = PlaceableBlock.BlockType.fromItemId(selectedItem.getItemId());
        if (baseType == null) return;

        PlaceableBlock previewBlock = new PlaceableBlock(baseType, new Vector2(targetX, targetY), null, false);
        TextureRegion blockTexture = BlockTextureManager.getBlockFrame(previewBlock, stateTime);

        if (blockTexture != null) {
            batch.begin();
            batch.setColor(1, 1, 1, 0.7f);
            batch.draw(blockTexture, targetX * World.TILE_SIZE, targetY * World.TILE_SIZE);
            batch.setColor(Color.WHITE);
            batch.end();
        }
    }

    private void renderBuildingPreview(SpriteBatch batch, int startX, int startY) {
        BuildingData buildingData = buildingHotbar.getSelectedBuilding();
        if (buildingData == null) return;
        BuildingTemplate template = buildingData.getTemplate();

        batch.begin();
        batch.setColor(1, 1, 1, 0.7f);

        for (int x = 0; x < template.getWidth(); x++) {
            for (int y = 0; y < template.getHeight(); y++) {
                BuildingTemplate.BlockData blockData = template.getBlockAt(x, y);
                if (blockData != null) {
                    PlaceableBlock previewBlock = new PlaceableBlock(blockData.type, new Vector2(startX + x, startY + y), null, blockData.isFlipped);
                    TextureRegion blockTexture = BlockTextureManager.getBlockFrame(previewBlock, stateTime);
                    if (blockTexture != null) {
                        float blockX = (startX + x) * World.TILE_SIZE;
                        float blockY = (startY + y) * World.TILE_SIZE;

                        if (blockData.isFlipped) {
                            batch.draw(blockTexture, blockX + blockTexture.getRegionWidth(), blockY, -blockTexture.getRegionWidth(), blockTexture.getRegionHeight());
                        } else {
                            batch.draw(blockTexture, blockX, blockY);
                        }
                    }
                }
            }
        }
        batch.setColor(Color.WHITE);
        batch.end();
    }

    public void toggleBuildingMode() {
        inBuildingMode = !inBuildingMode;
        hotbarTable.setVisible(!inBuildingMode);
        buildingHotbar.setVisible(inBuildingMode);
    }

    public boolean tryPlace() {
        if (!GameContext.get().getPlayer().isBuildMode()) return false;
        if (!canPlaceAtPreview) return false;

        int targetX = (int)previewPosition.x;
        int targetY = (int)previewPosition.y;

        if (inBuildingMode) {
            return tryPlaceBuilding(targetX, targetY);
        } else {
            return tryPlaceBlock(targetX, targetY);
        }
    }

    public boolean tryPlaceBuilding(int tileX, int tileY) {
        BuildingData building = buildingHotbar.getSelectedBuilding();
        if (building == null) return false;

        for (Map.Entry<String, Integer> req : building.getRequirements().entrySet()) {
            if (!hasEnoughMaterials(req.getKey(), req.getValue())) {
                GameLogger.info("Not enough materials for " + building.getName());
                return false;
            }
        }

        if (building.getTemplate().placeBuilding(GameContext.get().getWorld(), tileX, tileY)) {
            consumeMaterials(building.getRequirements());
            if (GameContext.get().isMultiplayer()) {
                NetworkProtocol.BuildingPlacement bp = building.getTemplate().toNetworkMessage(GameContext.get().getPlayer().getUsername(), tileX, tileY);
                GameContext.get().getGameClient().sendBuildingPlacement(bp);
            }
            return true;
        }
        return false;
    }

    private boolean hasEnoughMaterials(String itemId, int required) {
        return GameContext.get().getPlayer().getInventory().getAllItems().stream()
            .filter(item -> item != null && item.getItemId().equals(itemId))
            .mapToInt(ItemData::getCount).sum() >= required;
    }

    private void consumeMaterials(Map<String, Integer> requirements) {
        Inventory inventory = GameContext.get().getPlayer().getInventory();
        for (Map.Entry<String, Integer> req : requirements.entrySet()) {
            inventory.removeItem(req.getKey(), req.getValue());
        }
        refreshBuildInventory(); // Refresh hotbar after consumption
    }

    private boolean canPlaceBuilding(BuildingTemplate template, int startX, int startY) {
        for (int x = 0; x < template.getWidth(); x++) {
            for (int y = 0; y < template.getHeight(); y++) {
                if (template.getBlockAt(x, y) != null && !canPlaceBlockAt(startX + x, startY + y)) {
                    return false;
                }
            }
        }
        return true;
    }

    private boolean canPlaceBlockAt(int tileX, int tileY) {
        return GameContext.get().getWorld().isPassable(tileX, tileY) &&
            GameContext.get().getWorld().getBlockManager().getBlockAt(tileX, tileY) == null;
    }

    public boolean tryPlaceBlock(int tileX, int tileY) {
        ItemData selectedItem = GameContext.get().getPlayer().getBuildInventory().getItemAt(selectedSlot);
        if (selectedItem == null) return false;

        ItemData inventoryItem = findInventoryItem(selectedItem.getUuid());
        if (inventoryItem == null) {
            refreshBuildInventory();
            return false;
        }

        PlaceableBlock.BlockType blockType = PlaceableBlock.BlockType.fromItemId(inventoryItem.getItemId());
        if (blockType == null) return false;

        if (GameContext.get().getWorld().getBlockManager().placeBlock(blockType, tileX, tileY)) {
            consumeItem(inventoryItem);
            refreshBuildInventory();
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_PLACE_0);
            return true;
        }
        return false;
    }

    private ItemData findInventoryItem(UUID uuid) {
        return GameContext.get().getPlayer().getInventory().getAllItems().stream()
            .filter(item -> item != null && item.getUuid().equals(uuid))
            .findFirst().orElse(null);
    }

    private void consumeItem(ItemData itemToConsume) {
        itemToConsume.setCount(itemToConsume.getCount() - 1);
        if (itemToConsume.getCount() <= 0) {
            GameContext.get().getPlayer().getInventory().removeItem(itemToConsume);
        } else {
            // This is important for observers
            GameContext.get().getPlayer().getInventory().notifyObservers();
        }
    }

    public void refreshBuildInventory() {
        Inventory buildInv = GameContext.get().getPlayer().getBuildInventory();
        buildInv.clear();
        int buildSlot = 0;
        for (ItemData item : GameContext.get().getPlayer().getInventory().getAllItems()) {
            if (item != null && isBlockItem(item.getItemId())) {
                if (buildSlot < HOTBAR_SLOTS) {
                    buildInv.setItemAt(buildSlot++, item);
                } else break;
            }
        }
        updateHotbarContent();
    }

    private boolean isBlockItem(String itemId) {
        return PlaceableBlock.BlockType.fromItemId(itemId) != null;
    }

    private void updateHotbarContent() {
        hotbarTable.clear();
        hotbarTable.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        hotbarTable.pad(4);

        for (int i = 0; i < HOTBAR_SLOTS; i++) {
            final int slotIndex = i;
            Table slotCell = createSlotCell(i);
            slotCell.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    selectSlot(slotIndex);
                }
            });
            hotbarTable.add(slotCell).size(SLOT_SIZE).pad(2);
        }
    }

    private Table createSlotCell(int index) {
        Table slotCell = new Table();
        slotCell.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion(index == selectedSlot ? "slot_selected" : "slot_normal")));
        ItemData item = GameContext.get().getPlayer().getBuildInventory().getItemAt(index);

        if (item != null) {
            TextureRegion itemIcon = blockTextureManager.getItemIcon(item.getItemId());
            if (itemIcon != null) {
                Image itemImage = new Image(itemIcon);
                itemImage.setScaling(Scaling.fit);
                slotCell.add(itemImage).size(SLOT_SIZE - 8).center().expand();

                if (item.getCount() > 1) {
                    Label countLabel = new Label(String.valueOf(item.getCount()), skin);
                    countLabel.setColor(Color.WHITE);
                    slotCell.add(countLabel).align(Align.bottomRight).pad(2);
                }
            }
        }
        return slotCell;
    }

    public void selectSlot(int index) {
        if (index >= 0 && index < HOTBAR_SLOTS) {
            selectedSlot = index;
            updateHotbarContent();
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/CharacterPreviewDialog.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Timer;
import io.github.pokemeetup.system.gameplay.PlayerAnimations;

import java.util.Arrays;

public class CharacterPreviewDialog extends Dialog {
    private static final float PREVIEW_WIDTH = 64f;
    private static final float PREVIEW_HEIGHT = 96f;
    private static final float BUTTON_WIDTH = 120f;
    private static final float BUTTON_HEIGHT = 40f;

    private final Stage stage;
    private final Skin skin;
    private String selectedCharacterType = "boy";
    private float stateTime = 0f;
    private Table previewTable;
    private PlayerAnimations boyAnimations;
    private PlayerAnimations girlAnimations;
    private PlayerAnimations currentAnimations;
    private TextureRegion currentFrame;
    // Instead of storing "walk_down" etc., store only the direction.
    private String currentAnimation = "down";
    private boolean isAnimating = true;
    private TextButton boyButton;
    private TextButton girlButton;

    public CharacterPreviewDialog(Stage stage, Skin skin, DialogCallback callback) {
        super("Choose Your Character", skin);
        this.stage = stage;
        this.skin = skin;

        // Initialize animations
        boyAnimations = new PlayerAnimations("boy");
        girlAnimations = new PlayerAnimations("girl");
        currentAnimations = boyAnimations;

        createLayout();
        setupPreviewArea();
        setupConfirmationButtons(callback);

        // Add preview animation update task (about 60 FPS)
        Timer.schedule(new Timer.Task() {
            @Override
            public void run() {
                updatePreviewAnimation();
            }
        }, 0, 0.016f);
    }

    private void createLayout() {
        Table mainTable = getContentTable();
        mainTable.pad(10);

        // Character selection buttons
        Table buttonTable = new Table();
        buttonTable.defaults().pad(5).width(BUTTON_WIDTH).height(BUTTON_HEIGHT);

        boyButton = new TextButton("Boy", skin);
        girlButton = new TextButton("Girl", skin);

        boyButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                if (boyButton.isChecked()) {
                    updateCharacterType("boy");
                    boyButton.setColor(Color.SKY);
                    girlButton.setColor(Color.WHITE);
                }
            }
        });

        girlButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                if (girlButton.isChecked()) {
                    updateCharacterType("girl");
                    girlButton.setColor(Color.SKY);
                    boyButton.setColor(Color.WHITE);
                }
            }
        });

        // Set up button group
        ButtonGroup<TextButton> characterGroup = new ButtonGroup<>(boyButton, girlButton);
        characterGroup.setMinCheckCount(1);
        characterGroup.setMaxCheckCount(1);

        buttonTable.add(boyButton);
        buttonTable.add(girlButton);

        // Preview area
        previewTable = new Table();
        previewTable.setBackground(new TextureRegionDrawable(new TextureRegion(new Texture(createPreviewBackground()))));

        // Main layout
        Table contentTable = new Table();
        contentTable.add(buttonTable).padBottom(10).row();
        contentTable.add(previewTable).size(PREVIEW_WIDTH + 20, PREVIEW_HEIGHT + 20).padBottom(10).row();

        // Direction controls
        Table controlsTable = new Table();
        TextButton prevAnim = new TextButton("<", skin);
        TextButton nextAnim = new TextButton(">", skin);
        Label animLabel = new Label("Down", skin);

        prevAnim.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                cycleAnimation(-1);
                updateAnimationLabel(animLabel);
            }
        });

        nextAnim.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                cycleAnimation(1);
                updateAnimationLabel(animLabel);
            }
        });

        controlsTable.add(prevAnim).width(30);
        controlsTable.add(animLabel).width(60).pad(0, 10, 0, 10);
        controlsTable.add(nextAnim).width(30);

        contentTable.add(controlsTable);

        mainTable.add(contentTable);

        // Set initial selection
        boyButton.setChecked(true);
        boyButton.setColor(Color.SKY);
    }

    private void setupPreviewArea() {
        // Start by displaying the standing frame for "down"
        previewTable.add(new Image(currentAnimations.getStandingFrame("down"))).size(PREVIEW_WIDTH, PREVIEW_HEIGHT);
    }

    private void setupConfirmationButtons(DialogCallback callback) {
        getButtonTable().defaults().width(BUTTON_WIDTH).height(BUTTON_HEIGHT).pad(10);

        TextButton confirmButton = new TextButton("Confirm", skin);
        TextButton cancelButton = new TextButton("Cancel", skin);

        confirmButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                callback.onConfirm(selectedCharacterType);
                hide();
            }
        });

        cancelButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                hide();
            }
        });

        button(confirmButton, true);
        button(cancelButton, false);
    }

    private void updateCharacterType(String type) {
        selectedCharacterType = type;
        currentAnimations = type.equals("boy") ? boyAnimations : girlAnimations;
        stateTime = 0f;
    }

    private void updatePreviewAnimation() {
        if (isAnimating) {
            stateTime += Gdx.graphics.getDeltaTime();
            // currentAnimation already holds "down", "up", etc.
            currentFrame = currentAnimations.getCurrentFrame(currentAnimation, true, false, stateTime);

            Gdx.app.postRunnable(() -> {
                previewTable.clearChildren();
                previewTable.add(new Image(currentFrame)).size(PREVIEW_WIDTH, PREVIEW_HEIGHT);
            });
        }
    }

    private void cycleAnimation(int direction) {
        // Use an array of directions without the "walk_" prefix.
        String[] animTypes = {"down", "up", "left", "right"};
        int currentIndex = Arrays.asList(animTypes).indexOf(currentAnimation);
        if (currentIndex == -1) currentIndex = 0;
        currentIndex = (currentIndex + direction) % animTypes.length;
        if (currentIndex < 0) currentIndex = animTypes.length - 1;

        currentAnimation = animTypes[currentIndex];
        stateTime = 0f;

        // Force immediate update of the preview frame.
        if (currentAnimations != null) {
            currentFrame = currentAnimations.getCurrentFrame(currentAnimation, true, false, stateTime);
        }
    }

    private void updateAnimationLabel(Label label) {
        // Capitalize the first letter (e.g., "down" becomes "Down")
        label.setText(currentAnimation.substring(0, 1).toUpperCase() + currentAnimation.substring(1));
    }

    private Pixmap createPreviewBackground() {
        Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        pixmap.setColor(0.2f, 0.2f, 0.2f, 1);
        pixmap.fill();
        return pixmap;
    }

    @Override
    public void draw(Batch batch, float parentAlpha) {
        super.draw(batch, parentAlpha);
    }

    public void dispose() {
        if (boyAnimations != null) {
            boyAnimations.dispose();
        }
        if (girlAnimations != null) {
            girlAnimations.dispose();
        }
    }

    public interface DialogCallback {
        void onConfirm(String characterType);
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/GameMenu.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Application;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Preferences;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.client.GameClientSingleton;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.system.InputManager;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;
import io.github.pokemeetup.system.keybinds.ControllerBindsDialog;
import io.github.pokemeetup.system.keybinds.KeyBindsDialog;
import io.github.pokemeetup.utils.GameLogger;

public class GameMenu extends Actor {
    private static final float BUTTON_WIDTH = 200f;
    private static final float BUTTON_HEIGHT = 50f;
    private static final float MENU_PADDING = 20f;

    private final CreatureCaptureGame game;
    private final InputManager inputManager;
    private Stage stage;
    private Skin skin;
    private Window menuWindow;
    private Table menuTable;
    private boolean isVisible;
    private Window optionsWindow;
    private Slider musicSlider;
    private Slider soundSlider;
    private CheckBox musicEnabled;
    private CheckBox soundEnabled;
    private volatile boolean disposalRequested = false;
    private volatile boolean isDisposing = false;

    public GameMenu(CreatureCaptureGame game, Skin skin, InputManager inputManager) {
        this.game = game;
        this.skin = skin;
        this.inputManager = inputManager;
        this.stage = new Stage(new ScreenViewport());
        createMenu();
        menuWindow.setVisible(false);
        hide();
    }

    private void handleExit() {
        // In multiplayer mode, perform a multiplayer exit routine.
        GameClient client = GameContext.get().getGameClient();
        if (client != null && GameContext.get().isMultiplayer()) {
            performMultiplayerExit();
        } else {
            // Otherwise use the regular single-player save-and-dispose routine.
            performSaveAndExit();
        }
    }
    public void resize(int width, int height) {
        // Update the stage's viewport.
        stage.getViewport().update(width, height, true);

        // Center the main menu window.
        if (menuWindow != null) {
            menuWindow.pack(); // Recalculate size if needed
            menuWindow.setPosition(
                (width - menuWindow.getWidth()) / 2,
                (height - menuWindow.getHeight()) / 2
            );
        }

        // Center the options window as well.
        if (optionsWindow != null) {
            optionsWindow.pack();
            optionsWindow.setPosition(
                (width - optionsWindow.getWidth()) / 2,
                (height - optionsWindow.getHeight()) / 2
            );
        }
    }
    private TextButton controllerBindsButton;


    /**
     * Transitions to the title screen (or ModeSelectionScreen) after disposing of UI resources.
     *
     * @param loadingDialog  the dialog that was displayed during shutdown
     * @param isSinglePlayer if true, the game will reinitialize the world locally;
     *                       if false (multiplayer) it will simply switch to the title screen.
     */
    private void safeDisposeAndTransition(Dialog loadingDialog, boolean isSinglePlayer) {
        try {
            isDisposing = true;
            if (menuWindow != null) menuWindow.setVisible(false);
            if (stage != null) {
                stage.clear();
                stage.dispose();
            }
            if (loadingDialog != null) {
                loadingDialog.hide();
            }
            GameContext.get().setInventoryScreen(null);
            GameContext.get().setCraftingScreen(null);
            GameContext.get().setBuildModeUI(null);
            game.setScreen(new io.github.pokemeetup.screens.ModeSelectionScreen(game));
            isDisposing = false;
        } catch (Exception e) {
            GameLogger.error("Cleanup error: " + e.getMessage());
            isDisposing = false;
            if (loadingDialog != null) loadingDialog.hide();
            showErrorDialog("Error during cleanup: " + e.getMessage());
        }
    }

    private void performMultiplayerExit() {
        Dialog confirmDialog = new Dialog("Confirm Exit", skin) {
            @Override
            protected void result(Object object) {
                if ((Boolean) object) {
                    final Dialog loadingDialog = new Dialog("", skin);
                    loadingDialog.text("Saving and exiting...");
                    loadingDialog.show(stage);
                    new Thread(() -> {
                        try {
                            // In multiplayer, simply send the player state to the server.
                            GameClient client = GameContext.get().getGameClient();
                            // Dispose the client
                            if (client != null) {
                                client.dispose();
                            }
                            // Reset the client singleton and clear the reference
                            GameClientSingleton.resetInstance();
                            GameContext.get().setGameClient(null);
                            // (Optionally, also clear UI screens that depend on multiplayer.)
                            GameContext.get().setInventoryScreen(null);
                            GameContext.get().setCraftingScreen(null);
                            GameContext.get().setBuildModeUI(null);
                            // Transition to the title screen (or ModeSelectionScreen)
                            Gdx.app.postRunnable(() -> safeDisposeAndTransition(loadingDialog, false));
                        } catch (Exception e) {
                            GameLogger.error("Exit failed: " + e.getMessage());
                            Gdx.app.postRunnable(() -> {
                                loadingDialog.hide();
                                showErrorDialog("Failed to exit: " + e.getMessage());
                            });
                        }
                    }).start();
                }
            }
        };
        confirmDialog.text("Are you sure you want to exit to title?\nYour progress will be saved on the server.");
        confirmDialog.button("Yes", true);
        confirmDialog.button("No", false);
        confirmDialog.show(stage);
    }

    private void createMenu() {
        // Create the menu window and table
        menuWindow = new Window("Menu", skin);
        menuWindow.setMovable(false);
        menuWindow.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                GameLogger.info("GameMenu keyDown: keycode=" + keycode);
                return false; // Allow event propagation
            }
            @Override
            public boolean keyUp(InputEvent event, int keycode) {
                GameLogger.info("GameMenu keyUp: keycode=" + keycode);
                return false;
            }
        });

        menuTable = new Table();
        menuTable.defaults().pad(10).width(BUTTON_WIDTH).height(BUTTON_HEIGHT);

        // Create main menu buttons
        TextButton saveButton = new TextButton("Save Game", skin);
        TextButton bagButton = new TextButton("Bag", skin);
        TextButton pokemonButton = new TextButton("Pokemon", skin);
        TextButton optionsButton = new TextButton("Options", skin);
        TextButton exitButton = new TextButton("Quit and Save to Title", skin);

        saveButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                // Only save in single-player mode
                if (!GameContext.get().isMultiplayer()) {
                    saveGame();
                }
            }
        });
        bagButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                showNotImplementedMessage();
            }
        });
        pokemonButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                showPartyScreen(false);
            }
        });
        exitButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                // MODIFIED: Call the clean exit-to-menu method
                game.exitToMenu();
            }
        });
        optionsButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                showOptions();
            }
        });

        // Add buttons to the menu table
        menuTable.add(saveButton).row();
        menuTable.add(bagButton).row();
        menuTable.add(pokemonButton).row();
        menuTable.add(optionsButton).row();
        menuTable.add(exitButton).row();

        // Add the menu table to the menu window
        menuWindow.add(menuTable).pad(MENU_PADDING);
        menuWindow.pack();
        menuWindow.setPosition((Gdx.graphics.getWidth() - menuWindow.getWidth()) / 2,
            (Gdx.graphics.getHeight() - menuWindow.getHeight()) / 2);

        // Build the options menu (which also includes controller keybinds)
        createOptionsMenu();

        stage.addActor(menuWindow);
    }


    private void showPartyScreen(boolean battleMode) {
        // Hide menu window temporarily
        menuWindow.setVisible(false);
        if (GameContext.get().getGameScreen().getBattleSkin() != null) {
            // Create party screen
            PokemonPartyWindow partyScreen = new PokemonPartyWindow(
                GameContext.get().getGameScreen().getBattleSkin() ,
                GameContext.get().getPlayer().getPokemonParty(),
                battleMode,
                (selectedPokemon) -> {
                    // Handle selection
                    menuWindow.setVisible(true);
                },
                () -> {
                    // Handle cancel
                    menuWindow.setVisible(true);
                }
            );

            // Add to stage above other elements
            stage.addActor(partyScreen);
            partyScreen.show(stage);
        }
    }

    private void performSaveAndExit() {
        if (disposalRequested) return;
        disposalRequested = true;
        final Dialog loadingDialog = new Dialog("", skin);
        loadingDialog.text("Saving game...");
        loadingDialog.show(stage);
        new Thread(() -> {
            try {
                Gdx.app.postRunnable(() -> safeDisposeAndTransition(loadingDialog, true));
            } catch (Exception e) {
                GameLogger.error("Save failed: " + e.getMessage());
                Gdx.app.postRunnable(() -> {
                    loadingDialog.hide();
                    showErrorDialog("Failed to save: " + e.getMessage());
                });
            }
        }).start();
    }

    private void showErrorDialog(String message) {
        try {
            Dialog errorDialog = new Dialog("Error", skin);
            errorDialog.text(message);
            errorDialog.button("OK");
            errorDialog.show(stage);
        } catch (Exception e) {
            GameLogger.error("Failed to show error dialog: " + e.getMessage());
        }
    }

    public Stage getStage() {
        if (isDisposing || stage == null) {
            return null;
        }
        return stage;
    }

    public void show() {
        if (isVisible) return;
        isVisible = true;
        menuWindow.setVisible(true);
        stage.setKeyboardFocus(menuWindow);
        inputManager.setUIState(InputManager.UIState.MENU);
    }

    public void hide() {
        if (!isVisible) return;
        isVisible = false;
        menuWindow.setVisible(false);
        stage.unfocus(menuWindow); // Remove focus
        inputManager.setUIState(InputManager.UIState.NORMAL); // Update UI state
    }

    public boolean isVisible() {
        return isVisible;
    }

    private void saveGame() {
        GameLogger.info("Attempting to save game");
        try {
            if (GameContext.get().getGameClient() != null && GameContext.get().getPlayer().getWorld() != null) {
                PlayerData playerData = GameContext.get().getPlayer().getPlayerData();
                // In single-player mode, update and save the world state.
                GameContext.get().getWorld().getWorldData().savePlayerData(
                    GameContext.get().getPlayer().getUsername(), playerData, false);
                WorldManager.getInstance().saveWorld(GameContext.get().getWorld().getWorldData());
                GameLogger.info("Game saved successfully");
                showSaveSuccessDialog();
            } else {
                throw new Exception("Game state is invalid");
            }
        } catch (Exception e) {
            showSaveErrorDialog(e.getMessage());
        }
    }

    private void showSaveSuccessDialog() {
        Dialog dialog = new Dialog("Success", skin) {
            public void result(Object obj) {
                hide();
            }
        };
        dialog.text("Game saved successfully!");
        dialog.button("OK");
        dialog.show(stage);
    }

    private void showSaveErrorDialog(String errorMessage) {
        GameLogger.info("Save error: " + errorMessage);
        Dialog dialog = new Dialog("Error", skin) {
            public void result(Object obj) {
                hide();
            }
        };
        dialog.text("Failed to save game: " + errorMessage);
        dialog.button("OK");
        dialog.show(stage);
    }

    private void showNotImplementedMessage() {
        Dialog dialog = new Dialog("Notice", skin) {
            public void result(Object obj) {
                hide();
            }
        };
        dialog.text("This feature is not yet implemented.");
        dialog.button("OK");
        dialog.show(stage);
    }


    private void createOptionsMenu() {
        optionsWindow = new Window("Options", skin);
        optionsWindow.setMovable(false);

        Table optionsTable = new Table();
        optionsTable.pad(MENU_PADDING);

        // Audio settings
        Label musicLabel = new Label("Music Volume", skin);
        musicSlider = new Slider(0f, 1f, 0.1f, false, skin);
        musicSlider.setValue(AudioManager.getInstance().getMusicVolume());

        musicEnabled = new CheckBox(" Music Enabled", skin);
        musicEnabled.setChecked(AudioManager.getInstance().isMusicEnabled());

        Label soundLabel = new Label("Sound Volume", skin);
        soundSlider = new Slider(0f, 1f, 0.1f, false, skin);
        soundSlider.setValue(AudioManager.getInstance().getSoundVolume());

        soundEnabled = new CheckBox(" Sound Enabled", skin);
        soundEnabled.setChecked(AudioManager.getInstance().isSoundEnabled());

        // Buttons to open keybind dialogs
        TextButton keyBindsButton = new TextButton("Keyboard Key Bindings", skin);
        keyBindsButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                KeyBindsDialog dialog = new KeyBindsDialog(skin);
                dialog.show(stage);
            }
        });

        controllerBindsButton = new TextButton("Controller Key Bindings", skin);
        controllerBindsButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                ControllerBindsDialog dialog = new ControllerBindsDialog(skin);
                dialog.show(stage);
            }
        });

        // Add audio settings to options table
        optionsTable.add(keyBindsButton).width(BUTTON_WIDTH).height(BUTTON_HEIGHT).padTop(20).row();
        optionsTable.add(controllerBindsButton).width(BUTTON_WIDTH).height(BUTTON_HEIGHT).padTop(10).row();
        optionsTable.add(musicLabel).left().padBottom(10).row();
        optionsTable.add(musicSlider).width(200).padBottom(5).row();
        optionsTable.add(musicEnabled).left().padBottom(20).row();
        optionsTable.add(soundLabel).left().padBottom(10).row();
        optionsTable.add(soundSlider).width(200).padBottom(5).row();
        optionsTable.add(soundEnabled).left().padBottom(20).row();

        // Save and Cancel buttons for options
        TextButton saveButton = new TextButton("Save", skin);
        saveButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                saveAudioSettings();
                hideOptions();
            }
        });
        TextButton cancelButton = new TextButton("Cancel", skin);
        cancelButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                hideOptions();
            }
        });
        optionsTable.add(saveButton).width(BUTTON_WIDTH).height(BUTTON_HEIGHT).padTop(10).row();
        optionsTable.add(cancelButton).width(BUTTON_WIDTH).height(BUTTON_HEIGHT).padTop(10).row();

        optionsWindow.add(optionsTable);
        optionsWindow.pack();
        optionsWindow.setPosition((Gdx.graphics.getWidth() - optionsWindow.getWidth()) / 2,
            (Gdx.graphics.getHeight() - optionsWindow.getHeight()) / 2);
        optionsWindow.setVisible(false);
        stage.addActor(optionsWindow);
    }

    private void setupAudioListeners() {
        musicSlider.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                AudioManager.getInstance().setMusicVolume(musicSlider.getValue());
            }
        });

        musicEnabled.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                AudioManager.getInstance().setMusicEnabled(musicEnabled.isChecked());
            }
        });

        soundSlider.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                AudioManager.getInstance().setSoundVolume(soundSlider.getValue());
                if (soundEnabled.isChecked()) {
                    AudioManager.getInstance().playSound(AudioManager.SoundEffect.MENU_SELECT);
                }
            }
        });

        soundEnabled.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                AudioManager.getInstance().setSoundEnabled(soundEnabled.isChecked());
            }
        });
    }

    private void setupSaveButton(Table optionsTable) {
        TextButton saveButton = new TextButton("Save", skin);
        saveButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                saveAudioSettings();
                hideOptions();
            }
        });
        optionsTable.add(saveButton).width(BUTTON_WIDTH).height(BUTTON_HEIGHT).padTop(10).row();
    }

    private void setupCancelButton(Table optionsTable) {
        TextButton cancelButton = new TextButton("Cancel", skin);
        cancelButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                hideOptions();
            }
        });
        optionsTable.add(cancelButton).width(BUTTON_WIDTH).height(BUTTON_HEIGHT).padTop(10).row();
    }

    private void saveAudioSettings() {
        Preferences prefs = Gdx.app.getPreferences("audio_settings");
        prefs.putFloat("music_volume", musicSlider.getValue());
        prefs.putFloat("sound_volume", soundSlider.getValue());
        prefs.putBoolean("music_enabled", musicEnabled.isChecked());
        prefs.putBoolean("sound_enabled", soundEnabled.isChecked());
        prefs.flush();

        Dialog dialog = new Dialog("Settings Saved", skin) {
            public void result(Object obj) {
                hide();
            }
        };
        dialog.text("Settings have been saved.");
        dialog.button("OK");
        dialog.show(stage);
    }

    private void showOptions() {
        menuWindow.setVisible(false);
        optionsWindow.setVisible(true);
        musicSlider.setValue(AudioManager.getInstance().getMusicVolume());
        soundSlider.setValue(AudioManager.getInstance().getSoundVolume());
        musicEnabled.setChecked(AudioManager.getInstance().isMusicEnabled());
        soundEnabled.setChecked(AudioManager.getInstance().isSoundEnabled());
    }

    private void hideOptions() {
        optionsWindow.setVisible(false);
        menuWindow.setVisible(true);
    }

    public void render() {
        if (!isDisposing && isVisible && stage != null) {
            try {
                stage.act();
                stage.draw();
            } catch (Exception e) {
                GameLogger.error("Error rendering menu: " + e.getMessage());
            }
        }
    }

    public void dispose() {
        if (isDisposing) {
            return;
        }

        isDisposing = true;
        if (stage != null) {
            Gdx.app.postRunnable(() -> {
                try {
                    if (stage != null) {
                        stage.clear();
                        stage.dispose();
                        stage = null;
                    }
                    skin = null;
                    menuWindow = null;
                    optionsWindow = null;
                    menuTable = null;
                    GameLogger.info("GameMenu disposed successfully");
                } catch (Exception e) {
                    GameLogger.error("Error disposing GameMenu: " + e.getMessage());
                }
            });
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/HotbarSlot.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.Touchable;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.utils.textures.TextureManager;

public class HotbarSlot extends Stack {
    private static final float SLOT_SIZE = 40f;
    private final Table content;
    private final Image background;
    private final Label countLabel;
    private final Skin skin;

    public HotbarSlot(boolean selected, Skin skin) {
        this.skin = skin;
        // Get the background region based on selection.
        TextureRegion bgRegion = TextureManager.ui.findRegion(
            selected ? "slot_selected" : "slot_normal"
        );
        background = new Image(bgRegion);
        addActor(background);

        content = new Table();
        content.setFillParent(true);
        addActor(content);

        Label.LabelStyle labelStyle = new Label.LabelStyle(skin.getFont("default-font"), Color.WHITE);
        countLabel = new Label("", labelStyle);
        countLabel.setVisible(false);
        countLabel.setFontScale(0.8f);

        setSize(SLOT_SIZE, SLOT_SIZE);
        setTouchable(Touchable.enabled);
    }

    public void setItem(ItemData item) {
        content.clear();
        if (item == null) return;

        // Try to obtain the texture for the item.
        TextureRegion texture = TextureManager.items.findRegion(item.getItemId().toLowerCase() + "_item");
        if (texture == null) {
            texture = TextureManager.items.findRegion(item.getItemId().toLowerCase());
        }
        if (texture != null) {
            Image itemImage = new Image(texture);
            content.add(itemImage).size(32).expand().center();
            if (item.getCount() > 1) {
                countLabel.setText(String.valueOf(item.getCount()));
                countLabel.setVisible(true);
                content.add(countLabel).expand().bottom().right().pad(2);
            } else {
                countLabel.setVisible(false);
            }
        }
        content.invalidate();
    }

    public void clear() {
        content.clear();
        countLabel.setVisible(false);
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/HotbarSystem.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.Touchable;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

public class HotbarSystem {
    private static final int HOTBAR_SIZE = 9;
    private static final float SLOT_SIZE = 40f;
    private static final float VERTICAL_OFFSET = 30f;
    private final Table hotbarTable;
    private final Skin skin;
    private int selectedSlot = 0;

    public HotbarSystem(Stage stage, Skin skin) {
        GameLogger.info("Creating HotbarSystem with skin: " + skin);
        this.hotbarTable = new Table();
        this.skin = skin;

        // Create a container table for centered positioning at the bottom.
        Table containerTable = new Table();
        containerTable.setFillParent(true);
        containerTable.bottom().padBottom(VERTICAL_OFFSET);

        // Set a background for the hotbar if available.
        TextureRegion hotbarBg = TextureManager.ui.findRegion("hotbar_bg");
        if (hotbarBg == null) {
            GameLogger.error("Skin is missing region 'hotbar_bg'! Hotbar will not be visible.");
        } else {
            GameLogger.info("Found 'hotbar_bg' region.");
            hotbarTable.setBackground(new TextureRegionDrawable(hotbarBg));
        }
        containerTable.add(hotbarTable).center();
        stage.addActor(containerTable);

        updateHotbar();
    }

    public Table getHotbarTable() {
        return hotbarTable;
    }

    public void updateHotbar() {
        hotbarTable.clear();
        // Loop through each hotbar slot.
        for (int i = 0; i < HOTBAR_SIZE; i++) {
            final int slotIndex = i;
            // Create a new HotbarSlot.
            HotbarSlot slot = new HotbarSlot(i == selectedSlot, skin);

            // Set item data if available.
            ItemData item = GameContext.get().getPlayer().getInventory().getItemAt(i);
            if (item != null) {
                slot.setItem(item);
            }

            // Wrap the slot in a container so that its touch area is well defined.
            Container<HotbarSlot> slotContainer = new Container<HotbarSlot>(slot);
            slotContainer.setTouchable(Touchable.enabled);
            // Add a ClickListener to the container.
            slotContainer.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    setSelectedSlot(slotIndex);
                }
            });

            hotbarTable.add(slotContainer).pad(5);
        }
    }

    public void setSelectedSlot(int slot) {
        if (slot >= 0 && slot < HOTBAR_SIZE) {
            selectedSlot = slot;
            updateHotbar();
        }
    }

    public int getSelectedSlot() {
        return selectedSlot;
    }

    public ItemData getSelectedItem() {
        return GameContext.get().getPlayer().getInventory().getItemAt(selectedSlot);
    }

    public void resize(int width, int height) {
        float yPosition = 10f;
        hotbarTable.setPosition(width / 2f - (HOTBAR_SIZE * SLOT_SIZE) / 2f, yPosition);
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/InventorySlotUI.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.*;
import com.badlogic.gdx.utils.Align;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.screens.InventoryScreenInterface;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingSystem;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventoryLock;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotDataObserver;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.InventoryConverter;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.UUID;

public class InventorySlotUI extends Table implements InventorySlotDataObserver {
    public static final int ITEM_SIZE = 32;
    private static final float DURABILITY_BAR_HEIGHT = 4f;
    private static final float DURABILITY_BAR_PADDING = 2f;
    // Use an instance variable for slot size so that it can be set dynamically.
    private final int slotSize;
    private final InventorySlotData slotData;
    private final Skin skin;
    private final InventoryScreenInterface screenInterface;
    private Image itemImage;
    private Label countLabel;
    private Label itemNameLabel;
    private Label durabilityLabel;
    private Image durabilityBar;

    public InventorySlotUI(InventorySlotData slotData, Skin skin, InventoryScreenInterface screenInterface, int slotSize) {
        this.slotData = slotData;
        this.skin = skin;
        this.screenInterface = screenInterface;
        this.slotSize = slotSize;

        // Set the initial look and input settings.
        setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_normal")));
        // Do not call setSize() here because the layout from the parent (Table) will control it.
        setTouchable(Touchable.enabled);

        // Build the UI: add contents, tooltips, observers, and input listeners.
        setupContents();
        setupTooltip();
        slotData.addObserver(this);
        updateSlot();
        setupInput();
    }

    @Override
    public Actor hit(float x, float y, boolean touchable) {
        if (x >= 0 && x < getWidth() && y >= 0 && y < getHeight()) {
            return this;
        }
        return null;
    }

    /**
     * Helper that routes changes to the slot either directly (for non-crafting slots)
     * or through the CraftingSystem (for crafting grid slots).
     */
    private void setSlotItem(ItemData itemData) {
        if (slotData.getSlotType() == InventorySlotData.SlotType.CRAFTING ||
            slotData.getSlotType() == InventorySlotData.SlotType.EXPANDED_CRAFTING) {
            screenInterface.getCraftingSystem().setItemInGrid(slotData.getSlotIndex(), itemData);
        } else {
            slotData.setItemData(itemData);
        }
    }

    public void forceUpdate() {
        updateSlot();
    }

    private void setupTooltip() {
        Table tooltipTable = new Table();
        tooltipTable.setBackground(skin.newDrawable("white", new Color(0, 0, 0, 0.7f)));
        tooltipTable.pad(5);

        Label.LabelStyle tooltipStyle = new Label.LabelStyle(skin.getFont("default-font"), Color.WHITE);

        itemNameLabel = new Label("", tooltipStyle);
        durabilityLabel = new Label("", tooltipStyle);

        tooltipTable.add(itemNameLabel).left().row();
        tooltipTable.add(durabilityLabel).left();

        Tooltip<Table> tooltip = new Tooltip<>(tooltipTable);
        TooltipManager tooltipManager = TooltipManager.getInstance();
        tooltipManager.initialTime = 0f;
        tooltipManager.subsequentTime = 0f;
        addListener(tooltip);
    }

    public void updateSlot() {
        // For crafting-result slots, we retrieve the result from the crafting system.
        ItemData itemData = getSlotItemData();
        if (slotData.getSlotType() == InventorySlotData.SlotType.CRAFTING_RESULT) {
            CraftingSystem cs = screenInterface.getCraftingSystem();
            itemData = cs != null ? cs.getCraftingResult() : null;
        }

        if (itemData != null && itemData.getCount() > 0) {
            TextureRegion itemTexture = getItemTexture(itemData.getItemId());
            if (itemTexture != null) {
                itemImage.setDrawable(new TextureRegionDrawable(itemTexture));
                itemImage.setVisible(true);

                if (itemData.getCount() > 1) {
                    countLabel.setText(String.valueOf(itemData.getCount()));
                    countLabel.setVisible(true);
                } else {
                    countLabel.setVisible(false);
                }

                if (itemData.getMaxDurability() > 0) {
                    float percentage = itemData.getDurabilityPercentage();
                    percentage = Math.max(0f, Math.min(1f, percentage));
                    durabilityBar.setColor(getDurabilityColor(percentage));
                    float barWidth = (slotSize - DURABILITY_BAR_PADDING * 2) * percentage;
                    durabilityBar.setSize(barWidth, DURABILITY_BAR_HEIGHT);
                    durabilityBar.setPosition(DURABILITY_BAR_PADDING, DURABILITY_BAR_PADDING);
                    durabilityBar.setVisible(true);
                } else {
                    durabilityBar.setVisible(false);
                }
            } else {
                // If the texture is missing, hide the image and labels.
                itemImage.setVisible(false);
                countLabel.setVisible(false);
                durabilityBar.setVisible(false);
            }
        } else {
            itemImage.setVisible(false);
            countLabel.setVisible(false);
            durabilityBar.setVisible(false);
        }

        updateTooltip();
    }

    private void setupContents() {
        itemImage = new Image();
        itemImage.setSize(ITEM_SIZE, ITEM_SIZE);
        itemImage.setVisible(false);

        countLabel = new Label("", skin);
        countLabel.setAlignment(Align.bottomRight);
        countLabel.setVisible(false);

        durabilityBar = new Image(skin.newDrawable("white"));
        durabilityBar.setVisible(false);
        durabilityBar.setSize(0, DURABILITY_BAR_HEIGHT);

        Container<Image> durabilityContainer = new Container<>(durabilityBar);
        durabilityContainer.align(Align.bottomLeft);
        durabilityContainer.pad(DURABILITY_BAR_PADDING);
        durabilityContainer.setTouchable(Touchable.disabled);
        durabilityContainer.setFillParent(false);

        Stack stack = new Stack();
        stack.setSize(slotSize, slotSize);
        stack.add(itemImage);
        stack.add(durabilityContainer);
        stack.add(countLabel);

        // Let the parent layout (Table cell) control the final size.
        add(stack).expand().fill().size(slotSize, slotSize);
    }

    @Override
    public void onSlotDataChanged() {
        updateSlot();
    }

    private void updateTooltip() {
        ItemData itemData = getSlotItemData();
        if (itemData != null) {
            itemNameLabel.setText(itemData.getItemId());
            if (itemData.getMaxDurability() > 0) {
                durabilityLabel.setText("Durability: " +
                    itemData.getDurability() + "/" +
                    itemData.getMaxDurability());
                durabilityLabel.setVisible(true);
            } else {
                durabilityLabel.setVisible(false);
            }
        } else {
            itemNameLabel.setText("");
            durabilityLabel.setVisible(false);
        }
    }

    private TextureRegion getItemTexture(String itemId) {
        TextureRegion texture = TextureManager.items.findRegion(itemId.toLowerCase() + "_item");
        if (texture == null) {
            texture = TextureManager.items.findRegion(itemId.toLowerCase());
        }
        return texture;
    }

    private void setupInput() {
        addListener(new InputListener() {
            private boolean isHovered = false;
            private Vector2 touchDownPos = new Vector2();
            private long touchDownTime;

            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
                touchDownPos.set(x, y);
                touchDownTime = System.currentTimeMillis();
                setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_selected")));
                return true;
            }

            @Override
            public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
                float moveDistance = touchDownPos.dst(x, y);
                long clickDuration = System.currentTimeMillis() - touchDownTime;

                if (moveDistance < 5 && clickDuration < 200) {
                    boolean shiftHeld = isShiftDown();
                    if (button == Input.Buttons.LEFT) {
                        handleLeftClick(shiftHeld);
                    } else if (button == Input.Buttons.RIGHT) {
                        handleRightClick();
                    }
                }
                updateSlotBackground();
            }

            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                isHovered = true;
                updateSlotBackground();
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                isHovered = false;
                updateSlotBackground();
            }

            private void updateSlotBackground() {
                if (isHovered) {
                    setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_selected")));
                } else {
                    setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_normal")));
                }
            }
        });
    }

    private boolean isShiftDown() {
        return Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT);
    }

    // --- Click Handling Methods (unchanged logic) ---

    private void handleLeftClick(boolean shiftHeld) {
        InventoryLock.writeLock();
        try {
            Item heldItem = screenInterface.getHeldItemObject();
            ItemData currentSlotItem = getSlotItemData();
            InventorySlotData.SlotType slotType = slotData.getSlotType();

            if (slotType == InventorySlotData.SlotType.CRAFTING_RESULT) {
                handleCraftingResultClick(shiftHeld);
                return;
            }

            if (shiftHeld && currentSlotItem != null) {
                handleShiftClickMove(currentSlotItem);
                return;
            }

            if (currentSlotItem == null && heldItem != null) {
                // Place the entire held stack into an empty slot.
                placeStackIntoEmptySlot(heldItem, slotType, heldItem.getCount());
            } else if (currentSlotItem != null && heldItem == null) {
                pickUpEntireStack(currentSlotItem, slotType);
            } else if (currentSlotItem != null && heldItem != null) {
                if (canStackTogether(currentSlotItem, heldItem)) {
                    mergeStacks(currentSlotItem, heldItem, slotType);
                } else {
                    swapItems(currentSlotItem, heldItem, slotType);
                }
            }
        } catch (Exception e) {
            GameLogger.error("Error in handleLeftClick: " + e.getMessage());
            e.printStackTrace();
        } finally {
            InventoryLock.writeUnlock();
            updateSlot();
            screenInterface.updateHeldItemDisplay();
            if (slotData.getSlotType() == InventorySlotData.SlotType.CHEST) {
                GameContext.get().getGameClient().sendChestUpdate(screenInterface.getChestData());
            }
        }
    }

    private void handleRightClick() {
        InventoryLock.writeLock();
        try {
            Item heldItem = screenInterface.getHeldItemObject();
            ItemData currentSlotItem = getSlotItemData();
            InventorySlotData.SlotType slotType = slotData.getSlotType();

            if (slotType == InventorySlotData.SlotType.CRAFTING_RESULT) {
                pickUpOneCraftedItem();
            } else if (currentSlotItem == null && heldItem != null) {
                // Place one item from the held stack into an empty slot.
                placeStackIntoEmptySlot(heldItem, slotType, 1);
            } else if (currentSlotItem != null && heldItem == null) {
                pickUpHalfStack(currentSlotItem, slotType);
            } else if (currentSlotItem != null && heldItem != null && canStackTogether(currentSlotItem, heldItem)) {
                addOneItemToSlot(currentSlotItem, heldItem, slotType);
            }
        } catch (Exception e) {
            GameLogger.error("Error in handleRightClick: " + e.getMessage());
            e.printStackTrace();
        } finally {
            InventoryLock.writeUnlock();
            updateSlot();
            screenInterface.updateHeldItemDisplay();
            if (slotData.getSlotType() == InventorySlotData.SlotType.CHEST) {
                GameContext.get().getGameClient().sendChestUpdate(screenInterface.getChestData());
            }
        }
    }

    /**
     * [FIXED] Handles crafting one item and putting it on the cursor.
     */
    private void pickUpOneCraftedItem() {
        CraftingSystem cs = screenInterface.getCraftingSystem();
        if (cs == null) return;

        ItemData craftableResult = cs.getCraftingResult();
        if (craftableResult == null) return;

        Item heldItem = screenInterface.getHeldItemObject();

        if (heldItem == null) {
            // Cursor is empty, craft one and put it on the cursor.
            ItemData craftedItemData = cs.craftAndConsume();
            if (craftedItemData != null) {
                Item newItem = InventoryConverter.itemDataToItem(craftedItemData);
                screenInterface.setHeldItem(newItem);
            }
        } else {
            // Cursor has an item, check if we can stack.
            if (heldItem.getName().equals(craftableResult.getItemId()) && heldItem.isStackable()) {
                int potentialNewCount = heldItem.getCount() + craftableResult.getCount();
                if (potentialNewCount <= Item.MAX_STACK_SIZE) {
                    ItemData craftedItemData = cs.craftAndConsume();
                    if (craftedItemData != null) {
                        heldItem.setCount(potentialNewCount);
                        screenInterface.setHeldItem(heldItem); // Update held item view
                    }
                }
                // If it would over-stack, do nothing.
            }
        }
    }


    private void handleShiftClickMove(ItemData currentSlotItem) {
        InventorySlotData.SlotType slotType = slotData.getSlotType();
        if (currentSlotItem == null) return;

        if (slotType == InventorySlotData.SlotType.CHEST) {
            int remainder = fullyTryAddItem(screenInterface.getInventory(), currentSlotItem);
            if (remainder <= 0) {
                setSlotItem(null);
            } else {
                currentSlotItem.setCount(remainder);
                setSlotItem(currentSlotItem);
            }
        } else if (slotType == InventorySlotData.SlotType.INVENTORY) {
            ItemContainer chest = screenInterface.getChestData();
            if (chest == null) return;

            int remainder = fullyTryAddItem(chest, currentSlotItem);
            if (remainder <= 0) {
                setSlotItem(null);
            } else {
                currentSlotItem.setCount(remainder);
                setSlotItem(currentSlotItem);
            }
        } else if (slotType == InventorySlotData.SlotType.CRAFTING_RESULT) {
            handleMassCraftToInventory();
        }

        updateSlot();
        screenInterface.updateHeldItemDisplay();
        if (slotData.getSlotType() == InventorySlotData.SlotType.CHEST) {
            GameContext.get().getGameClient().sendChestUpdate(screenInterface.getChestData());
        }
    }

    /**
     * [FIXED] Handles crafting as many items as possible and moving them to the inventory.
     */
    private void handleMassCraftToInventory() {
        CraftingSystem cs = screenInterface.getCraftingSystem();
        if (cs == null) return;

        int maxCrafts = cs.calculateMaxCrafts();
        if (maxCrafts == 0) return;

        ItemData craftableResult = cs.getCraftingResult();
        if (craftableResult == null) return;

        for (int i = 0; i < maxCrafts; i++) {
            // Before each craft, check if the inventory has space.
            if (screenInterface.getInventory().hasSpaceFor(craftableResult)) {
                ItemData craftedItem = cs.craftAndConsume(); // This now returns the crafted item.
                if (craftedItem != null) {
                    // Add the item directly to the inventory.
                    screenInterface.getInventory().addItem(craftedItem);
                } else {
                    // Stop if crafting fails for any reason.
                    break;
                }
            } else {
                // Stop if there's no more space.
                break;
            }
        }
    }

    private void moveAllToInventory(ItemData itemData) {
        if (itemData == null) return;
        int remaining = addItemToContainer(screenInterface.getInventory(), itemData);
        if (remaining <= 0) {
            setSlotItem(null);
        } else {
            itemData.setCount(remaining);
            setSlotItem(itemData);
        }
    }

    private int addItemToContainer(ItemContainer container, ItemData itemData) {
        if (container instanceof Inventory) {
            Inventory inv = (Inventory) container;
            int originalCount = itemData.getCount();
            ItemData copy = itemData.copy();
            if (inv.addItem(copy)) {
                return 0;
            } else {
                return originalCount;
            }
        }
        return itemData.getCount();
    }

    private boolean canStackTogether(ItemData slotItem, Item heldItem) {
        if (!slotItem.getItemId().equals(heldItem.getName())) return false;
        Item template = ItemManager.getItemTemplate(heldItem.getName());
        return template != null && template.isStackable();
    }

    private void placeStackIntoEmptySlot(Item heldItem, InventorySlotData.SlotType slotType, int amount) {
        if (heldItem == null || heldItem.getCount() < amount) {
            return;
        }

        ItemData currentItem = slotData.getItemData();
        if (currentItem != null && currentItem.getCount() > 0) {
            return;
        }

        ItemData newItem = new ItemData(heldItem.getName(), amount, UUID.randomUUID());
        newItem.setDurability(heldItem.getDurability());
        newItem.setMaxDurability(heldItem.getMaxDurability());

        setSlotItem(newItem);

        int newCount = heldItem.getCount() - amount;
        if (newCount <= 0) {
            screenInterface.setHeldItem(null);
        } else {
            heldItem.setCount(newCount);
            screenInterface.setHeldItem(heldItem);
        }

        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }

    private void pickUpEntireStack(ItemData currentSlotItem, InventorySlotData.SlotType slotType) {
        if (currentSlotItem == null) return;
        setSlotItem(null);

        Item newHeld = new Item(currentSlotItem.getItemId());
        newHeld.setCount(currentSlotItem.getCount());
        newHeld.setDurability(currentSlotItem.getDurability());
        newHeld.setMaxDurability(currentSlotItem.getMaxDurability());
        newHeld.setUuid(UUID.randomUUID());

        screenInterface.setHeldItem(newHeld);
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }

    private int tryMergeItemData(ItemContainer container, ItemData itemToMove) {
        int remainder = itemToMove.getCount();

        for (int i = 0; i < container.getSize(); i++) {
            InventorySlotData slotData = container.getSlotData(i);
            ItemData slotItem = slotData.getItemData();
            if (slotItem != null
                && slotItem.getItemId().equals(itemToMove.getItemId())
                && slotItem.getCount() < Item.MAX_STACK_SIZE) {

                int space = Item.MAX_STACK_SIZE - slotItem.getCount();
                int toMove = Math.min(remainder, space);
                slotItem.setCount(slotItem.getCount() + toMove);
                slotData.setItemData(slotItem);
                remainder -= toMove;
                if (remainder <= 0) break;
            }
        }

        return remainder;
    }

    private int tryPlaceInEmptySlot(ItemContainer container, ItemData itemToMove) {
        int remainder = itemToMove.getCount();

        for (int i = 0; i < container.getSize(); i++) {
            InventorySlotData slotData = container.getSlotData(i);
            if (slotData.getItemData() == null) {
                int toPlace = Math.min(remainder, Item.MAX_STACK_SIZE);
                ItemData newData = itemToMove.copy();
                newData.setCount(toPlace);
                slotData.setItemData(newData);
                remainder -= toPlace;
                if (remainder <= 0) break;
            }
        }

        return remainder;
    }

    private int fullyTryAddItem(ItemContainer container, ItemData itemData) {
        int remainder = tryMergeItemData(container, itemData);

        if (remainder > 0) {
            ItemData remainderData = itemData.copy();
            remainderData.setCount(remainder);
            remainder = tryPlaceInEmptySlot(container, remainderData);
        }
        return remainder;
    }

    private void mergeStacks(ItemData currentSlotItem, Item heldItem, InventorySlotData.SlotType slotType) {
        int maxStack = Item.MAX_STACK_SIZE;
        int total = currentSlotItem.getCount() + heldItem.getCount();
        int newSlotCount = Math.min(total, maxStack);
        int remainder = total - newSlotCount;

        ItemData updated = currentSlotItem.copy();
        updated.setCount(newSlotCount);
        setSlotItem(updated);

        if (remainder <= 0) {
            screenInterface.setHeldItem(null);
        } else {
            heldItem.setCount(remainder);
            screenInterface.setHeldItem(heldItem);
        }

        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }

    private void swapItems(ItemData currentSlotItem, Item heldItem, InventorySlotData.SlotType slotType) {
        ItemData slotNew = new ItemData(heldItem.getName(), heldItem.getCount(), UUID.randomUUID());
        slotNew.setDurability(heldItem.getDurability());
        slotNew.setMaxDurability(heldItem.getMaxDurability());
        setSlotItem(slotNew);

        Item newHeld = new Item(currentSlotItem.getItemId());
        newHeld.setCount(currentSlotItem.getCount());
        newHeld.setUuid(UUID.randomUUID());
        newHeld.setDurability(currentSlotItem.getDurability());
        newHeld.setMaxDurability(currentSlotItem.getMaxDurability());
        screenInterface.setHeldItem(newHeld);

        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }

    private void pickUpHalfStack(ItemData currentSlotItem, InventorySlotData.SlotType slotType) {
        if (currentSlotItem == null) return;
        int half = (currentSlotItem.getCount() + 1) / 2;
        int remain = currentSlotItem.getCount() - half;

        ItemData updated = currentSlotItem.copy();
        updated.setCount(remain <= 0 ? 0 : remain);
        setSlotItem(remain <= 0 ? null : updated);

        Item newHeld = new Item(currentSlotItem.getItemId());
        newHeld.setCount(half);
        newHeld.setDurability(currentSlotItem.getDurability());
        newHeld.setMaxDurability(currentSlotItem.getMaxDurability());
        newHeld.setUuid(UUID.randomUUID());
        screenInterface.setHeldItem(newHeld);

        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }

    private void addOneItemToSlot(ItemData currentSlotItem, Item heldItem, InventorySlotData.SlotType slotType) {
        if (currentSlotItem.getCount() >= Item.MAX_STACK_SIZE) return;

        ItemData updated = currentSlotItem.copy();
        updated.setCount(currentSlotItem.getCount() + 1);
        setSlotItem(updated);

        int newHeldCount = heldItem.getCount() - 1;
        if (newHeldCount <= 0) {
            screenInterface.setHeldItem(null);
        } else {
            heldItem.setCount(newHeldCount);
            screenInterface.setHeldItem(heldItem);
        }

        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }

    /**
     * [FIXED] Handles both single and mass crafting from the result slot.
     */
    private void handleCraftingResultClick(boolean shiftHeld) {
        CraftingSystem cs = screenInterface.getCraftingSystem();
        if (cs == null) return;

        if (shiftHeld) {
            handleMassCraftToInventory();
        } else {
            pickUpOneCraftedItem();
        }
    }


    private ItemData getSlotItemData() {
        InventorySlotData.SlotType type = slotData.getSlotType();
        if (type == InventorySlotData.SlotType.CRAFTING ||
            type == InventorySlotData.SlotType.EXPANDED_CRAFTING) {
            CraftingSystem cs = screenInterface.getCraftingSystem();
            return cs != null ? cs.getItemInGrid(slotData.getSlotIndex()) : null;
        } else if (type == InventorySlotData.SlotType.CRAFTING_RESULT) {
            return null;
        } else {
            return slotData.getItemData();
        }
    }

    private Color getDurabilityColor(float percentage) {
        if (percentage > 0.6f) {
            return new Color(0.2f, 0.8f, 0.2f, 1f);
        } else if (percentage > 0.3f) {
            return new Color(0.8f, 0.8f, 0.2f, 1f);
        } else {
            return new Color(0.8f, 0.2f, 0.2f, 1f);
        }
    }

    @Override
    public void draw(Batch batch, float parentAlpha) {
        super.draw(batch, parentAlpha);
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/PokemonPartyWindow.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.utils.Scaling;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.PokemonParty;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.ArrayList;
import java.util.List;

import static com.badlogic.gdx.scenes.scene2d.actions.Actions.hide;

public class PokemonPartyWindow extends Window {
    private final PokemonParty party;
    private final boolean battleMode;
    private final PartySelectionListener selectionListener;
    private final Runnable cancelCallback;

    private Table contentTable;
    private int currentPokemonIndex = -1; // Index of the Pokemon currently in battle
    private ArrayList<PokemonSlot> pokemonSlots = new ArrayList<>();

    // For swapping in non–battle mode
    private int selectedIndex = -1;
    private PokemonSlot selectedSlot = null;
    private ScrollPane scrollPane;

    public PokemonPartyWindow(
        Skin skin,
        PokemonParty party,
        boolean battleMode,
        PartySelectionListener selectionListener,
        Runnable cancelCallback) {

        super("", skin);
        this.party = party;
        this.battleMode = battleMode;
        this.selectionListener = selectionListener;
        this.cancelCallback = cancelCallback;

        // Do not call getStage() here because this actor isn’t on a stage yet.
        setModal(true);
        setMovable(false);
        if (battleMode && GameContext.get().getBattleTable() != null) {
            Pokemon activePokemon = GameContext.get().getBattleTable().getPlayerPokemon(); // Assuming BattleTable has getPlayerPokemon()
            if (activePokemon != null) {
                List<Pokemon> partyList = party.getParty();
                for (int i = 0; i < partyList.size(); i++) {
                    if (partyList.get(i) == activePokemon) {
                        currentPokemonIndex = i;
                        break;
                    }
                }
            }
        }
        initialize();
    }

    /**
     * Tints the progress bar's background to a neutral grey and the fill portion
     * (knobBefore) to green/yellow/red based on HP percentage.
     */
    private static void updateHPBarColor(ProgressBar bar, float percentage, Skin skin) {
        // Clone the default progress bar style
        ProgressBar.ProgressBarStyle baseStyle = skin.get("default-horizontal", ProgressBar.ProgressBarStyle.class);
        ProgressBar.ProgressBarStyle newStyle = new ProgressBar.ProgressBarStyle(baseStyle);

        // 1) Tint the background to a neutral grey
        if (baseStyle.background instanceof TextureRegionDrawable) {
            TextureRegionDrawable bg = new TextureRegionDrawable(((TextureRegionDrawable) baseStyle.background).getRegion());
            bg.tint(new Color(0.35f, 0.35f, 0.35f, 1f));
            newStyle.background = bg;
        }

        // 2) Tint the fill portion (knobBefore) based on HP
        if (baseStyle.knobBefore instanceof TextureRegionDrawable) {
            TextureRegionDrawable fill = new TextureRegionDrawable(((TextureRegionDrawable) baseStyle.knobBefore).getRegion());
            if (percentage > 0.5f) {
                fill.tint(skin.getColor("green"));
            } else if (percentage > 0.2f) {
                fill.tint(Color.YELLOW);
            } else {
                fill.tint(skin.getColor("red"));
            }
            newStyle.knobBefore = fill;
        }

        // Optionally hide the knob itself (if you want a smoother bar)
        newStyle.knob = null;

        bar.setStyle(newStyle);
    }

    /**
     * Resizes/positions the window to about 70% of the screen width and 50% height, then centers it.
     */
    public void show(Stage stage) {
        // First, let the window pack to fit all content exactly
        pack();

        // Now clamp it so it does not exceed 70% of width or 50% of height
        float maxW = stage.getWidth() * 0.70f;
        float maxH = stage.getHeight() * 0.50f;
        if (getWidth() > maxW) setWidth(maxW);
        if (getHeight() > maxH) setHeight(maxH);

        // Center the window
        setPosition(
            (stage.getWidth() - getWidth()) / 2f,
            (stage.getHeight() - getHeight()) / 2f
        );

        layout();
        addAction(Actions.fadeIn(0.3f));
    }

    public void updateSlots() {
        rebuildSlots();
    }

    private void initialize() {
        Table rootTable = new Table();
        rootTable.setFillParent(true);

        // Create the main content table
        contentTable = new Table();
        contentTable.pad(10);

        // Put that table inside a scroll pane
        scrollPane = new ScrollPane(contentTable, getSkin());
        scrollPane.setFadeScrollBars(false);
        scrollPane.setScrollingDisabled(false, false);

        // Main content area (scrollable)
        rootTable.add(scrollPane).expand().fill().row();

        // If there's a cancel callback, show a "Cancel" button. Otherwise, no button.
        if (cancelCallback != null) {
            TextButton cancelButton = new TextButton("Cancel", getSkin());
            cancelButton.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    cancelCallback.run();
                    addAction(Actions.sequence(hide(), Actions.removeActor()));
                }
            });
            rootTable.add(cancelButton).expandX().center().padTop(8);
        }

        add(rootTable).expand().fill();

        getColor().a = 0;
        addAction(Actions.sequence(
            Actions.fadeIn(0.3f),
            Actions.run(() -> AudioManager.getInstance().playSound(AudioManager.SoundEffect.MENU_SELECT))
        ));

        rebuildSlots();
    }

    private void rebuildSlots() {
        contentTable.clearChildren();

        Label title = new Label(battleMode ? "Choose Pokémon" : "Pokémon Party", getSkin());
        title.setFontScale(1.2f);
        contentTable.add(title).expandX().center().pad(10).row();

        pokemonSlots.clear();
        List<Pokemon> partyList = party.getParty();
        for (int i = 0; i < partyList.size(); i++) {
            Pokemon pokemon = partyList.get(i);
            final int slotIndex = i;

            // Pass index and battle mode to the slot
            PokemonSlot slot = new PokemonSlot(this, pokemon, getSkin(), battleMode, slotIndex, i == currentPokemonIndex); // NEW: pass active status
            pokemonSlots.add(slot);

            // --- Updated Click Listener ---
            slot.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    if (selectionMade) return;

                    if (battleMode) {
                        // Prevent selecting fainted or current Pokemon in battle
                        if (pokemon.getCurrentHp() <= 0) {
                            // Optionally show a message "This Pokemon can't battle!"
                            // GameContext.get().getBattleTable().displayMessage(pokemon.getName() + " is unable to battle!");
                            return;
                        }
                        if (slotIndex == currentPokemonIndex) {
                            // Optionally show message "This Pokemon is already out!"
                            // GameContext.get().getBattleTable().displayMessage(pokemon.getName() + " is already in battle!");
                            return;
                        }

                        selectionMade = true;
                        // --- Pass INDEX back, not the Pokemon object ---
                        selectionListener.onPokemonSelected(slotIndex); // MODIFIED

                        PokemonPartyWindow.this.addAction(Actions.sequence(
                            Actions.fadeOut(0.3f),
                            Actions.run(PokemonPartyWindow.this::remove)
                        ));
                    } else {
                        // Non-battle mode swapping logic
                        handleSlotClick(slotIndex, slot);
                    }
                }
            });

            contentTable.add(slot).expandX().fillX().pad(5).row();
        }
    }

    private boolean selectionMade = false;


    /**
     * Swapping logic for non-battle mode.
     */
    private void handleSlotClick(int slotIndex, PokemonSlot slot) {
        if (selectedSlot == null) {
            selectedSlot = slot;
            selectedIndex = slotIndex;
            slot.setSelected(true);
        } else {
            if (selectedSlot == slot) {
                slot.setSelected(false);
                selectedSlot = null;
                selectedIndex = -1;
                return;
            }
            party.swapPositions(selectedIndex, slotIndex);
            selectedSlot.setSelected(false);
            selectedSlot = null;
            selectedIndex = -1;
            rebuildSlots();
            // If you have a GameScreen that displays your party, update it
            GameContext.get().getGameScreen().updatePartyDisplay();
        }
    }


    public interface PartySelectionListener {
        // Now accepts the index of the selected Pokemon
        void onPokemonSelected(int partyIndex); // MODIFIED
    }

    /**
     * Represents a single row (slot) in the party list.
     */
    private static class PokemonSlot extends Table {
        private final PokemonPartyWindow parentWindow;  // reference to the entire window
        private final Pokemon pokemon;
        private final Image icon;
        private final TextureRegion[] frames;
        private PokemonTooltip tooltip;
        private float animTime = 0f;
        private boolean isHovered = false;
        private boolean isSelected = false;

        private final boolean isActiveInBattle; // NEW field
        public PokemonSlot(PokemonPartyWindow parentWindow,
                           Pokemon pokemon,
                           Skin skin,
                           boolean battleMode,
                           int slotIndex,
                           boolean isActive) { // NEW parameter

            super(skin);
            this.parentWindow = parentWindow;  // store reference
            this.pokemon = pokemon;

            this.isActiveInBattle = isActive; // Store active status
            // Fallback if the icon is null
            TextureRegion fullIcon = pokemon.getIconSprite();
            if (fullIcon == null) {
                fullIcon = new TextureRegion(TextureManager.getWhitePixel());
            }
            frames = new TextureRegion[2];
            if (fullIcon.getRegionWidth() == 128 && fullIcon.getRegionHeight() == 64) {
                frames[0] = new TextureRegion(fullIcon, 0, 0, 64, 64);
                frames[1] = new TextureRegion(fullIcon, 64, 0, 64, 64);
            } else {
                frames[0] = fullIcon;
                frames[1] = fullIcon;
            }

            icon = new Image(new TextureRegionDrawable(frames[0]));
            icon.setScaling(Scaling.fit);

            // Build info table
            Table infoTable = new Table();
            Label nameLabel = new Label(pokemon.getName(), skin);
            Label levelLabel = new Label("Lv." + pokemon.getLevel(), skin);
            ProgressBar hpBar = new ProgressBar(0, pokemon.getStats().getHp(), 1, false, skin);
            hpBar.setValue(pokemon.getCurrentHp());
            updateHPBarColor(hpBar, pokemon.getCurrentHp() / (float) pokemon.getStats().getHp(), skin);
            Label hpLabel = new Label(pokemon.getCurrentHp() + "/" + pokemon.getStats().getHp(), skin);

            infoTable.add(nameLabel).left().padRight(10);
            infoTable.add(levelLabel).right().row();
            infoTable.add(hpBar).colspan(2).fillX().pad(2).row();
            infoTable.add(hpLabel).colspan(2).right().row();

            add(icon).width(Value.percentWidth(0.15f, this))
                .height(Value.percentWidth(0.15f, this))
                .padRight(10);
            add(infoTable).expand().fill().row();

            if (battleMode && (pokemon.getCurrentHp() <= 0 || isActiveInBattle)) {
                setColor(getColor().mul(0.6f));
                setTouchable(Touchable.disabled); // Make untappable
            } else {
                setTouchable(Touchable.enabled); // Ensure tappable otherwise
            }

            // Tooltip logic
            addListener(new InputListener() {
                @Override
                public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                    isHovered = true;
                    Stage currentStage = getStage();
                    if (tooltip == null && currentStage != null) {
                        tooltip = new PokemonTooltip(pokemon, skin);
                        currentStage.addActor(tooltip);
                        tooltip.toFront();
                        updateTooltipPosition(event.getStageX(), event.getStageY());
                    }
                }

                @Override
                public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                    isHovered = false;
                    removeTooltip();
                }

                @Override
                public boolean mouseMoved(InputEvent event, float x, float y) {
                    if (tooltip != null) {
                        updateTooltipPosition(event.getStageX(), event.getStageY());
                    }
                    return true;
                }
            });
        }

        public void setSelected(boolean selected) {
            isSelected = selected;
            if (selected) {
                addAction(Actions.scaleTo(1.08f, 1.08f, 0.2f));
                setBackground(new TextureRegionDrawable(TextureManager.getUi().findRegion("slot_selected")));
            } else {
                addAction(Actions.scaleTo(1f, 1f, 0.2f));
                setBackground(new TextureRegionDrawable(TextureManager.getUi().findRegion("slot_normal")));
            }
        }

        @Override
        public void act(float delta) {
            super.act(delta);
            // Simple animation logic to flip between frames if hovered or selected
            if (isHovered || isSelected) {
                animTime += delta;
                int index = (int) (animTime / 0.5f) % frames.length;
                if (frames[index] != null) {
                    icon.setDrawable(new TextureRegionDrawable(frames[index]));
                }
            } else {
                icon.setDrawable(new TextureRegionDrawable(frames[0]));
            }
        }

        private void updateTooltipPosition(float stageX, float stageY) {
            if (tooltip != null && getStage() != null) {
                float tooltipX = stageX + 15;
                float tooltipY = stageY - tooltip.getHeight();

                // Keep tooltip within stage bounds
                if (tooltipX + tooltip.getWidth() > getStage().getWidth()) {
                    tooltipX = stageX - tooltip.getWidth() - 15;
                }
                if (tooltipY < 0) {
                    tooltipY = stageY + 15;
                }

                tooltip.setPosition(tooltipX, tooltipY);
            }
        }

        private void removeTooltip() {
            if (tooltip != null) {
                tooltip.remove();
                tooltip = null;
            }
        }
    }

    /**
     * Tooltip window for a Pokémon.
     * It is made non-interactive so it does not capture input.
     */
    private static class PokemonTooltip extends Window {
        public PokemonTooltip(Pokemon pokemon, Skin skin) {
            super("", skin);
            setBackground(createTooltipBackground());
            pad(12);
            setTouchable(Touchable.disabled);
            setVisible(true);
            setZIndex(1000);

            // Use a Table for content
            Table content = new Table();
            content.defaults().pad(4).left();

            // Pokémon name
            Label nameLabel = new Label(pokemon.getName(), skin);
            content.add(nameLabel).padBottom(8).row();

            // Nature
            content.add(new Label("Nature: " + pokemon.getNature(), skin)).row();

            // Stats header
            content.add(new Label("Stats:", skin)).padTop(8).row();

            // Stats table
            Table statsTable = new Table();
            statsTable.defaults().pad(2);
            Pokemon.Stats stats = pokemon.getStats();
            addStatRow(statsTable, "HP", stats.getHp(), skin);
            addStatRow(statsTable, "Attack", stats.getAttack(), skin);
            addStatRow(statsTable, "Defense", stats.getDefense(), skin);
            addStatRow(statsTable, "Sp. Atk", stats.getSpecialAttack(), skin);
            addStatRow(statsTable, "Sp. Def", stats.getSpecialDefense(), skin);
            addStatRow(statsTable, "Speed", stats.getSpeed(), skin);
            content.add(statsTable).padBottom(8).row();

            // Moves section
            content.add(new Label("Moves:", skin)).padTop(8).row();
            Table movesTable = new Table();
            movesTable.defaults().pad(2);
            for (Move move : pokemon.getMoves()) {
                Table moveRow = new Table();
                moveRow.add(new Label(move.getName(), skin)).expandX().left();
                moveRow.add(new Label("PP: " + move.getPp() + "/" + move.getMaxPp(), skin)).right();
                movesTable.add(moveRow).fillX().row();
            }
            content.add(movesTable).fillX();

            add(content);
            pack();

            // Fade in animation
            getColor().a = 0;
            addAction(Actions.fadeIn(0.2f));
        }

        @Override
        public void act(float delta) {
            super.act(delta);
            // Keep tooltip at front
            toFront();
        }

        private static Drawable createTooltipBackground() {
            Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
            pixmap.setColor(0, 0, 0, 0.85f);
            pixmap.fill();
            TextureRegionDrawable bg = new TextureRegionDrawable(new TextureRegion(new Texture(pixmap)));
            pixmap.dispose();
            return bg;
        }

        private void addStatRow(Table container, String statName, int value, Skin skin) {
            Table row = new Table();
            row.add(new Label(statName + ":", skin)).left().width(80);
            row.add(new Label(String.valueOf(value), skin)).left();
            container.add(row).fillX().row();
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/ServerManagementDialog.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;

import java.util.function.Consumer;


public class ServerManagementDialog extends Dialog {
    private final TextField nameField;
    private final TextField ipField;
    private final TextField tcpPortField;
    private final TextField udpPortField;
    private final ServerConnectionConfig editingServer;
    private final Consumer<ServerConnectionConfig> onSave;

    public ServerManagementDialog(Skin skin, ServerConnectionConfig editServer,
                                  Consumer<ServerConnectionConfig> onSave) {
        super("", skin);
        this.editingServer = editServer;
        this.onSave = onSave;

        Table content = new Table();
        content.pad(20);

        // Title
        content.add(new Label(editServer == null ? "Add Server" : "Edit Server",
            skin, "title")).colspan(2).pad(10).row();

        // Fields
        nameField = new TextField(editServer != null ? editServer.getServerName() : "", skin);
        ipField = new TextField(editServer != null ? editServer.getServerIP() : "", skin);
        tcpPortField = new TextField(editServer != null ?
            String.valueOf(editServer.getTcpPort()) : "", skin);
        udpPortField = new TextField(editServer != null ?
            String.valueOf(editServer.getUdpPort()) : "", skin);

        content.add(new Label("Server Name:", skin)).left().pad(5);
        content.add(nameField).width(200).pad(5).row();

        content.add(new Label("IP Address:", skin)).left().pad(5);
        content.add(ipField).width(200).pad(5).row();

        content.add(new Label("TCP Port:", skin)).left().pad(5);
        content.add(tcpPortField).width(200).pad(5).row();

        content.add(new Label("UDP Port:", skin)).left().pad(5);
        content.add(udpPortField).width(200).pad(5).row();

        // Buttons
        TextButton saveButton = new TextButton("Save", skin);
        TextButton cancelButton = new TextButton("Cancel", skin);

        Table buttons = new Table();
        buttons.add(saveButton).width(100).pad(10);
        buttons.add(cancelButton).width(100).pad(10);

        content.add(buttons).colspan(2).pad(20);

        // Event handlers
        saveButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                saveServer();
            }
        });

        cancelButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                hide();
            }
        });

        getContentTable().add(content);
    }

    private void saveServer() {
        try {
            // Validate input
            String name = nameField.getText().trim();
            String ip = ipField.getText().trim();
            int tcpPort = Integer.parseInt(tcpPortField.getText().trim());
            int udpPort = Integer.parseInt(udpPortField.getText().trim());

            if (name.isEmpty() || ip.isEmpty()) {
                throw new IllegalArgumentException("All fields are required");
            }

            // Create config
            ServerConnectionConfig config = new ServerConnectionConfig(
                ip, tcpPort, udpPort, name, false, 100
            );

            onSave.accept(config);
            hide();

        } catch (NumberFormatException e) {
            showError("Invalid port number");
        } catch (Exception e) {
            showError(e.getMessage());
        }
    }

    private void showError(String message) {
        Dialog error = new Dialog("Error", getSkin());
        error.text(message);
        error.button("OK");
        error.show(getStage());
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/otherui/StarterSelectionTable.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Touchable;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Scaling;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.data.PokemonDatabase;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.ResponsiveLayout;
import io.github.pokemeetup.utils.textures.TextureManager;

public class StarterSelectionTable extends Table {
    // Use a static instance variable to enforce one instance at a time.
    private static StarterSelectionTable instance = null;

    // UI elements and fields (non‑final so they can be initialized in every run)
    private Label pokemonInfoLabel;
    private TextButton confirmButton;
    private Pokemon selectedStarter;
    private Table selectedCell = null;
    private SelectionListener selectionListener;
    private boolean selectionMade = false;

    private Skin skin;
    private Label titleLabel;
    private Table starters;  // Container for starter options

    // Base constants for layout
    private static final float BASE_TITLE_SCALE = 2.0f;
    private static final float BASE_PADDING = 20f;
    private static final float BASE_BUTTON_WIDTH = 300f;
    private static final float BASE_BUTTON_HEIGHT = 80f;

    // Private constructor
    public StarterSelectionTable(Skin skin) {
        this.skin = skin;
        GameLogger.info("Creating StarterSelectionTable");

        // (Optional) Adjust window size for testing.
        Gdx.graphics.setWindowedMode(
            Math.max(800, Gdx.graphics.getWidth()),
            Math.max(600, Gdx.graphics.getHeight())
        );

        // Setup this table
        setFillParent(true);
        setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("starter-bg")));
        setTouchable(Touchable.enabled);

        Table mainContainer = new Table();
        mainContainer.center();
        mainContainer.defaults().center().pad(20);

        // Top spacer for vertical centering
        mainContainer.add().expandY().row();

        // Title label
        titleLabel = new Label("Choose Your First Partner!", skin);
        titleLabel.setFontScale(BASE_TITLE_SCALE);
        titleLabel.setAlignment(Align.center);
        mainContainer.add(titleLabel).expandX().center().padBottom(40).row();

        // Starter options container
        starters = new Table();
        starters.defaults().pad(BASE_PADDING).space(40);
        starters.center();
        addStarterOption(starters, "BULBASAUR", "A reliable grass-type partner with a mysterious bulb.");
        addStarterOption(starters, "CHARMANDER", "A fierce fire-type partner with a burning tail.");
        addStarterOption(starters, "SQUIRTLE", "A sturdy water-type partner with a protective shell.");
        mainContainer.add(starters).expandX().center().padBottom(40).row();

        // Info label
        pokemonInfoLabel = new Label("Click on a Pokemon to learn more!", skin);
        pokemonInfoLabel.setWrap(true);
        pokemonInfoLabel.setAlignment(Align.center);
        pokemonInfoLabel.setFontScale(1.3f);
        Table infoContainer = new Table();
        infoContainer.add(pokemonInfoLabel).width(Gdx.graphics.getWidth() * 0.6f).pad(30);
        mainContainer.add(infoContainer).expandX().center().padBottom(30).row();

        // Confirm button
        confirmButton = new TextButton("Choose Pokemon!", skin);
        confirmButton.setDisabled(true);
        confirmButton.getLabel().setFontScale(1.5f);
        confirmButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (!confirmButton.isDisabled() && selectedStarter != null) {
                    confirmSelection();
                }
            }
        });
        mainContainer.add(confirmButton).size(BASE_BUTTON_WIDTH, BASE_BUTTON_HEIGHT).padBottom(40).row();

        // Bottom spacer for vertical centering
        mainContainer.add().expandY().row();

        add(mainContainer).expand().fill();

        GameLogger.info("StarterSelectionTable setup complete");
    }

    /**
     * Static factory method – returns the current instance if available;
     * otherwise creates a new one.
     */
    public static StarterSelectionTable getInstance(Skin skin) {
        if (instance == null) {
            instance = new StarterSelectionTable(skin);
        } else {
            GameLogger.info("Returning existing StarterSelectionTable instance.");
        }
        return instance;
    }

    @Override
    public boolean remove() {
        instance = null; // allow a new instance next time
        return super.remove();
    }

    private void addStarterOption(Table container, String pokemonName, String description) {
        Table cell = new Table();
        cell.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_normal")));
        cell.center();

        // Add Pokemon sprite
        TextureRegion sprite = TextureManager.getPokemonfront().findRegion(pokemonName + "_front");
        if (sprite != null) {
            Image image = new Image(sprite);
            image.setScaling(Scaling.fit);
            Vector2 imageSize = ResponsiveLayout.getElementSize(120, 120);
            cell.add(image)
                .size(imageSize.x, imageSize.y)
                .center().pad(ResponsiveLayout.getPadding()).row();
        }
        // Add Pokemon name label
        Label nameLabel = new Label(pokemonName, skin);
        nameLabel.setFontScale(ResponsiveLayout.getFontScale());
        cell.add(nameLabel).center().pad(ResponsiveLayout.getPadding());

        // Add click listener
        cell.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                selectStarter(pokemonName, description, cell);
            }
        });

        // Add the cell with fixed size
        Vector2 cellSize = ResponsiveLayout.getElementSize(180, 200);
        container.add(cell).size(cellSize.x, cellSize.y).center();
    }

    private void setupStarterPokemon(Pokemon starter) {
        switch (starter.getName()) {
            case "BULBASAUR":
                starter.setPrimaryType(Pokemon.PokemonType.GRASS);
                starter.getMoves().add(PokemonDatabase.getMoveByName("Tackle"));
                starter.getMoves().add(PokemonDatabase.getMoveByName("Growl"));
                starter.getMoves().add(PokemonDatabase.getMoveByName("Poison-Powder"));
                starter.setSecondaryType(Pokemon.PokemonType.POISON);
                starter.setLevel(5);
                starter.setCurrentHp(starter.getStats().getHp());
                break;
            case "CHARMANDER":
                starter.setPrimaryType(Pokemon.PokemonType.FIRE);
                starter.getMoves().add(PokemonDatabase.getMoveByName("Tackle"));
                starter.getMoves().add(PokemonDatabase.getMoveByName("Growl"));
                starter.setLevel(5);
                starter.setCurrentHp(starter.getStats().getHp());
                break;
            case "SQUIRTLE":
                starter.setPrimaryType(Pokemon.PokemonType.WATER);
                starter.getMoves().add(PokemonDatabase.getMoveByName("Tackle"));
                starter.getMoves().add(PokemonDatabase.getMoveByName("Withdraw"));
                starter.setLevel(5);
                starter.setCurrentHp(starter.getStats().getHp());
                break;
        }
        // Set base stats for all starters
        Pokemon.Stats stats = starter.getStats();
        stats.setHp(20);
        stats.setAttack(12);
        stats.setDefense(12);
        stats.setSpecialAttack(12);
        stats.setSpecialDefense(12);
        stats.setSpeed(12);
        starter.setCurrentHp(stats.getHp());
    }

    private void selectStarter(String pokemonName, String description, Table pokemonCell) {
        if (selectionMade) return;

        GameLogger.info("Selecting starter: " + pokemonName);
        selectedStarter = new Pokemon(pokemonName, 5);
        setupStarterPokemon(selectedStarter);

        if (selectedCell != null) {
            selectedCell.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_normal")));
            selectedCell.setColor(1, 1, 1, 1);
        }
        pokemonCell.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_selected")));
        selectedCell = pokemonCell;

        confirmButton.setDisabled(false);
        pokemonInfoLabel.setText(description);

        if (selectionListener != null) {
            selectionListener.onSelectionStart();
        }
    }

    private void confirmSelection() {
        if (selectedStarter != null && selectionListener != null && !selectionMade) {
            GameLogger.info("Confirming starter selection: " + selectedStarter.getName());
            selectionMade = true;
            selectionListener.onStarterSelected(selectedStarter);
        }
    }

    public void setSelectionListener(SelectionListener listener) {
        this.selectionListener = listener;
    }

    public void resize(int width, int height) {
        GameLogger.info("Resizing StarterSelectionTable to: " + width + "x" + height);
        float scaleFactor = Math.min(width / 1920f, height / 1080f);
        scaleFactor = Math.max(scaleFactor, 0.3f);
        float buttonWidth = BASE_BUTTON_WIDTH * scaleFactor;
        float buttonHeight = BASE_BUTTON_HEIGHT * scaleFactor;
        float padding = BASE_PADDING * scaleFactor;

        titleLabel.setFontScale(BASE_TITLE_SCALE * scaleFactor);
        pokemonInfoLabel.setFontScale(1.3f * scaleFactor);
        confirmButton.getLabel().setFontScale(1.5f * scaleFactor);

        starters.clear();
        starters.defaults().pad(padding).space(padding * 2);
        addStarterOption(starters, "BULBASAUR", "A reliable grass-type partner with a mysterious bulb.");
        addStarterOption(starters, "CHARMANDER", "A fierce fire-type partner with a burning tail.");
        addStarterOption(starters, "SQUIRTLE", "A sturdy water-type partner with a protective shell.");

        pokemonInfoLabel.setWidth(width * 0.6f);
        confirmButton.setSize(buttonWidth, buttonHeight);
        invalidateHierarchy();
        validate();
        setPosition((width - getWidth()) / 2, (height - getHeight()) / 2);
        GameLogger.info("StarterSelectionTable resize complete - Scale factor: " + scaleFactor);
    }

    public interface SelectionListener {
        void onStarterSelected(Pokemon starter);
        void onSelectionStart();
    }
}

================
File: src/main/java/io/github/pokemeetup/screens/WorldSelectionScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.*;
import com.badlogic.gdx.graphics.g2d.*;
import com.badlogic.gdx.graphics.glutils.FrameBuffer;
import com.badlogic.gdx.math.*;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.*;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.client.GameClientSingleton;
import io.github.pokemeetup.multiplayer.server.config.ServerConfigManager;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.screens.otherui.CharacterPreviewDialog;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import static io.github.pokemeetup.system.gameplay.overworld.World.INITIAL_LOAD_RADIUS;

/**
 * A screen that shows all available worlds, allows creation/deletion,
 * and loads either single- or multi-player.
 */
public class WorldSelectionScreen implements Screen {
    private static final String DEFAULT_PLAYER_NAME = "Player";
    private static final float MIN_BUTTON_WIDTH = 150f;
    private static final float MIN_BUTTON_HEIGHT = 40f;
    private static final float MIN_WORLD_LIST_WIDTH = 300f;
    private static final float MIN_INFO_PANEL_WIDTH = 200f;
    private final CreatureCaptureGame game;
    private final Stage stage;
    private final Skin skin;
    private final Map<String, Texture> worldThumbnails = new HashMap<>();
    private Table mainTable;
    private ScrollPane worldListScroll;
    private Table worldListTable;
    private Table infoPanel;
    private WorldData selectedWorld;
    // Buttons
    private TextButton playButton;
    private TextButton createButton;
    private TextButton deleteButton;
    private TextButton backButton;
    private ButtonGroup<TextButton> tabGroup;
    private String currentTab = "All";
    private ButtonGroup<TextButton> sortGroup;
    private String currentSort = "Name";
    private float screenWidth;
    private float screenHeight;
    private Table contentTable;
    private TextureRegion placeholderRegion;

    public WorldSelectionScreen(CreatureCaptureGame game) {
        this.game = game;
        this.stage = new Stage(new ScreenViewport());

        TextureAtlas atlas;
        try {
            atlas = new TextureAtlas(Gdx.files.internal("Skins/uiskin.atlas"));
        } catch (Exception e) {
            GameLogger.error("Failed to load TextureAtlas 'uiskin.atlas': " + e.getMessage());
            throw new RuntimeException("TextureAtlas loading failed.", e);
        }

        skin = new Skin(atlas);
        try {
            skin.load(Gdx.files.internal("Skins/uiskin.json"));
        } catch (Exception e) {
            GameLogger.error("Failed to load skin JSON 'uiskin.json': " + e.getMessage());
            throw new RuntimeException("Skin JSON loading failed.", e);
        }
        List<String> requiredDrawables = Arrays.asList(
            "default-round", "default-round-down", "default-rect",
            "default-window", "default-scroll", "default-round-large",
            "check-on", "check-off", "tree-minus", "tree-plus",
            "default-select", "default-select-selection",
            "default-splitpane-vertical", "default-splitpane",
            "default-slider", "default-slider-knob"
        );

        for (String drawableName : requiredDrawables) {
            if (!skin.has(drawableName, Drawable.class)) {
                GameLogger.error("Missing drawable in skin: " + drawableName);
            }
        }

        Gdx.input.setInputProcessor(stage);

        createUI();
        updateScreenSizes();
        refreshWorldList();
    }

    // Adjust layout on resizing
    private void updateScreenSizes() {
        screenWidth = Gdx.graphics.getWidth();
        screenHeight = Gdx.graphics.getHeight();

        // Calculate relative sizes
        float buttonWidth = Math.max(MIN_BUTTON_WIDTH, screenWidth * 0.2f);
        float buttonHeight = Math.max(MIN_BUTTON_HEIGHT, screenHeight * 0.08f);
        float worldListWidth = Math.max(MIN_WORLD_LIST_WIDTH, screenWidth * 0.55f);
        float infoPanelWidth = Math.max(MIN_INFO_PANEL_WIDTH, screenWidth * 0.35f);

        // Update UI elements with new sizes
        updateUIElements(buttonWidth, buttonHeight, worldListWidth, infoPanelWidth);
    }

    private void updateUIElements(float buttonWidth, float buttonHeight,
                                  float worldListWidth, float infoPanelWidth) {
        // Calculate font scale based on screen size
        float fontScale = Math.max(0.8f, Math.min(screenWidth, screenHeight) / 1000f);

        // Update main table padding
        if (mainTable != null) {
            mainTable.pad(screenWidth * 0.02f); // 2% of screen width

            // Update title scaling
            Label titleLabel = mainTable.findActor("titleLabel");
            if (titleLabel != null) {
                titleLabel.setFontScale(fontScale * 1.5f);
            }
        }

        // Update button sizes and font scales
        updateButton(createButton, buttonWidth, buttonHeight, fontScale);
        updateButton(playButton, buttonWidth, buttonHeight, fontScale);
        updateButton(deleteButton, buttonWidth, buttonHeight, fontScale);
        updateButton(backButton, buttonWidth, buttonHeight, fontScale);

        // Update scroll pane and info panel sizes
        if (worldListScroll != null && contentTable != null) {
            worldListTable.padRight(screenWidth * 0.02f);
            Cell<?> scrollCell = contentTable.getCell(worldListScroll);
            if (scrollCell != null) {
                scrollCell.width(worldListWidth);
            }

            Cell<?> infoPanelCell = contentTable.getCell(infoPanel);
            if (infoPanelCell != null) {
                infoPanelCell.width(infoPanelWidth);
            }
        }

        // Update world entry sizes
        if (worldListTable != null) {
            for (Actor actor : worldListTable.getChildren()) {
                if (actor instanceof Table) {
                    Table entry = (Table) actor;
                    float entryPadding = screenWidth * 0.01f;
                    entry.pad(entryPadding);

                    // Update thumbnail size
                    Image thumbnail = entry.findActor("thumbnail");
                    if (thumbnail != null) {
                        float thumbnailSize = Math.max(60f, screenWidth * 0.08f);
                        Cell<?> thumbnailCell = entry.getCell(thumbnail);
                        if (thumbnailCell != null) {
                            thumbnailCell.size(thumbnailSize);
                        }
                    }

                    // Update labels in the entry
                    for (Actor child : entry.getChildren()) {
                        if (child instanceof Label) {
                            ((Label) child).setFontScale(fontScale);
                        }
                    }
                }
            }
        }
    }

    private void updateButton(TextButton button, float width, float height, float fontScale) {
        if (button != null) {
            button.getLabel().setFontScale(fontScale);
            Table parent = button.getParent() instanceof Table ? (Table) button.getParent() : null;
            if (parent != null) {
                Cell<?> cell = parent.getCell(button);
                if (cell != null) {
                    cell.width(width)
                        .height(height)
                        .pad(screenWidth * 0.01f);
                }
            }
        }
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        updateScreenSizes();
    }

    private void createUI() {
        mainTable = new Table();
        mainTable.setFillParent(true);
        mainTable.pad(20);

        Label titleLabel = new Label("Select World", skin);
        titleLabel.setName("titleLabel");
        titleLabel.setFontScale(2.0f);
        mainTable.add(titleLabel).colspan(4).pad(20);
        mainTable.row();

        // Tab buttons
        Table tabTable = new Table();
        tabGroup = new ButtonGroup<>();

        String[] tabs = {"All", "Recent", "Multiplayer"};
        for (String tab : tabs) {
            TextButton tabButton = new TextButton(tab, skin);
            tabGroup.add(tabButton);
            tabTable.add(tabButton).pad(5);
        }
        mainTable.add(tabTable).colspan(4).pad(10);
        mainTable.row();

        // Sorting buttons
        Table sortTable = new Table();
        TextButton sortByNameButton = new TextButton("Sort by Name", skin);
        TextButton sortByDateButton = new TextButton("Sort by Date", skin);
        sortGroup = new ButtonGroup<>(sortByNameButton, sortByDateButton);
        sortGroup.setMaxCheckCount(1);
        sortGroup.setMinCheckCount(1);
        sortGroup.setUncheckLast(true);

        sortTable.add(sortByNameButton).pad(5);
        sortTable.add(sortByDateButton).pad(5);

        mainTable.add(sortTable).colspan(4).pad(10);
        mainTable.row();

        // World list setup
        worldListTable = new Table();
        worldListTable.top();
        worldListTable.defaults().expandX().fillX().pad(5f);

        ScrollPane.ScrollPaneStyle scrollPaneStyle = new ScrollPane.ScrollPaneStyle();
        scrollPaneStyle.background = skin.newDrawable("default-pane", new Color(0.15f, 0.15f, 0.15f, 0.8f));
        scrollPaneStyle.vScroll = skin.newDrawable("default-scroll");
        scrollPaneStyle.vScrollKnob = skin.newDrawable("default-round-large");

        worldListScroll = new ScrollPane(worldListTable, scrollPaneStyle);
        worldListScroll.setFadeScrollBars(false);
        worldListScroll.setScrollingDisabled(true, false);

        // Info panel
        infoPanel = new Table(skin);
        infoPanel.background("default-pane");
        infoPanel.pad(10);

        contentTable = new Table();
        contentTable.defaults().pad(10);
        contentTable.add(worldListScroll)
            .width(Gdx.graphics.getWidth() * 0.6f)
            .expandY()
            .fillY()
            .padRight(20);
        contentTable.add(infoPanel)
            .width(Gdx.graphics.getWidth() * 0.35f)
            .expandY()
            .fillY();

        mainTable.add(contentTable).colspan(4).expand().fill();
        mainTable.row();

        Table buttonTable = new Table();

        createButton = new TextButton("Create New World", skin);
        playButton = new TextButton("Play Selected World", skin);
        deleteButton = new TextButton("Delete World", skin);
        backButton = new TextButton("Back", skin);

        playButton.setDisabled(true);
        deleteButton.setDisabled(true);

        float fontScale = 1.2f;
        createButton.getLabel().setFontScale(fontScale);
        playButton.getLabel().setFontScale(fontScale);
        deleteButton.getLabel().setFontScale(fontScale);
        backButton.getLabel().setFontScale(fontScale);

        buttonTable.add(createButton).pad(10).width(250).height(70);
        buttonTable.add(playButton).pad(10).width(250).height(70);
        buttonTable.add(deleteButton).pad(10).width(250).height(70);
        buttonTable.row();
        buttonTable.add(backButton).colspan(3).width(250).height(70).pad(10);

        mainTable.add(buttonTable).colspan(4).pad(10);

        stage.addActor(mainTable);

        placeholderRegion = TextureManager.ui.findRegion("placeholder-image");
        addTabListeners();
        addSortListeners();
        addButtonListeners();

        tabGroup.getButtons().get(0).setChecked(true);
        sortGroup.getButtons().get(0).setChecked(true);
    }

    private void addTabListeners() {
        for (TextButton tabButton : tabGroup.getButtons()) {
            tabButton.addListener(new ChangeListener() {
                @Override
                public void changed(ChangeEvent event, Actor actor) {
                    if (tabButton.isChecked()) {
                        currentTab = tabButton.getText().toString();
                        refreshWorldList();
                    }
                }
            });
        }
    }

    private void addSortListeners() {
        for (TextButton sortButton : sortGroup.getButtons()) {
            sortButton.addListener(new ChangeListener() {
                @Override
                public void changed(ChangeEvent event, Actor actor) {
                    if (sortButton.isChecked()) {
                        currentSort = sortButton.getText().toString().replace("Sort by ", "");
                        refreshWorldList();
                    }
                }
            });
        }
    }

    private void addButtonListeners() {
        createButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                showCreateWorldDialog();
            }
        });

        playButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                if (selectedWorld != null) {
                    String username = selectedWorld.getPlayers().isEmpty()
                        ? DEFAULT_PLAYER_NAME
                        : selectedWorld.getPlayers().keySet().iterator().next();
                    loadSelectedWorld(username);
                }
            }
        });

        deleteButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                if (selectedWorld != null) {
                    showDeleteConfirmDialog();
                }
            }
        });

        backButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                game.setScreen(new ModeSelectionScreen(game));
                dispose();
            }
        });
    }

    private Table createWorldEntry(WorldData world) {
        Table entry = new Table(skin);
        entry.setName("worldEntry");
        entry.setBackground(skin.newDrawable("default-pane", new Color(0.2f, 0.2f, 0.2f, 0.8f)));

        Table contentTable = new Table();
        float padding = 10f;
        contentTable.pad(padding);

        Table thumbnailContainer = new Table();
        thumbnailContainer.setBackground(skin.newDrawable("default-pane", new Color(0.15f, 0.15f, 0.15f, 1f)));

        Image thumbnailImage;
        FileHandle thumbnailFile = Gdx.files.local("thumbnails/" + world.getName() + ".png");
        if (thumbnailFile.exists()) {
            Texture thumbnailTexture = new Texture(thumbnailFile);
            worldThumbnails.put(world.getName(), thumbnailTexture);
            thumbnailImage = new Image(new TextureRegionDrawable(new TextureRegion(thumbnailTexture)));
            thumbnailImage.setScaling(Scaling.fit);
        } else {
            thumbnailImage = new Image(placeholderRegion);
            thumbnailImage.setScaling(Scaling.fit);
        }
        thumbnailImage.setName("thumbnail");

        float thumbnailSize = 180f;
        thumbnailContainer.add(thumbnailImage).size(thumbnailSize).pad(2f);

        Table infoTable = new Table();
        infoTable.defaults().left().pad(5f);

        Label nameLabel = new Label(world.getName(), skin);
        nameLabel.setFontScale(1.2f);

        Label timeLabel = new Label("Last played: " + formatDate(world.getLastPlayed()), skin);
        timeLabel.setFontScale(0.9f);

        Label seedLabel = new Label("Seed: " + getSeedFromWorld(world), skin);
        seedLabel.setFontScale(0.9f);

        String playedTimeStr = formatPlayedTime(world.getPlayedTime());
        Label playedTimeLabel = new Label("Played time: " + playedTimeStr, skin);
        playedTimeLabel.setFontScale(0.9f);

        infoTable.add(nameLabel).expandX().fillX().padBottom(5f);
        infoTable.row();
        infoTable.add(timeLabel).expandX().fillX().padBottom(5f);
        infoTable.row();
        infoTable.add(seedLabel).expandX().fillX().padBottom(5f);
        infoTable.row();
        infoTable.add(playedTimeLabel).expandX().fillX();

        contentTable.add(thumbnailContainer).size(thumbnailSize + padding * 2).padRight(padding * 2);
        contentTable.add(infoTable).expand().fill();
        entry.add(contentTable).expand().fill();

        entry.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                resetWorldEntryStyles();
                entry.setBackground(skin.newDrawable("default-pane", new Color(0.3f, 0.6f, 1f, 0.8f)));
                selectWorld(world);
            }
        });

        return entry;
    }

    private void resetWorldEntryStyles() {
        for (Actor actor : worldListTable.getChildren()) {
            if (actor instanceof Table) {
                ((Table) actor).setBackground(skin.newDrawable("default-pane", new Color(0.2f, 0.2f, 0.2f, 0.8f)));
            }
        }
    }

    private void refreshWorldList() {
        worldListTable.clear();
        WorldData previousSelection = selectedWorld;

        List<WorldData> worldList = new ArrayList<>(GameContext.get().getWorldManager().getWorlds().values());
        worldList.removeIf(world -> !shouldShowWorld(world));

        if (currentSort.equals("Name")) {
            worldList.sort(Comparator.comparing(WorldData::getName));
        } else if (currentSort.equals("Date")) {
            worldList.sort(Comparator.comparingLong(WorldData::getLastPlayed).reversed());
        }

        worldListTable.defaults().expandX().fillX().pad(5f);

        for (WorldData world : worldList) {
            Table worldEntry = createWorldEntry(world);

            if (world.equals(previousSelection)) {
                worldEntry.setBackground(skin.newDrawable("default-pane", new Color(0.3f, 0.6f, 1f, 0.8f)));
                selectedWorld = world;
            }

            worldListTable.add(worldEntry).expandX().fillX();
            worldListTable.row();
        }

        playButton.setDisabled(selectedWorld == null);
        deleteButton.setDisabled(selectedWorld == null);

        updateInfoPanel();
    }

    private boolean shouldShowWorld(WorldData world) {
        switch (currentTab) {
            case "Recent":
                return (System.currentTimeMillis() - world.getLastPlayed()) < (7L * 24 * 60 * 60 * 1000);
            case "Multiplayer":
                return world.getName().equals(CreatureCaptureGame.MULTIPLAYER_WORLD_NAME);
            default:
                return true;
        }
    }

    private void selectWorld(WorldData world) {
        if (world == null) return;

        selectedWorld = world;
        updateInfoPanel();
        playButton.setDisabled(false);
        deleteButton.setDisabled(false);

        GameLogger.info("Selected world '" + world.getName() +
            "' - Commands " + (world.commandsAllowed() ? "enabled" : "disabled"));
    }

    private void updateInfoPanel() {
        infoPanel.clear();

        if (selectedWorld == null) {
            infoPanel.add(new Label("Select a world to view details", skin)).expand();
            return;
        }

        infoPanel.defaults().left().pad(5);

        // World name
        Label nameLabel = new Label(selectedWorld.getName(), skin);
        nameLabel.setFontScale(1.5f);
        infoPanel.add(nameLabel).expandX();
        infoPanel.row();

        // Last played
        Label lastPlayedLabel = new Label("Last played: " + formatDate(selectedWorld.getLastPlayed()), skin);
        lastPlayedLabel.setFontScale(1.0f);
        infoPanel.add(lastPlayedLabel);
        infoPanel.row();

        // World size
        infoPanel.add(new Label("World size: " + World.WORLD_SIZE + " x " + World.WORLD_SIZE, skin));
        infoPanel.row();

        // Seed
        long seed = getSeedFromWorld(selectedWorld);
        infoPanel.add(new Label("Seed: " + seed, skin));
        infoPanel.row();

        // Played time
        long playedTimeMillis = selectedWorld.getPlayedTime();
        String playedTimeStr = formatPlayedTime(playedTimeMillis);
        Label playedTimeLabel = new Label("Played time: " + playedTimeStr, skin);
        infoPanel.add(playedTimeLabel);
        infoPanel.row();

        // Username
        String username = selectedWorld.getPlayers() != null && !selectedWorld.getPlayers().isEmpty()
            ? selectedWorld.getPlayers().keySet().iterator().next()
            : "Player";
        Label usernameLabel = new Label("Username: " + username, skin);
        infoPanel.add(usernameLabel).row();
    }

    private String formatPlayedTime(long millis) {
        long seconds = millis / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;

        seconds = seconds % 60;
        minutes = minutes % 60;

        return String.format("%02dh %02dm %02ds", hours, minutes, seconds);
    }

    private String formatDate(long timestamp) {
        if (timestamp == 0) return "Never";
        return new SimpleDateFormat("MMM d, yyyy HH:mm").format(new Date(timestamp));
    }

    private long getSeedFromWorld(WorldData world) {
        if (world == null) return System.currentTimeMillis();
        WorldData.WorldConfig config = world.getConfig();
        if (config == null) {
            config = new WorldData.WorldConfig(System.currentTimeMillis());
            world.setConfig(config);
            GameLogger.error("Created new config for null config world");
        }
        return config.getSeed();
    }
    private void showCreateWorldDialog() {
        CharacterPreviewDialog characterDialog = new CharacterPreviewDialog(stage, skin,
            (selectedCharacterType) -> {
                // Show the world creation dialog after character selection
                showWorldCreationDialog(selectedCharacterType);
            });
        characterDialog.show(stage);
    }

    private void showWorldCreationDialog(String characterType) {
        Dialog dialog = new Dialog("Create New World", skin) {
            @Override
            protected void result(Object object) {
                if ((Boolean) object) {
                    TextField nameField = findActor("nameField");
                    CheckBox cheatsAllowed = findActor("cheatsAllowed");
                    TextField seedField = findActor("seedField");
                    TextField dialogUsernameField = findActor("usernameField");

                    boolean commandsEnabled = cheatsAllowed != null && cheatsAllowed.isChecked();
                    String worldName = nameField.getText().trim();
                    String seedText = seedField.getText().trim();
                    String username = dialogUsernameField.getText().trim();

                    if (worldName.isEmpty()) {
                        showError("World name cannot be empty");
                        return;
                    }
                    if (username.isEmpty()) {
                        username = DEFAULT_PLAYER_NAME;
                    }

                    long seed;
                    if (seedText.isEmpty()) {
                        seed = System.currentTimeMillis();
                    } else {
                        try {
                            seed = Long.parseLong(seedText);
                        } catch (NumberFormatException e) {
                            showError("Seed must be a valid number");
                            return;
                        }
                    }

                    createNewWorld(worldName, seed, username, commandsEnabled, characterType);
                }
            }
        };

        // Create input fields
        TextField nameField = new TextField("", skin);
        nameField.setName("nameField");
        nameField.setMessageText("World name");

        CheckBox cheatsAllowed = new CheckBox(" Enable Commands", skin);
        cheatsAllowed.setName("cheatsAllowed");
        cheatsAllowed.setChecked(false);

        TextField seedField = new TextField("", skin);
        seedField.setName("seedField");
        seedField.setMessageText("Optional seed (number)");

        TextField dialogUsernameField = new TextField("", skin);
        dialogUsernameField.setName("usernameField");
        dialogUsernameField.setMessageText("Your username (optional)");

        // Add fields to dialog
        dialog.getContentTable().add(new Label("World Name:", skin)).left().padBottom(5);
        dialog.getContentTable().row();
        dialog.getContentTable().add(nameField).width(300).padBottom(15);
        dialog.getContentTable().row();
        dialog.getContentTable().add(new Label("Seed (optional):", skin)).left().padBottom(5);
        dialog.getContentTable().row();
        dialog.getContentTable().add(seedField).width(300).padBottom(15);
        dialog.getContentTable().row();
        dialog.getContentTable().add(new Label("Username:", skin)).left().padBottom(5);
        dialog.getContentTable().row();
        dialog.getContentTable().add(dialogUsernameField).width(300).padBottom(15);
        dialog.getContentTable().row();
        dialog.getContentTable().add(cheatsAllowed).left().padBottom(15);

        dialog.button("Create", true);
        dialog.button("Cancel", false);
        dialog.show(stage);
    }
    private void showDeleteConfirmDialog() {
        Dialog dialog = new Dialog("Delete World", skin) {
            @Override
            protected void result(Object object) {
                if ((Boolean) object) {
                    deleteSelectedWorld();
                }
            }
        };

        dialog.text("Are you sure you want to delete '" + selectedWorld.getName() + "'?\nThis cannot be undone!");
        dialog.button("Delete", true);
        dialog.button("Cancel", false);
        dialog.show(stage);
    }

    private void deleteSelectedWorld() {
        try {
            GameContext.get().getWorldManager().deleteWorld(selectedWorld.getName());
            selectedWorld = null;
            refreshWorldList();
            updateInfoPanel();
            playButton.setDisabled(true);
            deleteButton.setDisabled(true);
        } catch (Exception e) {
            showError("Failed to delete world: " + e.getMessage());
            GameLogger.error("Failed to delete world: " + e.getMessage());
        }
    }

    private void createNewWorld(String name, long seed, String username, boolean cheatsAllowed, String characterType) {
        try {
            GameLogger.info("Creating new world '" + name + "' with commands " +
                (cheatsAllowed ? "enabled" : "disabled"));

            // Create world
            WorldData world = GameContext.get().getWorldManager().createWorld(name, seed, 0.15f, 0.05f);
            if (world == null) {
                showError("Failed to create world");
                return;
            }

            // Immediately set and save the commands flag
            world.setCommandsAllowed(cheatsAllowed);
            GameLogger.info("Set initial commands state: " + world.commandsAllowed());

            // Create and assign world config
            WorldData.WorldConfig config = new WorldData.WorldConfig(seed);
            config.setTreeSpawnRate(0.15f);
            config.setPokemonSpawnRate(0.05f);
            world.setConfig(config);

            // Create new player data and set the character type (e.g., "boy" or "girl")
            PlayerData playerData = new PlayerData(username);
            playerData.setCharacterType(characterType);
            world.savePlayerData(username, playerData, false);

            // Force an immediate save of the world
            GameContext.get().getWorldManager().saveWorld(world);

            GameLogger.info("World creation complete - Commands enabled: " + world.commandsAllowed());

            // Generate a thumbnail and update UI
            generateWorldThumbnail(world);
            refreshWorldList();
            selectWorld(world);

        } catch (Exception e) {
            GameLogger.error("Failed to create world: " + e.getMessage());
            showError("Failed to create world: " + e.getMessage());
        }
    }

    public void loadSelectedWorld(String username) {
        try {
            GameLogger.info("Starting world load: " + selectedWorld.getName());

            // (1) Save the current world state (if applicable)
            if (GameContext.get().getWorld() != null && GameContext.get().getPlayer() != null) {
                boolean currentIsMultiplayer = GameContext.get().getGameClient() != null &&
                    GameContext.get().isMultiplayer();
                boolean targetIsMultiplayer = selectedWorld.getName().equals(CreatureCaptureGame.MULTIPLAYER_WORLD_NAME);
                if (currentIsMultiplayer == targetIsMultiplayer) {
                    PlayerData currentState = GameContext.get().getPlayer().getPlayerData();
                    GameContext.get().getWorld().getWorldData().savePlayerData(
                        GameContext.get().getPlayer().getUsername(),
                        currentState,
                        currentIsMultiplayer
                    );
                }
            }

            // (2) Clean up the old client state
            if (GameContext.get().getGameClient() != null) {
                GameContext.get().getGameClient().dispose();
                GameContext.get().setGameClient(null);
            }

            // (3) Force a reload of the world data from disk rather than reusing the in-memory selectedWorld.
            // This is the key change.
            WorldData reloadedWorldData = GameContext.get().getWorldManager().loadAndValidateWorld(selectedWorld.getName());
            if (reloadedWorldData == null) {
                throw new IOException("Failed to load world data from disk for world: " + selectedWorld.getName());
            }
            // Update the last played timestamp (if needed)
            reloadedWorldData.setLastPlayed(System.currentTimeMillis());

            // (4) Retrieve the correct player data for this world from the reloaded data.
            PlayerData worldSpecificPlayerData = reloadedWorldData.getPlayerData(username, false);
            if (worldSpecificPlayerData == null) {
                worldSpecificPlayerData = new PlayerData(username);
            }

            // (5) Initialize the world using the reloaded data.
            game.initializeWorld(reloadedWorldData.getName(), false);

            // (6) Set up the singleplayer client.
            GameContext.get().setGameClient(GameClientSingleton.getSinglePlayerInstance(GameContext.get().getPlayer()));
            GameContext.get().getGameClient().setSinglePlayer(true);
            GameContext.get().setMultiplayer(false);

            // (7) Apply the saved player data to the new player.
            if (GameContext.get().getPlayer() != null) {
                GameContext.get().getPlayer().updateFromPlayerData(worldSpecificPlayerData);
            }

            // (8) Create and switch to a new GameScreen.
            GameScreen newScreen = new GameScreen(game, username,
                GameContext.get().getGameClient(), selectedWorld.commandsAllowed(), reloadedWorldData.getName());
            GameContext.get().setGameScreen(newScreen);
            game.setScreen(newScreen);
            dispose();

        } catch (Exception e) {
            GameLogger.error("Failed to load world: " + e.getMessage());
            showError("Failed to load world: " + e.getMessage());
        }
    }

    private void generateWorldThumbnail(WorldData worldData) {
        final int THUMBNAIL_SIZE = 256;
        FrameBuffer fbo = null;
        SpriteBatch batch = null;
        World tempWorld = null;

        try {
            GameLogger.info("Starting thumbnail generation for: " + worldData.getName());

            // Create new FBO
            fbo = new FrameBuffer(Pixmap.Format.RGBA8888, THUMBNAIL_SIZE, THUMBNAIL_SIZE, false);
            batch = new SpriteBatch();

            // Create minimal world just for a screenshot
            tempWorld = initializeWorldDirectly(worldData);

            // Setup camera
            OrthographicCamera camera = new OrthographicCamera();
            camera.setToOrtho(false, 16 * World.TILE_SIZE, 16 * World.TILE_SIZE);
            camera.position.set(World.DEFAULT_X_POSITION, World.DEFAULT_Y_POSITION, 0);
            camera.update();

            // Render into FBO
            fbo.begin();
            Gdx.gl.glViewport(0, 0, THUMBNAIL_SIZE, THUMBNAIL_SIZE);
            Gdx.gl.glClearColor(0.529f, 0.808f, 0.922f, 1);
            Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

            batch.setProjectionMatrix(camera.combined);
            batch.begin();

            Rectangle viewBounds = new Rectangle(
                camera.position.x - camera.viewportWidth / 2,
                camera.position.y - camera.viewportHeight / 2,
                camera.viewportWidth,
                camera.viewportHeight
            );
            tempWorld.render(batch, viewBounds, tempWorld.getPlayer());

            batch.end();
            Pixmap pixmap = Pixmap.createFromFrameBuffer(0, 0, THUMBNAIL_SIZE, THUMBNAIL_SIZE);
            fbo.end();
            Gdx.gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());

            // Flip the pixmap
            Pixmap flippedPixmap = flipPixmap(pixmap);
            pixmap.dispose();

            // Save thumbnail to file
            FileHandle thumbnailDir = Gdx.files.local("thumbnails");
            if (!thumbnailDir.exists()) {
                thumbnailDir.mkdirs();
            }

            FileHandle thumbnailFile = thumbnailDir.child(worldData.getName() + ".png");
            PixmapIO.writePNG(thumbnailFile, flippedPixmap);

            flippedPixmap.dispose();

        } catch (Exception e) {
            GameLogger.error("Failed to generate thumbnail: " + e.getMessage());
        } finally {
            if (batch != null) batch.dispose();
            if (fbo != null) fbo.dispose();
            if (tempWorld != null) tempWorld.dispose();
        }
    }

    private Pixmap flipPixmap(Pixmap src) {
        int width = src.getWidth();
        int height = src.getHeight();
        Pixmap flipped = new Pixmap(width, height, src.getFormat());

        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                int pixel = src.getPixel(x, y);
                flipped.drawPixel(x, height - y - 1, pixel);
            }
        }
        return flipped;
    }
    private World initializeWorldDirectly(WorldData worldData) throws IOException {
        if (worldData == null) {
            throw new IOException("WorldData cannot be null");
        }
        long seed = (worldData.getConfig() != null)
            ? worldData.getConfig().getSeed()
            : System.currentTimeMillis();
        World world = new World(worldData.getName(), seed);
        // Create and set a dummy player first.
        Player tempPlayer = new Player(World.DEFAULT_X_POSITION, World.DEFAULT_Y_POSITION, world, "ThumbnailGen");
        world.setPlayer(tempPlayer);
        // **NEW: Set the temporary world into the GameContext**
        GameContext.get().setWorld(world);

        // Synchronously load/generate chunks around the player's tile position.
        int radius = INITIAL_LOAD_RADIUS;
        int playerTileX = tempPlayer.getTileX();
        int playerTileY = tempPlayer.getTileY();
        int chunkX = Math.floorDiv(playerTileX, Chunk.CHUNK_SIZE);
        int chunkY = Math.floorDiv(playerTileY, Chunk.CHUNK_SIZE);
        GameLogger.info("Synchronously loading chunks around (" + playerTileX + "," + playerTileY + ")");
        for (int dx = -radius; dx <= radius; dx++) {
            for (int dy = -radius; dy <= radius; dy++) {
                Vector2 chunkPos = new Vector2(chunkX + dx, chunkY + dy);
                // Directly generate (or load from disk) the chunk
                Chunk chunk = world.loadOrGenerateChunk(chunkPos);
                if (chunk != null) {
                    world.chunks.put(chunkPos, chunk);
                } else {
                    GameLogger.error("Failed to load/generate chunk at " + chunkPos);
                }
            }
        }
        return world;
    }


    private void showError(String message) {
        Dialog dialog = new Dialog("Error", skin);
        dialog.text(message);
        dialog.button("OK");
        dialog.show(stage);
    }

    @Override
    public void show() {
        AudioManager.getInstance().playMenuMusic();
        Gdx.app.postRunnable(this::refreshWorldList);
    }

    @Override
    public void render(float delta) {
        AudioManager.getInstance().update(delta);

        // Handle back/escape key
        if (Gdx.input.isKeyJustPressed(Input.Keys.BACK) || Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            game.setScreen(new ModeSelectionScreen(game));
            dispose();
            return;
        }

        Gdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        stage.act(delta);
        stage.draw();
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
    }

    @Override
    public void dispose() {
        stage.dispose();
        skin.dispose();
        for (Texture texture : worldThumbnails.values()) {
            texture.dispose();
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/AndroidMovementController.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.MathUtils;

public class AndroidMovementController {
    private static final float DEADZONE = 0.2f;
    private static final float MAX_JOYSTICK_RADIUS = 100f;
    private static final float DIRECTION_THRESHOLD = 0.5f;

    private final Player player;
    private final Vector2 joystickCenter;
    private final Vector2 joystickCurrent;
    private final Vector2 movementVector;
    private boolean isActive;
    private String currentDirection;
    private float magnitude;

    public AndroidMovementController(Player player, InputHandler inputHandler) {
        this.player = player;
        this.joystickCenter = new Vector2();
        this.inputHandler = inputHandler;
        this.joystickCurrent = new Vector2();
        this.movementVector = new Vector2();
        this.isActive = false;
    }

    public void handleTouchDown(float x, float y) {
        joystickCenter.set(x, y);
        joystickCurrent.set(x, y);
        isActive = true;
        updateJoystick();
    }

    public void handleTouchDragged(float x, float y) {
        if (!isActive) return;

        joystickCurrent.set(x, y);
        updateJoystick();
    }



    private final InputHandler inputHandler;
    private void updateJoystick() {
        movementVector.set(joystickCurrent).sub(joystickCenter);

        // Calculate magnitude (0 to 1)
        magnitude = movementVector.len() / MAX_JOYSTICK_RADIUS;
        magnitude = MathUtils.clamp(magnitude, 0, 1);

        // Apply deadzone
        if (magnitude < DEADZONE) {
            magnitude = 0;
            movementVector.setZero();
            currentDirection = null;
            // Reset movement flags
            resetMovementFlags();
            return;
        }

        // Normalize vector
        movementVector.nor();

        updateDirection();

        // Set running based on magnitude
        if (inputHandler != null) {
            inputHandler.setRunning(magnitude > 0.8f);
        }
    } private void resetMovementFlags() {
        inputHandler.moveUp(false);
        inputHandler.moveDown(false);
        inputHandler.moveLeft(false);
        inputHandler.moveRight(false);
    }
    private void updateDirection() {
        float x = movementVector.x;
        float y = movementVector.y;

        // Reset movement flags
        resetMovementFlags();

        // Determine direction and set flags
        if (Math.abs(x) > DIRECTION_THRESHOLD) {
            if (x > 0) {
                inputHandler.moveRight(true);
            } else {
                inputHandler.moveLeft(true);
            }
        }
        if (Math.abs(y) > DIRECTION_THRESHOLD) {
            if (y > 0) {
                inputHandler.moveUp(true);
            } else {
                inputHandler.moveDown(true);
            }
        }
    }
    public void handleTouchUp() {
        isActive = false;
        movementVector.setZero();
        magnitude = 0;
        currentDirection = null;
        resetMovementFlags();
        if (player != null) {
            player.setMoving(false);
        }
    }

    public void update() {
        if (!isActive || magnitude < DEADZONE || currentDirection == null) {
            return;
        }
        if (!player.isMoving() && currentDirection != null) {
            player.move(currentDirection);
        } else if (player.isMoving()) {
            player.setDirection(currentDirection);
        }
    }

    public Vector2 getJoystickCenter() {
        return joystickCenter;
    }

    public Vector2 getJoystickCurrent() {
        return joystickCurrent;
    }

    public float getMaxRadius() {
        return MAX_JOYSTICK_RADIUS;
    }

    public boolean isActive() {
        return isActive;
    }

    public float getMagnitude() {
        return magnitude;
    }
}

================
File: src/main/java/io/github/pokemeetup/system/battle/BattleInitiationHandler.java
================
package io.github.pokemeetup.system.battle;

import io.github.pokemeetup.pokemon.WildPokemon;

public interface BattleInitiationHandler {
    void handleBattleInitiation();
    void forceBattleInitiation(WildPokemon aggressor);
}

================
File: src/main/java/io/github/pokemeetup/system/battle/BattleSystemHandler.java
================
package io.github.pokemeetup.system.battle;

import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;

public class BattleSystemHandler {
    private boolean isInBattle = false;

    private WildPokemon lockedPokemon = null;


    public void lockPokemonForBattle(WildPokemon pokemon) {
        if (pokemon != null) {
            pokemon.setMoving(false);
            if (pokemon.getAi() instanceof PokemonAI) {
                ((PokemonAI) pokemon.getAi()).setPaused(true);
            }
            pokemon.setX(pokemon.getX());
            pokemon.setY(pokemon.getY());
            lockedPokemon = pokemon;
        }
    }

    public void unlockPokemon() {
        if (lockedPokemon != null) {
            if (lockedPokemon.getAi() instanceof PokemonAI) {
                ((PokemonAI) lockedPokemon.getAi()).setPaused(false);
            }
            lockedPokemon = null;
        }
    }

    public void startBattle() {
        isInBattle = true;
    }

    public void endBattle() {
        isInBattle = false;
        unlockPokemon();
    }

    public boolean isInBattle() {
        return isInBattle;
    }
}

================
File: src/main/java/io/github/pokemeetup/system/data/BlockSaveData.java
================
package io.github.pokemeetup.system.data;

import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonValue;
import io.github.pokemeetup.utils.GameLogger;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BlockSaveData {
    private Map<String, List<BlockData>> placedBlocks;

    public BlockSaveData() {
        this.placedBlocks = new HashMap<>();
    }

    public void addBlock(String chunkKey, BlockData block) {
        if (block == null) {
            GameLogger.error("Attempted to add invalid block data");
            return;
        }

        placedBlocks.computeIfAbsent(chunkKey, k -> new ArrayList<>()).add(block);
        GameLogger.info("Added block " + block.type + " to chunk " + chunkKey);
    }

    public Map<String, List<BlockData>> getPlacedBlocks() {
        if (placedBlocks == null) {
            placedBlocks = new HashMap<>();
        }
        return placedBlocks;
    }

    public void setPlacedBlocks(Map<String, List<BlockData>> placedBlocks) {
        this.placedBlocks = placedBlocks;
    }

    public BlockSaveData copy() {
        BlockSaveData copy = new BlockSaveData();

        if (this.placedBlocks != null) {
            Map<String, List<BlockData>> placedBlocksCopy = new HashMap<>();
            for (Map.Entry<String, List<BlockData>> entry : this.placedBlocks.entrySet()) {
                String chunkKey = entry.getKey();
                List<BlockData> originalList = entry.getValue();
                List<BlockData> copiedList = new ArrayList<>();

                if (originalList != null) {
                    for (BlockData blockData : originalList) {
                        if (blockData != null) {
                            copiedList.add(blockData.copy());
                        } else {
                            copiedList.add(null);
                        }
                    }
                }

                placedBlocksCopy.put(chunkKey, copiedList);
            }
            copy.setPlacedBlocks(placedBlocksCopy);
        }

        return copy;
    }

    public static class BlockData implements Serializable, Json.Serializable {
        public String type;
        public int x;
        public int y;
        public boolean isFlipped;     // Ensure this field is present
        public boolean isChestOpen;
        public ChestData chestData;
        public HashMap<String, Object> extraData;

        public BlockData() {
            this.extraData = new HashMap<>();
        }

        public BlockData(String type, int x, int y) {
            this.type = type;
            this.x = x;
            this.y = y;
            this.extraData = new HashMap<>();
            this.isFlipped = false;
            this.isChestOpen = false;
        }

        @Override
        public void write(Json json) {
            json.writeValue("type", type);
            json.writeValue("x", x);
            json.writeValue("y", y);
            json.writeValue("isFlipped", isFlipped);   // Make sure we're writing this
            json.writeValue("isChestOpen", isChestOpen);
            json.writeValue("extraData", extraData, HashMap.class);

            if (chestData != null) {
                json.writeValue("chestData", chestData);
            }
        }

        @Override
        public void read(Json json, JsonValue jsonData) {
            type = jsonData.getString("type");
            x = jsonData.getInt("x");
            y = jsonData.getInt("y");
            isFlipped = jsonData.getBoolean("isFlipped", false); // Reading flipped state
            isChestOpen = jsonData.getBoolean("isChestOpen", false);
            extraData = json.readValue(HashMap.class, jsonData.get("extraData"));
            chestData = json.readValue(ChestData.class, jsonData.get("chestData"));
        }

        public BlockData copy() {
            BlockData copy = new BlockData();
            copy.type = this.type;
            copy.x = this.x;
            copy.y = this.y;
            copy.isFlipped = this.isFlipped;
            copy.isChestOpen = this.isChestOpen;
            copy.extraData = new HashMap<>(this.extraData);
            if (this.chestData != null) {
                copy.chestData = this.chestData.copy();
            }
            return copy;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/data/ChestData.java
================
package io.github.pokemeetup.system.data;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonValue;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class ChestData implements Serializable, Json.Serializable,ItemContainer {
    public static final int CHEST_SIZE = 27;
    private static final long serialVersionUID = 1L;
    public UUID chestId;
    public List<ItemData> items;
    public Vector2 position;
    public boolean isDirty;
    public transient InventorySlotData[] slotDataArray;

    public List<ItemData> getItems() {
        return items;
    }

    public void setItems(List<ItemData> items) {
        this.items = items;
    }

    public ChestData() {
        this.chestId = UUID.randomUUID();
        this.items = new ArrayList<>(CHEST_SIZE);
        this.position = new Vector2(0, 0);
        initializeSlots();
    }

    public ChestData(int x, int y) {
        this.chestId = UUID.randomUUID();
        this.items = new ArrayList<>(CHEST_SIZE);
        this.position = new Vector2(x, y);
        this.isDirty = false;
        initializeSlots();
    }

    private void initializeSlots() {
        // Clear and initialize items list
        if (items == null) {
            items = new ArrayList<>(CHEST_SIZE);
        }
        items.clear();
        for (int i = 0; i < CHEST_SIZE; i++) {
            items.add(null);
        }

        // Initialize slot data array
        initializeSlotDataArray();
    }

    public InventorySlotData getSlotData(int index) {
        if (slotDataArray == null) {
            initializeSlotDataArray();
        }

        if (index >= 0 && index < CHEST_SIZE) {
            return slotDataArray[index];
        }
        return null;
    }

    @Override
    public ItemData getItemAt(int index) {
        if (items == null) {
            initializeSlots();
        }

        if (index >= 0 && index < items.size()) {
            return items.get(index);
        }
        return null;
    }

    @Override
    public void setItemAt(int index, ItemData item) {
        if (items == null) {
            initializeSlots();
        }

        if (index >= 0 && index < items.size()) {
            if (item != null) {
                items.set(index, item.copy());
            } else {
                items.set(index, null);
            }
            isDirty = true;
        }
    }

    @Override
    public int getSize() {
        return CHEST_SIZE;
    }



    @Override
    public void write(Json json) {
        json.writeValue("chestId", chestId.toString());
        json.writeValue("position", position);
        json.writeValue("isDirty", isDirty);
        json.writeValue("items", items, ArrayList.class, ItemData.class);
    }

    @Override
    public void read(Json json, JsonValue jsonData) {
        chestId = UUID.fromString(jsonData.getString("chestId"));
        position = json.readValue(Vector2.class, jsonData.get("position"));
        isDirty = jsonData.getBoolean("isDirty", false);
        items = json.readValue(ArrayList.class, ItemData.class, jsonData.get("items"));
        initializeSlotDataArray();
    }

    public void initializeSlotDataArray() {
        if (slotDataArray == null) {
            slotDataArray = new InventorySlotData[CHEST_SIZE];
            for (int i = 0; i < CHEST_SIZE; i++) {
                slotDataArray[i] = new InventorySlotData(i, InventorySlotData.SlotType.CHEST, this);
            }
        }
    }


    public ChestData copy() {
        ChestData copy = new ChestData((int)position.x, (int)position.y);
        copy.chestId = UUID.fromString(this.chestId.toString()); // Deep copy UUID
        copy.isDirty = this.isDirty;

        // Deep copy items
        if (this.items != null) {
            for (int i = 0; i < this.items.size(); i++) {
                ItemData item = this.items.get(i);
                if (item != null) {
                    copy.items.set(i, item.copy());
                }
            }
        }

        return copy;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("ChestData{id=").append(chestId)
            .append(", position=").append(position)
            .append(", items=[");

        if (items != null) {
            for (int i = 0; i < items.size(); i++) {
                ItemData item = items.get(i);
                if (item != null) {
                    sb.append("\n  ").append(i).append(": ").append(item);
                }
            }
        }

        sb.append("\n]}");
        return sb.toString();
    }

}

================
File: src/main/java/io/github/pokemeetup/system/data/ItemData.java
================
package io.github.pokemeetup.system.data;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemDataObserver;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class ItemData {
    private final transient List<ItemDataObserver> observers = new ArrayList<>();
    public String itemId;   // Changed to public
    public int count;       // Changed to public
    public UUID uuid;       // Changed to public
    public int durability = -1;     // Changed to public
    public int maxDurability = -1;  // Changed to public

    public ItemData() {
        this.uuid = UUID.randomUUID();
    }

    public ItemData(String itemId, int count, UUID uuid) {
        this.itemId = itemId;
        this.count = count;
        this.uuid = uuid != null ? uuid : UUID.randomUUID();

        // Initialize durability from item template
        Item itemTemplate = ItemManager.getItemTemplate(itemId);
        if (itemTemplate != null) {
            this.durability = itemTemplate.getMaxDurability();
            this.maxDurability = itemTemplate.getMaxDurability();
        } else {
            this.durability = -1;
            this.maxDurability = -1;
        }
    }

    public ItemData(String itemId, int count) {
        this.itemId = itemId;
        this.count = count;
        this.uuid = UUID.randomUUID();
    }


    public ItemData(String itemId) {
        this.itemId = itemId;
        this.count = 1;
        this.uuid = UUID.randomUUID();
    }

    public ItemData(ItemData other) {
        this.itemId = other.itemId;
        this.count = other.count;
        this.uuid = other.uuid != null ? other.uuid : UUID.randomUUID();
        this.durability = other.durability;
        this.maxDurability = other.maxDurability;
    }

    public boolean isBroken() {
        return maxDurability > 0 && durability <= 0;
    }


    public void updateDurability(int amount) {
        if (maxDurability > 0) {
            int oldDurability = durability;
            durability = Math.max(0, Math.min(maxDurability, durability + amount));

            if (oldDurability != durability) {
                notifyObservers();
            }
        }
    }public void addObserver(ItemDataObserver observer) {
        if (observer != null && !observers.contains(observer)) {
            observers.add(observer);
        }
    }

    public void removeObserver(ItemDataObserver observer) {
        observers.remove(observer);
    }


    private void notifyObservers() {
        for (ItemDataObserver observer : observers) {
            observer.onItemDataChanged(this);
        }
    }


    public int getDurability() {
        return durability;
    }

    public void setDurability(int durability) {
        this.durability = durability;
        if (this.maxDurability > 0 && this.durability > this.maxDurability) {
            this.durability = this.maxDurability;
        }
        notifyObservers();
    }

    public boolean hasDurability() {
        return maxDurability > 0;
    }

    private String normalizeItemId(String itemId) {
        String normalized = itemId.toLowerCase();
        if (!normalized.endsWith("_item")) {
            normalized += "_item";
        }
        return normalized;
    }

    public String getItemId() {
        return itemId;
    }

    public void setItemId(String itemId) {
        this.itemId = itemId.toLowerCase(); // Normalize to lowercase

        // Retrieve item template using the consistent itemId
        Item itemTemplate = ItemManager.getItemTemplate(this.itemId);
        if (itemTemplate != null) {
            if (this.maxDurability == -1) {
                this.maxDurability = itemTemplate.getMaxDurability();
            }

            if (this.durability == -1) {
                this.durability = this.maxDurability;
            }

            if (this.maxDurability > 0 && this.durability > this.maxDurability) {
                this.durability = this.maxDurability;
            }
        }
    }



    public int getMaxDurability() {
        return maxDurability;
    }

    public void setMaxDurability(int maxDurability) {
        this.maxDurability = maxDurability;
    }

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        if (count < 0) {
            GameLogger.error("Attempted to set negative count: " + count);
            this.count = 0;
            return;
        }

        Item template = ItemManager.getItemTemplate(itemId);
        if (template != null && !template.isStackable()) {
            this.count = Math.min(1, count);
            GameLogger.info("Set count=1 for unstackable item: " + itemId);
        } else {
            this.count = Math.min(count, Item.MAX_STACK_SIZE);
            GameLogger.info("Set count=" + this.count + " for " + itemId);
        }
        notifyObservers(); // Notify when count changes
    }

    public UUID getUuid() {
        if (uuid == null) {
            uuid = UUID.randomUUID();
        }
        return uuid;
    }


    public void setUuid(UUID uuid) {
        this.uuid = uuid;
    }


    public boolean isEmpty() {
        return this.count <= 0;
    }

    public ItemData copyWithUUID() {
        return new ItemData(this.itemId, this.count, UUID.randomUUID());
    }


    @Override
    public String toString() {
        return "ItemData{" +
            "itemId='" + itemId + '\'' +
            ", count=" + count +
            ", uuid=" + uuid +
            '}';
    }
    public float getDurabilityPercentage() {
        if (maxDurability > 0) {
            return (float) durability / (float) maxDurability;
        } else {
            return 0f;
        }
    }

    public ItemData copy() {
        ItemData copy = new ItemData(this.itemId, this.count, this.uuid);
        copy.setDurability(this.durability);
        copy.setMaxDurability(this.maxDurability);
        return copy;
    }


    public boolean isValid() {
        if (itemId == null || itemId.trim().isEmpty()) {
            return false;
        }
        if (count <= 0) {
            return false;
        }
        if (uuid == null) {
            uuid = UUID.randomUUID(); // Auto-generate UUID if missing
        }
        return ItemManager.getItem(itemId) != null; // Verify item exists in manager
    }

}

================
File: src/main/java/io/github/pokemeetup/system/data/PlayerData.java
================
package io.github.pokemeetup.system.data;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.PokemonParty;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

public class PlayerData {
    private String username;
    private float x;
    private float y;
    private String direction;
    private boolean isMoving;
    private boolean wantsToRun;
    private List<ItemData> inventoryItems;
    private List<PokemonData> partyPokemon;

    private String characterType = "boy";

    public PlayerData() {
        this.direction = "down";
        this.inventoryItems = new ArrayList<>();
        this.partyPokemon = new ArrayList<>();
    }

    public PlayerData(String username) {
        this();
        this.username = username;
    }

    public void updateFromPlayer(Player player) {
        if (player == null) {
            GameLogger.error("Cannot update from null player");
            return;
        }

        try {
            this.x = player.getX();
            this.y = player.getY();
            this.direction = player.getDirection();
            this.isMoving = player.isMoving();
            this.wantsToRun = player.isRunning();

            // Update the character type from the player instance.
            this.setCharacterType(player.getCharacterType());

            this.inventoryItems = new ArrayList<>(Collections.nCopies(Inventory.INVENTORY_SIZE, null));
            this.partyPokemon = new ArrayList<>(Collections.nCopies(PokemonParty.MAX_PARTY_SIZE, null));

            if (player.getInventory() != null) {
                List<ItemData> items = player.getInventory().getAllItems();
                for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                    if (i < items.size() && items.get(i) != null) {
                        ItemData itemData = items.get(i);
                        if (validateItemData(itemData)) {
                            this.inventoryItems.set(i, itemData.copy());
                        }
                    }
                }
            }

            if (player.getPokemonParty() != null) {
                List<Pokemon> currentParty = player.getPokemonParty().getParty();
                for (int i = 0; i < PokemonParty.MAX_PARTY_SIZE; i++) {
                    if (i < currentParty.size() && currentParty.get(i) != null) {
                        Pokemon pokemon = currentParty.get(i);
                        try {
                            PokemonData pokemonData = PokemonData.fromPokemon(pokemon);
                            if (pokemonData.verifyIntegrity()) {
                                this.partyPokemon.set(i, pokemonData);
                            }
                        } catch (Exception e) {
                            GameLogger.error("Failed to convert Pokemon at slot " + i + ": " + e.getMessage());
                        }
                    }
                }
            }
        } catch (Exception ignored) {
        }
    }


    public boolean validateAndRepairState() {
        boolean wasRepaired = false;

        // Validate username
        if (username == null || username.trim().isEmpty()) {
            GameLogger.error("Critical: PlayerData has null/empty username");
            return false;
        }

        // Initialize/repair collections
        if (inventoryItems == null) {
            inventoryItems = new ArrayList<>();
            wasRepaired = true;
        }

        if (partyPokemon == null) {
            partyPokemon = new ArrayList<>();
            wasRepaired = true;
        }

        // Validate position
        if (Float.isNaN(x) || Float.isInfinite(x)) {
            x = 0;
            wasRepaired = true;
        }
        if (Float.isNaN(y) || Float.isInfinite(y)) {
            y = 0;
            wasRepaired = true;
        }

        // Validate direction
        if (direction == null) {
            direction = "down";
            wasRepaired = true;
        }

        if (wasRepaired) {
            GameLogger.info("Repaired PlayerData for: " + username);
        }

        return true;
    }


    /**
     * Applies this saved state to the given player.
     * Note that this implementation always clears the current inventory and Pokémon party.
     */
    public void applyToPlayer(Player player) {
        if (player == null) {
            GameLogger.error("Cannot apply PlayerData to a null player.");
            return;
        }

        // Update basic state (position, direction, movement)
        player.setX(this.x);
        player.setY(this.y);
        player.setDirection(this.direction);
        player.setMoving(this.isMoving);
        player.setRunning(this.wantsToRun);

        // Also update the character type in the Player instance.
        player.setCharacterType(this.characterType);

        if (player.getInventory() != null) {
            player.getInventory().clear();
        }
        if (this.inventoryItems != null) {
            for (ItemData item : this.inventoryItems) {
                if (item != null && item.isValid()) {
                    player.getInventory().addItem(item.copy());
                }
            }
        } else {
            GameLogger.info("No saved inventory items for player: " + username);
        }

        // Always update the Pokémon party: clear the party then add saved Pokémon.
        if (player.getPokemonParty() != null) {
            player.getPokemonParty().clearParty();
        }
        if (this.partyPokemon != null) {
            for (PokemonData pData : this.partyPokemon) {
                if (pData != null && pData.verifyIntegrity()) {
                    Pokemon pokemon = pData.toPokemon();
                    if (pokemon != null) {
                        player.getPokemonParty().addPokemon(pokemon);
                    } else {
                        GameLogger.error("Failed to convert PokemonData to Pokemon for player: " + username);
                    }
                }
            }
        } else {
            GameLogger.info("No saved Pokémon for player: " + username);
        }

        GameLogger.info("Applied saved PlayerData to player: " + username);
    }

    // --- New methods for character type support ---
    public String getCharacterType() {
        return characterType;
    }

    public void setCharacterType(String characterType) {
        this.characterType = characterType;
    }

    public PlayerData copy() {
        PlayerData copy = new PlayerData(this.username);

        copy.setX(this.x);
        copy.setY(this.y);
        copy.setDirection(this.direction);
        copy.setMoving(this.isMoving);
        copy.setWantsToRun(this.wantsToRun);
        copy.setCharacterType(this.characterType);
        if (this.inventoryItems != null) {
            List<ItemData> inventoryCopy = new ArrayList<>();
            for (ItemData item : this.inventoryItems) {
                if (item != null) {
                    inventoryCopy.add(item.copy());
                } else {
                    inventoryCopy.add(null);
                }
            }
            copy.setInventoryItems(inventoryCopy);
        }

        if (this.partyPokemon != null) {
            List<PokemonData> partyCopy = new ArrayList<>();
            for (PokemonData pokemon : this.partyPokemon) {
                if (pokemon != null) {
                    partyCopy.add(pokemon.copy());
                } else {
                    partyCopy.add(null);
                }
            }
            copy.setPartyPokemon(partyCopy);
        }

        return copy;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public float getX() {
        return x;
    }

    public void setX(float x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    public String getDirection() {
        return direction;
    }

    public void setDirection(String direction) {
        this.direction = direction;
    }

    public boolean isMoving() {
        return isMoving;
    }

    public void setMoving(boolean moving) {
        isMoving = moving;
    }

    public boolean isWantsToRun() {
        return wantsToRun;
    }

    public void setWantsToRun(boolean wantsToRun) {
        this.wantsToRun = wantsToRun;
    }

    public List<ItemData> getInventoryItems() {
        return inventoryItems;
    }

    public void setInventoryItems(List<ItemData> items) {
        this.inventoryItems = new ArrayList<>(items);
    }

    public List<PokemonData> getPartyPokemon() {
        return partyPokemon;
    }

    public void setPartyPokemon(List<PokemonData> partyPokemon) {
        this.partyPokemon = partyPokemon;
    }

    private boolean validateItemData(ItemData item) {
        return item != null &&
            item.getItemId() != null &&
            !item.getItemId().isEmpty() &&
            item.getCount() > 0 &&
            item.getCount() <= Item.MAX_STACK_SIZE &&
            ItemManager.getItem(item.getItemId()) != null &&
            item.getUuid() != null;
    }

    @Override
    public String toString() {
        return "io.github.pokemeetup.system.data.PlayerData{" +
            "username='" + username + '\'' +
            ", position=(" + x + "," + y + ")" +
            ", direction='" + direction + '\'' +
            ", inventory=" + (inventoryItems != null ? inventoryItems.size() : "null") + " items" +
            ", party=" + (partyPokemon != null ? partyPokemon.size() : "null") + " pokemon" +
            ", characterType='" + characterType + '\'' +
            '}';
    }
}

================
File: src/main/java/io/github/pokemeetup/system/data/PokemonData.java
================
package io.github.pokemeetup.system.data;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.attacks.LearnableMove;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.utils.GameLogger;

import java.io.Serializable;
import java.util.*;
import java.util.stream.Collectors;

public class PokemonData {
    private final Vector2 position = new Vector2();
    public String name;
    public UUID uuid = UUID.randomUUID();
    public int level;
    public String nature;
    public Pokemon.PokemonType primaryType;
    public Pokemon.PokemonType secondaryType;
    // Stats
    public Stats stats;
    // Moves
    public List<MoveData> moves;
    private int baseHp;
    private int currentExperience = 0;
    private int experienceToNextLevel = 0;

    public int getCurrentExperience() {
        return currentExperience;
    }

    public void setCurrentExperience(int experience) {
        this.currentExperience = Math.max(0, experience);
    }

    public int getExperienceToNextLevel() {
        return experienceToNextLevel;
    }

    public void setExperienceToNextLevel(int exp) {
        this.experienceToNextLevel = Math.max(0, exp);
    }
    private int baseAttack;
    private int baseDefense;
    private int baseSpAtk;
    private int baseSpDef;
    private int baseSpeed;
    private float width;
    private float height;
    private List<LearnableMove> learnableMoves;
    private List<String> tmMoves;
    private final HashMap<UUID, WildPokemonData> wildPokemon;
    public PokemonData() {
        this.uuid = UUID.randomUUID();
        this.learnableMoves = new ArrayList<>();
        this.moves = new ArrayList<>();
        this.tmMoves = new ArrayList<>();
        wildPokemon = new HashMap<>();
        this.stats = new Stats();
        this.currentHp = stats.getHp();
    }    public int getCurrentHp() {
        return currentHp;
    }

    public void setCurrentHp(int hp) {
        this.currentHp = Math.min(Math.max(0, hp), stats != null ? stats.getHp() : hp);
    }

    public static PokemonData fromPokemon(Pokemon pokemon) {
        if (pokemon == null) {
            throw new IllegalArgumentException("Cannot create PokemonData from null Pokemon.");
        }
        // (Optionally force a recalculation here:)
        pokemon.calculateStats();
        PokemonData data = new PokemonData();
        data.setName(pokemon.getName());
        data.setLevel(pokemon.getLevel());
        data.setNature(pokemon.getNature());
        data.setUuid(pokemon.getUuid());
        data.setPrimaryType(pokemon.getPrimaryType());
        data.setSecondaryType(pokemon.getSecondaryType());
        data.setCurrentHp(pokemon.getCurrentHp());

        // Save species base stats
        data.setBaseHp(pokemon.getSpeciesBaseHp());
        data.setBaseAttack(pokemon.getSpeciesBaseAttack());
        data.setBaseDefense(pokemon.getSpeciesBaseDefense());
        data.setBaseSpAtk(pokemon.getSpeciesBaseSpAtk());
        data.setBaseSpDef(pokemon.getSpeciesBaseSpDef());
        data.setBaseSpeed(pokemon.getSpeciesBaseSpeed());

        data.setCurrentExperience(pokemon.getCurrentExperience());
        data.setExperienceToNextLevel(pokemon.getExperienceForNextLevel());
        if (pokemon.getMoves() != null) {
            List<MoveData> moveDataList = pokemon.getMoves().stream()
                .map(MoveData::fromMove)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
            data.setMoves(moveDataList);
        }
        // IMPORTANT: Create a new PokemonData.Stats from the Pokemon's stats
        data.setStats(new PokemonData.Stats(pokemon.getStats()));
        return data;
    }


    public boolean verifyIntegrity() {
        if (this.name == null || this.name.isEmpty()) {
            GameLogger.error("PokemonData integrity check failed: name is null or empty");
            return false;
        }

        if (this.level <= 0) {
            GameLogger.error("PokemonData integrity check failed: level is non-positive");
            return false;
        }

        return true;
    }



    public void removeWildPokemon(UUID id) {
        wildPokemon.remove(id);
    }

    public Vector2 getPosition() {
        return position.cpy();
    }

    public void setPosition(float x, float y) {
        this.position.set(x, y);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public UUID getUuid() {
        if (uuid == null) {
            uuid = UUID.randomUUID();
        }
        return uuid;
    }

    public void setUuid(UUID uuid) {
        this.uuid = uuid != null ? uuid : UUID.randomUUID();
    }

    public int getLevel() {
        return level;
    }

    public void setLevel(int level) {
        this.level = level;
    }

    public String getNature() {
        return nature;
    }

    public void setNature(String nature) {
        this.nature = nature;
    }

    public Pokemon.PokemonType getPrimaryType() {
        return primaryType;
    }

    public void setPrimaryType(Pokemon.PokemonType primaryType) {
        this.primaryType = primaryType != null ? primaryType : Pokemon.PokemonType.NORMAL; // Default to NORMAL
    }

    public Pokemon.PokemonType getSecondaryType() {
        return secondaryType;
    }

    public void setSecondaryType(Pokemon.PokemonType secondaryType) {
        this.secondaryType = secondaryType;
    }

    public Stats getStats() {
        // Ensure stats are never null
        if (this.stats == null) {
            this.stats = new Stats();
        }
        return stats;
    }

    public void setStats(Stats stats) {
        this.stats = stats != null ? stats.copy() : new Stats();
    }


    public int getBaseHp() {
        return baseHp;
    }

    public void setBaseHp(int baseHp) {
        this.baseHp = baseHp;
    }

    public int getBaseAttack() {
        return baseAttack;
    }

    public void setBaseAttack(int baseAttack) {
        this.baseAttack = baseAttack;
    }

    public int getBaseDefense() {
        return baseDefense;
    }

    public void setBaseDefense(int baseDefense) {
        this.baseDefense = baseDefense;
    }

    public int getBaseSpAtk() {
        return baseSpAtk;
    }

    public void setBaseSpAtk(int baseSpAtk) {
        this.baseSpAtk = baseSpAtk;
    }

    public int getBaseSpDef() {
        return baseSpDef;
    }

    public void setBaseSpDef(int baseSpDef) {
        this.baseSpDef = baseSpDef;
    }

    public int getBaseSpeed() {
        return baseSpeed;
    }

    public void setBaseSpeed(int baseSpeed) {
        this.baseSpeed = baseSpeed;
    }

    public float getWidth() {
        return width;
    }

    public void setWidth(float width) {
        this.width = width;
    }

    public float getHeight() {
        return height;
    }

    public void setHeight(float height) {
        this.height = height;
    }

    public List<MoveData> getMoves() {
        return moves;
    }

    public void setMoves(List<MoveData> moves) {
        this.moves = moves != null ? new ArrayList<>(moves) : new ArrayList<>();
    }


    public PokemonData copy() {
        PokemonData copy = new PokemonData();
        copy.baseHp = this.baseHp;
        copy.baseAttack = this.baseAttack;
        copy.baseDefense = this.baseDefense;
        copy.baseSpAtk = this.baseSpAtk;
        copy.baseSpDef = this.baseSpDef;
        copy.baseSpeed = this.baseSpeed;

        if (this.tmMoves != null) {
            copy.tmMoves = new ArrayList<>(this.tmMoves);
        }

        copy.name = this.name;
        copy.currentHp = this.currentHp;
        copy.level = this.level;
        copy.nature = this.nature;
        copy.uuid = this.uuid;
        copy.primaryType = this.primaryType;
        copy.secondaryType = this.secondaryType;
        // Ensure stats are never null in copies
        copy.stats = this.stats != null ? this.stats.copy() : new Stats();


        copy.currentExperience = this.currentExperience;
        copy.experienceToNextLevel = this.experienceToNextLevel;
        if (this.moves != null) {
            copy.moves = new ArrayList<>();

            for (MoveData move : this.moves) {
                copy.moves.add(move.copy());
            }
        }

        if (this.learnableMoves != null) {
            copy.learnableMoves = new ArrayList<>(this.learnableMoves);
        }

        return copy;
    }
    public void heal(int amount) {
        if (this.stats != null) {
            this.currentHp = Math.min(this.stats.getHp(), this.currentHp + amount);
        }
    }
    private int currentHp;public Pokemon toPokemon() {
        if (name == null || name.isEmpty()) {
            throw new IllegalStateException("Pokemon name is missing.");
        }
        // Create the Pokemon using the full constructor that takes species base stats:
        Pokemon pokemon = new Pokemon(name, level, baseHp, baseAttack, baseDefense, baseSpAtk, baseSpDef, baseSpeed);
        pokemon.setUuid(uuid);
        pokemon.setNature(nature);
        pokemon.setPrimaryType(primaryType);
        pokemon.setSecondaryType(secondaryType);
        // Recalculate stats in case they need to be recomputed:
        pokemon.calculateStats();
        pokemon.setCurrentHp(pokemon.getStats().getHp());
        // Convert moves and add them
        for (MoveData moveData : moves) {
            Move move = moveData.toMove();
            if (move != null) {
                pokemon.getMoves().add(move);
            }
        }
        return pokemon;
    }



    public static class Stats {
        public int hp;
        public int attack;
        public int defense;
        public int specialAttack;
        public int specialDefense;
        public int speed;
        public int[] ivs = new int[6];
        public int[] evs = new int[6];

        public Stats() {
            // Initialize with default values
            this.hp = 1;
            this.attack = 1;
            this.defense = 1;
            this.specialAttack = 1;
            this.specialDefense = 1;
            this.speed = 1;
            // Initialize IVs and EVs with zeros
            this.ivs = new int[6];
            this.evs = new int[6];
        }


        public Stats(Pokemon.Stats stats) {
            if (stats != null) {
                this.hp = stats.getHp();
                this.attack = stats.getAttack();
                this.defense = stats.getDefense();
                this.specialAttack = stats.getSpecialAttack();
                this.specialDefense = stats.getSpecialDefense();
                this.speed = stats.getSpeed();
                System.arraycopy(stats.ivs, 0, this.ivs, 0, 6);
                System.arraycopy(stats.evs, 0, this.evs, 0, 6);
            }
        }

        public int getHp() {
            return hp;
        }

        public void setHp(int hp) {
            this.hp = hp;
        }

        public int getAttack() {
            return attack;
        }

        public void setAttack(int attack) {
            this.attack = attack;
        }

        public int getDefense() {
            return defense;
        }

        public void setDefense(int defense) {
            this.defense = defense;
        }

        public int getSpecialAttack() {
            return specialAttack;
        }

        public void setSpecialAttack(int specialAttack) {
            this.specialAttack = specialAttack;
        }

        public int getSpecialDefense() {
            return specialDefense;
        }

        public void setSpecialDefense(int specialDefense) {
            this.specialDefense = specialDefense;
        }

        public int getSpeed() {
            return speed;
        }

        public void setSpeed(int speed) {
            this.speed = speed;
        }

        public Stats copy() {
            Stats copy = new Stats();
            copy.hp = this.hp;
            copy.attack = this.attack;
            copy.defense = this.defense;
            copy.specialAttack = this.specialAttack;
            copy.specialDefense = this.specialDefense;
            copy.speed = this.speed;
            copy.ivs = this.ivs.clone();
            copy.evs = this.evs.clone();
            return copy;
        }
    }

    // Nested MoveData class
    public static class MoveData {
        public String name;
        public Pokemon.PokemonType type;
        public int power;
        public int accuracy;
        public int pp;
        public int maxPp;
        public boolean isSpecial;
        public String description; // Add description field
        public MoveEffectData effect; // Add effect field
        public boolean canFlinch;

        public MoveData() {
        }

        public int getAccuracy() {
            return accuracy;
        }

        public MoveEffectData getEffect() {
            return effect;
        }

        public boolean isCanFlinch() {
            return canFlinch;
        }

        public void setAccuracy(int accuracy) {
            this.accuracy = accuracy;
        }

        public void setEffect(MoveEffectData effect) {
            this.effect = effect;
        }

        public void setCanFlinch(boolean canFlinch) {
            this.canFlinch = canFlinch;
        }

        public MoveData(String name, Pokemon.PokemonType type, int power, int accuracy, int pp, int maxPp, boolean isSpecial, String description, MoveEffectData effect, boolean canFlinch) {
            this.name = name;
            this.type = type;
            this.power = power;
            this.accuracy = accuracy;
            this.pp = pp;
            this.maxPp = maxPp;
            this.isSpecial = isSpecial;
            this.description = description;
            this.effect = effect;
            this.canFlinch = canFlinch;
        }

        public static MoveData fromMove(Move move) {
            if (move == null) return null;
            MoveData moveData = new MoveData();
            moveData.name = move.getName();
            moveData.type = move.getType();
            moveData.power = move.getPower();
            moveData.accuracy = move.getAccuracy();
            moveData.pp = move.getPp();
            moveData.maxPp = move.getMaxPp();
            moveData.isSpecial = move.isSpecial();
            moveData.description = move.getDescription();
            moveData.canFlinch = move.canFlinch();


            return moveData;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Pokemon.PokemonType getType() {
            return type;
        }

        public void setType(Pokemon.PokemonType type) {
            this.type = type;
        }

        private int currentExperience = 0;
        private int experienceToNextLevel = 0;

        // Add getters and setters
        public int getCurrentExperience() {
            return currentExperience;
        }

        public void setCurrentExperience(int experience) {
            this.currentExperience = Math.max(0, experience);
        }

        public int getExperienceToNextLevel() {
            return experienceToNextLevel;
        }

        public void setExperienceToNextLevel(int exp) {
            this.experienceToNextLevel = Math.max(0, exp);
        }

        public int getPower() {
            return power;
        }

        public void setPower(int power) {
            this.power = power;
        }

        public int getPp() {
            return pp;
        }

        public void setPp(int pp) {
            this.pp = pp;
        }

        public int getMaxPp() {
            return maxPp;
        }

        public void setMaxPp(int maxPp) {
            this.maxPp = maxPp;
        }

        public boolean isSpecial() {
            return isSpecial;
        }

        public void setSpecial(boolean special) {
            isSpecial = special;
        }

        public String getDescription() {
            return description;
        }

        public void setDescription(String description) {
            this.description = description;
        }

        public Move toMove() {
            if (name == null || name.isEmpty()) {
                GameLogger.error("Move name is missing.");
                return null;
            }

            if (type == null) {
                GameLogger.error("Move type is null for move " + name + ", setting to NORMAL.");
                type = Pokemon.PokemonType.NORMAL;
            }

            Move.Builder builder = new Move.Builder(name, type)
                .power(power)
                .accuracy(accuracy)
                .pp(pp) // This incorrectly sets maxPp = pp, which we will correct below.
                .special(isSpecial)
                .description(description)
                .canFlinch(canFlinch);

            // This part is missing in your original code but is a latent bug where effects aren't loaded.
            if (this.effect != null) {
                builder.effect(this.effect.toMoveEffect());
            }

            Move move = builder.build();

            // FIX: The Builder's pp() method incorrectly sets maxPp. We override it here
            // with the correct maxPp value that was saved.
            if (this.maxPp > 0) {
                move.setMaxPp(this.maxPp);
            } else {
                // Fallback for older save files that might not have maxPp.
                // In this case, the max PP will be the last-saved current PP.
                move.setMaxPp(this.pp);
            }

            // As a safety check, ensure the current PP does not exceed the (now correct) max PP.
            if (move.getPp() > move.getMaxPp()) {
                move.setPp(move.getMaxPp());
            }

            return move;
        }

        public MoveData copy() {
            return new MoveData(name, type, power, accuracy, pp, maxPp, isSpecial, description, effect, canFlinch);
        }

        public static class MoveEffectData {
            public Pokemon.Status statusEffect;
            public Map<String, Integer> statModifiers;
            public String effectType;
            public float chance;
            public String animation;
            public String sound;
            public int duration;

            public MoveEffectData(Pokemon.Status statusEffect, Map<String, Integer> statModifiers, String effectType, float chance, String animation, String sound, int duration) {
                this.statusEffect = statusEffect;
                this.statModifiers = statModifiers;
                this.effectType = effectType;
                this.chance = chance;
                this.animation = animation;
                this.sound = sound;
                this.duration = duration;
            }

            public MoveEffectData() {
            }

            public static MoveEffectData fromMoveEffect(Move.MoveEffect moveEffect) {
                if (moveEffect == null) return null;
                MoveEffectData effectData = new MoveEffectData();
                effectData.statusEffect = moveEffect.getStatusEffect();
                effectData.statModifiers = new HashMap<>(moveEffect.getStatModifiers());
                effectData.effectType = moveEffect.getEffectType();
                effectData.chance = moveEffect.getChance();
                effectData.animation = moveEffect.getAnimation();
                effectData.sound = moveEffect.getSound();
                effectData.duration = moveEffect.getDuration();
                return effectData;
            }

            public Pokemon.Status getStatusEffect() {
                return statusEffect;
            }

            public void setStatusEffect(Pokemon.Status statusEffect) {
                this.statusEffect = statusEffect;
            }

            public Map<String, Integer> getStatModifiers() {
                return statModifiers;
            }

            public void setStatModifiers(Map<String, Integer> statModifiers) {
                this.statModifiers = statModifiers;
            }

            public String getEffectType() {
                return effectType;
            }

            public void setEffectType(String effectType) {
                this.effectType = effectType;
            }

            public float getChance() {
                return chance;
            }

            public void setChance(float chance) {
                this.chance = chance;
            }

            public String getAnimation() {
                return animation;
            }

            public void setAnimation(String animation) {
                this.animation = animation;
            }

            public String getSound() {
                return sound;
            }

            public void setSound(String sound) {
                this.sound = sound;
            }

            public int getDuration() {
                return duration;
            }

            public void setDuration(int duration) {
                this.duration = duration;
            }

            public Move.MoveEffect toMoveEffect() {
                Move.MoveEffect moveEffect = new Move.MoveEffect();
                moveEffect.setStatusEffect(statusEffect);
                moveEffect.setStatModifiers(statModifiers != null ? new HashMap<>(statModifiers) : new HashMap<>());
                moveEffect.setEffectType(effectType);
                moveEffect.setChance(chance);
                moveEffect.setAnimation(animation);
                moveEffect.setSound(sound);
                moveEffect.setDuration(duration);
                return moveEffect;
            }
        }
    }

    public static class WildPokemonData implements Serializable {
        private String name;
        private int level;
        private Vector2 position;
        private String direction;
        private boolean isMoving;
        private long spawnTime;
        private Pokemon.PokemonType primaryType;
        private Pokemon.PokemonType secondaryType;
        private float currentHp;
        private Stats stats;
        private List<MoveData> moves;
        private UUID uuid;

        public WildPokemonData() {
            this.position = new Vector2();
            this.stats = new Stats();
            this.moves = new ArrayList<>();
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getLevel() {
            return level;
        }

        public void setLevel(int level) {
            this.level = level;
        }

        public Vector2 getPosition() {
            return position;
        }

        public void setPosition(Vector2 position) {
            this.position = position;
        }

        public String getDirection() {
            return direction;
        }

        public void setDirection(String direction) {
            this.direction = direction;
        }

        public boolean isMoving() {
            return isMoving;
        }

        public void setMoving(boolean moving) {
            isMoving = moving;
        }

        public long getSpawnTime() {
            return spawnTime;
        }

        public void setSpawnTime(long spawnTime) {
            this.spawnTime = spawnTime;
        }

        public Pokemon.PokemonType getPrimaryType() {
            return primaryType;
        }

        public void setPrimaryType(Pokemon.PokemonType type) {
            this.primaryType = type;
        }

        public Pokemon.PokemonType getSecondaryType() {
            return secondaryType;
        }

        public void setSecondaryType(Pokemon.PokemonType type) {
            this.secondaryType = type;
        }

        public float getCurrentHp() {
            return currentHp;
        }

        public void setCurrentHp(float hp) {
            this.currentHp = hp;
        }

        public Stats getStats() {
            return stats;
        }

        public void setStats(Stats stats) {
            this.stats = stats;
        }

        public List<MoveData> getMoves() {
            return moves;
        }

        public void setMoves(List<MoveData> moves) {
            this.moves = moves;
        }

        public UUID getUuid() {
            return uuid;
        }

        public void setUuid(UUID uuid) {
            this.uuid = uuid;
        }
    }

    public static class MoveEffectData {
        private String type;
        private float chance;
        private Pokemon.Status status;
        private Map<String, Integer> statChanges = new HashMap<>();

        public MoveEffectData(String type, float chance) {
            this.type = type;
            this.chance = chance;
        }

        public String getType() {
            return type;
        }


        public Pokemon.Status getStatus() {
            return status;
        }

        public void setStatus(Pokemon.Status status) {
            this.status = status;
        }

        public void setStatChanges(Map<String, Integer> changes) {
            this.statChanges = changes;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/data/WorldData.java
================
package io.github.pokemeetup.system.data;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Json;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.JsonConfig;

import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class WorldData {

    private final Object timeLock = new Object();
    private final Object saveLock = new Object();
    private final Map<UUID, WildPokemon> wildPokemonMap = new ConcurrentHashMap<>();
    private final Map<Vector2, List<WorldObject>> chunkObjects;
    private double worldTimeInMinutes = 480.0;
    private long playedTime = 0L;
    private float dayLength = 10.0f;
    private PokemonData pokemonData;
    private String name;
    private Set<UUID> playerUUIDs;
    private long lastPlayed;
    private WorldConfig config;
    private boolean isDirty;
    private BlockSaveData blockData;
    private Map<Vector2, Chunk> chunks;
    private HashMap<String, PlayerData> players;
    private String username;
    private Map<Vector2, List<WorldObject>> dynamicObjects;
    private boolean commandsAllowed;

    public WorldData(String name) {
        this();
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("World name cannot be null or empty");
        }
        this.name = name.trim();
    }

    public WorldData() {
        this.playerUUIDs = new HashSet<>();
        this.players = new HashMap<>();
        this.pokemonData = new PokemonData();
        this.lastPlayed = System.currentTimeMillis();
        this.chunks = new HashMap<>();
        this.chunkObjects = new HashMap<>();
        this.commandsAllowed = false;
    }

    public WorldData(String name, long lastPlayed, WorldConfig config) {
        this();
        this.name = name;
        this.pokemonData = new PokemonData();
        this.lastPlayed = lastPlayed;
        this.config = config;
        this.commandsAllowed = false;
    }

    public WorldData(String name, long lastPlayed, WorldConfig config, String username) {
        this(name, lastPlayed, config);
        this.username = username;
        this.commandsAllowed = false;
    }


    public static WorldData fromJson(String jsonStr) {
        try {
            Json json = JsonConfig.getInstance();
            return json.fromJson(WorldData.class, jsonStr);
        } catch (Exception e) {
            GameLogger.error("Failed to parse WorldData from JSON: " + e.getMessage());
            return null;
        }
    }

    public WorldData copy() {
        WorldData copy = new WorldData(this.name);
        synchronized (saveLock) {
            copy.commandsAllowed = this.commandsAllowed;
            copy.worldTimeInMinutes = this.worldTimeInMinutes;
            copy.playedTime = this.playedTime;
            copy.dayLength = this.dayLength;
            copy.lastPlayed = this.lastPlayed;
            copy.isDirty = this.isDirty;
            copy.username = this.username;

            // Copy config
            if (this.config != null) {
                WorldConfig configCopy = new WorldConfig(this.config.getSeed());
                configCopy.setTreeSpawnRate(this.config.getTreeSpawnRate());
                configCopy.setPokemonSpawnRate(this.config.getPokemonSpawnRate());
                configCopy.setTileSpawnX(this.config.getTileSpawnX());
                configCopy.setTileSpawnY(this.config.getTileSpawnY());
                copy.config = configCopy;
            }
            if (this.players != null) {
                HashMap<String, PlayerData> playersCopy = new HashMap<>();
                for (Map.Entry<String, PlayerData> entry : this.players.entrySet()) {
                    playersCopy.put(entry.getKey(), entry.getValue().copy());
                }
                copy.setPlayers(playersCopy);
            } else {
                copy.setPlayers(new HashMap<>());
            }
            // Copy player UUIDs
            if (this.playerUUIDs != null) {
                copy.playerUUIDs = new HashSet<>(this.playerUUIDs);
            }

            // Copy Pokemon data
            if (this.pokemonData != null) {
                copy.pokemonData = this.pokemonData.copy();
            }

            // Copy block data if exists
            if (this.blockData != null) {
                copy.blockData = this.blockData.copy();
            }

            // Copy chunk references (chunks themselves are managed separately)
            if (this.chunks != null) {
                copy.chunks = new HashMap<>(this.chunks);
            }

            // Deep copy chunk objects
            if (this.chunkObjects != null) {
                copy.dynamicObjects = new HashMap<>();
                for (Map.Entry<Vector2, List<WorldObject>> entry : this.chunkObjects.entrySet()) {
                    List<WorldObject> objectsCopy = new ArrayList<>();
                    for (WorldObject obj : entry.getValue()) {
                        objectsCopy.add(obj.copy());
                    }
                    copy.dynamicObjects.put(entry.getKey().cpy(), objectsCopy);
                }
            }


            return copy;
        }
    }

    public Map<Vector2, Chunk> getChunks() {
        return chunks;
    }


    public Map<Vector2, List<WorldObject>> getChunkObjects() {
        return chunkObjects;
    }

    public double getWorldTimeInMinutes() {
        synchronized (timeLock) {
            return worldTimeInMinutes;
        }
    }

    public void setWorldTimeInMinutes(double time) {
        synchronized (timeLock) {
            this.worldTimeInMinutes = time;
            GameLogger.info("Set world time to: " + time);
        }
    }

    public long getPlayedTime() {
        synchronized (timeLock) {
            return playedTime;
        }
    }

    public void setPlayedTime(long time) {
        synchronized (timeLock) {
            this.playedTime = time;
            GameLogger.info("Set played time to: " + time);
        }
    }

    public void validateAndRepairWorld() {
        if (this.players == null) {
            this.players = new HashMap<>();
            isDirty = true;
        }
        if (this.pokemonData == null) {
            this.pokemonData = new PokemonData();
            setDirty(true);
        }

        // Validate Pokemon in player data
        if (players != null) {
            for (PlayerData player : players.values()) {
                if (player.getPartyPokemon() != null) {
                    List<PokemonData> validPokemon = new ArrayList<>();
                    for (PokemonData pokemon : player.getPartyPokemon()) {
                        if (pokemon != null) {
                            validPokemon.add(pokemon);
                            setDirty(true);
                        }
                    }
                    if (!validPokemon.isEmpty()) {
                        player.setPartyPokemon(validPokemon);
                    }
                }
            }
        }
    }

    public void validateAndRepair() {
        synchronized (timeLock) {
            if (worldTimeInMinutes < 0 || worldTimeInMinutes >= 24 * 60) {
                GameLogger.error("Repairing invalid world time: " + worldTimeInMinutes);
                worldTimeInMinutes = 480.0;
            }

            if (dayLength <= 0) {
                GameLogger.error("Repairing invalid day length: " + dayLength);
                dayLength = 10.0f;
            }

            if (playedTime < 0) {
                GameLogger.error("Repairing invalid played time: " + playedTime);
                playedTime = 0;
            }
        }

        if (blockData == null) {
            GameLogger.error("blockData is null during validation. Blocks may not be loaded correctly.");
        }

        // Validate players data
        if (players != null) {
            for (Map.Entry<String, PlayerData> entry : players.entrySet()) {
                PlayerData playerData = entry.getValue();
                if (playerData.getInventoryItems() == null) {
                    playerData.setInventoryItems(new ArrayList<>());
                }

                // Validate each inventory item
                for (int i = 0; i < playerData.getInventoryItems().size(); i++) {
                    ItemData item = playerData.getInventoryItems().get(i);
                    if (item != null && item.getUuid() == null) {
                        item.setUuid(UUID.randomUUID());
                        GameLogger.info("Generated new UUID for item: " + item.getItemId());
                    }
                }
            }
        }
    }

    public void save() {
        synchronized (saveLock) {
            try {
                GameLogger.info("Saving world data - Time: " + worldTimeInMinutes +
                    " Played Time: " + playedTime +
                    " Day Length: " + dayLength);

                setDirty(true);
                WorldManager worldManager = WorldManager.getInstance();
                worldManager.saveWorld(this);

                GameLogger.info("Successfully saved world: " + name);

            } catch (Exception e) {
                GameLogger.error("Failed to save world: " + name + " - " + e.getMessage());
            }
        }
    }

    public void save(boolean createBackup) {
        synchronized (saveLock) {
            try {
                validateAndRepairWorld();
                if (createBackup) {
                    String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
                    String backupName = name + "_backup_" + timestamp;

                    WorldData backup = new WorldData(backupName);
                    backup.setConfig(this.config);
                    backup.setWorldTimeInMinutes(this.worldTimeInMinutes);
                    backup.setPlayedTime(this.playedTime);
                    backup.setDayLength(this.dayLength);
                    backup.setPlayers(new HashMap<>(this.players));
                    backup.setBlockData(this.blockData);
                    // Save backup
                    WorldManager.getInstance().saveWorld(backup);
                    GameLogger.info("Created backup of world: " + name);
                }
                save();

            } catch (Exception e) {
                GameLogger.error("Failed to save world with backup: " + name + " - " + e.getMessage());
            }
        }
    }

    public boolean commandsAllowed() {
        return commandsAllowed;
    }

    public void setCommandsAllowed(boolean commandsAllowed) {
        synchronized (saveLock) {
            this.commandsAllowed = commandsAllowed;
            isDirty = true;
            GameLogger.info("Commands " + (commandsAllowed ? "enabled" : "disabled") +
                " for world: " + name);
        }
    }


    public void addChunkObjects(Vector2 position, List<WorldObject> objects) {
        chunkObjects.put(position, new ArrayList<>(objects));
    }

    public Object getTimeLock() {
        return timeLock;
    }


    public void updateTime(float deltaTime) {
        synchronized (timeLock) {
            long deltaMillis = (long) (deltaTime * 1000);
            playedTime += deltaMillis;
            double gameMinutesPerSecond = (24 * 60.0) / (dayLength * 60.0);
            double timeToAdd = deltaTime * gameMinutesPerSecond;

            worldTimeInMinutes = (worldTimeInMinutes + timeToAdd) % (24 * 60);


        }
    }

    public float getDayLength() {
        return dayLength;
    }

    public void setDayLength(float dayLength) {
        this.dayLength = dayLength;
    }


    public PokemonData getPokemonData() {
        return pokemonData;
    }

    public void setPokemonData(PokemonData pokemonData) {
        this.pokemonData = pokemonData;
    }

    public BlockSaveData getBlockData() {
        return blockData;
    }

    public void setBlockData(BlockSaveData blockData) {
        this.blockData = blockData;
    }



    public PlayerData getLegacyPlayerData(String username) {
        synchronized (saveLock) {
            PlayerData data = players.get(username);
            if (data != null) {
                return data.copy();
            }
            return null;
        }
    }

    public void savePlayerData(String username, PlayerData data, boolean isMultiplayer) {
        if (isMultiplayer) {
            // Multiplayer mode logic (just store UUID reference)
        } else {
            // Singleplayer mode: store actual data
            if (data != null && username != null) {
                this.players.put(username, data.copy());
                this.isDirty = true;
            }
        }
    }


    public PlayerData getPlayerData(String username, boolean isMultiplayer) {
        if (isMultiplayer) {
            // In multiplayer mode, this should not be used directly
            // Instead, use ServerStorageSystem to get player data
            GameLogger.error("Attempted to get player data directly in multiplayer mode");
            return null;
        } else {
            return getLegacyPlayerData(username);
        }
    }

    public WorldConfig getConfig() {
        return config;
    }

    public void setConfig(WorldConfig config) {
        synchronized (saveLock) {
            this.config = config;
            isDirty = true;
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        synchronized (saveLock) {
            if (name == null || name.trim().isEmpty()) {
                throw new IllegalArgumentException("World name cannot be null or empty");
            }
            this.name = name.trim();
            setDirty(true);
        }
    }

    public long getLastPlayed() {
        return lastPlayed;
    }

    public void setLastPlayed(long lastPlayed) {
        synchronized (saveLock) {
            this.lastPlayed = lastPlayed;
            isDirty = true;
        }
    }

    public Map<String, PlayerData> getPlayers() {
        if (players != null) {
            return Collections.unmodifiableMap(players);
        }
        return null;
    }

    public void setPlayers(HashMap<String, PlayerData> players) {
        this.players = players;
    }


    public void removeWildPokemon(UUID uuid) {
        wildPokemonMap.remove(uuid);
        if (pokemonData != null) {
            pokemonData.removeWildPokemon(uuid);
        }
    }

    public boolean isDirty() {
        return isDirty;
    }

    public void setDirty(boolean dirty) {
        isDirty = dirty;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        synchronized (saveLock) {
            this.username = username;
            isDirty = true;
        }
    }


    @Override
    public String toString() {
        return "WorldData{" +
            "name='" + name + '\'' +
            ", players=" + players.size() +
            ", lastPlayed=" + lastPlayed +
            ", username='" + username + '\'' +
            '}';
    }

    public static class WorldConfig {
        private long seed;
        private float treeSpawnRate = 0.15f;
        private float pokemonSpawnRate = 0.05f;
        ;
        private int tileSpawnX;
        ;
        private int tileSpawnY;

        public WorldConfig() {
        }

        public WorldConfig(long seed) {
            this.seed = seed;
        }

        // Getters and Setters
        public long getSeed() {
            return seed;
        }

        public void setSeed(long seed) {
            this.seed = seed;
        }

        public int getTileSpawnX() {
            return tileSpawnX;
        }

        public void setTileSpawnX(int tileSpawnX) {
            this.tileSpawnX = tileSpawnX;
        }

        public int getTileSpawnY() {
            return tileSpawnY;
        }

        public void setTileSpawnY(int tileSpawnY) {
            this.tileSpawnY = tileSpawnY;
        }

        public float getTreeSpawnRate() {
            return treeSpawnRate;
        }

        public void setTreeSpawnRate(float rate) {
            this.treeSpawnRate = rate;
        }

        public float getPokemonSpawnRate() {
            return pokemonSpawnRate;
        }

        public void setPokemonSpawnRate(float rate) {
            this.pokemonSpawnRate = rate;
        }
    }

    public static class WorldObjectData implements Serializable {
        public String type;
        public float x, y;
        public String id;
        // Add other object properties
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/ChestInteractionHandler.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.context.GameContext;

public class ChestInteractionHandler {
    private boolean isChestOpen = false;
    private Vector2 currentChestPosition = null;


    public boolean canInteractWithChest() {
        if (GameContext.get().getPlayer() == null || GameContext.get().getPlayer().getWorld() == null) {
            return false;
        }    if (isChestOpen) {
            return false;
        }

        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();

        // Get tile in front of player based on direction
        switch (GameContext.get().getPlayer().getDirection()) {
            case "up":
                targetY++;
                break;
            case "down":
                targetY--;
                break;
            case "left":
                targetX--;
                break;
            case "right":
                targetX++;
                break;
        }

        PlaceableBlock block = GameContext.get().getWorld().getBlockManager().getBlockAt(targetX, targetY);
        if (block != null && block.getType() == PlaceableBlock.BlockType.CHEST) {
            currentChestPosition = new Vector2(targetX, targetY);
            return true;
        }

        return false;
    }

    public Vector2 getCurrentChestPosition() {
        return currentChestPosition;
    }

    public boolean isChestOpen() {
        return isChestOpen;
    }

    public void setChestOpen(boolean isOpen) {
        this.isChestOpen = isOpen;
    }

    public void reset() {
        isChestOpen = false;
        currentChestPosition = null;
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/CraftingGrid.java
================
package io.github.pokemeetup.system.gameplay.inventory.crafting;

import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotDataObserver;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class CraftingGrid implements ItemContainer {
    private final int size;
    private final ItemData[] gridItems;
    private final List<CraftingGridObserver> observers = new ArrayList<>();
    private final List<InventorySlotDataObserver>[] slotObservers;
    private final InventorySlotData[] slotData;

    @SuppressWarnings("unchecked")
    public CraftingGrid(int size) {
        this.size = size;
        this.gridItems = new ItemData[size];
        this.slotObservers = new List[size];
        this.slotData = new InventorySlotData[size];

        for (int i = 0; i < size; i++) {
            slotObservers[i] = new ArrayList<>();
            slotData[i] = new InventorySlotData(i, InventorySlotData.SlotType.CRAFTING, this);
        }
    }

    @Override
    public ItemData getItemAt(int index) {
        if (index >= 0 && index < size) {
            return gridItems[index];
        }
        return null;
    }

    public List<ItemData> getAllItems() {
        List<ItemData> items = new ArrayList<>();
        Collections.addAll(items, gridItems);
        return items;
    }

    @Override
    public void setItemAt(int index, ItemData item) {
        if (index >= 0 && index < size) {
            gridItems[index] = item;
            notifySlotObservers(index);
            notifyObservers();
        }
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public InventorySlotData getSlotData(int index) {
        if (index >= 0 && index < size) {
            return slotData[index];
        }
        return null;
    }

    public void clear() {
        for (int i = 0; i < size; i++) {
            gridItems[i] = null;
            notifySlotObservers(i);
        }
        notifyObservers();
    }

    public void addObserver(CraftingGridObserver observer) {
        if (!observers.contains(observer)) {
            observers.add(observer);
        }
    }

    public void addSlotObserver(int index, InventorySlotDataObserver observer) {
        if (index >= 0 && index < size) {
            slotObservers[index].add(observer);
        }
    }

    public void removeSlotObserver(int index, InventorySlotDataObserver observer) {
        if (index >= 0 && index < size) {
            slotObservers[index].remove(observer);
        }
    }

    public void removeObserver(CraftingGridObserver observer) {
        observers.remove(observer);
    }

    private void notifySlotObservers(int index) {
        if (index >= 0 && index < size) {
            for (InventorySlotDataObserver observer : slotObservers[index]) {
                observer.onSlotDataChanged();
            }
        }
    }

    private void notifyObservers() {
        for (CraftingGridObserver observer : observers) {
            observer.onCraftingGridChanged();
        }
    }

    public interface CraftingGridObserver {
        void onCraftingGridChanged();
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/CraftingSystem.java
================
package io.github.pokemeetup.system.gameplay.inventory.crafting;

import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotDataObserver;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class CraftingSystem {
    private final CraftingGrid craftingGrid;
    private final Object craftingLock = new Object();
    private final List<CraftingGridObserver> gridObservers = new CopyOnWriteArrayList<>();
    private final List<CraftingSystemObserver> observers = new CopyOnWriteArrayList<>();
    private final Inventory inventory;
    private final int gridSize;
    private final RecipeManager recipeManager;
    private ItemData resultSlot;

    public CraftingSystem(Inventory inventory, int gridSize, CraftingGrid craftingGrid) {
        this.inventory = inventory;
        this.gridSize = gridSize;
        this.craftingGrid = craftingGrid;
        this.recipeManager = RecipeManager.getInstance();
        this.craftingGrid.addObserver(this::onCraftingGridChanged);
    }

    public void returnItemsToInventory() {
        synchronized (craftingLock) {
            for (int i = 0; i < craftingGrid.getSize(); i++) {
                ItemData item = craftingGrid.getItemAt(i);
                if (item != null) {
                    boolean added = inventory.addItem(item.copy());
                    if (added) {
                        craftingGrid.setItemAt(i, null);
                        notifySlotObservers(i);
                    } else {
                        GameLogger.error("Inventory full, cannot return item: " + item.getItemId());
                    }
                }
            }
            updateCraftingResult();
        }
    }

    public void addObserver(CraftingSystemObserver observer) {
        if (!observers.contains(observer)) {
            observers.add(observer);
        }
    }

    public void addSlotObserver(int index, InventorySlotDataObserver observer) {
        if (index >= 0 && index < craftingGrid.getSize()) {
            craftingGrid.addSlotObserver(index, observer);
        }
    }

    public void updateCraftingResult() {
        synchronized (craftingLock) {
            resultSlot = checkRecipes();
            notifyCraftingResultChanged();
        }
    }

    private ItemData checkRecipes() {
        List<RecipeManager.CraftingRecipe> allRecipes = recipeManager.getAllRecipes();
        for (RecipeManager.CraftingRecipe recipe : allRecipes) {
            if (matchesRecipe(recipe)) {
                return recipe.getResult().copy();
            }
        }
        return null;
    }

    private boolean matchesRecipe(RecipeManager.CraftingRecipe recipe) {
        if (recipe.isShaped()) {
            return matchesShapedRecipe(recipe);
        } else {
            return matchesShapelessRecipe(recipe);
        }
    }


    private boolean matchesShapedRecipe(RecipeManager.CraftingRecipe recipe) {
        String[][] pattern = recipe.getPattern();
        // Compute frequency for each non-null symbol in the pattern
        Map<String, Integer> symbolFrequency = new HashMap<>();
        for (int r = 0; r < pattern.length; r++) {
            for (int c = 0; c < pattern[r].length; c++) {
                String symbol = pattern[r][c];
                if (symbol != null) {
                    symbolFrequency.merge(symbol, 1, Integer::sum);
                }
            }
        }

        // Build the expected mapping: for each symbol, we expect a specific item.
        // We assume that for each symbol, its frequency matches one ingredient’s required count.
        Map<String, String> expectedMapping = new HashMap<>();
        // Make a copy of the ingredients map (itemId -> count)
        Map<String, Integer> ingredients = new HashMap<>(recipe.getIngredients());

        for (Map.Entry<String, Integer> symbolEntry : symbolFrequency.entrySet()) {
            boolean found = false;
            for (Iterator<Map.Entry<String, Integer>> it = ingredients.entrySet().iterator(); it.hasNext();) {
                Map.Entry<String, Integer> ingEntry = it.next();
                if (ingEntry.getValue().equals(symbolEntry.getValue())) {
                    expectedMapping.put(symbolEntry.getKey(), ingEntry.getKey());
                    it.remove();
                    found = true;
                    break;
                }
            }
            if (!found) {
                // No matching ingredient with the exact count – pattern does not match recipe.
                return false;
            }
        }

        // Try the recipe pattern at every possible starting position in the grid.
        int patternHeight = pattern.length;
        int patternWidth = pattern[0].length;
        for (int startRow = 0; startRow <= gridSize - patternHeight; startRow++) {
            for (int startCol = 0; startCol <= gridSize - patternWidth; startCol++) {
                if (matchesPatternAtPosition(pattern, startRow, startCol, expectedMapping)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean matchesPatternAtPosition(String[][] pattern, int startRow, int startCol, Map<String, String> expectedMapping) {
        Set<Integer> usedSlots = new HashSet<>();
        for (int row = 0; row < pattern.length; row++) {
            for (int col = 0; col < pattern[row].length; col++) {
                int gridIndex = (startRow + row) * gridSize + (startCol + col);
                String symbol = pattern[row][col];
                ItemData slotItem = craftingGrid.getItemAt(gridIndex);

                if (symbol == null) {
                    if (slotItem != null) return false;
                    continue;
                }
                if (slotItem == null) return false;

                // Instead of inferring, check against our expected mapping.
                String expectedItemId = expectedMapping.get(symbol);
                if (expectedItemId == null || !expectedItemId.equals(slotItem.getItemId())) {
                    return false;
                }

                usedSlots.add(gridIndex);
            }
        }
        // Ensure all grid slots not used by the pattern are empty.
        for (int i = 0; i < craftingGrid.getSize(); i++) {
            if (!usedSlots.contains(i) && craftingGrid.getItemAt(i) != null) {
                return false;
            }
        }
        return true;
    }


    private boolean matchesShapelessRecipe(RecipeManager.CraftingRecipe recipe) {
        Map<String, Integer> required = new HashMap<>(recipe.getIngredients());
        Map<String, Integer> found = new HashMap<>();

        // Count all items in grid
        for (int i = 0; i < craftingGrid.getSize(); i++) {
            ItemData item = craftingGrid.getItemAt(i);
            if (item != null) {
                found.merge(item.getItemId(), item.getCount(), Integer::sum);
            }
        }

        // Check if we have all required items
        for (Map.Entry<String, Integer> entry : required.entrySet()) {
            int foundCount = found.getOrDefault(entry.getKey(), 0);
            if (foundCount < entry.getValue()) {
                return false;
            }
        }

        // Check if we have no extra items
        return found.keySet().equals(required.keySet());
    }

    private RecipeManager.CraftingRecipe findMatchingRecipe() {
        if (resultSlot == null) return null;
        List<RecipeManager.CraftingRecipe> recipes = recipeManager.getRecipesByOutput(resultSlot.getItemId());
        for (RecipeManager.CraftingRecipe recipe : recipes) {
            if (matchesRecipe(recipe)) {
                return recipe;
            }
        }
        return null;
    }

    private int getTotalItemCountInGrid(String itemId) {
        int totalCount = 0;
        for (int i = 0; i < craftingGrid.getSize(); i++) {
            ItemData item = craftingGrid.getItemAt(i);
            if (item != null && item.getItemId().equals(itemId)) {
                totalCount += item.getCount();
            }
        }
        return totalCount;
    }

    /**
     * [FIXED] Consumes one set of ingredients from the grid and returns the crafted item.
     * It no longer adds the item to the inventory directly.
     *
     * @return The crafted ItemData, or null if crafting failed.
     */
    public ItemData craftAndConsume() {
        synchronized (craftingLock) {
            if (resultSlot == null) {
                return null;
            }

            ItemData craftedItem = resultSlot.copy();

            RecipeManager.CraftingRecipe recipe = findMatchingRecipe();
            if (recipe == null) {
                GameLogger.error("Recipe mismatch for result: " + resultSlot.getItemId());
                return null;
            }

            // Consume ingredients from the grid
            for (Map.Entry<String, Integer> entry : recipe.getIngredients().entrySet()) {
                consumeItemsFromGrid(entry.getKey(), entry.getValue());
            }

            AudioManager.getInstance().playSound(AudioManager.SoundEffect.CRAFT);
            updateCraftingResult(); // This will re-evaluate the grid, which is now missing ingredients

            return craftedItem;
        }
    }

    /**
     * [NEW] Calculates the maximum number of times the current recipe can be crafted
     * based on the ingredients available in the crafting grid.
     *
     * @return The number of times the current recipe can be crafted.
     */
    public int calculateMaxCrafts() {
        synchronized (craftingLock) {
            if (resultSlot == null) return 0;
            RecipeManager.CraftingRecipe recipe = findMatchingRecipe();
            if (recipe == null) return 0;

            int maxCrafts = Integer.MAX_VALUE;

            for (Map.Entry<String, Integer> req : recipe.getIngredients().entrySet()) {
                String itemId = req.getKey();
                int requiredCount = req.getValue();
                if (requiredCount == 0) continue;

                int availableCount = 0;
                for (int i = 0; i < craftingGrid.getSize(); i++) {
                    ItemData item = craftingGrid.getItemAt(i);
                    if (item != null && item.getItemId().equals(itemId)) {
                        availableCount += item.getCount();
                    }
                }

                maxCrafts = Math.min(maxCrafts, availableCount / requiredCount);
            }

            return (maxCrafts == Integer.MAX_VALUE) ? 0 : maxCrafts;
        }
    }

    private void consumeItemsFromGrid(String itemId, int requiredCount) {
        int remaining = requiredCount;

        for (int i = 0; i < craftingGrid.getSize() && remaining > 0; i++) {
            ItemData item = craftingGrid.getItemAt(i);
            if (item != null && item.getItemId().equals(itemId)) {
                int toConsume = Math.min(remaining, item.getCount());
                remaining -= toConsume;

                if (toConsume >= item.getCount()) {
                    craftingGrid.setItemAt(i, null);
                } else {
                    item.setCount(item.getCount() - toConsume);
                }
                notifySlotObservers(i);
            }
        }
    }

    public void setItemInGrid(int index, ItemData item) {
        synchronized (craftingLock) {
            if (index < 0 || index >= craftingGrid.getSize()) {
                GameLogger.error("Invalid grid index: " + index);
                return;
            }

            if (item != null) {
                ItemData itemCopy = item.copy();
                craftingGrid.setItemAt(index, itemCopy);
            } else {
                craftingGrid.setItemAt(index, null);
            }

            notifySlotObservers(index);
            updateCraftingResult();
        }
    }

    public ItemData getItemInGrid(int index) {
        synchronized (craftingLock) {
            if (index < 0 || index >= craftingGrid.getSize()) {
                return null;
            }
            return craftingGrid.getItemAt(index);
        }
    }

    public ItemData getCraftingResult() {
        synchronized (craftingLock) {
            if (resultSlot == null) return null;
            return resultSlot.copy();
        }
    }

    private void notifySlotObservers(int index) {
        gridObservers.forEach(observer -> observer.onSlotChanged(index));
    }

    private void notifyCraftingResultChanged() {
        observers.forEach(observer -> observer.onCraftingResultChanged(resultSlot));
    }

    public void onCraftingGridChanged() {
        updateCraftingResult();
    }

    public CraftingGrid getCraftingGrid() {
        return craftingGrid;
    }

    public interface CraftingGridObserver {
        void onSlotChanged(int index);
    }

    public interface CraftingSystemObserver {
        void onCraftingResultChanged(ItemData newResult);
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/RecipeGlossaryUI.java
================
package io.github.pokemeetup.system.gameplay.inventory.crafting;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import io.github.pokemeetup.screens.InventoryScreenInterface;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.List;
import java.util.Map;

import static io.github.pokemeetup.screens.CraftingTableScreen.SLOT_SIZE;

public class RecipeGlossaryUI {
    private final Stage stage;
    private final Skin skin;
    private ScrollPane recipeScroll;
    private Table recipeList;
    private final InventoryScreenInterface screenInterface;
    private final CraftingSystem craftingSystem;

    public RecipeGlossaryUI(Stage stage, Skin skin, InventoryScreenInterface screenInterface,
                            CraftingSystem craftingSystem) {
        this.stage = stage;
        this.skin = skin;
        this.screenInterface = screenInterface;
        this.craftingSystem = craftingSystem;

        recipeList = new Table();
        recipeList.top().left();

        recipeScroll = new ScrollPane(recipeList, skin);
        recipeScroll.setFadeScrollBars(false);

        populateRecipes();
        setupUI();
    }


    private void setupUI() {
        recipeList = new Table();
        recipeList.top().left();

        // Style the scroll pane
        ScrollPane.ScrollPaneStyle scrollStyle = new ScrollPane.ScrollPaneStyle(skin.get(ScrollPane.ScrollPaneStyle.class));
        scrollStyle.background = new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg"))
            .tint(new Color(0.2f, 0.2f, 0.2f, 0.7f));

        recipeScroll = new ScrollPane(recipeList, scrollStyle);
        recipeScroll.setFadeScrollBars(false);
        recipeScroll.setScrollbarsVisible(true);

        populateRecipes();
    }

    private void populateRecipes() {
        recipeList.clear();
        List<RecipeManager.CraftingRecipe> recipes = RecipeManager.getInstance().getAllRecipes();

        // Compute available grid dimension (e.g., 2 for a 2x2 grid, 3 for a 3x3 grid)
        int availableDimension = (int) Math.sqrt(craftingSystem.getCraftingGrid().getSize());

        for (RecipeManager.CraftingRecipe recipe : recipes) {
            if (recipe.isShaped()) {
                // Get the dimensions of the recipe's pattern
                int patternRows = recipe.getPattern().length;
                int patternCols = recipe.getPattern()[0].length;

                // If the recipe requires a grid larger than what is available, skip it.
                if (patternRows > availableDimension || patternCols > availableDimension) {
                    continue;
                }
            } else {
                // For shapeless recipes, ensure the total ingredient count fits in the grid
                int totalIngredients = recipe.getIngredients().values().stream().mapToInt(Integer::intValue).sum();
                if (totalIngredients > availableDimension * availableDimension) {
                    continue;
                }
            }
            createRecipeEntry(recipe);
        }
    }

    public ScrollPane getRecipeScroll() {
        return recipeScroll;
    }

    private void createRecipeEntry(RecipeManager.CraftingRecipe recipe) {
        Table entry = new Table();

        // Result display with fixed width
        Table resultDisplay = new Table();
        resultDisplay.add(createItemDisplay(recipe.getResult()))
            .width(SLOT_SIZE * 3)
            .left();

        // Ingredients with scrolling if needed
        Table ingredientsList = new Table();
        ScrollPane ingredientsScroll = new ScrollPane(ingredientsList);
        recipe.getIngredients().forEach((itemId, count) -> {
            Label ingredient = new Label(itemId + " x" + count, skin);
            ingredient.setFontScale(SLOT_SIZE * 0.025f);
            ingredientsList.add(ingredient).padRight(10).left().row();
        });

        // Fixed widths to prevent horizontal scroll
        entry.add(resultDisplay).width(SLOT_SIZE * 3).pad(5);
        entry.add(ingredientsScroll).width(SLOT_SIZE * 4).pad(5);
        entry.add(createCraftButton(recipe)).pad(5);

        recipeList.add(entry).expandX().fillX().pad(5).row();
    }

    private Table createItemDisplay(ItemData item) {
        Table display = new Table();
        TextureRegion texture = TextureManager.items.findRegion(item.getItemId().toLowerCase() + "_item");
        if (texture != null) {
            display.add(new Image(texture)).size(SLOT_SIZE * 0.8f);
            display.add(new Label(item.getItemId(), skin)).padLeft(5);
        }
        return display;
    }

    private TextButton createCraftButton(RecipeManager.CraftingRecipe recipe) {
        TextButton craftButton = new TextButton("Craft", skin);
        craftButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                attemptAutoCraft(recipe);
            }
        });
        return craftButton;
    }

    /**
     * [FIXED] This method now correctly uses the new crafting system.
     */
    private void attemptAutoCraft(RecipeManager.CraftingRecipe recipe) {
        Inventory inventory = screenInterface.getInventory();
        Map<String, Integer> required = recipe.getIngredients();
        String[][] pattern = recipe.getPattern();

        // Check if we have all ingredients
        boolean hasAll = required.entrySet().stream()
            .allMatch(entry -> hasEnoughItems(inventory, entry.getKey(), entry.getValue()));

        // [NEW] Check if the player's inventory has space for the result
        boolean hasSpace = inventory.hasSpaceFor(recipe.getResult());

        if (hasAll && hasSpace) {
            // Auto-place items in the crafting grid (this consumes them from the inventory)
            placeItemsInGrid(pattern, recipe.isShaped());

            // [FIXED] Trigger the craft, which consumes grid items and returns the result
            ItemData craftedItem = craftingSystem.craftAndConsume();

            // [FIXED] Add the crafted item to the player's inventory
            if (craftedItem != null) {
                inventory.addItem(craftedItem);
            }
        } else if (!hasAll) {
            // Show a "missing ingredients" message if materials are insufficient
            showMissingIngredientsDialog(required);
        } else {
            // [NEW] Show an "inventory full" message if there's no space
            showInventoryFullDialog();
        }
    }

    private boolean hasEnoughItems(Inventory inventory, String itemId, int required) {
        int count = 0;
        List<ItemData> items = inventory.getAllItems();
        for (ItemData item : items) {
            if (item != null && item.getItemId().equals(itemId)) {
                count += item.getCount();
            }
        }
        return count >= required;
    }

    private void placeItemsInGrid(String[][] pattern, boolean shaped) {
        // Clear existing grid
        for (int i = 0; i < craftingSystem.getCraftingGrid().getSize(); i++) {
            craftingSystem.setItemInGrid(i, null);
        }

        if (shaped) {
            // Calculate grid dimension (assumed square) and compute offsets to center the pattern.
            int totalSlots = craftingSystem.getCraftingGrid().getSize();
            int gridDimension = (int) Math.sqrt(totalSlots);
            int patternRows = pattern.length;
            int patternCols = pattern[0].length;
            int offsetRow = (gridDimension - patternRows) / 2;
            int offsetCol = (gridDimension - patternCols) / 2;

            for (int row = 0; row < patternRows; row++) {
                for (int col = 0; col < patternCols; col++) {
                    if (pattern[row][col] != null) {
                        // Use the grid dimension and offset to calculate the proper grid index.
                        int gridIndex = (offsetRow + row) * gridDimension + (offsetCol + col);
                        String symbol = pattern[row][col];
                        String itemId = null;
                        if ("P".equals(symbol)) {
                            itemId = ItemManager.ItemIDs.WOODEN_PLANKS;
                        } else if ("S".equals(symbol)) {
                            itemId = ItemManager.ItemIDs.STICK;
                        }
                        if (itemId != null) {
                            ItemData item = findAndRemoveItem(screenInterface.getInventory(), itemId, 1);
                            if (item != null) {
                                craftingSystem.setItemInGrid(gridIndex, item);
                            }
                        }
                    }
                }
            }
        } else {
            // For shapeless recipes, a simple sequential placement can be used.
            int gridSize = craftingSystem.getCraftingGrid().getSize();
            int index = 0;
            for (String[] strings : pattern) {
                for (String string : strings) {
                    if (string != null) {
                        String itemId = null;
                        if ("P".equals(string)) {
                            itemId = ItemManager.ItemIDs.WOODEN_PLANKS;
                        } else if ("S".equals(string)) {
                            itemId = ItemManager.ItemIDs.STICK;
                        }
                        if (itemId != null) {
                            // Place item in the next available slot in grid order
                            while (index < gridSize && craftingSystem.getItemInGrid(index) != null) {
                                index++;
                            }
                            if (index < gridSize) {
                                ItemData item = findAndRemoveItem(screenInterface.getInventory(), itemId, 1);
                                if (item != null) {
                                    craftingSystem.setItemInGrid(index, item);
                                }
                                index++;
                            }
                        }
                    }
                }
            }
        }
    }


    private ItemData findAndRemoveItem(Inventory inventory, String itemId, int count) {
        for (int i = 0; i < inventory.getSize(); i++) {
            ItemData item = inventory.getItemAt(i);
            if (item != null && item.getItemId().equals(itemId) && item.getCount() >= count) {
                ItemData result = item.copy();
                result.setCount(count);

                // Update original item count
                int newCount = item.getCount() - count;
                if (newCount <= 0) {
                    inventory.removeItemAt(i);
                } else {
                    item.setCount(newCount);
                }

                return result;
            }
        }
        return null;
    }

    private void showMissingIngredientsDialog(Map<String, Integer> required) {
        Dialog dialog = new Dialog("Missing Ingredients", skin);
        Table content = new Table(skin);

        required.forEach((itemId, count) -> {
            if (!hasEnoughItems(screenInterface.getInventory(), itemId, count)) {
                content.add(new Label("Need: " + itemId + " x" + count, skin)).row();
            }
        });

        dialog.getContentTable().add(content);
        dialog.button("OK");
        dialog.show(stage);
    }

    /**
     * [NEW] Shows a dialog informing the user their inventory is full.
     */
    private void showInventoryFullDialog() {
        Dialog dialog = new Dialog("Inventory Full", skin);
        dialog.text("Not enough space in your inventory to craft this item.");
        dialog.button("OK");
        dialog.show(stage);
    }

    public void show() {
        Table container = new Table();
        container.setFillParent(true);
        container.add(recipeScroll).expand().fill().pad(10);
        stage.addActor(container);
    }

    public void hide() {
        recipeScroll.remove();
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/RecipeManager.java
================
package io.github.pokemeetup.system.gameplay.inventory.crafting;

import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;

import java.util.*;
import java.util.List;

public class RecipeManager {
    private static RecipeManager instance;
    private final Map<String, CraftingRecipe> recipes = new HashMap<>();
    private final Map<String, List<CraftingRecipe>> recipesByOutput = new HashMap<>();

    private RecipeManager() {
        initializeRecipes();
    }

    public static synchronized RecipeManager getInstance() {
        if (instance == null) {
            instance = new RecipeManager();
        }
        return instance;
    }

    private void initializeRecipes() {
        // Add Wooden Axe recipe
        Map<String, Integer> axeIngredients = new HashMap<>();
        axeIngredients.put(ItemManager.ItemIDs.WOODEN_PLANKS, 3);
        axeIngredients.put(ItemManager.ItemIDs.STICK, 2);
        addRecipe(new CraftingRecipe(
            "wooden_axe_recipe",
            axeIngredients,
            new ItemData(ItemManager.ItemIDs.WOODEN_AXE, 1, UUID.randomUUID()),
            new String[][]{
                {"P", "P", null},
                {"S", "P", null},
                {"S", null, null}
            },
            true // Shaped recipe
        ));

        // Add Crafting Table recipe
        Map<String, Integer> tableIngredients = new HashMap<>();
        tableIngredients.put(ItemManager.ItemIDs.WOODEN_PLANKS, 4);
        addRecipe(new CraftingRecipe(
            "crafting_table_recipe",
            tableIngredients,
            new ItemData(ItemManager.ItemIDs.CRAFTING_TABLE, 1, UUID.randomUUID()),
            new String[][]{
                {"P", "P"},
                {"P", "P"}
            },
            true
        ));

        // Add Stick recipe
        Map<String, Integer> stickIngredients = new HashMap<>();
        stickIngredients.put(ItemManager.ItemIDs.WOODEN_PLANKS, 2);
        addRecipe(new CraftingRecipe(
            "stick_recipe",
            stickIngredients,
            new ItemData(ItemManager.ItemIDs.STICK, 4, UUID.randomUUID()),
            new String[][]{
                {"P"},
                {"P"}
            },
            true
        ));
    }

    public void addRecipe(CraftingRecipe recipe) {
        recipes.put(recipe.getId(), recipe);
        recipesByOutput.computeIfAbsent(recipe.getResult().getItemId(), k -> new ArrayList<>())
            .add(recipe);
    }

    public List<CraftingRecipe> getAllRecipes() {
        return new ArrayList<>(recipes.values());
    }

    public List<CraftingRecipe> getRecipesByOutput(String itemId) {
        return recipesByOutput.getOrDefault(itemId, new ArrayList<>());
    }

    public CraftingRecipe getRecipeById(String id) {
        return recipes.get(id);
    }

    public static class CraftingRecipe {
        private final String id;
        private final Map<String, Integer> ingredients;
        private final ItemData result;
        private final String[][] pattern;
        private final boolean shaped;

        public CraftingRecipe(String id, Map<String, Integer> ingredients, ItemData result,
                              String[][] pattern, boolean shaped) {
            this.id = id;
            this.ingredients = ingredients;
            this.result = result;
            this.pattern = pattern;
            this.shaped = shaped;
        }

        public String getId() { return id; }
        public Map<String, Integer> getIngredients() { return ingredients; }
        public ItemData getResult() { return result; }
        public String[][] getPattern() { return pattern; }
        public boolean isShaped() { return shaped; }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/Inventory.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventoryObserver;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Inventory implements ItemContainer {
    public static final int INVENTORY_SIZE = 27;
    private final List<Slot> slots;
    private final Map<UUID, ItemData> itemTracker;
    private final Object inventoryLock = new Object();
    private final List<InventoryObserver> observers = new ArrayList<>();
    private InventorySlotData[] slotDataArray;

    public Inventory() {
        this.slots = new ArrayList<>(INVENTORY_SIZE);
        for (int i = 0; i < INVENTORY_SIZE; i++) {
            slots.add(new Slot());
        }
        this.itemTracker = new ConcurrentHashMap<>();
        validateSlots();
        slotDataArray = new InventorySlotData[INVENTORY_SIZE];
        for (int i = 0; i < INVENTORY_SIZE; i++) {
            slotDataArray[i] = new InventorySlotData(i, InventorySlotData.SlotType.INVENTORY, this);
        }
    }

    /**
     * [NEW] Checks if the inventory has enough of a specific item.
     * @param itemId The ID of the item to check.
     * @param requiredCount The amount required.
     * @return true if the inventory contains at least the required amount.
     */
    public boolean hasEnoughItems(String itemId, int requiredCount) {
        synchronized (inventoryLock) {
            int total = 0;
            for (Slot slot : slots) {
                ItemData item = slot.getItemData();
                if (item != null && item.getItemId().equals(itemId)) {
                    total += item.getCount();
                }
            }
            return total >= requiredCount;
        }
    }

    /**
     * [NEW] Removes a specified amount of an item from the inventory by its ID.
     * @param itemId The ID of the item to remove.
     * @param count The amount to remove.
     * @return true if the items were successfully removed.
     */
    public boolean removeItem(String itemId, int count) {
        synchronized (inventoryLock) {
            if (!hasEnoughItems(itemId, count)) {
                return false;
            }

            int remainingToRemove = count;
            // Iterate backwards to safely remove items or reduce counts
            for (int i = slots.size() - 1; i >= 0; i--) {
                if (remainingToRemove <= 0) break;

                Slot slot = slots.get(i);
                ItemData item = slot.getItemData();

                if (item != null && item.getItemId().equals(itemId)) {
                    int countInSlot = item.getCount();
                    if (countInSlot <= remainingToRemove) {
                        // Remove the whole stack
                        remainingToRemove -= countInSlot;
                        setItemAt(i, null);
                    } else {
                        // Reduce the stack count
                        item.setCount(countInSlot - remainingToRemove);
                        remainingToRemove = 0;
                        // Notify observers since we modified the item directly
                        notifyObservers();
                    }
                }
            }
            return true;
        }
    }

    /**
     * [NEW] Checks if the inventory has space for a given item, considering stacking.
     * Does not modify the inventory.
     *
     * @param itemToAdd The item to check for.
     * @return True if the item can be fully added, false otherwise.
     */
    public boolean hasSpaceFor(ItemData itemToAdd) {
        if (itemToAdd == null) return true;
        synchronized (inventoryLock) {
            int remaining = itemToAdd.getCount();
            Item itemTemplate = ItemManager.getItemTemplate(itemToAdd.getItemId());
            boolean isStackable = (itemTemplate != null && itemTemplate.isStackable());

            // Pass 1: try to stack with existing items
            if (isStackable) {
                for (Slot slot : slots) {
                    ItemData existing = slot.getItemData();
                    if (existing != null && existing.getItemId().equals(itemToAdd.getItemId()) && existing.getCount() < Item.MAX_STACK_SIZE) {
                        int space = Item.MAX_STACK_SIZE - existing.getCount();
                        int canAdd = Math.min(remaining, space);
                        remaining -= canAdd;
                        if (remaining <= 0) return true;
                    }
                }
            }

            // Pass 2: find empty slots
            for (Slot slot : slots) {
                if (slot.isEmpty()) {
                    remaining -= isStackable ? Item.MAX_STACK_SIZE : 1;
                    if (remaining <= 0) return true;
                }
            }

            return false;
        }
    }

    public ItemData getSelectedItem(int hotbarSlot) {
        synchronized (inventoryLock) {
            if (hotbarSlot >= 0 && hotbarSlot < 9) {
                Slot slot = slots.get(hotbarSlot);
                return slot != null ? slot.getItemData() : null;
            }
            return null;
        }
    }
    public boolean removeItem(ItemData itemData) {
        synchronized (inventoryLock) {
            for (Slot slot : slots) {
                ItemData slotItem = slot.getItemData();
                if (slotItem != null && slotItem.getUuid().equals(itemData.getUuid())) {
                    slot.setItemData(null);
                    itemTracker.remove(itemData.getUuid());
                    notifyObservers();
                    return true;
                }
            }
            return false;
        }
    }

    public ItemData getItemAt(int index) {
        synchronized (inventoryLock) {
            if (index < 0 || index >= INVENTORY_SIZE) {
                GameLogger.error("Invalid inventory slot index: " + index);
                return null;
            }

            Slot slot = slots.get(index);
            if (slot == null) {
                return null;
            }

            return slot.getItemData();
        }
    }

    public void update() {
        synchronized (inventoryLock) {
            // Remove items with invalid counts or UUIDs
            for (Slot slot : slots) {
                ItemData item = slot.getItemData();
                if (item != null && (item.getCount() <= 0 || item.getUuid() == null)) {
                    itemTracker.remove(item.getUuid());
                    slot.setItemData(null);
                }
            }

            // Rebuild itemTracker
            itemTracker.clear();
            for (Slot slot : slots) {
                ItemData item = slot.getItemData();
                if (item != null && item.getUuid() != null) {
                    itemTracker.put(item.getUuid(), item);
                }
            }

            // Handle items with zero durability
            for (Slot slot : slots) {
                ItemData item = slot.getItemData();
                if (item != null && item.getDurability() == 0) {
                    GameLogger.info("Item broken due to zero durability: " + item.getItemId());
                    itemTracker.remove(item.getUuid());
                    slot.setItemData(null);
                    notifyObservers();
                }
            }
        }
    }

    public void setItemAt(int index, ItemData itemData) {
        synchronized (inventoryLock) {
            if (index < 0 || index >= slots.size()) {
                GameLogger.error("Invalid slot index: " + index);
                return;
            }

            Slot slot = slots.get(index);
            if (slot == null) {
                slot = new Slot();
                slots.set(index, slot);
            }

            ItemData oldItem = slot.getItemData();
            if (oldItem != null && oldItem.getUuid() != null) {
                itemTracker.remove(oldItem.getUuid());
            }

            if (itemData != null) {
                if (itemData.getUuid() == null) {
                    itemData.setUuid(UUID.randomUUID());
                }

                // Ensure unstackable items have count of 1
                Item itemTemplate = ItemManager.getItemTemplate(itemData.getItemId());
                if (itemTemplate != null && !itemTemplate.isStackable()) {
                    if (itemData.getCount() > 1) {
                        GameLogger.error("Attempted to set unstackable item with count > 1: " + itemData.getItemId());
                        itemData.setCount(1);
                    }
                }

                slot.setItemData(itemData);
                itemTracker.put(itemData.getUuid(), itemData);
            } else {
                slot.setItemData(null);
            }
            notifyObservers();
        }
    }

    @Override
    public int getSize() {
        return INVENTORY_SIZE;
    }

    public List<ItemData> getAllItems() {
        synchronized (inventoryLock) {
            List<ItemData> items = new ArrayList<>(INVENTORY_SIZE);
            for (Slot slot : slots) {
                if (slot == null) {
                    items.add(null);
                    continue;
                }
                // Return the actual item, not a defensive copy.
                items.add(slot.getItemData());
            }
            return items;
        }
    }


    public void setAllItems(List<ItemData> items) {
        if (items == null) {
            return;
        }
        synchronized (inventoryLock) {
            GameLogger.info("Setting all items - Received " +
                items.stream().filter(Objects::nonNull).count() + " items");
            for (int i = 0; i < INVENTORY_SIZE; i++) {
                if (i < items.size() && items.get(i) != null) {
                    ItemData item = items.get(i).copy(); // Make defensive copy
                    setItemAt(i, item);
                    GameLogger.info("Set item at " + i + ": " + item.getItemId() + " x" + item.getCount());
                } else {
                    setItemAt(i, null);
                }
            }

            notifyObservers();
            validateAndRepair();
        }
    }

    public boolean addItem(ItemData itemData) {
        if (itemData == null) return false;

        synchronized (inventoryLock) {
            try {
                Item itemTemplate = ItemManager.getItemTemplate(itemData.getItemId());
                if (itemTemplate == null) {
                    return false;
                }
                if (itemTemplate.isStackable()) {
                    int remainingCount = itemData.getCount();
                    GameLogger.info("Processing stackable item, count=" + remainingCount);

                    // First pass: Stack with existing items
                    for (int i = 0; i < slots.size() && remainingCount > 0; i++) {
                        Slot slot = slots.get(i);
                        if (slot == null) {
                            slots.set(i, new Slot());
                            continue;
                        }

                        ItemData existingItem = slot.getItemData();
                        if (existingItem != null &&
                            existingItem.getItemId().equals(itemData.getItemId()) &&
                            existingItem.getCount() < Item.MAX_STACK_SIZE) {

                            int spaceInStack = Item.MAX_STACK_SIZE - existingItem.getCount();
                            int amountToAdd = Math.min(spaceInStack, remainingCount);

                            // Create new item data with updated count
                            ItemData updatedItem = existingItem.copy();
                            updatedItem.setCount(existingItem.getCount() + amountToAdd);
                            slot.setItemData(updatedItem);

                            remainingCount -= amountToAdd;
                            GameLogger.info("Stacked " + amountToAdd + " in slot " + i +
                                ", remaining: " + remainingCount);
                        }
                    }

                    // If we still have items, find empty slots
                    while (remainingCount > 0) {
                        Slot emptySlot = findEmptySlot();
                        if (emptySlot == null) {
                            GameLogger.info("No empty slots for remaining " + remainingCount + " items");
                            return remainingCount < itemData.getCount(); // Return true if we stacked anything
                        }

                        int stackSize = Math.min(remainingCount, Item.MAX_STACK_SIZE);
                        ItemData newStack = new ItemData(itemData.getItemId(), stackSize, UUID.randomUUID());
                        emptySlot.setItemData(newStack);

                        remainingCount -= stackSize;
                        GameLogger.info("Created new stack of " + stackSize + " in empty slot");
                    }

                    validateAndRepair();
                    notifyObservers();
                    return true;
                } else {
                    // Non-stackable items
                    for (int i = 0; i < itemData.getCount(); i++) {
                        Slot emptySlot = findEmptySlot();
                        if (emptySlot == null) {
                            GameLogger.info("No empty slots for non-stackable item");
                            return i > 0; // Return true if we placed any items
                        }

                        ItemData singleItem = new ItemData(itemData.getItemId(), 1, UUID.randomUUID());
                        emptySlot.setItemData(singleItem);
                        GameLogger.info("Placed non-stackable item in empty slot");
                    }

                    validateAndRepair();
                    notifyObservers();
                    return true;
                }

            } catch (Exception e) {
                GameLogger.error("Error in addItem: " + e.getMessage());
                validateAndRepair();
                return false;
            }
        }
    }

    public InventorySlotData getSlotData(int index) {
        if (index >= 0 && index < slotDataArray.length) {
            return slotDataArray[index];
        }
        return null;
    }

    private Slot findEmptySlot() {
        for (Slot slot : slots) {
            if (slot == null) continue;
            if (slot.isEmpty()) return slot;
        }
        return null;
    }

    public void notifyObservers() {
        for (InventoryObserver observer : observers) {
            observer.onInventoryChanged();
        }
    }

    public void addObserver(InventoryObserver observer) {
        observers.add(observer);
    }


    public void validateAndRepair() {
        synchronized (inventoryLock) {
            try {

                // Validate slots array
                if (slots.size() != INVENTORY_SIZE) {
                    GameLogger.error("Invalid slots size: " + slots.size());
                    while (slots.size() < INVENTORY_SIZE) {
                        slots.add(new Slot());
                    }
                }

                // Rebuild item tracker
                itemTracker.clear();
                int itemCount = 0;

                for (int i = 0; i < slots.size(); i++) {
                    Slot slot = slots.get(i);
                    if (slot == null) {
                        slots.set(i, new Slot());
                        continue;
                    }

                    ItemData item = slot.getItemData();
                    if (item != null) {
                        itemCount++;
                        // Ensure valid UUID
                        if (item.getUuid() == null) {
                            item.setUuid(UUID.randomUUID());
                        }
                        itemTracker.put(item.getUuid(), item);

                        // Validate stack size and unstackable items
                        Item itemTemplate = ItemManager.getItemTemplate(item.getItemId());
                        if (itemTemplate != null) {
                            if (!itemTemplate.isStackable() && item.getCount() > 1) {
                                GameLogger.error("Unstackable item with count > 1 in slot " + i + ": " + item.getCount());
                                item.setCount(1);
                            } else if (item.getCount() <= 0 || item.getCount() > Item.MAX_STACK_SIZE) {
                                GameLogger.error("Invalid stack size in slot " + i + ": " + item.getCount());
                                if (item.getCount() <= 0) {
                                    slot.setItemData(null);
                                    itemCount--;
                                } else {
                                    item.setCount(Item.MAX_STACK_SIZE);
                                }
                            }
                        }
                    }
                }

            } catch (Exception e) {
                GameLogger.error("Error during inventory validation: " + e.getMessage());
            }
        }
    }

    public void clear() {
        synchronized (inventoryLock) {
            for (Slot slot : slots) {
                if (slot != null) {
                    slot.setItemData(null);
                }
            }
            itemTracker.clear();
        }
    }


    public Object getInventoryLock() {
        return inventoryLock;
    }

    public void load() {
        synchronized (inventoryLock) {
            validateSlots(); // Ensure slots are valid before loading
            validateAndRepair(); // Validate after loading
        }
    }

    private void validateSlots() {
        synchronized (inventoryLock) {
            boolean needsRepair = false;
            for (int i = 0; i < INVENTORY_SIZE; i++) {
                if (slots.get(i) == null) {
                    slots.set(i, new Slot());
                    needsRepair = true;
                    GameLogger.error("Repaired null slot at index " + i);
                }
            }

            if (needsRepair) {
                validateAndRepair(); // Run full validation after slot repair
            }
        }
    }


    public void removeItemAt(int index) {
        synchronized (inventoryLock) {
            if (index < 0 || index >= slots.size()) {
                return;
            }

            Slot slot = slots.get(index);
            ItemData removedItem = slot.getItemData();
            if (removedItem != null) {
                itemTracker.remove(removedItem.getUuid());
                slot.setItemData(null);
                notifyObservers();
            }
        }
    }

    public boolean isEmpty() {
        synchronized (inventoryLock) {
            return slots.stream().allMatch(Slot::isEmpty);
        }
    }


}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/Item.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.UUID;

public class Item {
    public static final int MAX_STACK_SIZE = 64;
    private boolean stackable = true;  // Default to stackable
    private int maxDurability = -1;    // -1 means no durability
    private int durability = -1;       // Current durability

    private UUID uuid; // Unique identifier for each Item instance
    private String name;
    private String iconName; // Name of the texture region
    private transient TextureRegion icon; // Marked transient to avoid serialization
    private int count = 1;
    private boolean isCraftingResult = false;

    public Item(String name) {
        this.name = name;
        this.uuid = UUID.randomUUID();
        Item template = ItemManager.getItemTemplate(name);
        if (template != null) {
            this.iconName = template.getIconName();
            this.icon = template.getIcon();
            this.stackable = template.isStackable();
            this.maxDurability = template.getMaxDurability();
            this.durability = template.getMaxDurability();
        } else {
            // Log error but don't crash
            GameLogger.error("Failed to find template for item: " + name);
            this.iconName = "missing";
            this.icon = TextureManager.items.findRegion("stick_item");
        }
        this.count = 1;
    }

    public Item(String name, String iconName, TextureRegion icon) {
        this.name = name;
        this.iconName = iconName;
        this.icon = icon;
        this.uuid = UUID.randomUUID();
        if (name.toLowerCase().contains("axe")) {
            this.stackable = false;
            this.maxDurability = 100;  // Example durability for tools
            this.durability = 100;
        }
    }

    public Item(String name, String iconName, TextureRegion icon, int count) {
        this.name = name;
        this.iconName = iconName;
        this.icon = icon;
        this.count = count;
        this.uuid = UUID.randomUUID();
        if (name.toLowerCase().contains("axe")) {
            this.stackable = false;
            this.maxDurability = 100;  // Example durability for tools
            this.durability = 100;
        }
    }

    public Item() {
        this.uuid = UUID.randomUUID();
    }

    public Item(Item other) {
        this.name = other.name;
        this.count = other.count;
        this.icon = other.icon;
        this.uuid = other.uuid;
        this.stackable = other.stackable;
        this.maxDurability = other.maxDurability;
        this.durability = other.durability;
    }
    public int getDurability() {
        return durability;
    }

    public void setDurability(int durability) {
        this.durability = durability;
    }

    public boolean isStackable() {
        return stackable;
    }

    public void setStackable(boolean stackable) {
        this.stackable = stackable;
    }

    public int getMaxDurability() {
        return maxDurability;
    }

    public void setMaxDurability(int maxDurability) {
        this.maxDurability = maxDurability;
    }

    public boolean isCraftingResult() {
        return isCraftingResult;
    }

    public void setCraftingResult(boolean craftingResult) {
        isCraftingResult = craftingResult;
    }

    public boolean isBlock() {
        for (PlaceableBlock.BlockType type : PlaceableBlock.BlockType.values()) {
            if (getName().equalsIgnoreCase(type.getId())) {
                return true;
            }
        }
        return false;
    }



    public UUID getUuid() {
        return uuid;
    }

    public void setUuid(UUID uuid) {
        this.uuid = uuid;
    }

    public int getCount() {
        GameLogger.info("Item '" + name + "' getCount() returning: " + this.count);
        return this.count;
    }
    public void setCount(int count) {
        if (count < 0) {
            GameLogger.error("Attempted to set negative count for item '" + name + "': " + count);
            this.count = 0;
        } else {
            this.count = Math.min(count, MAX_STACK_SIZE);
        }
        GameLogger.info("Item '" + name + "' count set to: " + this.count);
    }


    public boolean isEmpty() {
        return this.count <= 0;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getIconName() {
        return iconName;
    }

    public void setIconName(String iconName) {
        this.iconName = iconName;
    }

    public TextureRegion getIcon() {
        if (icon == null) {
            // Try to load from TextureManager
            icon = TextureManager.items.findRegion(name.toLowerCase() + "_item");
            if (icon != null) {
                GameLogger.info("Loaded icon for " + name + " from TextureManager");
            } else {
                GameLogger.error("Could not find icon for " + name);
            }
        }
        return icon;
    }

    public void setIcon(TextureRegion icon) {
        if (icon == null) {
            GameLogger.error("Attempted to set null icon for item: " + name);
            return;
        }
        this.icon = icon;
        GameLogger.info("Set icon for item: " + name);
    }

    public Item copy() {
        return new Item(this);
    }

    @Override
    public String toString() {
        return "Item{" +
            "name='" + name + '\'' +
            ", count=" + count +
            ", uuid=" + uuid +
            '}';
    }

}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/ItemEntity.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.UUID;

public class ItemEntity {
    private static final float ITEM_SIZE = 24f; // Size of item in the world
    private static final float PICKUP_DELAY = 0.5f; // Delay before item can be picked up
    private static final float DESPAWN_TIME = 300f; // 5 minutes before despawning

    private final UUID entityId;
    private final ItemData itemData;
    private final Vector2 position;
    private final Rectangle bounds;
    private TextureRegion texture;
    private float timeAlive;
    private float pickupDelay;
    private boolean canBePickedUp;
    private boolean pickedUp;

    public ItemEntity(ItemData itemData, float x, float y) {
        this.entityId = UUID.randomUUID();
        this.itemData = itemData;
        this.position = new Vector2(x, y);
        this.bounds = new Rectangle(x - ITEM_SIZE/2, y - ITEM_SIZE/2, ITEM_SIZE, ITEM_SIZE);
        this.pickupDelay = PICKUP_DELAY;
        this.canBePickedUp = false;
        this.pickedUp = false;  // Initially not picked up.

        // Load texture
        String textureKey = itemData.getItemId().toLowerCase() + "_item";
        this.texture = TextureManager.items.findRegion(textureKey);
        if (this.texture == null) {
            this.texture = TextureManager.items.findRegion(itemData.getItemId().toLowerCase());
        }
    }

    public void update(float delta) {
        timeAlive += delta;
        if (pickupDelay > 0) {
            pickupDelay -= delta;
            if (pickupDelay <= 0) {
                canBePickedUp = true;
            }
        }
    }

    public void render(SpriteBatch batch) {
        if (texture != null) {
            batch.draw(texture,
                position.x - ITEM_SIZE/2,
                position.y - ITEM_SIZE/2,
                ITEM_SIZE,
                ITEM_SIZE);
        }
    }

    public boolean canBePickedUp() {
        return canBePickedUp && !pickedUp;
    }

    public boolean shouldDespawn() {
        return timeAlive >= DESPAWN_TIME;
    }

    public void markPickedUp() {
        pickedUp = true;
    }

    // Getters
    public UUID getEntityId() { return entityId; }
    public ItemData getItemData() { return itemData; }
    public Vector2 getPosition() { return position; }
    public Rectangle getBounds() { return bounds; }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/ItemEntityManager.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class ItemEntityManager {
    private final Map<UUID, ItemEntity> itemEntities = new ConcurrentHashMap<>();

    public void update(float delta) {
        Iterator<Map.Entry<UUID, ItemEntity>> it = itemEntities.entrySet().iterator();
        while (it.hasNext()) {
            ItemEntity entity = it.next().getValue();
            entity.update(delta);
            if (entity.shouldDespawn()) {
                // Mark as picked up so we don’t send duplicate messages.
                entity.markPickedUp();
                it.remove();
                if (GameContext.get().isMultiplayer()) {
                    NetworkProtocol.ItemPickup pickup = new NetworkProtocol.ItemPickup();
                    pickup.entityId = entity.getEntityId();
                    GameContext.get().getGameClient().sendItemPickup(pickup);
                }
            }
        }
    }

    public ItemEntity getItemEntity(UUID entityId) {
        return itemEntities.get(entityId);
    }

    public void render(SpriteBatch batch) {
        for (ItemEntity entity : itemEntities.values()) {
            entity.render(batch);
        }
    }

    public void spawnItemEntity(ItemData itemData, float x, float y) {
        ItemEntity entity = new ItemEntity(itemData, x, y);
        itemEntities.put(entity.getEntityId(), entity);

        if (GameContext.get().isMultiplayer()) {
            NetworkProtocol.ItemDrop drop = new NetworkProtocol.ItemDrop();
            drop.itemData = itemData;
            drop.x = x;
            drop.y = y;
            GameContext.get().getGameClient().sendItemDrop(itemData, new Vector2(x, y));
        }
    }

    public void spawnItemsFromChest(ChestData chest, float x, float y) {
        if (chest == null || chest.items == null) return;

        Random rand = new Random();
        for (ItemData item : chest.items) {
            if (item != null) {
                // Scatter items around the chest position
                float offsetX = rand.nextFloat() * 32 - 16;
                float offsetY = rand.nextFloat() * 32 - 16;
                spawnItemEntity(item, x + offsetX, y + offsetY);
            }
        }
    }

    public void removeItemEntity(UUID entityId) {
        ItemEntity entity = itemEntities.get(entityId);
        if (entity != null && !entity.canBePickedUp()) {
            // The item is either not ready or already picked up.
            return;
        }
        if (entity != null) {
            // Mark it so that any further pickup requests are ignored.
            entity.markPickedUp();
            // Remove it from the manager.
            itemEntities.remove(entityId);
            // In multiplayer, broadcast the pickup to other clients.
            if (GameContext.get().isMultiplayer()) {
                NetworkProtocol.ItemPickup pickup = new NetworkProtocol.ItemPickup();
                pickup.entityId = entityId;
                GameContext.get().getGameClient().sendItemPickup(pickup);
            }
        }
    }


    public void handleRemoteItemDrop(NetworkProtocol.ItemDrop drop) {
        // Only handle drops from other players
        if (!drop.username.equals(GameContext.get().getGameClient().getLocalUsername())) {
            ItemEntity entity = new ItemEntity(drop.itemData, drop.x, drop.y);
            itemEntities.put(entity.getEntityId(), entity);
        }
    }

    public void handleRemoteItemPickup(NetworkProtocol.ItemPickup pickup) {
        // Only handle pickups from other players
        if (!pickup.username.equals(GameContext.get().getGameClient().getLocalUsername())) {
            itemEntities.remove(pickup.entityId);
        }
    }

    public ItemEntity getClosestPickableItem(float x, float y, float range) {
        ItemEntity closest = null;
        float closestDist = range;

        for (ItemEntity entity : itemEntities.values()) {
            if (!entity.canBePickedUp()) continue;

            float dist = Vector2.dst(x, y,
                entity.getPosition().x,
                entity.getPosition().y);

            if (dist < closestDist) {
                closestDist = dist;
                closest = entity;
            }
        }

        return closest;
    }

    public Collection<ItemEntity> getAllItems() {
        return itemEntities.values();
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/ItemManager.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

public class ItemManager {
    private static final Map<String, Item> items = new HashMap<>();
    private static final String DEFAULT_TEXTURE = "missing_texture";
    private static boolean initialized = false;
    private static boolean isServerMode = false;

    public static void setServerMode(boolean serverMode) {
        isServerMode = serverMode;
        initialized = false; // Reset initialization to allow server-specific init
    }

    public static void initialize(TextureAtlas atlas) {
        if (initialized) {
            return;
        }
        if (isServerMode && atlas == null) {
            initializeServerItems();
            return;
        }

        if (atlas == null) {
            GameLogger.error("Cannot initialize ItemManager - atlas is null");
            return;
        }

        GameLogger.info("Initializing ItemManager with atlas...");
        logAvailableRegions(atlas);

        // Register standard items...
        Map<String, String> standardItems = new HashMap<>();
        standardItems.put(ItemIDs.POTION, "potion_item");
        standardItems.put(ItemIDs.ELIXIR, "elixir_item");
        standardItems.put(ItemIDs.POKEBALL, "pokeball_item");
        standardItems.put(ItemIDs.WOODEN_AXE, "wooden_axe_item");
        standardItems.put(ItemIDs.STICK, "stick_item");

        // Register block items
        for (PlaceableBlock.BlockType blockType : PlaceableBlock.BlockType.values()) {
            String itemId = blockType.getId().toLowerCase();
            String textureKey = itemId + "_item";
            standardItems.put(itemId, textureKey);
            GameLogger.info("Registered block item: " + itemId);
        }

        for (Map.Entry<String, String> entry : standardItems.entrySet()) {
            String itemId = entry.getKey().toLowerCase();
            String textureKey = entry.getValue();

            TextureRegion texture = getTextureWithFallbacks(atlas, textureKey, itemId);
            if (texture != null) {
                Item item = new Item(itemId, textureKey, texture);


                if (itemId.equals(ItemIDs.WOODEN_AXE)) {
                    item.setStackable(false);
                    item.setMaxDurability(100);
                    item.setDurability(100);
                } else {
                    item.setStackable(true);
                    item.setMaxDurability(-1);
                }

                items.put(itemId, item); // Use normalized itemId without "_item"
                GameLogger.info(String.format("Initialized item: %s with texture %s", itemId, textureKey));
            }
        }

        initialized = true;
        validateItems();
        logInitializationSummary();
    }

    private static void initializeServerItems() {
        GameLogger.info("Initializing ItemManager in server mode...");

        // Register standard items
        Map<String, String> standardItems = new HashMap<>();
        standardItems.put(ItemIDs.POTION, "potion");
        standardItems.put(ItemIDs.ELIXIR, "elixir");
        standardItems.put(ItemIDs.POKEBALL, "pokeball");
        standardItems.put(ItemIDs.WOODEN_AXE, "wooden_axe");
        standardItems.put(ItemIDs.STICK, "stick");

        // Register block items
        for (PlaceableBlock.BlockType blockType : PlaceableBlock.BlockType.values()) {
            String itemId = blockType.getId().toLowerCase();
            standardItems.put(itemId, itemId);
        }

        for (Map.Entry<String, String> entry : standardItems.entrySet()) {
            String itemId = entry.getKey().toLowerCase();
            // Create items without textures in server mode
            Item item = new Item(itemId, entry.getValue(), null);

            if (itemId.equals(ItemIDs.WOODEN_AXE)) {
                item.setStackable(false);
                item.setMaxDurability(100);
                item.setDurability(100);
            } else {
                item.setStackable(true);
                item.setMaxDurability(-1);
            }

            items.put(itemId, item);
            GameLogger.info("Initialized server item: " + itemId);
        }

        initialized = true;
        GameLogger.info("Server mode ItemManager initialization complete: " + items.size() + " items");
    }

    private static TextureRegion getTextureWithFallbacks(TextureAtlas atlas, String primaryKey, String itemId) {
        TextureRegion texture;
        String[] attempts = new String[]{
            primaryKey,
            itemId + "_item",
            itemId.toLowerCase() + "_item",
            itemId,
            itemId.toLowerCase(),
            DEFAULT_TEXTURE
        };

        for (String key : attempts) {
            texture = atlas.findRegion(key);
            if (texture != null) {
                GameLogger.info(String.format("Found texture for %s using key: %s", itemId, key));
                return texture;
            }
        }

        GameLogger.error(String.format("Failed to find any texture for item: %s", itemId));
        return null;
    }

    public static Item getItemTemplate(String itemId) {
        if (!initialized) {
            GameLogger.error("Attempting to get item before ItemManager initialization");
            return null;
        }
        return items.get(itemId);
    }

    public static Item getItem(String itemId) {
        if (!initialized) {
            if (isServerMode) {
                initialize(null); // Auto-initialize for server
            } else {
                GameLogger.error("Attempting to get item before ItemManager initialization");
                return null;
            }
        }

        if (itemId == null) {
            GameLogger.error("Null itemId provided to getItem");
            return null;
        }

        String normalizedId = itemId.toLowerCase().replace("_item", "");
        Item baseItem = items.get(normalizedId);

        if (baseItem == null) {
            GameLogger.error("No item found with ID: " + normalizedId);
            return null;
        }

        if (!isServerMode && baseItem.getIcon() == null) {
            GameLogger.error("Item found but missing texture: " + itemId);
            return null;
        }

        return baseItem.copy();
    }


    public static void validateItems() {
        GameLogger.info("Validating initialized items...");
        if (isServerMode) {
            // Simple validation for server mode
            GameLogger.info("Validating server items...");
            for (Map.Entry<String, Item> entry : items.entrySet()) {
                GameLogger.info("Validated server item: " + entry.getKey());
            }
            return;
        }
        for (Map.Entry<String, Item> entry : items.entrySet()) {
            Item item = entry.getValue();
            if (item.getIcon() == null) {
                GameLogger.error(String.format("Item %s is missing texture", entry.getKey()));
                continue;
            }

            if (!item.getIcon().getTexture().isManaged()) {
                GameLogger.error(String.format("Item %s has invalid texture state", entry.getKey()));
            }

            GameLogger.info(String.format("Validated item: %s (texture: %dx%d)",
                entry.getKey(),
                item.getIcon().getRegionWidth(),
                item.getIcon().getRegionHeight()));
        }
    }

    public static Collection<String> getAllItemNames() {
        if (!initialized) {
            GameLogger.error("Attempting to get item names before initialization");
            return Collections.emptyList();
        }
        return new ArrayList<>(items.keySet());
    }

    public static List<String> getAllFindableItemNames() {
        List<String> itemsFindable = new ArrayList<>();
        if (!initialized) {
            GameLogger.error("Attempting to get item names before initialization");
            return Collections.emptyList();
        }
        itemsFindable.add("pokeball");
        itemsFindable.add("stick");
        itemsFindable.add("potion");
        itemsFindable.add("elixir");

        return itemsFindable;
    }

    public static boolean isInitialized() {
        return initialized;
    }

    // Helper methods
    private static void logAvailableRegions(TextureAtlas atlas) {
        GameLogger.info("Available regions in atlas:");
        for (TextureAtlas.AtlasRegion region : atlas.getRegions()) {
            GameLogger.info(String.format("- %s (%dx%d)",
                region.name, region.getRegionWidth(), region.getRegionHeight()));
        }
    }

    private static void logInitializationSummary() {
        GameLogger.info(String.format("ItemManager initialization complete: %d items loaded",
            items.size()));
        GameLogger.info("Loaded items: " + String.join(", ", items.keySet()));
    }

    public static final class ItemIDs {
        public static final String POTION = "potion";
        public static final String HOUSE_PLANKS = "house_planks";
        public static final String ELIXIR = "elixir";
        public static final String POKEBALL = "pokeball";
        public static final String STICK = "stick";
        public static final String CRAFTING_TABLE = "craftingtable";
        public static final String FURNACE = "furnace";
        public static final String WOODEN_PLANKS = "wooden_planks";
        public static final String WOODEN_DOOR = "wooden_door";
        public static final String ROOF_CORNER = "roof_corner";
        public static final String HOUSE_PART = "house_part";
        public static final String HOUSE_MIDDLE_PART = "house_middlesection_part";
        public static final String HOUSE_MIDDLE_PART_0 = "house_midsection_part";
        public static final String HOUSE_MIDDLE_PART_1 = "house_middlesection";
        public static final String ROOF_CORNER_1 = "roof_middle_part";
        public static final String ROOF_MIDDLE = "roof_middle";
        public static final String ROOFINNER = "roofinner";
        public static final String ROOF_INSIDE = "roof_middle_outside";
        public static final String CHEST = "chest";
        public static final String WOODEN_AXE = "wooden_axe";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventoryLock.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

import java.util.concurrent.locks.ReentrantReadWriteLock;

public class InventoryLock {
    private static final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true);
    
    public static void readLock() {
        lock.readLock().lock();
    }
    
    public static void readUnlock() {
        lock.readLock().unlock();
    }
    
    public static void writeLock() {
        lock.writeLock().lock();
    }
    
    public static void writeUnlock() {
        lock.writeLock().unlock();
    }
    
    public static ReentrantReadWriteLock getLock() {
        return lock;
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventoryObserver.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

public interface InventoryObserver {
    void onInventoryChanged();
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventorySlotData.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class InventorySlotData implements ItemDataObserver {
    private final int slotIndex;
    private final List<InventorySlotDataObserver> observers = new ArrayList<>();
    private final transient ItemContainer itemContainer;
    private SlotType slotType;
    private int position;
    private String slotId;

    public InventorySlotData(int slotIndex, SlotType slotType, ItemContainer itemContainer) {
        this.slotIndex = slotIndex;
        this.slotType = slotType;
        this.itemContainer = itemContainer;
        this.position = 0;
        this.slotId = "";
    }

    public SlotType getSlotType() {
        return slotType;
    }

    public void setSlotType(SlotType slotType) {
        this.slotType = slotType;
    }

    public InventorySlotData copy() {
        InventorySlotData copy = new InventorySlotData(this.slotIndex, this.slotType, this.itemContainer);
        copy.position = this.position;
        copy.slotId = this.slotId;
        return copy;
    }

    public void setItem(String itemId, int count, UUID uuid) {
        if (itemId == null || count <= 0) {
            this.itemContainer.setItemAt(slotIndex, null);
        } else {
            ItemData newItemData = new ItemData(itemId, count, uuid != null ? uuid : UUID.randomUUID());
            this.itemContainer.setItemAt(slotIndex, newItemData);

            if (slotType == SlotType.CRAFTING || slotType == SlotType.CRAFTING_RESULT) {
                notifyObservers();
            }
        }
        notifyObservers();
    }


    public void clear() {
        ItemData currentItem = getItemData();
        if (currentItem != null) {
            currentItem.removeObserver(this);
        }
        this.itemContainer.setItemAt(slotIndex, null);
        notifyObservers();
    }

    @Override
    public void onItemDataChanged(ItemData itemData) {
        GameLogger.error("Item data changed in slot " + slotIndex + ": " +
            (itemData != null ? itemData.getItemId() + " x" + itemData.getCount() : "null"));
        notifyObservers();
    }

    public void addObserver(InventorySlotDataObserver observer) {
        if (!observers.contains(observer)) {
            observers.add(observer);
        }
    }

    public void notifyObservers() {
        for (InventorySlotDataObserver observer : observers) {
            observer.onSlotDataChanged();
        }
    }

    public boolean isEmpty() {
        ItemData itemData = getItemData();
        return itemData == null || itemData.getCount() <= 0;
    }

    public String getItemId() {
        ItemData itemData = getItemData();
        return itemData != null ? itemData.getItemId() : null;
    }

    public int getCount() {
        ItemData itemData = getItemData();
        return itemData != null ? itemData.getCount() : 0;
    }

    public void setCount(int count) {
        ItemData itemData = getItemData();
        if (itemData != null) {
            itemData.setCount(count);
            if (count <= 0) {
                this.itemContainer.setItemAt(slotIndex, null);
            }
        }
        notifyObservers();
    }

    public ItemData getItemData() {
        // Removed the logging inside this getter to avoid confusion
        return itemContainer.getItemAt(slotIndex);
    }

    public void setItemData(ItemData itemData) {
        try {
            // Only log important changes, not every trivial action
            if (itemData != null) {
                ItemData copyData = itemData.copy();
                copyData.addObserver(this);
                this.itemContainer.setItemAt(slotIndex, copyData);
            } else {
                this.itemContainer.setItemAt(slotIndex, null);
            }

            notifyObservers();
        } catch (Exception e) {
            GameLogger.error("Error in setItemData: " + e.getMessage() + " for slot " + slotIndex);
        }
    }


    public int getSlotIndex() {
        return slotIndex;
    }

    public int getPosition() {
        return position;
    }

    public void setPosition(int position) {
        this.position = position;
    }

    public UUID getUuid() {
        ItemData itemData = getItemData();
        return itemData != null ? itemData.getUuid() : null;
    }

    public Item getItem() {
        ItemData itemData = getItemData();
        if (itemData == null) return null;

        Item baseItem = ItemManager.getItem(itemData.getItemId());
        if (baseItem == null) {
            GameLogger.error("Could not find base item for: " + itemData.getItemId());
            return null;
        }

        Item item = baseItem.copy();
        item.setCount(itemData.getCount());
        item.setUuid(itemData.getUuid());
        return item;
    }


    public ItemContainer getItemContainer() {
        return itemContainer;
    }

    public enum SlotType {
        INVENTORY,
        HOTBAR,
        CRAFTING,
        CRAFTING_RESULT,
        EXPANDED_CRAFTING,
        CHEST
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventorySlotDataObserver.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

public interface InventorySlotDataObserver {
    void onSlotDataChanged();

}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/ItemContainer.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

import io.github.pokemeetup.system.data.ItemData;

public interface ItemContainer {
    ItemData getItemAt(int index);
    void setItemAt(int index, ItemData item);
    int getSize();
    InventorySlotData getSlotData(int index);
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/ItemDataObserver.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

import io.github.pokemeetup.system.data.ItemData;

public interface ItemDataObserver {
    void onItemDataChanged(ItemData itemData);
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/inventory/Slot.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.utils.GameLogger;

import java.util.UUID;

public class Slot {
    private final Object slotLock = new Object();
    private ItemData itemData;

    public Slot() {

    }


    public ItemData getItemData() {
        synchronized (slotLock) {
            return itemData;
        }
    }


    public void setItemData(ItemData newItemData) {
        synchronized (slotLock) {
            this.itemData = newItemData;
            validateItemData();
        }
    }

    private void validateItemData() {
        if (itemData != null) {
            Item template = ItemManager.getItemTemplate(itemData.getItemId());
            if (template != null) {
                if (!template.isStackable() && itemData.getCount() > 1) {
                    GameLogger.info("Fixing unstackable item count for: " + itemData.getItemId());
                    itemData.setCount(1);
                }
                if (itemData.getCount() <= 0) {
                    GameLogger.info("Removing item with invalid count: " + itemData.getItemId());
                    itemData = null;
                }
            }
        }
    }

    public boolean isEmpty() {
        synchronized (slotLock) {
            return itemData == null || itemData.getCount() <= 0;
        }
    }

    public void clear() {
        synchronized (slotLock) {
            this.itemData = null;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/biomes/Biome.java
================
package io.github.pokemeetup.system.gameplay.overworld.biomes;

import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.*;

public class Biome {
    private final BiomeType type;
    private HashMap<Integer, Integer> tileDistribution;
    private String name;
    private List<Integer> allowedTileTypes;
    private List<WorldObject.ObjectType> spawnableObjects;
    private Map<WorldObject.ObjectType, Double> spawnChances;

    public Biome(String name, BiomeType type) {
        this.name = name;
        this.type = type;
        this.allowedTileTypes = new ArrayList<>();
        this.spawnableObjects = new ArrayList<>();
        this.spawnChances = new HashMap<>();
        this.tileDistribution = new HashMap<>();
    }

    public List<WorldObject.ObjectType> getSpawnableObjects() {
        return spawnableObjects != null ? spawnableObjects : new ArrayList<>();
    }


    public Map<WorldObject.ObjectType, Double> getSpawnChances() {
        return spawnChances;
    }

    public void loadSpawnableObjects(List<String> objectStrings) {
        this.spawnableObjects = new ArrayList<>();
        for (String objStr : objectStrings) {
            try {
                WorldObject.ObjectType type = WorldObject.ObjectType.valueOf(objStr);
                this.spawnableObjects.add(type);
            } catch (IllegalArgumentException e) {
                GameLogger.error(name + ": Invalid object type: " + objStr);
            }
        }
    }
    public void loadSpawnChances(Map<String, Double> chanceMap) {
        this.spawnChances = new HashMap<>();
        for (Map.Entry<String, Double> entry : chanceMap.entrySet()) {
            try {
                WorldObject.ObjectType type = WorldObject.ObjectType.valueOf(entry.getKey());
                this.spawnChances.put(type, entry.getValue());
            } catch (IllegalArgumentException e) {
                GameLogger.error(name + ": Invalid object type in spawn chances: " + entry.getKey());
            }
        }
    }

    public double getSpawnChanceForObject(WorldObject.ObjectType objectType) {
        return spawnChances != null ? spawnChances.getOrDefault(objectType, 0.0) : 0.0;
    }

    public void setTileDistribution(Map<Integer, Integer> distribution) {
        if (distribution == null || distribution.isEmpty()) {
            throw new IllegalArgumentException("Tile distribution cannot be null or empty");
        }

        // If allowed types is empty, initialize it from the distribution
        if (allowedTileTypes.isEmpty()) {
            allowedTileTypes = new ArrayList<>(distribution.keySet());
        }

        // Add any missing tile types to allowed types
        for (Integer tileType : distribution.keySet()) {
            if (!allowedTileTypes.contains(tileType)) {
                allowedTileTypes.add(tileType);
            }
        }



        double totalWeight = distribution.values().stream()
            .mapToDouble(Integer::doubleValue)
            .sum();

        // Normalize weights if needed
        if (Math.abs(totalWeight - 100.0) > 0.001) {
            Map<Integer, Integer> normalizedDist = new HashMap<>();

            for (Map.Entry<Integer, Integer> entry : distribution.entrySet()) {
                double normalizedValue = (entry.getValue() / totalWeight) * 100.0;
                normalizedDist.put(entry.getKey(), (int) Math.round(normalizedValue));
            }

            // Adjust for rounding errors
            int finalTotal = normalizedDist.values().stream()
                .mapToInt(Integer::intValue)
                .sum();

            if (finalTotal != 100) {
                int diff = 100 - finalTotal;
                int highestKey = normalizedDist.entrySet().stream()
                    .max(Map.Entry.comparingByValue())
                    .map(Map.Entry::getKey)
                    .orElse(distribution.keySet().iterator().next());

                normalizedDist.put(highestKey, normalizedDist.get(highestKey) + diff);
            }

            distribution = normalizedDist;
        }

        this.tileDistribution = new HashMap<>(distribution);

    }public void setBeachTileDistribution(Map<Integer, Integer> beachTileDistribution) {
        this.beachTileDistribution = beachTileDistribution;
    }

    private Map<Integer, Integer> beachTileDistribution;
    public Map<Integer, Integer> getBeachTileDistribution() {
        if (beachTileDistribution == null || beachTileDistribution.isEmpty()) {
            // Fallback distribution: 100% BEACH_SAND.
            Map<Integer, Integer> defaultBeach = new HashMap<>();
            defaultBeach.put(TileType.BEACH_SAND, 60);
            defaultBeach.put(TileType.BEACH_GRASS, 20);
            defaultBeach.put(TileType.BEACH_GRASS_2, 20);
            defaultBeach.put(TileType.BEACH_SHELL, 5);
            defaultBeach.put(TileType.BEACH_STARFISH, 5);
            return defaultBeach;
        }
        return beachTileDistribution;
    }
    public BiomeType getType() {
        return type;
    }
    private Map<Integer, Integer> transitionTileDistribution = new HashMap<>();

    public Map<Integer, Integer> getTransitionTileDistribution() {
        return transitionTileDistribution;
    }

    public void setTransitionTileDistribution(Map<Integer, Integer> map) {
        this.transitionTileDistribution = map;
    }


    public HashMap<Integer, Integer> getTileDistribution() {
        return tileDistribution;
    }
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }


    public List<Integer> getAllowedTileTypes() {
        return allowedTileTypes;
    }

    public void setAllowedTileTypes(List<Integer> allowedTileTypes) {
        this.allowedTileTypes = allowedTileTypes;
    }
    private void useFallbackDistribution() {
        // Provide safe default distribution
        Map<Integer, Integer> fallback = new HashMap<>();
        fallback.put(1, 70);  // grass
        fallback.put(2, 20);  // dirt
        fallback.put(3, 10);  // stone

        this.allowedTileTypes = new ArrayList<>(fallback.keySet());
        this.tileDistribution = new HashMap<>(fallback);

        GameLogger.info(String.format("Biome %s using fallback distribution: %s",
            name, fallback));
    }

    // Add this method to validate the entire biome state
    public void validate() {
        if (allowedTileTypes == null) {
            allowedTileTypes = new ArrayList<>();
        }

        if (tileDistribution == null || tileDistribution.isEmpty()) {
            useFallbackDistribution();
        }

        if (spawnableObjects == null) {
            spawnableObjects = new ArrayList<>();
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/biomes/BiomeType.java
================
package io.github.pokemeetup.system.gameplay.overworld.biomes;

public enum BiomeType {
    PLAINS,
    FOREST,
    SNOW,
    HAUNTED,
    DESERT,
    RAIN_FOREST,
    BIG_MOUNTAINS,
    RUINS,
    CHERRY_GROVE,
    BEACH,
    OCEAN
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/Chunk.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.system.data.BlockSaveData;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.*;

public class Chunk {
    public static final int CHUNK_SIZE = 16;

    private final int chunkX;
    private final int chunkY;
    public boolean isDirty = false;
    private TextureRegion[][] autotileRegions;
    private TextureRegion[][] seatileRegions;
    private Biome biome;
    private Map<Vector2, PlaceableBlock> blocks = new HashMap<>();
    private int[][] tileData;
    private List<WorldObject> worldObjects = new ArrayList<>();

    public Chunk() {
        this.chunkX = 0;
        this.chunkY = 0;
        this.finalBiomeTypes = new BiomeType[CHUNK_SIZE][CHUNK_SIZE];
    }

    public Chunk(int chunkX, int chunkY, Biome biome, long worldSeed) {
        this.chunkX = chunkX;
        this.finalBiomeTypes = new BiomeType[CHUNK_SIZE][CHUNK_SIZE];
        this.chunkY = chunkY;
        this.biome = biome;
        this.tileData = new int[CHUNK_SIZE][CHUNK_SIZE];
    }

    public TextureRegion[][] getAutotileRegions() {
        return autotileRegions;
    }


    public void setAutotileRegions(TextureRegion[][] regions) {
        this.autotileRegions = regions;
    }


    public void addBlock(PlaceableBlock block) {
        if (block != null) {
            blocks.put(block.getPosition(), block);
            isDirty = true;
        }
    }
    private BiomeType[][] finalBiomeTypes;

    public void removeBlock(Vector2 position) {
        blocks.remove(position);
        isDirty = true;
    }

    public TextureRegion[][] getSeatileRegions() {
        return seatileRegions;
    }

    public void setSeatileRegions(TextureRegion[][] seatileRegions) {
        this.seatileRegions = seatileRegions;
    }

    public List<WorldObject> getWorldObjects() {
        return worldObjects;
    }

    public void setWorldObjects(List<WorldObject> worldObjects) {
        this.worldObjects = worldObjects;
    }

    public PlaceableBlock getBlock(Vector2 position) {
        return blocks.get(position);
    }

    public Map<Vector2, PlaceableBlock> getBlocks() {
        return new HashMap<>(blocks);
    }

    public void setBlocks(Map<Vector2, PlaceableBlock> blocks) {
        this.blocks = blocks;
    }

    public boolean isDirty() {
        return isDirty;
    }

    public void setDirty(boolean dirty) {
        this.isDirty = dirty;
    }

    public Biome getBiome() {
        return biome;
    }

    public void setBiome(Biome biome) {
        this.biome = biome;
    }

    public int getTileType(int localX, int localY) {
        if (localX < 0 || localX >= CHUNK_SIZE || localY < 0 || localY >= CHUNK_SIZE) {
            return -1;
        }
        return tileData[localX][localY];
    }

    public int[][] getTileData() {
        return tileData;
    }

    public void setTileData(int[][] tileData) {
        this.tileData = tileData;
    }

    public int getChunkX() {
        return chunkX;
    }

    public int getChunkY() {
        return chunkY;
    }

    public List<BlockSaveData.BlockData> getBlockDataForSave() {
        List<BlockSaveData.BlockData> blockDataList = new ArrayList<>();
        for (PlaceableBlock b : blocks.values()) {
            BlockSaveData.BlockData data = new BlockSaveData.BlockData();
            data.type = b.getId();
            data.x = (int) b.getPosition().x;
            data.y = (int) b.getPosition().y;
            data.isFlipped = b.isFlipped();
            data.isChestOpen = b.isChestOpen();
            if (b.getType() == PlaceableBlock.BlockType.CHEST && b.getChestData() != null) {
                data.chestData = b.getChestData();
            }
            blockDataList.add(data);
        }
        return blockDataList;
    }



    public boolean isPassable(int localX, int localY) {
        localX = (localX + CHUNK_SIZE) % CHUNK_SIZE;
        localY = (localY + CHUNK_SIZE) % CHUNK_SIZE;
        int tType = tileData[localX][localY];
        return TileType.isPassableTile(tType);
    }

    public BiomeType[][] getFinalBiomeTypes() {
        return finalBiomeTypes;
    }

    public void setFinalBiomeTypes(BiomeType[][] finalBiomeTypes) {
        this.finalBiomeTypes = finalBiomeTypes;
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/DayNightCycle.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.graphics.Color;

public class DayNightCycle {
    private static final float NIGHT_END = 5.0f;     // 5:00 AM
    private static final float DAWN_START = 5.0f;    // 5:00 AM
    private static final float DAWN_END = 6.0f;      // 6:00 AM
    private static final float DAY_START = 6.0f;     // 6:00 AM
    private static final float DAY_END = 18.0f;      // 6:00 PM
    private static final float DUSK_START = 18.0f;   // 6:00 PM
    private static final float NIGHT_START = 19.0f;  // 7:00 PM

    private static final Color DAY_COLOR = new Color(1.0f, 1.0f, 1.0f, 1.0f);
    private static final Color NIGHT_COLOR = new Color(0.25f, 0.25f, 0.45f, 1.0f);
    private static final Color DAWN_COLOR = new Color(0.85f, 0.75f, 0.65f, 1.0f);
    private static final Color DUSK_COLOR = new Color(0.85f, 0.65f, 0.55f, 1.0f);
    private static final Color DAWN_DUSK_COLOR = new Color(0.8f, 0.6f, 0.6f, 1);
    public enum TimePeriod {
        NIGHT, DAWN, DAY, DUSK
    }

    public static TimePeriod getTimePeriod(float hourOfDay) {
        if (hourOfDay >= NIGHT_START || hourOfDay < NIGHT_END) {
            return TimePeriod.NIGHT;
        } else if (hourOfDay >= DAWN_START && hourOfDay < DAWN_END) {
            return TimePeriod.DAWN;
        } else if (hourOfDay >= DAY_START && hourOfDay < DAY_END) {
            return TimePeriod.DAY;
        } else {
            return TimePeriod.DUSK;
        }
    }public static float getHourOfDay(double worldTimeInMinutes) {
        return (float)((worldTimeInMinutes % (24 * 60)) / 60.0);
    }


    public static Color getWorldColor(float hourOfDay) {
        // Add debug logging

        Color result = new Color();

        // Check if it's nighttime (including crossing midnight)
        if (hourOfDay >= NIGHT_START || hourOfDay < DAWN_START) {
            return new Color(NIGHT_COLOR);
        }

        // Dawn transition
        if (hourOfDay >= DAWN_START && hourOfDay < DAY_START) {
            float progress = (hourOfDay - DAWN_START);
            return result.set(DAWN_COLOR).lerp(DAY_COLOR, progress);
        }

        // Day time
        if (hourOfDay >= DAY_START && hourOfDay < DUSK_START) {
            return new Color(DAY_COLOR);
        }

        // Dusk transition
        float progress = (hourOfDay - DUSK_START);
        return result.set(DAY_COLOR).lerp(NIGHT_COLOR, progress);
    }

    private static float clamp(float value, float min, float max) {
        return Math.max(min, Math.min(max, value));
    }
    public static String getTimeString(double worldTimeInMinutes) {
        int hour = (int)(worldTimeInMinutes / 60) % 24;
        int minute = (int)(worldTimeInMinutes % 60);
        String amPm = hour >= 12 ? "PM" : "AM";
        hour = hour % 12;
        if (hour == 0) hour = 12;
        return String.format("%d:%02d %s", hour, minute, amPm);
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/EnhancedWorldObjectSpawner.java
================
// File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/EnhancedWorldObjectSpawner.java

package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Refined world object spawning system with proper spacing
 * and balanced vegetation distribution.
 */
public class EnhancedWorldObjectSpawner {

    // Increased minimum spacing between trees
    private static final float MIN_TREE_SPACING = 3.5f;

    // Higher spacing for specific large trees
    private static final float APRICORN_TREE_SPACING = 4.0f;

    // Buffer around chunk edges to prevent cross-chunk overlap
    private static final int CHUNK_EDGE_BUFFER = 1;

    /**
     * Spawns world objects in the chunk with improved spacing and distribution.
     */
    public static List<WorldObject> spawnWorldObjects(Chunk chunk, int[][] tiles, long worldSeed) {
        List<WorldObject> spawned = new ArrayList<>();
        Random rng = new Random(worldSeed + (chunk.getChunkX() * 31L) ^ (chunk.getChunkY() * 1337L));
        Biome biome = chunk.getBiome();
        List<WorldObject.ObjectType> spawnable = biome.getSpawnableObjects();

        if (spawnable == null || spawnable.isEmpty()) {
            GameLogger.error("Biome " + biome.getName() + " returned no spawnable objects.");
            return spawned;
        }

        // First pass: spawn trees with strict spacing rules
        spawnTreeObjects(spawnable, biome, chunk, tiles, rng, spawned);

        // Second pass: spawn other objects including appropriately balanced tall grass
        spawnNonTreeObjects(spawnable, biome, chunk, tiles, rng, spawned);

        // Log summary of what was spawned
        int treeCount = 0, grassCount = 0, otherCount = 0;
        for (WorldObject obj : spawned) {
            if (isTreeType(obj.getType())) treeCount++;
            else if (isTallGrassType(obj.getType())) grassCount++;
            else otherCount++;
        }

        GameLogger.info(String.format("Spawned objects in chunk (%d,%d): %d trees, %d grass, %d other objects",
            chunk.getChunkX(), chunk.getChunkY(), treeCount, grassCount, otherCount));

        return spawned;
    }

    /**
     * Spawns tree objects with strict spacing requirements
     */
    private static void spawnTreeObjects(List<WorldObject.ObjectType> spawnable,
                                         Biome biome,
                                         Chunk chunk,
                                         int[][] tiles,
                                         Random rng,
                                         List<WorldObject> spawned) {

        // Filter for tree object types
        List<WorldObject.ObjectType> treeTypes = new ArrayList<>();
        for (WorldObject.ObjectType type : spawnable) {
            if (isTreeType(type)) {
                treeTypes.add(type);
            }
        }

        if (treeTypes.isEmpty()) return;

        // Calculate tree density (reduced from original)
        float totalTreeChance = 0;
        for (WorldObject.ObjectType type : treeTypes) {
            totalTreeChance += biome.getSpawnChanceForObject(type);
        }

        // More conservative density multiplier
        float densityMultiplier = 0.6f;
        int treeAttempts = Math.round(Chunk.CHUNK_SIZE * Chunk.CHUNK_SIZE * totalTreeChance * densityMultiplier);

        // Track tree placements in a virtual grid for quick collision detection
        boolean[][] treeGrid = new boolean[Chunk.CHUNK_SIZE + 6][Chunk.CHUNK_SIZE + 6];

        // Try to place each tree
        for (int i = 0; i < treeAttempts; i++) {
            // Pick a random tree type based on weighted probabilities
            WorldObject.ObjectType selectedType = selectRandomTreeType(treeTypes, biome, rng);
            if (selectedType == null) continue;

            // Try multiple positions to find a valid placement
            for (int attempt = 0; attempt < 15; attempt++) {
                // Keep trees away from chunk edges to prevent cross-chunk overlap
                int lx = CHUNK_EDGE_BUFFER + rng.nextInt(Chunk.CHUNK_SIZE - (2 * CHUNK_EDGE_BUFFER));
                int ly = CHUNK_EDGE_BUFFER + rng.nextInt(Chunk.CHUNK_SIZE - (2 * CHUNK_EDGE_BUFFER));

                // Skip if position already has a tree (quick check)
                if (treeGrid[lx + 3][ly + 3]) continue;

                // Perform thorough spacing check
                if (canPlaceTreeAt(lx, ly, selectedType, chunk, tiles, spawned, biome, treeGrid)) {
                    int worldTileX = chunk.getChunkX() * Chunk.CHUNK_SIZE + lx;
                    int worldTileY = chunk.getChunkY() * Chunk.CHUNK_SIZE + ly;

                    WorldObject tree = new WorldObject(worldTileX, worldTileY, null, selectedType);
                    tree.ensureTexture();
                    spawned.add(tree);

                    // Mark tree location and surrounding area in grid
                    markTreeInGrid(lx, ly, selectedType, treeGrid);

                    // Only add a limited number of trees per chunk
                    if (countTreesOfType(spawned, selectedType) >= getMaxTreesOfType(selectedType, biome)) {
                        break;
                    }

                    break;
                }
            }
        }
    }

    /**
     * Marks tree position and buffer zone in the grid
     */
    private static void markTreeInGrid(int lx, int ly, WorldObject.ObjectType type, boolean[][] grid) {
        int treeWidth = getTreeWidth(type);
        int treeHeight = getTreeHeight(type);

        int bufferSize = (type == WorldObject.ObjectType.APRICORN_TREE) ? 5 : 4;

        for (int dx = -bufferSize; dx < treeWidth + bufferSize; dx++) {
            for (int dy = -bufferSize; dy < treeHeight + bufferSize; dy++) {
                int gx = lx + dx + 3;
                int gy = ly + dy + 3;

                if (gx >= 0 && gx < grid.length && gy >= 0 && gy < grid[0].length) {
                    grid[gx][gy] = true;
                }
            }
        }
    }

    /**
     * Returns the maximum number of trees of a specific type to spawn per chunk
     */
    private static int getMaxTreesOfType(WorldObject.ObjectType type, Biome biome) {
        // Limit number of trees based on type and biome
        if (type == WorldObject.ObjectType.APRICORN_TREE) {
            return 2; // Limit to 2 apricorn trees per chunk
        } else if (biome.getType() == BiomeType.FOREST || biome.getType() == BiomeType.RAIN_FOREST) {
            return 6; // More trees in forest biomes
        } else {
            return 4; // Default for other biomes
        }
    }

    /**
     * Count trees of a specific type in the spawned list
     */
    private static int countTreesOfType(List<WorldObject> spawned, WorldObject.ObjectType type) {
        int count = 0;
        for (WorldObject obj : spawned) {
            if (obj.getType() == type) {
                count++;
            }
        }
        return count;
    }

    /**
     * Spawns non-tree objects with balanced distribution
     */
    private static void spawnNonTreeObjects(List<WorldObject.ObjectType> spawnable,
                                            Biome biome,
                                            Chunk chunk,
                                            int[][] tiles,
                                            Random rng,
                                            List<WorldObject> spawned) {

        // Track tall grass count to limit total amount
        int tallGrassCount = 0;
        int maxTallGrassPerChunk = calculateMaxGrassPerChunk(biome);

        for (WorldObject.ObjectType type : spawnable) {
            if (isTreeType(type)) continue; // Skip trees, already handled

            // Adjusted multipliers - reduced for tall grass but still more than original
            float multiplier;
            if (isTallGrassType(type)) {
                multiplier = 0.4f; // Reduced from 0.85f to create a more balanced amount
                if (tallGrassCount >= maxTallGrassPerChunk) continue;
            } else {
                multiplier = 0.35f; // Other objects stay the same
            }

            double spawnChance = biome.getSpawnChanceForObject(type) * multiplier;
            int attempts = (int) (Chunk.CHUNK_SIZE * Chunk.CHUNK_SIZE * spawnChance);

            for (int i = 0; i < attempts; i++) {
                int lx = rng.nextInt(Chunk.CHUNK_SIZE);
                int ly = rng.nextInt(Chunk.CHUNK_SIZE);

                // Pass rng to canPlaceObjectAt
                if (canPlaceObjectAt(lx, ly, type, chunk, tiles, spawned, biome, rng)) {
                    int worldTileX = chunk.getChunkX() * Chunk.CHUNK_SIZE + lx;
                    int worldTileY = chunk.getChunkY() * Chunk.CHUNK_SIZE + ly;

                    WorldObject object = new WorldObject(worldTileX, worldTileY, null, type);
                    object.ensureTexture();
                    spawned.add(object);

                    if (isTallGrassType(type)) {
                        tallGrassCount++;
                        if (tallGrassCount >= maxTallGrassPerChunk) break;
                    }
                }
            }
        }
    }

    /**
     * Calculate maximum grass objects per chunk based on biome
     */
    private static int calculateMaxGrassPerChunk(Biome biome) {
        switch (biome.getType()) {
            case PLAINS:
                return 45; // Moderately grassy
            case FOREST:
            case RAIN_FOREST:
                return 35; // Still grassy but not overwhelming
            case DESERT:
                return 15; // Sparse grass in desert
            case SNOW:
                return 20; // Limited snow grass
            default:
                return 30; // Default for other biomes
        }
    }

    /**
     * Checks if a tree can be placed at the given location with strict spacing rules
     */
    private static boolean canPlaceTreeAt(int localX, int localY,
                                          WorldObject.ObjectType type,
                                          Chunk chunk,
                                          int[][] tiles,
                                          List<WorldObject> existingObjects,
                                          Biome biome,
                                          boolean[][] treeGrid) {

        // Basic terrain check
        int tileType = chunk.getTileType(localX, localY);
        if (!biome.getAllowedTileTypes().contains(tileType)) return false;
        if (!chunk.isPassable(localX, localY)) return false;

        // Skip water and beach tiles
        if (tileType == TileType.WATER || tileType == TileType.BEACH_SAND) return false;

        // Convert to world coordinates
        int worldTileX = chunk.getChunkX() * Chunk.CHUNK_SIZE + localX;
        int worldTileY = chunk.getChunkY() * Chunk.CHUNK_SIZE + localY;

        // Create a candidate object to get its placement bounding box
        WorldObject candidate = new WorldObject(worldTileX, worldTileY, null, type);
        candidate.ensureTexture();

        // Check for collision with any existing object using its full bounding box.
        if (collidesWithExistingObjects(candidate.getPlacementBoundingBox(), existingObjects)) {
            return false;
        }

        // Check if the entire tree footprint is on valid terrain
        int treeWidth = getTreeWidth(type);
        int treeHeight = getTreeHeight(type);
        for (int dx = -1; dx <= treeWidth; dx++) {
            for (int dy = -1; dy <= treeHeight; dy++) {
                int checkX = localX + dx;
                int checkY = localY + dy;

                // Skip if outside chunk bounds
                if (checkX < 0 || checkX >= Chunk.CHUNK_SIZE ||
                    checkY < 0 || checkY >= Chunk.CHUNK_SIZE) {
                    continue;
                }

                int checkTileType = chunk.getTileType(checkX, checkY);

                // Check for invalid placement tiles
                if (checkTileType == TileType.WATER ||
                    checkTileType == TileType.BEACH_SAND ||
                    !chunk.isPassable(checkX, checkY)) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Checks if a non-tree object can be placed at the given location.
     *
     * @param rng The random number generator to use for pattern creation
     */
    private static boolean canPlaceObjectAt(int localX, int localY,
                                            WorldObject.ObjectType type,
                                            Chunk chunk,
                                            int[][] tiles,
                                            List<WorldObject> existingObjects,
                                            Biome biome,
                                            Random rng) {

        // Basic terrain check
        int tileType = chunk.getTileType(localX, localY);
        if (!biome.getAllowedTileTypes().contains(tileType)) return false;
        if (!chunk.isPassable(localX, localY)) return false;

        // Convert to world coordinates
        int worldTileX = chunk.getChunkX() * Chunk.CHUNK_SIZE + localX;
        int worldTileY = chunk.getChunkY() * Chunk.CHUNK_SIZE + localY;

        // Create a candidate object to get its placement bounding box
        WorldObject candidate = new WorldObject(worldTileX, worldTileY, null, type);
        candidate.ensureTexture();

        // Check for collision with any existing object using its full bounding box.
        if (collidesWithExistingObjects(candidate.getPlacementBoundingBox(), existingObjects)) {
            return false;
        }

        // Special case for tall grass
        if (isTallGrassType(type)) {
            // Don't spawn grass in water
            if (tileType == TileType.WATER) return false;
            // Apply a simple random pattern to make grass less uniform
            return rng.nextFloat() < 0.65f;
        }

        // For other objects, don't spawn on water or sand
        if (tileType == TileType.WATER || tileType == TileType.BEACH_SAND) return false;

        return true;
    }

    /**
     * Checks if a candidate object's bounds would overlap with any existing objects.
     * This ensures that new objects, including large ones like trees, do not spawn on top of others.
     * @param candidateBounds The bounding box of the object to be placed.
     * @param existingObjects A list of objects already in the chunk.
     * @return true if a collision is detected, false otherwise.
     */
    private static boolean collidesWithExistingObjects(Rectangle candidateBounds, List<WorldObject> existingObjects) {
        for (WorldObject existing : existingObjects) {
            // Use the placement bounding box for the most accurate check of occupied space
            if (candidateBounds.overlaps(existing.getPlacementBoundingBox())) {
                return true;
            }
        }
        return false;
    }

    /**
     * Selects a random tree type based on weighted probabilities.
     */
    private static WorldObject.ObjectType selectRandomTreeType(List<WorldObject.ObjectType> trees,
                                                               Biome biome,
                                                               Random rng) {
        if (trees.isEmpty()) return null;

        float totalWeight = 0;
        for (WorldObject.ObjectType type : trees) {
            totalWeight += biome.getSpawnChanceForObject(type);
        }

        if (totalWeight <= 0) return trees.get(0);

        float roll = rng.nextFloat() * totalWeight;
        float current = 0;

        for (WorldObject.ObjectType type : trees) {
            current += biome.getSpawnChanceForObject(type);
            if (roll < current) {
                return type;
            }
        }

        return trees.get(0);
    }

    /**
     * Determines if the given object type is a tree.
     */
    private static boolean isTreeType(WorldObject.ObjectType type) {
        return type == WorldObject.ObjectType.TREE_0 ||
            type == WorldObject.ObjectType.TREE_1 ||
            type == WorldObject.ObjectType.SNOW_TREE ||
            type == WorldObject.ObjectType.HAUNTED_TREE ||
            type == WorldObject.ObjectType.RUINS_TREE ||
            type == WorldObject.ObjectType.APRICORN_TREE ||
            type == WorldObject.ObjectType.RAIN_TREE ||
            type == WorldObject.ObjectType.CHERRY_TREE ||
            type == WorldObject.ObjectType.BEACH_TREE;
    }

    /**
     * Determines if the given object type is tall grass.
     */
    private static boolean isTallGrassType(WorldObject.ObjectType type) {
        return type == WorldObject.ObjectType.TALL_GRASS ||
            type == WorldObject.ObjectType.TALL_GRASS_2 ||
            type == WorldObject.ObjectType.TALL_GRASS_3 ||
            type == WorldObject.ObjectType.FOREST_TALL_GRASS ||
            type == WorldObject.ObjectType.HAUNTED_TALL_GRASS ||
            type == WorldObject.ObjectType.RAIN_FOREST_TALL_GRASS ||
            type == WorldObject.ObjectType.DESERT_TALL_GRASS ||
            type == WorldObject.ObjectType.SNOW_TALL_GRASS ||
            type == WorldObject.ObjectType.RUINS_TALL_GRASS;
    }

    /**
     * Gets the width of a tree in tiles.
     */
    private static int getTreeWidth(WorldObject.ObjectType type) {
        if (type == WorldObject.ObjectType.APRICORN_TREE) {
            return 3; // 3x3 tree
        } else if (isTreeType(type)) {
            return 2; // 2x3 tree
        } else {
            return 1; // Default size
        }
    }

    /**
     * Gets the height of a tree in tiles.
     */
    private static int getTreeHeight(WorldObject.ObjectType type) {
        if (isTreeType(type)) {
            return 3; // Trees are 3 tiles tall
        } else {
            return 1; // Default size
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/ApproachPlayerBehavior.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.battle.BattleInitiationHandler;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonPersonalityTrait;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

// Approach Player Behavior
public class ApproachPlayerBehavior implements PokemonBehavior {
    private static final float APPROACH_RANGE = 10.0f * World.TILE_SIZE;
    private static final float OPTIMAL_DISTANCE = 2.0f * World.TILE_SIZE;

    private final WildPokemon pokemon;
    private final PokemonAI ai;

    public ApproachPlayerBehavior(WildPokemon pokemon, PokemonAI ai) {
        this.pokemon = pokemon;
        this.ai = ai;
    }

    private static final float ATTACK_RANGE = 1.25f * World.TILE_SIZE;

    @Override
    public void execute(float delta) {
        if (!pokemon.isMoving()) {
            if (ai.isOnCooldown(getName())) return;
            Player player = GameContext.get().getPlayer();
            if (player != null) {
                float distance = Vector2.dst(pokemon.getX(), pokemon.getY(), player.getX(), player.getY());

                // NEW: Check for forceful battle initiation
                if (ai.hasPersonalityTrait(PokemonPersonalityTrait.AGGRESSIVE) && distance <= ATTACK_RANGE) {
                    // Check if GameScreen is available and not already in battle
                    if (GameContext.get().getGameScreen() != null && !GameContext.get().getBattleSystem().isInBattle()) {

                        GameLogger.info(pokemon.getName() + " is initiating battle forcefully!");
                        // Post the action to the main game thread to avoid concurrency issues with UI
                        Gdx.app.postRunnable(() -> {
                            ((BattleInitiationHandler) GameContext.get().getGameScreen()).forceBattleInitiation(pokemon);
                        });
                        ai.setCooldown(getName(), 15f); // Cooldown after attempting to battle
                    }
                    return;
                }

                moveTowardsPlayer(player);
            }
        }
    }

    private void moveTowardsPlayer(Player player) {
        World world = GameContext.get().getWorld();
        if (world == null) return;

        int pokemonTileX = pokemon.getTileX();
        int pokemonTileY = pokemon.getTileY();
        int playerTileX = player.getTileX();
        int playerTileY = player.getTileY();

        int dx = Integer.compare(playerTileX, pokemonTileX);
        int dy = Integer.compare(playerTileY, pokemonTileY);

        if (dx == 0 && dy == 0) return; // Already at target

        // FIX: Ensure cardinal movement by randomly choosing a valid axis to move on.
        List<String> moveOptions = new ArrayList<>();
        if (dx != 0) moveOptions.add("horizontal");
        if (dy != 0) moveOptions.add("vertical");
        Collections.shuffle(moveOptions);

        for (String move : moveOptions) {
            int targetTileX = pokemonTileX;
            int targetTileY = pokemonTileY;
            String direction;

            if (move.equals("horizontal")) {
                targetTileX += dx;
                direction = dx > 0 ? "right" : "left";
            } else { // vertical
                targetTileY += dy;
                direction = dy > 0 ? "up" : "down";
            }


            if (world.isPassable(targetTileX, targetTileY)) {
                pokemon.moveToTile(targetTileX, targetTileY, direction);
                ai.setCurrentState(PokemonAI.AIState.APPROACHING);
                ai.setCooldown(getName(), 0.5f); // Was 1.0f
                return; // Move made, exit
            }
        }
    }

    public boolean canExecute() {
        if (!ai.hasPersonalityTrait(PokemonPersonalityTrait.AGGRESSIVE) &&
            !ai.hasPersonalityTrait(PokemonPersonalityTrait.CURIOUS)) {
            return false;
        }

        Player player = GameContext.get().getPlayer();
        if (player == null) return false;

        float distance = Vector2.dst(pokemon.getX(), pokemon.getY(),
            player.getX(), player.getY());

        // Aggressive pokemon will continue to approach until very close
        if (ai.hasPersonalityTrait(PokemonPersonalityTrait.AGGRESSIVE)) {
            return distance <= APPROACH_RANGE && !ai.isOnCooldown(getName());
        }

        // Curious pokemon will stop at an optimal distance
        return distance <= APPROACH_RANGE && distance > OPTIMAL_DISTANCE && !ai.isOnCooldown(getName()) && MathUtils.random() < (ai.getApproachFactor() * 0.25f);
    }

    @Override
    public int getPriority() {
        return 6;
    }

    @Override
    public String getName() {
        return "approach_player";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/DefendTerritoryBehavior.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.battle.BattleInitiationHandler;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonPersonalityTrait;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

// Defend Territory Behavior - More aggressive territory defense
public class DefendTerritoryBehavior implements PokemonBehavior {
    private static final float CHASE_DISTANCE = 20.0f * World.TILE_SIZE;

    private final WildPokemon pokemon;
    private final PokemonAI ai;
    private boolean isChasing = false;
    private int chaseStepsRemaining = 0;

    public DefendTerritoryBehavior(WildPokemon pokemon, PokemonAI ai) {
        this.pokemon = pokemon;
        this.ai = ai;
    }

    @Override
    public void execute(float delta) {
        if (!pokemon.isMoving()) {
            Player player = GameContext.get().getPlayer();
            if (player != null) {
                if (shouldChasePlayer(player)) {
                    initiateChase(player);
                } else if (isChasing) {
                    endChase();
                }
            }
        }
    }

    private boolean shouldChasePlayer(Player player) {
        Vector2 territory = ai.getTerritoryCenter();
        float playerDistanceFromTerritory = Vector2.dst(player.getX(), player.getY(), territory.x, territory.y);
        float pokemonDistanceFromPlayer = Vector2.dst(pokemon.getX(), pokemon.getY(), player.getX(), player.getY());

        return playerDistanceFromTerritory <= ai.getTerritoryRadius() &&
            pokemonDistanceFromPlayer <= CHASE_DISTANCE;
    }

    private void initiateChase(Player player) {
        if (!isChasing) {
            GameLogger.info(pokemon.getName() + " aggressively chases intruder!");
            isChasing = true;
            chaseStepsRemaining = MathUtils.random(3, 6);
        }

        if (chaseStepsRemaining > 0) {
            moveTowardsPlayer(player);
            float distance = Vector2.dst(pokemon.getX(), pokemon.getY(), player.getX(), player.getY());
            if (distance <= 1.5f * World.TILE_SIZE) {
                if (GameContext.get().getGameScreen() != null && !GameContext.get().getBattleSystem().isInBattle()) {
                    GameLogger.info(pokemon.getName() + " is initiating battle while defending territory!");
                    Gdx.app.postRunnable(() -> {
                        ((BattleInitiationHandler) GameContext.get().getGameScreen()).forceBattleInitiation(pokemon);
                    });
                    ai.setCooldown(getName(), 15f);
                    endChase(); // End the chase behavior
                    return;
                }
            }
            chaseStepsRemaining--;
        } else {
            endChase();
        }}
    private void moveTowardsPlayer(Player player) {
        World world = GameContext.get().getWorld();
        if (world == null) return;

        int pokemonTileX = pokemon.getTileX();
        int pokemonTileY = pokemon.getTileY();
        int playerTileX = player.getTileX();
        int playerTileY = player.getTileY();

        int dx = Integer.compare(playerTileX, pokemonTileX);
        int dy = Integer.compare(playerTileY, pokemonTileY);

        if (dx == 0 && dy == 0) return;

        // FIX: Ensure cardinal movement by randomly choosing a valid axis to move on.
        List<String> moveOptions = new ArrayList<>();
        if (dx != 0) moveOptions.add("horizontal");
        if (dy != 0) moveOptions.add("vertical");
        Collections.shuffle(moveOptions);

        for (String move : moveOptions) {
            int targetTileX = pokemonTileX;
            int targetTileY = pokemonTileY;
            String direction;

            if (move.equals("horizontal")) {
                targetTileX += dx;
                direction = dx > 0 ? "right" : "left";
            } else { // vertical
                targetTileY += dy;
                direction = dy > 0 ? "up" : "down";
            }

            if (world.isPassable(targetTileX, targetTileY)) {
                pokemon.moveToTile(targetTileX, targetTileY, direction);
                ai.setCurrentState(PokemonAI.AIState.APPROACHING);
                return; // Move made, exit
            }
        }
    }

    private void endChase() {
        isChasing = false;
        chaseStepsRemaining = 0;
        ai.setCooldown(getName(), 8.0f);
        GameLogger.info(pokemon.getName() + " stops chasing");
    }

    @Override
    public boolean canExecute() {
        return ai.hasPersonalityTrait(PokemonPersonalityTrait.TERRITORIAL) &&
            ai.hasPersonalityTrait(PokemonPersonalityTrait.AGGRESSIVE) &&
            !ai.isOnCooldown(getName());
    }

    @Override
    public int getPriority() {
        return 9; // Very high priority
    }

    @Override
    public String getName() {
        return "defend_territory";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/FleeBehavior.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;

// Flee Behavior
public class FleeBehavior implements PokemonBehavior {
    private static final float FLEE_SPEED_MULTIPLIER = 0.5f; // Faster movement
    private static final int MAX_FLEE_STEPS = 32;

    private final WildPokemon pokemon;
    private final PokemonAI ai;
    private int fleeStepsRemaining = 0;
    private String fleeDirection;

    public FleeBehavior(WildPokemon pokemon, PokemonAI ai) {
        this.pokemon = pokemon;
        this.ai = ai;
    }

    @Override
    public void execute(float delta) {
        if (!pokemon.isMoving()) {
            if (fleeStepsRemaining <= 0) {
                initiateFlee();
            } else {
                continueFleeMovement();
            }
        }
    }

    private void initiateFlee() {
        Player player = GameContext.get().getPlayer();
        if (player == null) return;

        fleeDirection = calculateFleeDirection(player);
        fleeStepsRemaining = MathUtils.random(2, MAX_FLEE_STEPS);
        continueFleeMovement();
    }

    private void continueFleeMovement() {
        World world = GameContext.get().getWorld();
        if (world == null) return;

        int currentTileX = (int) (pokemon.getX() / World.TILE_SIZE);
        int currentTileY = (int) (pokemon.getY() / World.TILE_SIZE);

        int targetTileX = currentTileX;
        int targetTileY = currentTileY;

        switch (fleeDirection) {
            case "up":
                targetTileY++;
                break;
            case "down":
                targetTileY--;
                break;
            case "left":
                targetTileX--;
                break;
            case "right":
                targetTileX++;
                break;
        }

        if (world.isPassable(targetTileX, targetTileY)) {
            pokemon.moveToTile(targetTileX, targetTileY, fleeDirection);
            fleeStepsRemaining--;
            ai.setCurrentState(PokemonAI.AIState.FLEEING);
        } else {
            // Try alternative directions
            tryAlternativeFleeDirection(world);
        }

        if (fleeStepsRemaining <= 0) {
            ai.setCooldown(getName(), 5.0f);
        }
    }

    private void tryAlternativeFleeDirection(World world) {
        String[] alternatives = {"up", "down", "left", "right"};
        int currentTileX = (int) (pokemon.getX() / World.TILE_SIZE);
        int currentTileY = (int) (pokemon.getY() / World.TILE_SIZE);

        for (String direction : alternatives) {
            if (direction.equals(fleeDirection)) continue;

            int targetTileX = currentTileX;
            int targetTileY = currentTileY;

            switch (direction) {
                case "up":
                    targetTileY++;
                    break;
                case "down":
                    targetTileY--;
                    break;
                case "left":
                    targetTileX--;
                    break;
                case "right":
                    targetTileX++;
                    break;
            }

            if (world.isPassable(targetTileX, targetTileY)) {
                pokemon.moveToTile(targetTileX, targetTileY, direction);
                fleeDirection = direction;
                fleeStepsRemaining--;
                return;
            }
        }

        // No valid escape route
        fleeStepsRemaining = 0;
    }

    private String calculateFleeDirection(Player player) {
        int pokemonTileX = (int) (pokemon.getX() / World.TILE_SIZE);
        int pokemonTileY = (int) (pokemon.getY() / World.TILE_SIZE);
        int playerTileX = (int) (player.getX() / World.TILE_SIZE);
        int playerTileY = (int) (player.getY() / World.TILE_SIZE);

        int dx = pokemonTileX - playerTileX;
        int dy = pokemonTileY - playerTileY;

        if (Math.abs(dx) >= Math.abs(dy)) {
            return (dx >= 0) ? "right" : "left";
        } else {
            return (dy >= 0) ? "up" : "down";
        }
    }

    @Override
    public boolean canExecute() {
        Player player = GameContext.get().getPlayer();
        if (player == null) return false;

        float distance = Vector2.dst(pokemon.getX(), pokemon.getY(),
            player.getX(), player.getY());
        return distance < ai.getFleeThreshold();
    }

    @Override
    public int getPriority() {
        return 8; // High priority
    }

    @Override
    public String getName() {
        return "flee";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/FollowPackBehavior.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonPersonalityTrait;

import java.util.*;

public class FollowPackBehavior implements PokemonBehavior {
    private static final float FOLLOW_DISTANCE = 3.0f * World.TILE_SIZE;
    private static final float MAX_FOLLOW_DISTANCE = 6.0f * World.TILE_SIZE;

    private final WildPokemon pokemon;
    private final PokemonAI ai;

    public FollowPackBehavior(WildPokemon pokemon, PokemonAI ai) {
        this.pokemon = pokemon;
        this.ai = ai;
    }

    @Override
    public void execute(float delta) {
        if (!pokemon.isMoving()) {
            WildPokemon leader = findPackLeader();
            if (leader != null) {
                followLeader(leader);
            }
        }
    }

    private WildPokemon findPackLeader() {
        UUID leaderId = ai.getPackLeaderId();
        if (leaderId == null) return null;

        // In a real implementation, you'd get this from the spawn manager
        Collection<WildPokemon> nearbyPokemon = GameContext.get().getWorld()
            .getPokemonSpawnManager().getPokemonInRange(
                pokemon.getX(), pokemon.getY(), MAX_FOLLOW_DISTANCE);

        for (WildPokemon nearby : nearbyPokemon) {
            if (nearby.getUuid().equals(leaderId)) {
                return nearby;
            }
        }

        return null;
    }

    private void followLeader(WildPokemon leader) {
        float distance = Vector2.dst(pokemon.getX(), pokemon.getY(),
            leader.getX(), leader.getY());

        // Only follow if too far away
        if (distance <= FOLLOW_DISTANCE) {
            return;
        }

        World world = GameContext.get().getWorld();
        if (world == null) return;

        int pokemonTileX = (int) (pokemon.getX() / World.TILE_SIZE);
        int pokemonTileY = (int) (pokemon.getY() / World.TILE_SIZE);
        int leaderTileX = (int) (leader.getX() / World.TILE_SIZE);
        int leaderTileY = (int) (leader.getY() / World.TILE_SIZE);

        int dx = Integer.compare(leaderTileX, pokemonTileX);
        int dy = Integer.compare(leaderTileY, pokemonTileY);

        // FIX: Ensure cardinal movement by randomly choosing a valid axis to move on.
        List<String> moveOptions = new ArrayList<>();
        if (dx != 0) moveOptions.add("horizontal");
        if (dy != 0) moveOptions.add("vertical");
        Collections.shuffle(moveOptions);
        String direction;

        for (String move : moveOptions) {
            int targetTileX = pokemonTileX;
            int targetTileY = pokemonTileY;

            if (move.equals("horizontal")) {
                targetTileX += dx;
                direction = dx > 0 ? "right" : "left";
            } else { // vertical
                targetTileY += dy;
                direction = dy > 0 ? "up" : "down";
            }

            if (world.isPassable(targetTileX, targetTileY)) {
                pokemon.moveToTile(targetTileX, targetTileY, direction);
                ai.setCurrentState(PokemonAI.AIState.FOLLOWING);
                ai.setCooldown(getName(), 0.5f); // Was 1.0f
                return; // Move made, exit
            }
        }
    }

    @Override
    public boolean canExecute() {
        return ai.hasPersonalityTrait(PokemonPersonalityTrait.FOLLOWER) &&
            ai.getPackLeaderId() != null &&
            !ai.isOnCooldown(getName());
    }

    @Override
    public int getPriority() {
        return 6; // Higher than wandering, lower than fleeing
    }

    @Override
    public String getName() {
        return "follow_pack";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/IdleBehavior.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

import com.badlogic.gdx.math.MathUtils;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;

public class IdleBehavior implements PokemonBehavior {
    // Shorter idle times to encourage more frequent movement.
    private static final float MIN_IDLE_TIME = 0.3f; // Was 0.5f
    private static final float MAX_IDLE_TIME = 1.2f; // Was 1.5f

    private final WildPokemon pokemon;
    private final PokemonAI ai;
    private float idleDuration;

    public IdleBehavior(WildPokemon pokemon, PokemonAI ai) {
        this.pokemon = pokemon;
        this.ai = ai;
        this.idleDuration = MathUtils.random(MIN_IDLE_TIME, MAX_IDLE_TIME);
    }

    @Override
    public void execute(float delta) {
        if (ai.getStateTimer() >= idleDuration) {
            idleDuration = MathUtils.random(MIN_IDLE_TIME, MAX_IDLE_TIME);
            ai.setCurrentState(PokemonAI.AIState.IDLE);
        }
    }

    @Override
    public boolean canExecute() {
        return !pokemon.isMoving();
    }

    @Override
    public int getPriority() {
        return 1; // Lowest priority - default behavior
    }

    @Override
    public String getName() {
        return "idle";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/InvestigateBehavior.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonPersonalityTrait;

// Investigate Behavior
public class InvestigateBehavior implements PokemonBehavior {
    private static final float INVESTIGATION_RANGE = 20.0f * World.TILE_SIZE;

    private final WildPokemon pokemon;
    private final PokemonAI ai;
    private Vector2 investigationTarget;

    public InvestigateBehavior(WildPokemon pokemon, PokemonAI ai) {
        this.pokemon = pokemon;
        this.ai = ai;
    }

    @Override
    public void execute(float delta) {
        if (!pokemon.isMoving()) {
            if (investigationTarget == null) {
                findSomethingToInvestigate();
            } else {
                moveTowardsInvestigationTarget();
            }
        }
    }

    private void findSomethingToInvestigate() {
        Player player = GameContext.get().getPlayer();
        if (player != null) {
            float distance = Vector2.dst(pokemon.getX(), pokemon.getY(),
                player.getX(), player.getY());
            if (distance <= INVESTIGATION_RANGE) {
                investigationTarget = new Vector2(player.getX(), player.getY());
            }
        }
    }

    private void moveTowardsInvestigationTarget() {
        World world = GameContext.get().getWorld();
        if (world == null) return;

        int pokemonTileX = (int) (pokemon.getX() / World.TILE_SIZE);
        int pokemonTileY = (int) (pokemon.getY() / World.TILE_SIZE);
        int targetTileX = (int) (investigationTarget.x / World.TILE_SIZE);
        int targetTileY = (int) (investigationTarget.y / World.TILE_SIZE);

        // If we've reached the investigation point
        if (pokemonTileX == targetTileX && pokemonTileY == targetTileY) {
            investigationTarget = null;
            ai.setCooldown(getName(), 10.0f);
            return;
        }

        int dx = Integer.compare(targetTileX, pokemonTileX);
        int dy = Integer.compare(targetTileY, pokemonTileY);

        String direction;
        int nextTileX = pokemonTileX;
        int nextTileY = pokemonTileY;

        if (Math.abs(dx) >= Math.abs(dy)) {
            direction = dx > 0 ? "right" : "left";
            nextTileX += dx;
        } else {
            direction = dy > 0 ? "up" : "down";
            nextTileY += dy;
        }

        if (world.isPassable(nextTileX, nextTileY)) {
            pokemon.moveToTile(nextTileX, nextTileY, direction);
            ai.setCurrentState(PokemonAI.AIState.INVESTIGATING);
        } else {
            investigationTarget = null; // Can't reach target
        }
    }

    @Override
    public boolean canExecute() {
        return ai.hasPersonalityTrait(PokemonPersonalityTrait.CURIOUS) &&
            !ai.isOnCooldown(getName()) &&
            MathUtils.random() < 0.05f; // 5% chance per update
    }

    @Override
    public int getPriority() {
        return 5;
    }

    @Override
    public String getName() {
        return "investigate";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/PackLeaderBehavior.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonPersonalityTrait;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

// Pack Leader Behavior - Coordinates pack movement and behavior
public class PackLeaderBehavior implements PokemonBehavior {
    private static final float PACK_COORDINATION_RANGE = 16.0f * World.TILE_SIZE;
    private static final float LEADERSHIP_COOLDOWN = 0.5f;

    private final WildPokemon pokemon;
    private final PokemonAI ai;
    private Vector2 packDestination;

    public PackLeaderBehavior(WildPokemon pokemon, PokemonAI ai) {
        this.pokemon = pokemon;
        this.ai = ai;
    }

    @Override
    public void execute(float delta) {
        if (!pokemon.isMoving()) {
            coordinatePackMovement();
            ai.setCooldown(getName(), LEADERSHIP_COOLDOWN);
        }
    }

    private void coordinatePackMovement() {
        // Determine where the pack should move
        if (packDestination == null || hasReachedDestination()) {
            packDestination = selectNewPackDestination();
        }

        if (packDestination != null) {
            moveTowardsDestination();
            signalPackMembers();
        }
    }

    private Vector2 selectNewPackDestination() {
        World world = GameContext.get().getWorld();
        if (world == null) return null;

        // Choose a destination within territory if territorial, otherwise random
        Vector2 center = ai.hasPersonalityTrait(PokemonPersonalityTrait.TERRITORIAL) ?
            ai.getTerritoryCenter() : new Vector2(pokemon.getX(), pokemon.getY());

        float maxRange = ai.hasPersonalityTrait(PokemonPersonalityTrait.TERRITORIAL) ?
            ai.getTerritoryRadius() : PACK_COORDINATION_RANGE;

        for (int attempts = 0; attempts < 10; attempts++) {
            float angle = MathUtils.random(MathUtils.PI2);
            float distance = MathUtils.random(World.TILE_SIZE * 2, maxRange);
            float x = center.x + MathUtils.cos(angle) * distance;
            float y = center.y + MathUtils.sin(angle) * distance;

            int tileX = Math.round(x / World.TILE_SIZE);
            int tileY = Math.round(y / World.TILE_SIZE);

            if (world.isPassable(tileX, tileY)) {
                return new Vector2(tileX * World.TILE_SIZE, tileY * World.TILE_SIZE);
            }
        }

        return null;
    }

    private boolean hasReachedDestination() {
        if (packDestination == null) return true;

        float distance = Vector2.dst(pokemon.getX(), pokemon.getY(),
            packDestination.x, packDestination.y);
        return distance <= World.TILE_SIZE;
    }
    private void moveTowardsDestination() {
        World world = GameContext.get().getWorld();
        if (world == null || packDestination == null) return;

        int pokemonTileX = pokemon.getTileX();
        int pokemonTileY = pokemon.getTileY();
        int destTileX = (int) (packDestination.x / World.TILE_SIZE);
        int destTileY = (int) (packDestination.y / World.TILE_SIZE);

        int dx = Integer.compare(destTileX, pokemonTileX);
        int dy = Integer.compare(destTileY, pokemonTileY);

        if (dx == 0 && dy == 0) return;

        // FIX: Ensure cardinal movement by randomly choosing a valid axis to move on.
        List<String> moveOptions = new ArrayList<>();
        if (dx != 0) moveOptions.add("horizontal");
        if (dy != 0) moveOptions.add("vertical");
        Collections.shuffle(moveOptions);

        for (String move : moveOptions) {
            int targetTileX = pokemonTileX;
            int targetTileY = pokemonTileY;
            String direction;

            if (move.equals("horizontal")) {
                targetTileX += dx;
                direction = dx > 0 ? "right" : "left";
            } else { // vertical
                targetTileY += dy;
                direction = dy > 0 ? "up" : "down";
            }

            if (world.isPassable(targetTileX, targetTileY)) {
                pokemon.moveToTile(targetTileX, targetTileY, direction);
                ai.setCurrentState(PokemonAI.AIState.WANDERING);
                return; // Move made, exit
            }
        }
    }

    private void signalPackMembers() {
        // Pack members will detect leader movement and follow
        // This is handled in the FollowPackBehavior
        GameLogger.info("Pack leader " + pokemon.getName() + " signals movement");
    }

    @Override
    public boolean canExecute() {
        return ai.hasPersonalityTrait(PokemonPersonalityTrait.PACK_LEADER) &&
            !ai.getPackMembers().isEmpty() &&
            !ai.isOnCooldown(getName());
    }

    @Override
    public int getPriority() {
        return 5;
    }

    @Override
    public String getName() {
        return "pack_leader";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/PatrolBehavior.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonPersonalityTrait;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

// Patrol Behavior
public class PatrolBehavior implements PokemonBehavior {
    private final WildPokemon pokemon;
    private final PokemonAI ai;

    public PatrolBehavior(WildPokemon pokemon, PokemonAI ai) {
        this.pokemon = pokemon;
        this.ai = ai;
    }

    @Override
    public void execute(float delta) {
        if (!pokemon.isMoving() && !ai.getPatrolRoute().isEmpty()) {
            moveToNextPatrolPoint();
        }
    }

    private void moveToNextPatrolPoint() {
        World world = GameContext.get().getWorld();
        if (world == null) return;

        Vector2 currentTarget = ai.getCurrentPatrolTarget();
        if (currentTarget == null) {
            ai.setCurrentPatrolIndex(0);
            currentTarget = ai.getCurrentPatrolTarget();
        }

        if (currentTarget != null) {
            int targetTileX = (int) (currentTarget.x / World.TILE_SIZE);
            int targetTileY = (int) (currentTarget.y / World.TILE_SIZE);
            int pokemonTileX = (int) (pokemon.getX() / World.TILE_SIZE);
            int pokemonTileY = (int) (pokemon.getY() / World.TILE_SIZE);

            // Check if we've reached the patrol point
            if (pokemonTileX == targetTileX && pokemonTileY == targetTileY) {
                // Move to next patrol point
                int nextIndex = (ai.getCurrentPatrolIndex() + 1) % ai.getPatrolRoute().size();
                ai.setCurrentPatrolIndex(nextIndex);
                ai.setCooldown(getName(), 0.75f); // Was 2.0f
                return;
            }

            // Move towards current patrol point
            int dx = Integer.compare(targetTileX, pokemonTileX);
            int dy = Integer.compare(targetTileY, pokemonTileY);

            // FIX: Ensure cardinal movement by randomly choosing a valid axis to move on.
            List<String> moveOptions = new ArrayList<>();
            if (dx != 0) moveOptions.add("horizontal");
            if (dy != 0) moveOptions.add("vertical");
            Collections.shuffle(moveOptions);

            for (String move : moveOptions) {
                int nextTileX = pokemonTileX;
                int nextTileY = pokemonTileY;
                String direction;

                if (move.equals("horizontal")) {
                    nextTileX += dx;
                    direction = dx > 0 ? "right" : "left";
                } else { // vertical
                    nextTileY += dy;
                    direction = dy > 0 ? "up" : "down";
                }

                if (world.isPassable(nextTileX, nextTileY)) {
                    pokemon.moveToTile(nextTileX, nextTileY, direction);
                    ai.setCurrentState(PokemonAI.AIState.PATROLLING);
                    return; // Move made, exit
                }
            }
        }
    }

    @Override
    public boolean canExecute() {
        return ai.hasPersonalityTrait(PokemonPersonalityTrait.TERRITORIAL) &&
            !ai.getPatrolRoute().isEmpty() &&
            !ai.isOnCooldown(getName()) &&
            ai.getStateTimer() > 3.0f;
    }

    @Override
    public int getPriority() {
        return 4;
    }

    @Override
    public String getName() {
        return "patrol";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/PokemonBehavior.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

public interface PokemonBehavior {
    void execute(float delta);
    boolean canExecute();
    int getPriority();
    String getName();
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/SocialInteractionBehavior.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

import com.badlogic.gdx.math.MathUtils;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonPersonalityTrait;
import io.github.pokemeetup.utils.GameLogger;

import java.util.Collection;

// Social Interaction Behavior - Pokemon interact with each other
public class SocialInteractionBehavior implements PokemonBehavior {
    private static final float INTERACTION_RANGE = 2.0f * World.TILE_SIZE;
    private static final float SOCIAL_COOLDOWN = 4.0f; // Was 10.0f

    private final WildPokemon pokemon;
    private final PokemonAI ai;

    public SocialInteractionBehavior(WildPokemon pokemon, PokemonAI ai) {
        this.pokemon = pokemon;
        this.ai = ai;
    }

    @Override
    public void execute(float delta) {
        if (!pokemon.isMoving()) {
            WildPokemon nearbyPokemon = findNearbyPokemon();
            if (nearbyPokemon != null) {
                interactWith(nearbyPokemon);
            }
        }
    }

    private WildPokemon findNearbyPokemon() {
        Collection<WildPokemon> nearby = GameContext.get().getWorld()
            .getPokemonSpawnManager().getPokemonInRange(
                pokemon.getX(), pokemon.getY(), INTERACTION_RANGE);

        for (WildPokemon other : nearby) {
            if (!other.getUuid().equals(pokemon.getUuid()) && !other.isMoving()) {
                return other;
            }
        }

        return null;
    }

    private void interactWith(WildPokemon other) {
        // Different interaction types based on personality
        if (ai.hasPersonalityTrait(PokemonPersonalityTrait.AGGRESSIVE)) {
            // Aggressive Pokemon might challenge others
            GameLogger.info(pokemon.getName() + " challenges " + other.getName());
        } else if (ai.hasPersonalityTrait(PokemonPersonalityTrait.CURIOUS)) {
            // Curious Pokemon might investigate
            GameLogger.info(pokemon.getName() + " curiously approaches " + other.getName());
        } else {
            // Peaceful interaction
            GameLogger.info(pokemon.getName() + " peacefully interacts with " + other.getName());
        }

        ai.setCooldown(getName(), SOCIAL_COOLDOWN);
    }

    @Override
    public boolean canExecute() {
        return !ai.hasPersonalityTrait(PokemonPersonalityTrait.SOLITARY) &&
            !ai.isOnCooldown(getName()) &&
            MathUtils.random() < 0.2f; // Was 0.05f (5% chance)
    }

    @Override
    public int getPriority() {
        return 2; // Low priority
    }

    @Override
    public String getName() {
        return "social_interaction";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/TerritorialBehavior.java
================
// Additional Behavior Implementations
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonPersonalityTrait;
import io.github.pokemeetup.utils.GameLogger;

// Territorial Behavior - Actively defends territory boundaries
public class TerritorialBehavior implements PokemonBehavior {
    private static final float TERRITORY_AGGRESSION_RANGE = 3.0f * World.TILE_SIZE;

    private final WildPokemon pokemon;
    private final PokemonAI ai;
    private boolean isDefending = false;

    public TerritorialBehavior(WildPokemon pokemon, PokemonAI ai) {
        this.pokemon = pokemon;
        this.ai = ai;
    }

    @Override
    public void execute(float delta) {
        if (!pokemon.isMoving()) {
            Player player = GameContext.get().getPlayer();
            if (player != null && isPlayerInTerritory(player)) {
                initiateDefense(player);
            } else {
                isDefending = false;
            }
        }
    }

    private boolean isPlayerInTerritory(Player player) {
        Vector2 territory = ai.getTerritoryCenter();
        float distance = Vector2.dst(player.getX(), player.getY(), territory.x, territory.y);
        return distance <= ai.getTerritoryRadius();
    }

    private void initiateDefense(Player player) {
        if (!isDefending) {
            GameLogger.info(pokemon.getName() + " is defending its territory!");
            isDefending = true;
        }

        // Move towards the boundary between player and territory center
        Vector2 territory = ai.getTerritoryCenter();
        int pokemonTileX = (int)(pokemon.getX() / World.TILE_SIZE);
        int pokemonTileY = (int)(pokemon.getY() / World.TILE_SIZE);
        int playerTileX = (int)(player.getX() / World.TILE_SIZE);
        int playerTileY = (int)(player.getY() / World.TILE_SIZE);

        // Move towards player but stop at territory edge
        int dx = Integer.compare(playerTileX, pokemonTileX);
        int dy = Integer.compare(playerTileY, pokemonTileY);

        String direction;
        int targetTileX = pokemonTileX;
        int targetTileY = pokemonTileY;

        if (Math.abs(dx) >= Math.abs(dy)) {
            direction = dx > 0 ? "right" : "left";
            targetTileX += dx;
        } else {
            direction = dy > 0 ? "up" : "down";
            targetTileY += dy;
        }

        World world = GameContext.get().getWorld();
        if (world != null && world.isPassable(targetTileX, targetTileY)) {
            pokemon.moveToTile(targetTileX, targetTileY, direction);
            ai.setCurrentState(PokemonAI.AIState.APPROACHING);
        }
    }

    @Override
    public boolean canExecute() {
        return ai.hasPersonalityTrait(PokemonPersonalityTrait.TERRITORIAL) &&
            !ai.isOnCooldown(getName());
    }

    @Override
    public int getPriority() {
        return 7; // High priority when defending territory
    }

    @Override
    public String getName() {
        return "territorial_defense";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/behaviors/WanderBehavior.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonPersonalityTrait;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class WanderBehavior implements PokemonBehavior {
    // Make Pokemon move more frequently by reducing cooldown.
    private static final float WANDER_COOLDOWN = 0.4f; // Was 1.0f

    private final WildPokemon pokemon;
    private final PokemonAI ai;

    public WanderBehavior(WildPokemon pokemon, PokemonAI ai) {
        this.pokemon = pokemon;
        this.ai = ai;
    }

    @Override
    public void execute(float delta) {
        if (!pokemon.isMoving()) {
            World world = GameContext.get().getWorld();
            if (world != null) {
                moveRandomDirection(world);
                ai.setCooldown(getName(), WANDER_COOLDOWN);
            }
        }
    }

    private void moveRandomDirection(World world) {
        // 15% chance to just stay idle for this tick, makes movement less predictable.
        if (MathUtils.random() < 0.15f) {
            ai.setCooldown(getName(), WANDER_COOLDOWN * 1.5f); // Slightly longer cooldown if idling
            return;
        }

        int currentTileX = pokemon.getTileX();
        int currentTileY = pokemon.getTileY();
        String lastDirection = pokemon.getDirection();

        // Create a list of potential directions
        List<String> potentialDirections = new ArrayList<>(Arrays.asList("up", "down", "left", "right"));

        // Shuffle to randomize the order of non-priority directions
        Collections.shuffle(potentialDirections);

        // Bias towards continuing in the same direction by moving it to the front
        potentialDirections.remove(lastDirection);
        potentialDirections.add(0, lastDirection);

        // Try to move in the prioritized order
        for (String direction : potentialDirections) {
            int targetTileX = currentTileX;
            int targetTileY = currentTileY;

            switch (direction) {
                case "up":    targetTileY++; break;
                case "down":  targetTileY--; break;
                case "left":  targetTileX--; break;
                case "right": targetTileX++; break;
            }

            if (world.isPassable(targetTileX, targetTileY) && isWithinWanderRange(targetTileX, targetTileY)) {
                pokemon.moveToTile(targetTileX, targetTileY, direction);
                ai.setCurrentState(PokemonAI.AIState.WANDERING);
                return;
            }
        }
    }

    private boolean isWithinWanderRange(int tileX, int tileY) {
        if (!ai.hasPersonalityTrait(PokemonPersonalityTrait.TERRITORIAL)) {
            return true; // No territory restrictions
        }

        Vector2 territory = ai.getTerritoryCenter();
        float distance = Vector2.dst(tileX * World.TILE_SIZE, tileY * World.TILE_SIZE,
            territory.x, territory.y);
        return distance <= ai.getTerritoryRadius();
    }

    @Override
    public boolean canExecute() {
        // Pokemon can decide to wander more quickly after stopping.
        return !pokemon.isMoving() &&
            !ai.isOnCooldown(getName()) &&
            ai.getStateTimer() > 0.4f; // Was 1.0f
    }

    @Override
    public int getPriority() {
        return 3;
    }

    @Override
    public String getName() {
        return "wander";
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/PokemonAI.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.behaviors.*;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

public class PokemonAI {
    private static final float BASE_DETECTION_RANGE = 4.0f * World.TILE_SIZE;
    private static final float UPDATE_INTERVAL = 0.1f;

    private final WildPokemon pokemon;
    private final Set<PokemonPersonalityTrait> personalityTraits;
    private final List<PokemonBehavior> behaviors;
    private final Map<String, Float> behaviorCooldowns;
    private final Vector2 territoryCenter;
    private final float territoryRadius;

    private float updateTimer = 0f;
    private boolean isPaused = false;
    private AIState currentState = AIState.IDLE;
    private PokemonBehavior activeBehavior;
    private UUID packLeaderId;
    private Set<UUID> packMembers = new HashSet<>();

    // Movement state
    private float stateTimer = 0f;
    private Vector2 patrolTarget;
    private List<Vector2> patrolRoute = new ArrayList<>();
    private int currentPatrolIndex = 0;

    public PokemonAI(WildPokemon pokemon) {
        this.pokemon = pokemon;
        this.personalityTraits = generatePersonalityTraits();
        this.behaviors = new ArrayList<>();
        this.behaviorCooldowns = new HashMap<>();
        this.territoryCenter = new Vector2(pokemon.getX(), pokemon.getY());
        this.territoryRadius = calculateTerritoryRadius();

        initializeBehaviors();
        setupPatrolRoute();

        GameLogger.info("Created enhanced AI for " + pokemon.getName() +
            " with traits: " + personalityTraits.toString());
    }

    private Set<PokemonPersonalityTrait> generatePersonalityTraits() {
        Set<PokemonPersonalityTrait> traits = new HashSet<>();

        // Primary personality (always has one)
        PokemonPersonalityTrait[] primaryTraits = {
            PokemonPersonalityTrait.AGGRESSIVE, PokemonPersonalityTrait.PASSIVE,
            PokemonPersonalityTrait.CURIOUS, PokemonPersonalityTrait.TIMID,
            PokemonPersonalityTrait.TERRITORIAL, PokemonPersonalityTrait.LAZY
        };
        traits.add(primaryTraits[MathUtils.random(primaryTraits.length - 1)]);

        // Social behavior (70% chance)
        if (MathUtils.random() < 0.7f) {
            PokemonPersonalityTrait[] socialTraits = {
                PokemonPersonalityTrait.PACK_LEADER, PokemonPersonalityTrait.FOLLOWER,
                PokemonPersonalityTrait.SOLITARY
            };
            traits.add(socialTraits[MathUtils.random(socialTraits.length - 1)]);
        }

        // Time preference (30% chance)
        if (MathUtils.random() < 0.3f) {
            traits.add(MathUtils.randomBoolean() ?
                PokemonPersonalityTrait.NOCTURNAL : PokemonPersonalityTrait.DIURNAL);
        }

        // Species-specific traits
        addSpeciesSpecificTraits(traits);

        return traits;
    }

    private void addSpeciesSpecificTraits(Set<PokemonPersonalityTrait> traits) {
        String species = pokemon.getName().toLowerCase();

        switch (species) {
            case "growlithe":
            case "arcanine":
            case "manectric":
                traits.add(PokemonPersonalityTrait.PROTECTIVE);
                break;
            case "snorlax":
            case "sloth":
                traits.add(PokemonPersonalityTrait.LAZY);
                break;
            case "primeape":
            case "mankey":
                traits.add(PokemonPersonalityTrait.AGGRESSIVE);
                break;
            case "eevee":
            case "skitty":
                traits.add(PokemonPersonalityTrait.CURIOUS);
                break;
        }
    }

    private void initializeBehaviors() {
        behaviors.add(new IdleBehavior(pokemon, this));
        behaviors.add(new WanderBehavior(pokemon, this));
        behaviors.add(new FleeBehavior(pokemon, this));

        // Conditional behaviors based on personality
        if (hasPersonalityTrait(PokemonPersonalityTrait.AGGRESSIVE)) {
            behaviors.add(new ApproachPlayerBehavior(pokemon, this));
            behaviors.add(new TerritorialBehavior(pokemon, this));
        }

        if (hasPersonalityTrait(PokemonPersonalityTrait.CURIOUS)) {
            behaviors.add(new InvestigateBehavior(pokemon, this));
        }

        if (hasPersonalityTrait(PokemonPersonalityTrait.TERRITORIAL)) {
            behaviors.add(new PatrolBehavior(pokemon, this));
            behaviors.add(new DefendTerritoryBehavior(pokemon, this));
        }

        if (hasPersonalityTrait(PokemonPersonalityTrait.PACK_LEADER)) {
            behaviors.add(new PackLeaderBehavior(pokemon, this));
        }

        if (hasPersonalityTrait(PokemonPersonalityTrait.FOLLOWER)) {
            behaviors.add(new FollowPackBehavior(pokemon, this));
        }

        // Sort behaviors by priority
        behaviors.sort((a, b) -> Integer.compare(b.getPriority(), a.getPriority()));
    }

    private void setupPatrolRoute() {
        if (!hasPersonalityTrait(PokemonPersonalityTrait.TERRITORIAL)) return;

        Vector2 center = territoryCenter;
        float radius = territoryRadius * 0.7f; // Patrol within territory

        // Create a circular patrol route
        int numPoints = MathUtils.random(3, 6);
        for (int i = 0; i < numPoints; i++) {
            float angle = (i * MathUtils.PI2) / numPoints;
            float x = center.x + MathUtils.cos(angle) * radius;
            float y = center.y + MathUtils.sin(angle) * radius;

            // Snap to tile grid
            int tileX = Math.round(x / World.TILE_SIZE);
            int tileY = Math.round(y / World.TILE_SIZE);

            patrolRoute.add(new Vector2(tileX * World.TILE_SIZE, tileY * World.TILE_SIZE));
        }
    }

    public void update(float delta, World world) {
        if (world == null || pokemon == null || isPaused) return;

        updateTimer += delta;
        if (updateTimer < UPDATE_INTERVAL) return;
        updateTimer = 0f;

        stateTimer += delta;
        updateBehaviorCooldowns(delta);

        // Handle species-specific special abilities
        handleSpecialAbilities(world);

        // Find and execute highest priority behavior
        PokemonBehavior newBehavior = selectBehavior();
        if (newBehavior != activeBehavior) {
            if (activeBehavior != null) {
                GameLogger.info(pokemon.getName() + " switching from " +
                    activeBehavior.getName() + " to " + newBehavior.getName());
            }
            activeBehavior = newBehavior;
            stateTimer = 0f;
        }

        if (activeBehavior != null) {
            activeBehavior.execute(delta);
        }
    }

    private PokemonBehavior selectBehavior() {
        for (PokemonBehavior behavior : behaviors) {
            if (behavior.canExecute() && !isOnCooldown(behavior.getName())) {
                return behavior;
            }
        }

        // Default to idle if no other behavior can execute
        return behaviors.stream()
            .filter(b -> b instanceof IdleBehavior)
            .findFirst()
            .orElse(null);
    }

    private void updateBehaviorCooldowns(float delta) {
        behaviorCooldowns.replaceAll((behavior, cooldown) -> Math.max(0f, cooldown - delta));
        behaviorCooldowns.entrySet().removeIf(entry -> entry.getValue() <= 0f);
    }

    private void handleSpecialAbilities(World world) {
        if (pokemon.isMoving()) return;

        String species = pokemon.getName().toLowerCase();
        float abilityChance = 0.01f;

        if (MathUtils.random() > abilityChance) return;

        switch (species) {
            case "abra":
                performTeleport(world);
                break;
            case "diglett":
            case "dugtrio":
                performBurrow(world);
                break;
            case "haunter":
            case "gastly":
                performPhase(world);
                break;
            case "pikachu":
            case "raichu":
                performElectricDisplay();
                break;
        }
    }

    private void performTeleport(World world) {
        int currentTileX = (int)(pokemon.getX() / World.TILE_SIZE);
        int currentTileY = (int)(pokemon.getY() / World.TILE_SIZE);

        int maxDistance = hasPersonalityTrait(PokemonPersonalityTrait.TERRITORIAL) ?
            (int)(territoryRadius / World.TILE_SIZE) : 8;

        for (int attempts = 0; attempts < 10; attempts++) {
            int distance = MathUtils.random(3, maxDistance);
            float angle = MathUtils.random(MathUtils.PI2);
            int targetTileX = currentTileX + Math.round(MathUtils.cos(angle) * distance);
            int targetTileY = currentTileY + Math.round(MathUtils.sin(angle) * distance);

            if (world.isPassable(targetTileX, targetTileY)) {
                GameLogger.info(pokemon.getName() + " teleports to (" + targetTileX + "," + targetTileY + ")");
                pokemon.setX(targetTileX * World.TILE_SIZE);
                pokemon.setY(targetTileY * World.TILE_SIZE);
                enterIdleState();
                setCooldown("teleport", 30f);
                break;
            }
        }
    }

    private void performBurrow(World world) {
        // Similar to teleport but shorter range and different flavor
        performTeleport(world);
        setCooldown("burrow", 20f);
    }

    private void performPhase(World world) {
        // Ghost types can "phase" through one obstacle
        int currentTileX = (int)(pokemon.getX() / World.TILE_SIZE);
        int currentTileY = (int)(pokemon.getY() / World.TILE_SIZE);

        String[] directions = {"up", "down", "left", "right"};
        String direction = directions[MathUtils.random(directions.length - 1)];

        int targetTileX = currentTileX;
        int targetTileY = currentTileY;

        switch (direction) {
            case "up": targetTileY += 2; break;
            case "down": targetTileY -= 2; break;
            case "left": targetTileX -= 2; break;
            case "right": targetTileX += 2; break;
        }

        if (world.isPassable(targetTileX, targetTileY)) {
            GameLogger.info(pokemon.getName() + " phases through obstacles");
            pokemon.setX(targetTileX * World.TILE_SIZE);
            pokemon.setY(targetTileY * World.TILE_SIZE);
            enterIdleState();
            setCooldown("phase", 25f);
        }
    }

    private void performElectricDisplay() {
        // Visual/audio effect only - could trigger particle effects
        GameLogger.info(pokemon.getName() + " creates an electric display");
        setCooldown("electric_display", 15f);
    }

    // Getters and utility methods
    public boolean hasPersonalityTrait(PokemonPersonalityTrait trait) {
        return personalityTraits.contains(trait);
    }

    public float getDetectionRange() {
        float multiplier = personalityTraits.stream()
            .map(trait -> trait.detectionRangeMultiplier)
            .max(Float::compareTo)
            .orElse(1.0f);
        return BASE_DETECTION_RANGE * multiplier;
    }

    public float getFleeThreshold() {
        return personalityTraits.stream()
            .map(trait -> trait.fleeThreshold)
            .min(Float::compareTo)
            .orElse(1.0f) * World.TILE_SIZE;
    }

    public float getApproachFactor() {
        return personalityTraits.stream()
            .map(trait -> trait.approachFactor)
            .max(Float::compareTo)
            .orElse(1.0f);
    }

    public Vector2 getTerritoryCenter() { return territoryCenter; }
    public float getTerritoryRadius() { return territoryRadius; }
    public List<Vector2> getPatrolRoute() { return patrolRoute; }
    public Vector2 getCurrentPatrolTarget() { return patrolTarget; }
    public int getCurrentPatrolIndex() { return currentPatrolIndex; }

    public void setCurrentPatrolIndex(int index) {
        currentPatrolIndex = index;
        if (index >= 0 && index < patrolRoute.size()) {
            patrolTarget = patrolRoute.get(index);
        }
    }

    public void setCooldown(String behavior, float seconds) {
        behaviorCooldowns.put(behavior, seconds);
    }

    public boolean isOnCooldown(String behavior) {
        return behaviorCooldowns.containsKey(behavior) && behaviorCooldowns.get(behavior) > 0f;
    }

    public void enterIdleState() {
        currentState = AIState.IDLE;
        stateTimer = 0f;
        pokemon.setMoving(false);
    }

    public void setPaused(boolean paused) { this.isPaused = paused; }
    public AIState getCurrentState() { return currentState; }
    public void setCurrentState(AIState state) { this.currentState = state; }
    public float getStateTimer() { return stateTimer; }

    // Pack management
    public void setPackLeader(UUID leaderId) { this.packLeaderId = leaderId; }
    public UUID getPackLeaderId() { return packLeaderId; }
    public void addPackMember(UUID memberId) { packMembers.add(memberId); }
    public void removePackMember(UUID memberId) { packMembers.remove(memberId); }
    public Set<UUID> getPackMembers() { return packMembers; }

    private float calculateTerritoryRadius() {
        if (hasPersonalityTrait(PokemonPersonalityTrait.TERRITORIAL)) {
            return MathUtils.random(4, 8) * World.TILE_SIZE;
        }
        return 2 * World.TILE_SIZE; // Small default territory
    }

    public enum AIState {
        IDLE, WANDERING, FLEEING, APPROACHING, PATROLLING, INVESTIGATING, FOLLOWING
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/PokemonPersonalityTrait.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai;

public enum PokemonPersonalityTrait {
    // Aggression levels
    AGGRESSIVE(1.5f, 0.8f, 3.0f), // approach factor, flee threshold, detection range multiplier
    TERRITORIAL(1.2f, 0.6f, 2.5f),
    PASSIVE(0.3f, 1.5f, 1.0f),
    CURIOUS(1.1f, 1.0f, 2.0f),
    TIMID(0.1f, 2.0f, 1.5f),
    LAZY(0.5f, 1.0f, 0.8f),

    // Social behaviors
    PACK_LEADER(1.0f, 0.7f, 2.0f),
    FOLLOWER(0.8f, 1.2f, 1.2f),
    SOLITARY(0.6f, 1.0f, 1.0f),

    // Special traits
    NOCTURNAL(1.0f, 1.0f, 1.0f),
    DIURNAL(1.0f, 1.0f, 1.0f),
    PROTECTIVE(1.3f, 0.5f, 2.5f);

    public final float approachFactor;
    public final float fleeThreshold;
    public final float detectionRangeMultiplier;

    PokemonPersonalityTrait(float approachFactor, float fleeThreshold, float detectionRangeMultiplier) {
        this.approachFactor = approachFactor;
        this.fleeThreshold = fleeThreshold;
        this.detectionRangeMultiplier = detectionRangeMultiplier;
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/mechanics/AutoTileSystem.java
================
// File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/mechanics/AutoTileSystem.java
package io.github.pokemeetup.system.gameplay.overworld.mechanics;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.ArrayList;
import java.util.List;

public class AutoTileSystem {

    /**
     * We do a 4-bit adjacency mask:
     *   bit 1 => Up
     *   bit 2 => Right
     *   bit 4 => Down
     *   bit 8 => Left
     * Then pass that mask to TextureManager.getAutoTileRegion("sand_shore", mask, animFrame)
     * which returns a 32×32 region scaled from the correct 16×16 piece.
     */
    public void applyShorelineAutotiling(Chunk chunk, int animFrame, World world) {
        final int size = Chunk.CHUNK_SIZE;

        // Step 1: Identify "shore" tiles. A shore tile is any non-water tile with a water neighbor.
        boolean[][] shoreMap = new boolean[size][size];
        for (int x = 0; x < size; x++) {
            for (int y = 0; y < size; y++) {
                int worldX = chunk.getChunkX() * size + x;
                int worldY = chunk.getChunkY() * size + y;
                if (world.getTileTypeAt(worldX, worldY) != TileType.WATER) { // Any land tile
                    if (hasWaterNeighbor(world, worldX, worldY)) {
                        shoreMap[x][y] = true;
                    }
                }
            }
        }

        // Step 2: Prepare the chunk's overlay array
        TextureRegion[][] overlay = chunk.getAutotileRegions();
        if (overlay == null) {
            overlay = new TextureRegion[size][size];
            chunk.setAutotileRegions(overlay);
        }

        // Step 3: For each "shore" tile, build the 32×32 tile from a 4–bit edge mask.
        for (int x = 0; x < size; x++) {
            for (int y = 0; y < size; y++) {
                if (!shoreMap[x][y]) {
                    overlay[x][y] = null;
                    continue;
                }
                int worldX = chunk.getChunkX() * size + x;
                int worldY = chunk.getChunkY() * size + y;
                int mask = computeEdgeMask(world, worldX, worldY);
                TextureRegion base32 = TextureManager.getAutoTileRegion("sand_shore", mask, animFrame);
                // FIX: Check for null base region before using it.
                if (base32 == null) {
                    System.err.println("AutoTileSystem.applyShorelineAutotiling: base32 is null for mask " + mask + " at (" + x + "," + y + ")");
                    overlay[x][y] = null;
                    continue;
                }
                CompositeRegion comp = new CompositeRegion(base32);
                overlay[x][y] = comp;
            }
        }

        // Step 4: Apply inside-corner overlays (if the sub–tile sheet is available)
        TextureRegion cornerSheet = TextureManager.getSubTile("sand_shore", animFrame, 2, 0);
        if (cornerSheet != null) {
            TextureRegion miniTL = new TextureRegion(cornerSheet, 0, 0, 16, 16);
            TextureRegion miniTR = new TextureRegion(cornerSheet, 16, 0, 16, 16);
            TextureRegion miniBL = new TextureRegion(cornerSheet, 0, 16, 16, 16);
            TextureRegion miniBR = new TextureRegion(cornerSheet, 16, 16, 16, 16);
            for (int x = 0; x < size; x++) {
                for (int y = 0; y < size; y++) {
                    if (!shoreMap[x][y]) continue;
                    TextureRegion reg = overlay[x][y];
                    if (!(reg instanceof CompositeRegion)) continue;
                    CompositeRegion comp = (CompositeRegion) reg;
                    int worldX = chunk.getChunkX() * size + x;
                    int worldY = chunk.getChunkY() * size + y;
                    if (isInnerCornerTopLeft(world, worldX, worldY)) {
                        comp.addMiniOverlay(miniTL, 0, 16);
                    }
                    if (isInnerCornerTopRight(world, worldX, worldY)) {
                        comp.addMiniOverlay(miniTR, 16, 16);
                    }
                    if (isInnerCornerBottomLeft(world, worldX, worldY)) {
                        comp.addMiniOverlay(miniBL, 0, 0);
                    }
                    if (isInnerCornerBottomRight(world, worldX, worldY)) {
                        comp.addMiniOverlay(miniBR, 16, 0);
                    }
                }
            }
        }
    }

    /** 4-bit mask => bit 1=Up, bit2=Right, bit4=Down, bit8=Left */
    private int computeEdgeMask(World world, int worldX, int worldY) {
        int mask = 0;
        if (isWater(world, worldX, worldY + 1)) mask |= 1;  // up
        if (isWater(world, worldX + 1, worldY)) mask |= 2;  // right
        if (isWater(world, worldX, worldY - 1)) mask |= 4;  // down
        if (isWater(world, worldX - 1, worldY)) mask |= 8;  // left
        return mask;
    }

    // Inside corner checks: diagonal is water, but the two orthogonal neighbors are beach
    private boolean isInnerCornerTopLeft(World world, int worldX, int worldY) {
        return isBeach(world, worldX, worldY + 1) && isBeach(world, worldX - 1, worldY) && isWater(world, worldX - 1, worldY + 1);
    }

    private boolean isInnerCornerTopRight(World world, int worldX, int worldY) {
        return isBeach(world, worldX, worldY + 1) && isBeach(world, worldX + 1, worldY) && isWater(world, worldX + 1, worldY + 1);
    }

    private boolean isInnerCornerBottomLeft(World world, int worldX, int worldY) {
        return isBeach(world, worldX, worldY - 1) && isBeach(world, worldX - 1, worldY) && isWater(world, worldX - 1, worldY - 1);
    }

    private boolean isInnerCornerBottomRight(World world, int worldX, int worldY) {
        return isBeach(world, worldX, worldY - 1) && isBeach(world, worldX + 1, worldY) && isWater(world, worldX + 1, worldY - 1);
    }

    // Basic checks
    private boolean isBeach(int tileID) {
        return (tileID == TileType.BEACH_SAND ||
            tileID == TileType.BEACH_GRASS ||
            tileID == TileType.BEACH_GRASS_2 ||
            tileID == TileType.BEACH_STARFISH ||
            tileID == TileType.BEACH_SHELL);
    }

    private boolean isBeach(World world, int worldX, int worldY) {
        return isBeach(world.getTileTypeAt(worldX, worldY));
    }

    private boolean isWater(World world, int worldX, int worldY) {
        return world.getTileTypeAt(worldX, worldY) == TileType.WATER;
    }

    private boolean hasWaterNeighbor(World world, int worldX, int worldY) {
        int[][] offsets = {
            {0, 1}, {1, 0}, {0, -1}, {-1, 0},  // orthogonal
            {1, 1}, {1, -1}, {-1, 1}, {-1, -1}   // diagonal
        };
        for (int[] off : offsets) {
            if (isWater(world, worldX + off[0], worldY + off[1])) return true;
        }
        return false;
    }


    private boolean isWaterSafe(int[][] t, int x, int y) {
        if (x < 0 || y < 0 || x >= t.length || y >= t[0].length) return false;
        return (t[x][y] == TileType.WATER);
    }



    /**
     * A "composite region" stores:
     *  - a 32×32 base tile
     *  - zero or more 16×16 corner overlays
     * This allows us to place inside-corner pieces on top of the base tile.
     */
    public static class CompositeRegion extends TextureRegion {
        private final TextureRegion base32;
        private final List<MiniOverlay> overlays = new ArrayList<>();

        public CompositeRegion(TextureRegion base) {
            super(base);
            this.base32 = base;
        }

        public void addMiniOverlay(TextureRegion mini, int offX, int offY) {
            overlays.add(new MiniOverlay(mini, offX, offY));
        }

        public TextureRegion getBase32() {return base32;}
        public List<MiniOverlay> getOverlays() {return overlays;}
    }

    /** A single 16×16 corner overlay with a local offset. */
    public static class MiniOverlay {
        public final TextureRegion region16;
        public final int offsetX, offsetY;
        public MiniOverlay(TextureRegion r, int x, int y) {
            region16 = r;
            offsetX  = x;
            offsetY  = y;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/multiworld/PokemonSpawnManager.java
================
package io.github.pokemeetup.system.gameplay.overworld.multiworld;

import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.DayNightCycle;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.PokemonLevelCalculator;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import static io.github.pokemeetup.system.gameplay.overworld.World.TILE_SIZE;

public class PokemonSpawnManager {
    public static final float POKEMON_DESPAWN_TIME = 300f;
    private static final float BASE_SPAWN_RATE = 0.275f;
    private static final float SPAWN_CHECK_INTERVAL = 2.5f;
    private static final Map<BiomeType, Map<TimeOfDay, String[]>> POKEMON_SPAWNS = new HashMap<>();

    // Enhanced spawn configuration
    private static final float MIN_SPAWN_DISTANCE_PIXELS = 10 * TILE_SIZE;
    private static final float MAX_SPAWN_DISTANCE_PIXELS = 20 * TILE_SIZE;
    private static final int MAX_POKEMON_PER_CHUNK = 6;
    private static final float MIN_POKEMON_SPACING = TILE_SIZE * 1.5f;

    // Pack spawning configuration
    private static final float PACK_SPAWN_CHANCE = 0.3f;
    private static final int MIN_PACK_SIZE = 2;
    private static final int MAX_PACK_SIZE = 5;
    private static final float PACK_BASE_RADIUS = TILE_SIZE * 2;
    private static final float PACK_MAX_RADIUS = TILE_SIZE * 4;
    private static final int MAX_PACK_SPAWN_ATTEMPTS = 15;

    // Species-specific pack behavior
    private static final Map<String, PackBehaviorInfo> PACK_SPECIES = new HashMap<>();

    static {
        // Initialize pack species with their behavior patterns
        PACK_SPECIES.put("rattata", new PackBehaviorInfo(0.4f, 2, 4, true));
        PACK_SPECIES.put("pidgey", new PackBehaviorInfo(0.3f, 3, 6, false));
        PACK_SPECIES.put("zubat", new PackBehaviorInfo(0.5f, 4, 8, true));
        PACK_SPECIES.put("caterpie", new PackBehaviorInfo(0.2f, 2, 3, false));
        PACK_SPECIES.put("weedle", new PackBehaviorInfo(0.2f, 2, 3, false));
        PACK_SPECIES.put("sentret", new PackBehaviorInfo(0.3f, 2, 4, true));
        PACK_SPECIES.put("hoppip", new PackBehaviorInfo(0.4f, 3, 5, false));
        PACK_SPECIES.put("poochyena", new PackBehaviorInfo(0.6f, 3, 6, true));
        PACK_SPECIES.put("zigzagoon", new PackBehaviorInfo(0.3f, 2, 4, false));
    }

    private final TextureAtlas atlas;
    private final Random random;
    private final Map<Vector2, List<WildPokemon>> pokemonByChunk;
    private final Map<UUID, WildPokemon> pokemonById;
    private final Map<UUID, NetworkSyncData> syncedPokemon = new ConcurrentHashMap<>();
    private final Map<UUID, Set<UUID>> pokemonPacks = new ConcurrentHashMap<>();
    private float spawnTimer = 0;

    public PokemonSpawnManager(TextureAtlas atlas) {
        this.atlas = atlas;
        this.random = new Random();
        this.pokemonByChunk = new ConcurrentHashMap<>();
        this.pokemonById = new ConcurrentHashMap<>();
        initializePokemonSpawns();
    }

    private void checkSpawns(Vector2 playerPos) {
        if (random.nextFloat() > BASE_SPAWN_RATE) {
            return;
        }

        Set<Vector2> loadedChunks = getLoadedChunksAroundPlayer(playerPos);
        if (loadedChunks.isEmpty()) {
            GameLogger.error("No loaded chunks found around player");
            return;
        }

        SpawnAttemptResult result = attemptSpawn(playerPos, loadedChunks);
        if (!result.successful) {
            GameLogger.info("Failed to spawn after " + result.attempts + " attempts");
        }
    }

    private SpawnAttemptResult attemptSpawn(Vector2 playerPos, Set<Vector2> loadedChunks) {
        int maxAttempts = 15;

        for (int attempt = 0; attempt < maxAttempts; attempt++) {
            SpawnPosition spawnPos = generateSpawnPosition(playerPos, loadedChunks);
            if (spawnPos == null) continue;

            String selectedSpecies = selectPokemonForBiome(spawnPos.biome);
            if (selectedSpecies == null) continue;

            // Determine if this should be a pack spawn
            boolean shouldSpawnPack = shouldSpawnAsPack(selectedSpecies);

            if (shouldSpawnPack) {
                PackSpawnResult packResult = spawnPokemonPack(
                    spawnPos.pixelX, spawnPos.pixelY, spawnPos.chunkPos, selectedSpecies);
                if (packResult.spawned > 0) {
                    GameLogger.info("Successfully spawned pack of " + packResult.spawned +
                        " " + selectedSpecies + " at (" + spawnPos.pixelX + ", " + spawnPos.pixelY + ")");
                    return new SpawnAttemptResult(true, attempt + 1);
                }
            } else {
                if (spawnSinglePokemon(spawnPos.pixelX, spawnPos.pixelY, spawnPos.chunkPos, selectedSpecies)) {
                    GameLogger.info("Successfully spawned " + selectedSpecies +
                        " at (" + spawnPos.pixelX + ", " + spawnPos.pixelY + ")");
                    return new SpawnAttemptResult(true, attempt + 1);
                }
            }
        }

        return new SpawnAttemptResult(false, maxAttempts);
    }

    private SpawnPosition generateSpawnPosition(Vector2 playerPos, Set<Vector2> loadedChunks) {
        float angle = random.nextFloat() * MathUtils.PI2;
        float distance = MathUtils.random(MIN_SPAWN_DISTANCE_PIXELS, MAX_SPAWN_DISTANCE_PIXELS);
        float spawnPixelX = playerPos.x * TILE_SIZE + MathUtils.cos(angle) * distance;
        float spawnPixelY = playerPos.y * TILE_SIZE + MathUtils.sin(angle) * distance;

        Vector2 chunkPos = getChunkPosition(spawnPixelX, spawnPixelY);
        if (!loadedChunks.contains(chunkPos)) {
            return null;
        }

        // Check chunk capacity
        List<WildPokemon> chunkPokemon = pokemonByChunk.getOrDefault(chunkPos, new ArrayList<>());
        if (chunkPokemon.size() >= MAX_POKEMON_PER_CHUNK) {
            return null;
        }

        // Snap to grid for consistency
        float snappedX = Math.round(spawnPixelX / TILE_SIZE) * TILE_SIZE;
        float snappedY = Math.round(spawnPixelY / TILE_SIZE) * TILE_SIZE;

        if (!isValidSpawnPosition(snappedX, snappedY)) {
            return null;
        }

        // Get biome for this position
        int tileX = (int)(snappedX / TILE_SIZE);
        int tileY = (int)(snappedY / TILE_SIZE);
        Biome biome = GameContext.get().getWorld().getBiomeAt(tileX, tileY);

        return new SpawnPosition(snappedX, snappedY, chunkPos, biome);
    }

    private boolean shouldSpawnAsPack(String species) {
        PackBehaviorInfo packInfo = PACK_SPECIES.get(species.toLowerCase());
        if (packInfo == null) return false;

        return random.nextFloat() < (PACK_SPAWN_CHANCE * packInfo.packChance);
    }

    private PackSpawnResult spawnPokemonPack(float centerX, float centerY, Vector2 chunkPos, String species) {
        PackBehaviorInfo packInfo = PACK_SPECIES.get(species.toLowerCase());
        if (packInfo == null) {
            packInfo = new PackBehaviorInfo(0.3f, MIN_PACK_SIZE, MAX_PACK_SIZE, false);
        }

        int packSize = MathUtils.random(packInfo.minPackSize, packInfo.maxPackSize);
        List<WildPokemon> packMembers = new ArrayList<>();
        Set<UUID> packMemberIds = new HashSet<>();

        GameLogger.info("Attempting to spawn pack of " + packSize + " " + species +
            " at (" + centerX + ", " + centerY + ")");

        // Spawn the pack leader first
        WildPokemon leader = createPokemon(species, centerX, centerY, chunkPos);
        if (leader != null) {
            // Set leader personality
            PokemonAI leaderAI = (PokemonAI) leader.getAi();
            if (leaderAI != null) {
                // Leaders are typically more territorial/aggressive
                leaderAI.addPackMember(leader.getUuid());
            }

            packMembers.add(leader);
            packMemberIds.add(leader.getUuid());

            // Spawn pack members around the leader
            List<Vector2> spawnPositions = generatePackPositions(centerX, centerY, packSize - 1);

            for (Vector2 pos : spawnPositions) {
                WildPokemon member = createPokemon(species, pos.x, pos.y, chunkPos);
                if (member != null) {
                    packMembers.add(member);
                    packMemberIds.add(member.getUuid());

                    // Set up pack relationships
                    PokemonAI memberAI = (PokemonAI) member.getAi();
                    if (memberAI != null && leaderAI != null) {
                        memberAI.setPackLeader(leader.getUuid());
                        leaderAI.addPackMember(member.getUuid());
                    }
                }
            }

            // Register the pack
            if (packMembers.size() > 1) {
                UUID packId = UUID.randomUUID();
                pokemonPacks.put(packId, packMemberIds);

                GameLogger.info("Created pack " + packId + " with " + packMembers.size() +
                    " members of species " + species);
            }
        }

        return new PackSpawnResult(packMembers.size(), packMemberIds);
    }

    private List<Vector2> generatePackPositions(float centerX, float centerY, int memberCount) {
        List<Vector2> positions = new ArrayList<>();
        Set<Vector2> occupiedTiles = new HashSet<>();

        // Add center position as occupied
        occupiedTiles.add(new Vector2(
            Math.round(centerX / TILE_SIZE) * TILE_SIZE,
            Math.round(centerY / TILE_SIZE) * TILE_SIZE
        ));

        for (int i = 0; i < memberCount; i++) {
            Vector2 position = findValidPackMemberPosition(centerX, centerY, occupiedTiles);
            if (position != null) {
                positions.add(position);
                occupiedTiles.add(position);
            } else {
                GameLogger.info("Could not find valid position for pack member " + (i + 1));
            }
        }

        return positions;
    }

    private Vector2 findValidPackMemberPosition(float centerX, float centerY, Set<Vector2> occupiedTiles) {
        // Try multiple strategies for positioning pack members

        // Strategy 1: Try concentric circles around center
        for (float radius = PACK_BASE_RADIUS; radius <= PACK_MAX_RADIUS; radius += TILE_SIZE) {
            Vector2 position = tryCircularPattern(centerX, centerY, radius, occupiedTiles);
            if (position != null) return position;
        }

        // Strategy 2: Try grid pattern around center
        Vector2 position = tryGridPattern(centerX, centerY, occupiedTiles);
        if (position != null) return position;

        // Strategy 3: Try random positions within pack area
        return tryRandomPattern(centerX, centerY, occupiedTiles);
    }

    private Vector2 tryCircularPattern(float centerX, float centerY, float radius, Set<Vector2> occupied) {
        int numPoints = Math.max(8, (int)(radius / TILE_SIZE) * 4);

        for (int i = 0; i < numPoints; i++) {
            float angle = (i * MathUtils.PI2) / numPoints;
            float x = centerX + MathUtils.cos(angle) * radius;
            float y = centerY + MathUtils.sin(angle) * radius;

            // Snap to grid
            float snappedX = Math.round(x / TILE_SIZE) * TILE_SIZE;
            float snappedY = Math.round(y / TILE_SIZE) * TILE_SIZE;
            Vector2 testPos = new Vector2(snappedX, snappedY);

            if (!occupied.contains(testPos) && isValidSpawnPosition(snappedX, snappedY)) {
                return testPos;
            }
        }

        return null;
    }

    private Vector2 tryGridPattern(float centerX, float centerY, Set<Vector2> occupied) {
        int maxOffset = (int)(PACK_MAX_RADIUS / TILE_SIZE);

        // Try in spiral order for better distribution
        for (int offset = 1; offset <= maxOffset; offset++) {
            for (int dx = -offset; dx <= offset; dx++) {
                for (int dy = -offset; dy <= offset; dy++) {
                    if (Math.abs(dx) != offset && Math.abs(dy) != offset) continue;

                    float x = centerX + dx * TILE_SIZE;
                    float y = centerY + dy * TILE_SIZE;
                    Vector2 testPos = new Vector2(x, y);

                    if (!occupied.contains(testPos) && isValidSpawnPosition(x, y)) {
                        return testPos;
                    }
                }
            }
        }

        return null;
    }

    private Vector2 tryRandomPattern(float centerX, float centerY, Set<Vector2> occupied) {
        for (int attempt = 0; attempt < 20; attempt++) {
            float angle = random.nextFloat() * MathUtils.PI2;
            float distance = MathUtils.random(TILE_SIZE, PACK_MAX_RADIUS);
            float x = centerX + MathUtils.cos(angle) * distance;
            float y = centerY + MathUtils.sin(angle) * distance;

            // Snap to grid
            float snappedX = Math.round(x / TILE_SIZE) * TILE_SIZE;
            float snappedY = Math.round(y / TILE_SIZE) * TILE_SIZE;
            Vector2 testPos = new Vector2(snappedX, snappedY);

            if (!occupied.contains(testPos) && isValidSpawnPosition(snappedX, snappedY)) {
                return testPos;
            }
        }

        return null;
    }

    private WildPokemon createPokemon(String species, float x, float y, Vector2 chunkPos) {
        try {
            TextureRegion sprite = atlas.findRegion(species.toUpperCase() + "_overworld");
            if (sprite == null) {
                GameLogger.error("Failed to load sprite for " + species);
                return null;
            }

            WildPokemon pokemon = new WildPokemon(
                species,
                calculatePokemonLevel(x, y),
                (int) x,
                (int) y,
                sprite
            );

            pokemon.setWorld(GameContext.get().getWorld());

            // Replace old AI with enhanced AI
            PokemonAI enhancedAI = new PokemonAI(pokemon);
            pokemon.setAi(enhancedAI);

            enhancedAI.enterIdleState();

            // Add to collections
            pokemonById.put(pokemon.getUuid(), pokemon);
            pokemonByChunk.computeIfAbsent(chunkPos, k -> new ArrayList<>()).add(pokemon);
            pokemon.updateBoundingBox();

            return pokemon;
        } catch (Exception e) {
            GameLogger.error("Failed to create Pokemon " + species + ": " + e.getMessage());
            return null;
        }
    }

    private boolean spawnSinglePokemon(float x, float y, Vector2 chunkPos, String species) {
        return createPokemon(species, x, y, chunkPos) != null;
    }

    private boolean isValidSpawnPosition(float pixelX, float pixelY) {
        // Convert to tile coordinates for passability check
        int tileX = (int)(pixelX / TILE_SIZE);
        int tileY = (int)(pixelY / TILE_SIZE);

        if (GameContext.get().getWorld() == null) {
            GameLogger.error("World reference is null in spawn validation");
            return false;
        }

        // Check if tile is passable
        if (!GameContext.get().getWorld().isPassable(tileX, tileY)) {
            return false;
        }

        // Check distance from other Pokemon with improved spacing
        Collection<WildPokemon> nearby = getPokemonInRange(pixelX, pixelY, MIN_POKEMON_SPACING);
        if (!nearby.isEmpty()) {
            return false;
        }

        // Check chunk loaded
        Vector2 chunkPos = getChunkPosition(pixelX, pixelY);
        return GameContext.get().getWorld().getChunks().containsKey(chunkPos);
    }

    public void update(float delta, Vector2 playerPosition) {
        spawnTimer += delta;
        if (!GameContext.get().isMultiplayer()) {
            if (spawnTimer >= SPAWN_CHECK_INTERVAL) {
                spawnTimer = 0;
                checkSpawns(playerPosition);
                removeExpiredPokemon();
            }
        }

        // Update all Pokemon with enhanced AI
        for (WildPokemon pokemon : pokemonById.values()) {
            try {
                pokemon.update(delta, GameContext.get().getWorld());
            } catch (Exception e) {
                GameLogger.error("Error updating " + pokemon.getName() + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    // [Rest of the methods remain the same but use enhanced AI]
    private int calculatePokemonLevel(float pixelX, float pixelY) {
        return PokemonLevelCalculator.calculateLevel(pixelX, pixelY, TILE_SIZE);
    }

    public Collection<WildPokemon> getPokemonInRange(float centerPixelX, float centerPixelY, float rangePixels) {
        List<WildPokemon> inRange = new ArrayList<>();
        float rangeSquared = rangePixels * rangePixels;

        for (WildPokemon pokemon : pokemonById.values()) {
            float dx = pokemon.getX() - centerPixelX;
            float dy = pokemon.getY() - centerPixelY;

            if (dx * dx + dy * dy <= rangeSquared) {
                inRange.add(pokemon);
            }
        }

        return inRange;
    }

    private Set<Vector2> getLoadedChunksAroundPlayer(Vector2 playerPixelPos) {
        Set<Vector2> loadedChunks = new HashSet<>();

        Vector2 playerChunk = getChunkPosition(playerPixelPos.x * TILE_SIZE, playerPixelPos.y * TILE_SIZE);

        if (GameContext.get().getWorld() == null) {
            GameLogger.error("World reference is null!");
            return loadedChunks;
        }

        Map<Vector2, Chunk> worldChunks = GameContext.get().getWorld().getChunks();
        int radius = 1;
        for (int dx = -radius; dx <= radius; dx++) {
            for (int dy = -radius; dy <= radius; dy++) {
                Vector2 checkPos = new Vector2(playerChunk.x + dx, playerChunk.y + dy);
                if (worldChunks.containsKey(checkPos)) {
                    loadedChunks.add(checkPos);
                }
            }
        }

        return loadedChunks;
    }

    private Vector2 getChunkPosition(float pixelX, float pixelY) {
        int chunkX = Math.floorDiv((int) pixelX, World.CHUNK_SIZE * TILE_SIZE);
        int chunkY = Math.floorDiv((int) pixelY, World.CHUNK_SIZE * TILE_SIZE);
        return new Vector2(chunkX, chunkY);
    }

    public void removePokemon(UUID pokemonId) {
        WildPokemon pokemon = pokemonById.remove(pokemonId);
        if (pokemon != null) {
            Vector2 chunkPos = getChunkPosition(pokemon.getX(), pokemon.getY());
            List<WildPokemon> pokemonList = pokemonByChunk.get(chunkPos);
            if (pokemonList != null) {
                pokemonList.remove(pokemon);
                if (pokemonList.isEmpty()) {
                    pokemonByChunk.remove(chunkPos);
                }
            }
            syncedPokemon.remove(pokemonId);

            // Remove from packs
            removeFromPacks(pokemonId);

            if (!GameContext.get().getGameClient().isSinglePlayer()) {
                GameContext.get().getGameClient().sendPokemonDespawn(pokemonId);
            }
        }
    }

    private void removeFromPacks(UUID pokemonId) {
        pokemonPacks.entrySet().removeIf(entry -> {
            entry.getValue().remove(pokemonId);
            return entry.getValue().isEmpty();
        });
    }

    private void removeExpiredPokemon() {
        List<UUID> toRemove = new ArrayList<>();
        for (WildPokemon pokemon : pokemonById.values()) {
            if (pokemon.isExpired()) {
                toRemove.add(pokemon.getUuid());
                Vector2 chunkPos = getChunkPosition(pokemon.getX(), pokemon.getY());
                List<WildPokemon> pokemonList = pokemonByChunk.get(chunkPos);
                if (pokemonList != null) {
                    pokemonList.remove(pokemon);
                }
            }
        }

        for (UUID id : toRemove) {
            pokemonById.remove(id);
        }
    }

    // Initialize Pokemon spawns (same as before)

    private void initializePokemonSpawns() {
        // PLAINS biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> plainsSpawns = new HashMap<>();
        plainsSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Rattata", "Pidgey", "Sentret", "Hoppip", "Sunkern",
            "Caterpie", "Weedle", "Oddish", "Bellsprout", "Zigzagoon", "Spinarak", "Abra"
        });
        plainsSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Zubat", "Hoothoot", "Rattata", "Caterpie", "Weedle",
            "Hoppip", "Sunkern", "Spinarak", "Skitty"
        });
        POKEMON_SPAWNS.put(BiomeType.PLAINS, plainsSpawns);

        // FOREST biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> forestSpawns = new HashMap<>();
        forestSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Caterpie", "Weedle", "Oddish", "Bellsprout", "Treecko",
            "Shroomish", "Seedot", "Lotad", "Nincada", "Poochyena",
            "Hoppip", "Sunkern"
        });
        forestSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Hoothoot", "Caterpie", "Weedle", "Oddish", "Bellsprout",
            "Treecko", "Shroomish", "Seedot", "Lotad", "Poochyena",
            "Hoppip", "Nincada"
        });
        POKEMON_SPAWNS.put(BiomeType.FOREST, forestSpawns);

        // SNOW biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> snowSpawns = new HashMap<>();
        snowSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Swinub", "Snorunt", "Snover", "Spheal", "Cubchoo",
            "Sneasel", "Vanillite", "Snom"
        });
        snowSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Swinub", "Snorunt", "Snover", "Spheal", "Cubchoo",
            "Sneasel", "Vanillite", "Snom"
        });
        POKEMON_SPAWNS.put(BiomeType.SNOW, snowSpawns);

        // DESERT biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> desertSpawns = new HashMap<>();
        desertSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Sandshrew", "Trapinch", "Cacnea", "Sandile", "Diglett",
            "Vulpix", "Ekans", "Spinarak", "Poochyena"
        });
        desertSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Sandshrew", "Trapinch", "Cacnea", "Sandile", "Diglett",
            "Vulpix", "Ekans", "Zubat", "Spinarak"
        });
        POKEMON_SPAWNS.put(BiomeType.DESERT, desertSpawns);

        // HAUNTED biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> hauntedSpawns = new HashMap<>();
        hauntedSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Gastly", "Misdreavus", "Shuppet", "Duskull", "Sableye",
            "Litwick", "Murkrow", "Yamask"
        });
        hauntedSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Gastly", "Misdreavus", "Shuppet", "Duskull", "Sableye",
            "Litwick", "Murkrow", "Yamask"
        });
        POKEMON_SPAWNS.put(BiomeType.HAUNTED, hauntedSpawns);

        // RAIN FOREST biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> rainforestSpawns = new HashMap<>();
        rainforestSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Treecko", "Mudkip", "Torchic", "Lotad", "Seedot",
            "Shroomish", "Sunkern", "Hoppip", "Caterpie", "Weedle",
            "Nincada", "Poochyena"
        });
        rainforestSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Treecko", "Mudkip", "Torchic", "Lotad", "Seedot",
            "Shroomish", "Sunkern", "Hoppip", "Caterpie", "Weedle",
            "Nincada", "Poochyena"
        });
        POKEMON_SPAWNS.put(BiomeType.RAIN_FOREST, rainforestSpawns);

        // BIG MOUNTAINS biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> mountainSpawns = new HashMap<>();
        mountainSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Geodude", "Machop", "Onix", "Rhyhorn", "Nosepass",
            "Larvitar", "Meditite", "Riolu", "Rockruff", "Swinub"
        });
        mountainSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Geodude", "Machop", "Onix", "Rhyhorn", "Nosepass",
            "Larvitar", "Meditite", "Riolu", "Rockruff", "Swinub"
        });
        POKEMON_SPAWNS.put(BiomeType.BIG_MOUNTAINS, mountainSpawns);

        // RUINS biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> ruinsSpawns = new HashMap<>();
        ruinsSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Zubat", "Geodude", "Kabuto", "Omanyte", "Aerodactyl",
            "Rattata", "Gastly", "Onix", "Abra", "Cubone"
        });
        ruinsSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Zubat", "Geodude", "Kabuto", "Omanyte", "Aerodactyl",
            "Rattata", "Gastly", "Onix", "Abra", "Cubone"
        });
        POKEMON_SPAWNS.put(BiomeType.RUINS, ruinsSpawns);

        // CHERRY_GROVE biome (Cherry blossom–themed; Pokémon up to Gen 6)
        Map<PokemonSpawnManager.TimeOfDay, String[]> cherryGroveSpawns = new HashMap<>();
        cherryGroveSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Cherrim",  // A flower–themed Pokémon with different forms
            "Budew",    // The pre–evolution of Roselia
            "Roselia",  // Often depicted amid blossoms
            "Floette",
            "Jigglypuff",
            "Cleffa",
            "Wooper",
            "Litleo"
        });
        cherryGroveSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Cherrim",  // Its Overcast form may be seen at night
            "Roselia",
            "Floette",
            "Jigglypuff",
            "Cleffa",
            "Delibird",
            "Abra",
            "Marill",
            "Clefairy"
        });
        POKEMON_SPAWNS.put(BiomeType.CHERRY_GROVE, cherryGroveSpawns);

        // BEACH biome (Coastal areas with shallow water)
        Map<PokemonSpawnManager.TimeOfDay, String[]> beachSpawns = new HashMap<>();
        beachSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Krabby", "Corphish", "Wingull", "Staryu", "Corsola",
            "Shellder", "Goldeen", "Surskit"
        });
        beachSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Krabby", "Wingull", "Chinchou", "Staryu",
            "Corsola", "Shellder", "Goldeen"
        });
        POKEMON_SPAWNS.put(BiomeType.BEACH, beachSpawns);

        // OCEAN biome (Deep water environments)
        Map<PokemonSpawnManager.TimeOfDay, String[]> oceanSpawns = new HashMap<>();
        oceanSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Magikarp", "Tentacruel", "Horsea", "Seadra", "Staryu",
            "Starmie", "Chinchou", "Wishiwashi"
        });
        oceanSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Magikarp", "Tentacruel", "Horsea", "Seadra", "Staryu",
            "Starmie", "Lanturn", "Pyukumuku"
        });
        POKEMON_SPAWNS.put(BiomeType.OCEAN, oceanSpawns);
    }

    private String selectPokemonForBiome(Biome biome) {
        GameLogger.info("Selecting Pokemon for biome: " + biome.getType());

        double worldTimeInMinutes = GameContext.get().getWorld().getWorldData().getWorldTimeInMinutes();
        float hourOfDay = DayNightCycle.getHourOfDay(worldTimeInMinutes);
        TimeOfDay timeOfDay = (hourOfDay >= 6 && hourOfDay < 18) ? TimeOfDay.DAY : TimeOfDay.NIGHT;

        Map<TimeOfDay, String[]> biomeSpawns = POKEMON_SPAWNS.get(biome.getType());
        if (biomeSpawns == null) {
            return getDefaultPokemon(timeOfDay);
        }

        String[] possiblePokemon = biomeSpawns.get(timeOfDay);
        if (possiblePokemon == null || possiblePokemon.length == 0) {
            return getDefaultPokemon(timeOfDay);
        }

        return possiblePokemon[random.nextInt(possiblePokemon.length)];
    }

    private String getDefaultPokemon(TimeOfDay timeOfDay) {
        return timeOfDay == TimeOfDay.DAY ? "Rattata" : "Hoothoot";
    }

    public Collection<WildPokemon> getAllWildPokemon() {
        return pokemonById.values();
    }

    public void addPokemonToChunk(WildPokemon pokemon, Vector2 chunkPos) {
        try {
            List<WildPokemon> pokemonList = pokemonByChunk.computeIfAbsent(chunkPos, k -> new ArrayList<>());

            if (!pokemonList.contains(pokemon)) {
                pokemonList.add(pokemon);
                pokemonById.put(pokemon.getUuid(), pokemon);
                GameLogger.info("Added Pokémon " + pokemon.getName() + " to chunk at " + chunkPos);
            }
        } catch (Exception e) {
            GameLogger.error("Error adding Pokémon to chunk at " + chunkPos + ": " + e.getMessage());
            e.printStackTrace();
        }
    }

    public GameClient getGameClient() {
        return GameContext.get().getGameClient();
    }

    // Helper classes
    private static class PackBehaviorInfo {
        final float packChance;
        final int minPackSize;
        final int maxPackSize;
        final boolean aggressive;

        PackBehaviorInfo(float packChance, int minPackSize, int maxPackSize, boolean aggressive) {
            this.packChance = packChance;
            this.minPackSize = minPackSize;
            this.maxPackSize = maxPackSize;
            this.aggressive = aggressive;
        }
    }

    private static class SpawnPosition {
        final float pixelX, pixelY;
        final Vector2 chunkPos;
        final Biome biome;

        SpawnPosition(float pixelX, float pixelY, Vector2 chunkPos, Biome biome) {
            this.pixelX = pixelX;
            this.pixelY = pixelY;
            this.chunkPos = chunkPos;
            this.biome = biome;
        }
    }

    private static class SpawnAttemptResult {
        final boolean successful;
        final int attempts;

        SpawnAttemptResult(boolean successful, int attempts) {
            this.successful = successful;
            this.attempts = attempts;
        }
    }

    private static class PackSpawnResult {
        final int spawned;
        final Set<UUID> memberIds;

        PackSpawnResult(int spawned, Set<UUID> memberIds) {
            this.spawned = spawned;
            this.memberIds = memberIds;
        }
    }

    public enum TimeOfDay {
        DAY, NIGHT
    }

    public static class NetworkSyncData {
        public long lastUpdateTime;
        public Vector2 targetPosition;
        public String direction;
        public boolean isMoving;

        public NetworkSyncData() {
            this.lastUpdateTime = System.currentTimeMillis();
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/multiworld/WorldManager.java
================
package io.github.pokemeetup.system.gameplay.overworld.multiworld;

import com.badlogic.gdx.utils.Json;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.system.data.*;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.GameFileSystem;
import io.github.pokemeetup.utils.storage.JsonConfig;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class WorldManager {// In WorldManager (or a new StorageManager utility)
    private static final String WORLDS_BASE_DIR = "worlds/";
    private static final String SINGLE_PLAYER_DIR = WORLDS_BASE_DIR + "singleplayer/";
    private static WorldManager instance;
    private final ExecutorService storageExecutor = Executors.newSingleThreadExecutor();
    private final Map<String, WorldData> worlds;
    private final Object worldLock = new Object();
    private final String baseDirectory;
    private final GameFileSystem fs;
    private final Map<String, WorldData> worldCache = new ConcurrentHashMap<>();
    private final Object saveLock = new Object();
    private boolean isInitialized = false;
    private WorldManager() {
        this.worlds = new ConcurrentHashMap<>();
        this.baseDirectory = SINGLE_PLAYER_DIR;
        this.fs = GameFileSystem.getInstance();
        createDirectoryStructure();
    }

    public static synchronized WorldManager getInstance() {
        if (instance == null) {
            instance = new WorldManager();
        }
        return instance;
    }

    // When disposing, shut it down:
    public void disposeStorage() {
        storageExecutor.shutdown();
        try {
            if (!storageExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                storageExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            storageExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    public synchronized void init() {
        if (isInitialized) {
            return;
        }

        synchronized (worldLock) {
            try {
                worlds.clear();

                initializeSingleplayerMode();


                isInitialized = true;

            } catch (Exception e) {
                GameLogger.error("Failed to initialize WorldManager: " + e.getMessage());
                throw new RuntimeException("WorldManager initialization failed", e);
            }
        }
    }

    private void initializeSingleplayerMode() {
        try {
            cleanupCorruptedWorlds();
            loadSingleplayerWorlds();
        } catch (Exception e) {
            GameLogger.error("Error initializing singleplayer mode: " + e.getMessage());
            throw e;
        }
    }

    public WorldData createWorld(String name, long seed, float treeSpawnRate, float pokemonSpawnRate) {
        synchronized (worldLock) {
            try {
                if (name == null || name.trim().isEmpty()) {
                    throw new IllegalArgumentException("World name cannot be null or empty");
                }

                if (worlds.containsKey(name)) {
                    GameLogger.info("Cleaning up existing world: " + name);
                    deleteWorld(name);
                }

                GameLogger.info("Creating new world: " + name + " with seed: " + seed);

                WorldData.WorldConfig config = new WorldData.WorldConfig();
                config.setSeed(seed);
                config.setTreeSpawnRate(treeSpawnRate);
                config.setPokemonSpawnRate(pokemonSpawnRate);

                WorldData world = new WorldData(name);
                world.setName(name);
                world.setLastPlayed(System.currentTimeMillis());
                world.setConfig(config);
                world.setPlayers(new HashMap<>());
                world.setPokemonData(new PokemonData());

                worlds.put(name, world);
                GameLogger.info("Created world data object");

                return world;

            } catch (Exception e) {
                GameLogger.error("Failed to create world: " + name + " - " + e.getMessage());
                throw new RuntimeException("World creation failed: " + e.getMessage(), e);
            }
        }
    }

    public void saveWorld(WorldData worldData) {
        if (GameContext.get().isMultiplayer()){
            return;
        }
        GameLogger.info("Saving world: " + worldData.getName());
        synchronized (saveLock) {
            try {
                // Log pre-save state
                GameLogger.info("Saving world: " + worldData.getName() +
                    " with commands: " + worldData.commandsAllowed());

                // Create deep copy for saving
                WorldData saveData = worldData.copy();

                // Verify copy worked
                if (saveData.commandsAllowed() != worldData.commandsAllowed()) {
                    GameLogger.error("Command state mismatch in copy! Fixing...");
                    saveData.setCommandsAllowed(worldData.commandsAllowed());
                }
                Json json = JsonConfig.getInstance();
                String jsonStr = json.toJson(saveData);

                // Singleplayer mode - save to local file system
                String worldDirPath = baseDirectory + worldData.getName();
                if (!fs.exists(worldDirPath)) {
                    fs.createDirectory(worldDirPath);
                }

                String tempFilePath = worldDirPath + "/world.json.temp";
                fs.writeString(tempFilePath, jsonStr);

                // Verify saved data
                WorldData verification = json.fromJson(WorldData.class, fs.readString(tempFilePath));
                if (verification != null) {
                    if (verification.commandsAllowed() != worldData.commandsAllowed()) {
                        GameLogger.error("Command state lost in save! Original: " +
                            worldData.commandsAllowed() + ", Saved: " + verification.commandsAllowed());
                        // Try to fix
                        verification.setCommandsAllowed(worldData.commandsAllowed());
                        fs.writeString(tempFilePath, json.toJson(verification));
                    }
                }

                // Move temp file to final location
                String worldFilePath = worldDirPath + "/world.json";
                if (fs.exists(worldFilePath)) {
                    fs.deleteFile(worldFilePath);
                }
                fs.moveFile(tempFilePath, worldFilePath);

                GameLogger.info("Successfully saved world with commands state: " +
                    worldData.commandsAllowed());

                // **NEW:** Invalidate the cache so future loads will get the updated file.
                worldCache.remove(worldData.getName());

            } catch (Exception e) {
                GameLogger.error("Failed to save world: " + worldData.getName() +
                    " - " + e.getMessage());
            }
        }
    }


    public WorldData getWorld(String name) {
        synchronized (worldLock) {
            try {

                WorldData world = worlds.get(name);
                if (world == null && !GameContext.get().isMultiplayer()) {
                    world = JsonConfig.loadWorldData(name);
                    if (world != null) {
                        applyWorldData(world);
                    }
                }
                return world;
            } catch (Exception e) {
                GameLogger.error("Error loading world: " + name + " - " + e.getMessage());
                throw new RuntimeException("Failed to load world", e);
            }
        }
    }

    private void createDirectoryStructure() {
        try {
            fs.createDirectory(WORLDS_BASE_DIR);
            fs.createDirectory(baseDirectory);
            fs.createDirectory(baseDirectory + "backups/");
            GameLogger.info("Directory structure initialized: " + baseDirectory);

        } catch (Exception e) {
            GameLogger.error("Failed to create directory structure: " + e.getMessage());
            throw new RuntimeException("Failed to initialize directory structure", e);
        }
    }

    public void deleteWorld(String name) {
        synchronized (worldLock) {
            WorldData removed = worlds.remove(name);
            if (removed != null) {
                deleteSingleplayerWorld(name);

                GameLogger.info("Deleted world: " + name);
            } else {
                GameLogger.info("Attempted to delete non-existent world: " + name);
            }
        }
    }

    private void applyWorldData(WorldData world) {
        if (world == null) return;

        try {
            world.validateAndRepair();
            worlds.put(world.getName(), world);

        } catch (Exception e) {
            GameLogger.error("Failed to apply world data: " + e.getMessage());
            throw new RuntimeException("World data application failed", e);
        }
    }

    public Map<String, WorldData> getWorlds() {
        return Collections.unmodifiableMap(worlds);
    }

    private void cleanupCorruptedWorlds() {
        if (!fs.exists("worlds/singleplayer/")) return;

        String[] directories = fs.list("worlds/singleplayer/");
        for (String dirName : directories) {
            String dirPath = "worlds/singleplayer/" + dirName;
            if (fs.isDirectory(dirPath)) continue;

            String worldFilePath = dirPath + "/world.json";
            if (fs.exists(worldFilePath)) {
                try {
                    Json json = JsonConfig.getInstance();
                    String content = fs.readString(worldFilePath);
                    WorldData world = json.fromJson(WorldData.class, content);

                    if (world == null) {
                        String backupPath = dirPath + "/world.json.corrupted";
                        fs.writeString(backupPath, content);
                        fs.deleteFile(worldFilePath);
                        world = new WorldData(dirName);
                        world.setLastPlayed(System.currentTimeMillis());
                        fs.writeString(worldFilePath, json.toJson(world));
                        GameLogger.info("Repaired corrupted world: " + dirName);
                    }
                } catch (Exception e) {
                    GameLogger.error("Failed to parse world file: " + dirName + " - " + e.getMessage());
                }
            }
        }
    }

    private void loadSingleplayerWorlds() {
        try {
            if (!fs.exists("worlds/singleplayer/")) {
                fs.createDirectory("worlds/singleplayer/");
                GameLogger.info("Created worlds directory.");
                return;
            }

            String[] worldFolders = fs.list("worlds/singleplayer/");
            if (worldFolders == null || worldFolders.length == 0) {
                GameLogger.info("No singleplayer worlds found.");
                return;
            }

            for (String dirName : worldFolders) {
                String dirPath = "worlds/singleplayer/" + dirName;
                // Process only directories; skip if it's not a directory.
                if (!fs.isDirectory(dirPath)) continue;

                String worldFilePath = dirPath + "/world.json";
                if (!fs.exists(worldFilePath)) {
                    GameLogger.info("Missing 'world.json' in: " + dirPath);
                    continue;
                }

                try {
                    // Load and validate the world
                    WorldData world = loadAndValidateWorld(dirName);
                    if (world != null) {
                        // Important: Add valid worlds to the worlds map
                        worlds.put(dirName, world);
                        GameLogger.info("Successfully loaded world: " + dirName);
                    }
                } catch (Exception e) {
                    GameLogger.error("Error loading world: " + dirName + " - " + e.getMessage());
                }
            }

            GameLogger.info("Loaded " + worlds.size() + " singleplayer worlds.");
        } catch (Exception e) {
            GameLogger.error("Error loading singleplayer worlds: " + e.getMessage());
        }
    }


    public WorldData loadAndValidateWorld(String worldName) {
        synchronized (saveLock) {
            try {
                // Check for cached world first
                WorldData cached = worldCache.get(worldName);
                if (cached != null) {
                    GameLogger.info("Found cached world: " + worldName);
                    return cached;
                }

                String worldPath = SINGLE_PLAYER_DIR + worldName + "/world.json";
                if (!fs.exists(worldPath)) {
                    GameLogger.error("World file not found: " + worldPath);
                    return null;
                }

                String jsonContent = fs.readString(worldPath);
                if (jsonContent == null || jsonContent.isEmpty()) {
                    GameLogger.error("World file is empty: " + worldPath);
                    return null;
                }

                WorldData worldData = JsonConfig.getInstance().fromJson(WorldData.class, jsonContent);
                if (worldData == null) {
                    GameLogger.error("Failed to parse world data from JSON");
                    return null;
                }

                // Log the loaded data state
                GameLogger.info("Loaded world data - Players: " +
                    (worldData.getPlayers() != null ? worldData.getPlayers().size() : 0));

                if (worldData.getPlayers() != null) {
                    for (Map.Entry<String, PlayerData> entry : worldData.getPlayers().entrySet()) {
                        PlayerData playerData = entry.getValue();
                        if (playerData != null) {
                            GameLogger.info("Loaded player: " + entry.getKey() +
                                " Items: " + playerData.getInventoryItems().size() +
                                " Pokemon: " + playerData.getPartyPokemon().size());
                        }
                    }
                }

                worldCache.put(worldName, worldData);
                return worldData;

            } catch (Exception e) {
                GameLogger.error("Error loading world: " + worldName + " - " + e.getMessage());
                return null;
            }
        }
    }


    private void deleteSingleplayerWorld(String name) {
        try {
            String worldPath = "worlds/singleplayer/" + name;
            if (fs.exists(worldPath)) {
                fs.deleteDirectory(worldPath);
                GameLogger.info("Deleted singleplayer world directory: " + name);
            } else {
                GameLogger.info("Singleplayer world directory does not exist: " + name);
            }
        } catch (Exception e) {
            GameLogger.error("Failed to delete singleplayer world: " + name + " - " + e.getMessage());
            throw new RuntimeException("Singleplayer world deletion failed", e);
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/PersistOperation.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.math.Vector2;

import java.util.ArrayList;
import java.util.List;

public class PersistOperation extends WorldObjectOperation {
    public final Vector2 chunkPos;
    public final List<WorldObject> objects;

    public PersistOperation(Vector2 chunkPos, List<WorldObject> objects) {
        super(WorldObjectOperation.OperationType.PERSIST);
        this.chunkPos = chunkPos;
        this.objects = new ArrayList<>(objects);
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/RemoveOperation.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.math.Vector2;

public class RemoveOperation extends WorldObjectOperation {
    public final Vector2 chunkPos;
    public final String objectId;

    public RemoveOperation(Vector2 chunkPos, String objectId) {
        super(OperationType.REMOVE);
        this.chunkPos = chunkPos;
        this.objectId = objectId;
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/UnifiedWorldGenerator.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.managers.BiomeTransitionResult;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.system.gameplay.overworld.mechanics.AutoTileSystem;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.NoiseCache;
import io.github.pokemeetup.utils.OpenSimplex2;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.*;

/**
 * Fully refactored world generator that:
 * - Creates large islands with a guaranteed beach ring, then ocean beyond.
 * - Ensures smoother biome transitions (reduces abrupt chunk boundary changes).
 * - Preserves mountain logic while reducing stray or random lumps.
 * - Spawns WorldObjects with a beach buffer.
 * - Optionally BFS‐cleans any weird "inland ocean pockets" inside the island.
 */
public class UnifiedWorldGenerator {

    public static final int CHUNK_SIZE = 16; // Must match Chunk.CHUNK_SIZE
    private static final int TEMP_SIZE = CHUNK_SIZE;

    private static final ThreadLocal<int[][]> smoothingTemp = ThreadLocal.withInitial(() -> {
        int[][] arr = new int[TEMP_SIZE][TEMP_SIZE];
        for (int i = 0; i < TEMP_SIZE; i++) {
            arr[i] = new int[TEMP_SIZE];
        }
        return arr;
    });

    public static Chunk generateChunk(int chunkX, int chunkY, long worldSeed, BiomeManager biomeManager) {
        // determine an approximate biome at chunk center
        float centerWorldX = (chunkX * Chunk.CHUNK_SIZE + Chunk.CHUNK_SIZE * 0.5f) * World.TILE_SIZE;
        float centerWorldY = (chunkY * Chunk.CHUNK_SIZE + Chunk.CHUNK_SIZE * 0.5f) * World.TILE_SIZE;

        BiomeTransitionResult centerBTR = GameContext.get().getBiomeManager().getBiomeAt(centerWorldX, centerWorldY);
        Biome primary = centerBTR.getPrimaryBiome();
        if (primary == null) primary = GameContext.get().getBiomeManager().getBiome(BiomeType.PLAINS);

        Chunk chunk = new Chunk(chunkX, chunkY, primary, worldSeed);

        // The new "fill"
        fillChunkTiles(chunk, worldSeed, GameContext.get().getBiomeManager());

        return chunk;
    }

    private static List<WorldObject> spawnWorldObjects(Chunk chunk, int[][] tiles, long worldSeed) {
        // Use the new enhanced spawner for better object distribution
        return EnhancedWorldObjectSpawner.spawnWorldObjects(chunk, tiles, worldSeed);
    }

    /**
     * Generates a chunk for server-side use with deterministic properties to ensure consistent
     * generation across server restarts and multiple client sessions.
     *
     * @param chunkX X coordinate of the chunk
     * @param chunkY Y coordinate of the chunk
     * @param worldSeed The world seed for deterministic generation
     * @param biomeManager The biome manager instance
     * @return A fully initialized chunk
     */
    public static Chunk generateChunkForServer(int chunkX, int chunkY, long worldSeed, BiomeManager biomeManager) {
        try {
            // Determine biome at a fixed point (center of chunk) for consistency
            float centerWorldX = (chunkX * CHUNK_SIZE + CHUNK_SIZE * 0.5f) * World.TILE_SIZE;
            float centerWorldY = (chunkY * CHUNK_SIZE + CHUNK_SIZE * 0.5f) * World.TILE_SIZE;

            // Round coordinates for deterministic queries
            centerWorldX = (float) (Math.floor(centerWorldX / 10.0f) * 10.0f);
            centerWorldY = (float) (Math.floor(centerWorldY / 10.0f) * 10.0f);

            BiomeTransitionResult centerBTR = biomeManager.getBiomeAt(centerWorldX, centerWorldY);
            Biome primary = centerBTR.getPrimaryBiome();
            if (primary == null) {
                GameLogger.error("Null primary biome at (" + chunkX + "," + chunkY + "), defaulting to PLAINS");
                primary = biomeManager.getBiome(BiomeType.PLAINS);
            }

            // Create a new chunk with the determined primary biome and deterministic seed
            Chunk chunk = new Chunk(chunkX, chunkY, primary, worldSeed);

            final int size = Chunk.CHUNK_SIZE;
            final int MARGIN = 2;
            final int sampleW = size + 2 * MARGIN;
            final int sampleH = size + 2 * MARGIN;
            int[][] sampleTiles = new int[sampleW][sampleH];

            // Create a chunk-specific sub-seed for local variation that's still deterministic
            long chunkSpecificSeed = worldSeed + (((long)chunkX << 32) | ((long)chunkY & 0xFFFFFFFFL));
            Random chunkRng = new Random(chunkSpecificSeed);

            // Phase 1: Sample tiles with deterministic noise
            for (int sx = 0; sx < sampleW; sx++) {
                for (int sy = 0; sy < sampleH; sy++) {
                    int worldTileX = (chunkX * size) + (sx - MARGIN);
                    int worldTileY = (chunkY * size) + (sy - MARGIN);
                    float worldX = worldTileX * World.TILE_SIZE;
                    float worldY = worldTileY * World.TILE_SIZE;

                    // Ensure rounded coordinates for deterministic queries
                    worldX = (float) (Math.floor(worldX / 10.0f) * 10.0f);
                    worldY = (float) (Math.floor(worldY / 10.0f) * 10.0f);

                    // Use biome manager's domain warp
                    float[] warped = biomeManager.domainWarp(worldX, worldY);

                    // Find closest island using deterministic approach
                    BiomeManager.Island isl = biomeManager.findClosestIsland(warped[0], warped[1]);
                    if (isl == null) {
                        sampleTiles[sx][sy] = TileType.WATER;
                        continue;
                    }

                    // Use deterministic distance calculation
                    float dx = warped[0] - isl.centerX;
                    float dy = warped[1] - isl.centerY;
                    float dist = (float) Math.sqrt(dx * dx + dy * dy);
                    float angle = MathUtils.atan2(dy, dx);

                    // Use the island's seed for consistent distortion
                    float distort = OpenSimplex2.noise2(isl.seed, MathUtils.cos(angle), MathUtils.sin(angle));
                    distort = Math.max(0, distort);

                    // Use consistent coefficients
                    float newExpandFactor = 1.3f;
                    float reducedFactor = 0.1f;
                    float effectiveRadius = isl.radius * newExpandFactor + (isl.radius * newExpandFactor * reducedFactor * distort);

                    // Define fixed beach band size
                    float beachBand = effectiveRadius * 0.1f;
                    float innerThreshold = effectiveRadius;
                    float outerThreshold = effectiveRadius + beachBand;

                    if (dist < innerThreshold) {
                        // Land tile: use the land biome Voronoi method
                        BiomeTransitionResult landTrans = biomeManager.landBiomeVoronoi(warped[0], warped[1]);
                        sampleTiles[sx][sy] = TileDataPicker.pickTileFromBiomeOrBlend(landTrans, worldX, worldY, worldSeed);
                    } else if (dist < outerThreshold) {
                        // Beach tiles
                        BiomeTransitionResult beachTrans = new BiomeTransitionResult(
                            biomeManager.getBiome(BiomeType.BEACH),
                            null,
                            1f
                        );
                        sampleTiles[sx][sy] = TileDataPicker.pickBeachTile(beachTrans, worldX, worldY, worldSeed);
                    } else {
                        // Ocean tiles
                        sampleTiles[sx][sy] = TileType.WATER;
                    }
                }
            }

            // Phase 2: Remove inland ocean pockets for visual consistency
            removeInlandOceanPockets(sampleTiles);

            // Phase 3: Copy the central region to chunk tiles
            int[][] tiles = new int[size][size];
            for (int lx = 0; lx < size; lx++) {
                System.arraycopy(sampleTiles[lx + MARGIN], MARGIN, tiles[lx], 0, size);
            }
            chunk.setTileData(tiles);



            // Apply mountain generation if needed, using the deterministic chunk-specific seed
            applyMountainsIfNeeded(chunk, tiles, chunkSpecificSeed);

            // Generate objects with the same deterministic seed
            List<WorldObject> objects = spawnWorldObjects(chunk, tiles, chunkSpecificSeed);

            // Log what we've generated for debugging
            GameLogger.info("Generated chunk (" + chunkX + "," + chunkY + ") with " +
                objects.size() + " objects, biome: " + primary.getType());

            // Store the objects and mark as dirty
            chunk.setWorldObjects(objects);
            chunk.setDirty(true);

            // CRITICAL FIX: Force the chunk biome to match what was determined at the center
            // This ensures consistent biome assignment
            chunk.setBiome(primary);

            return chunk;
        } catch (Exception e) {
            // Add robust error handling to prevent crashes
            GameLogger.error("Error generating chunk at (" + chunkX + "," + chunkY + "): " + e.getMessage());
            e.printStackTrace();

            // Return a fallback chunk in case of errors
            Biome fallbackBiome = biomeManager.getBiome(BiomeType.PLAINS);
            Chunk fallbackChunk = new Chunk(chunkX, chunkY, fallbackBiome, worldSeed);
            int[][] fallbackTiles = new int[CHUNK_SIZE][CHUNK_SIZE];
            for (int x = 0; x < CHUNK_SIZE; x++) {
                for (int y = 0; y < CHUNK_SIZE; y++) {
                    fallbackTiles[x][y] = TileType.GRASS;  // Simple fallback
                }
            }
            fallbackChunk.setTileData(fallbackTiles);
            fallbackChunk.setDirty(true);
            return fallbackChunk;
        }
    }


    /**
     * Fills the chunk's tile data with a large island ring, ensuring beach outside
     * the island boundary, then ocean beyond, plus smoothing any random pockets.
     */
    // The new method in UnifiedWorldGenerator:
    private static void fillChunkTiles(Chunk chunk, long worldSeed, BiomeManager biomeManager) {
        final int size = Chunk.CHUNK_SIZE;
        final int chunkX = chunk.getChunkX();
        final int chunkY = chunk.getChunkY();

        // Prepare the tile array
        int[][] tiles = new int[size][size];

        // We'll sample a slightly bigger region around the chunk
        // so that transitions along chunk edges are smoother.
        final int MARGIN = 2;
        final int sampleW = size + 2 * MARGIN;
        final int sampleH = size + 2 * MARGIN;
        int[][] sampleTiles = new int[sampleW][sampleH];

        // Phase 1: For each tile in the expanded sample area:
        for (int sx = 0; sx < sampleW; sx++) {
            for (int sy = 0; sy < sampleH; sy++) {
                // Convert to actual world tile coords:
                int worldTileX = (chunkX * size) + (sx - MARGIN);
                int worldTileY = (chunkY * size) + (sy - MARGIN);

                float worldX = worldTileX * World.TILE_SIZE;
                float worldY = worldTileY * World.TILE_SIZE;

                // 1) domain-warp
                float[] warped = GameContext.get().getBiomeManager().domainWarp(worldX, worldY);

                // 2) find closest island => ocean/land
                BiomeManager.Island isl = GameContext.get().getBiomeManager().findClosestIsland(warped[0], warped[1]);
                if (isl == null) {
                    sampleTiles[sx][sy] = TileType.WATER;
                    continue;
                }

                // distance, distortion => effectiveRadius
                float dx = warped[0] - isl.centerX;
                float dy = warped[1] - isl.centerY;
                float dist = (float) Math.sqrt(dx * dx + dy * dy);

                float angle = MathUtils.atan2(dy, dx);
                float distort = OpenSimplex2.noise2(isl.seed, MathUtils.cos(angle), MathUtils.sin(angle));
                distort = Math.max(0, distort);

                float newExpandFactor = 1.3f;
                float reducedFactor = 0.1f;
                float effectiveRadius = isl.radius * newExpandFactor
                    + (isl.radius * newExpandFactor * reducedFactor * distort);

                float beachBand = effectiveRadius * 0.1f;
                float innerThreshold = effectiveRadius - (beachBand * 0.5f);
                float outerThreshold = effectiveRadius + (beachBand * 0.5f);

                if (dist < innerThreshold) {
                    // land => pick tile from the land Voronoi approach
                    BiomeTransitionResult landTrans = GameContext.get().getBiomeManager().landBiomeVoronoi(warped[0], warped[1]);
                    sampleTiles[sx][sy] = TileDataPicker.pickTileFromBiomeOrBlend(
                        landTrans, worldX, worldY, worldSeed
                    );
                } else if (dist > outerThreshold) {
                    // ocean
                    sampleTiles[sx][sy] = TileType.WATER;
                } else {
                    // beach ring => blend from beach → ocean
                    float t = (dist - innerThreshold) / (outerThreshold - innerThreshold);
                    BiomeTransitionResult beachTrans = new BiomeTransitionResult(
                        GameContext.get().getBiomeManager().getBiome(BiomeType.BEACH),
                        GameContext.get().getBiomeManager().getBiome(BiomeType.OCEAN),
                        t
                    );
                    sampleTiles[sx][sy] = TileDataPicker.pickBeachTile(beachTrans, worldX, worldY, worldSeed);
                }
            }
        }

        // Phase 2: remove small "inland pockets" of water if you want
        removeInlandOceanPockets(sampleTiles);

        // Phase 3: copy the central region (the real chunk) out of sampleTiles
        for (int lx = 0; lx < size; lx++) {
            System.arraycopy(sampleTiles[lx + MARGIN], MARGIN, tiles[lx], 0, size);
        }

        // set chunk tile data
        chunk.setTileData(tiles);
        try {
            new AutoTileSystem().applyShorelineAutotiling(chunk, 0, GameContext.get().getWorld());
        } catch (Exception e) {
            GameLogger.error("Error during autotiling: " + e.getMessage());
        }
        applyMountainsIfNeeded(chunk, tiles, worldSeed);
        chunk.setDirty(true);

        // spawn objects (trees, stones, etc.)
        List<WorldObject> objects = spawnWorldObjects(chunk, tiles, worldSeed);
        GameLogger.info("spawnWorldObjects produced " + objects.size() + " objects for chunk (" +
            chunk.getChunkX() + "," + chunk.getChunkY() + ").");
        chunk.setWorldObjects(objects);
        // find "dominant" chunk–wide biome for display
        Biome chunkBiome = findDominantBiomeInChunk(chunk, biomeManager);
        chunk.setBiome(chunkBiome);
    }


    /**
     * BFS pass to remove "inland ocean pockets" from sampleTiles. If water is connected
     * to the edges, we keep it. Otherwise, we flood‐fill it with land. This helps
     * avoid random water holes in the interior.
     */
    private static void removeInlandOceanPockets(int[][] sampleTiles) {
        int w = sampleTiles.length;
        int h = sampleTiles[0].length;

        // We'll keep track of visited, and anything that is water connected to boundary is "ocean"
        boolean[][] visited = new boolean[w][h];

        // We'll BFS from edges: any water tile on the boundary means that region is ocean
        Queue<Point> queue = new LinkedList<>();

        // 1) Add edge water tiles to queue
        for (int x = 0; x < w; x++) {
            // top row
            if (sampleTiles[x][0] == TileType.WATER) {
                visited[x][0] = true;
                queue.add(new Point(x, 0));
            }
            // bottom row
            if (sampleTiles[x][h - 1] == TileType.WATER) {
                visited[x][h - 1] = true;
                queue.add(new Point(x, h - 1));
            }
        }
        for (int y = 0; y < h; y++) {
            // left col
            if (sampleTiles[0][y] == TileType.WATER) {
                visited[0][y] = true;
                queue.add(new Point(0, y));
            }
            // right col
            if (sampleTiles[w - 1][y] == TileType.WATER) {
                visited[w - 1][y] = true;
                queue.add(new Point(w - 1, y));
            }
        }

        // 2) BFS to mark all connected "ocean"
        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while (!queue.isEmpty()) {
            Point p = queue.poll();
            for (int[] d : dirs) {
                int nx = p.x + d[0];
                int ny = p.y + d[1];
                if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
                if (!visited[nx][ny] && sampleTiles[nx][ny] == TileType.WATER) {
                    visited[nx][ny] = true;
                    queue.add(new Point(nx, ny));
                }
            }
        }

        // 3) Any water tile that is NOT visited => it's an inland pocket => fill it with random land
        // For simplicity, fill with grass or something
        for (int x = 0; x < w; x++) {
            for (int y = 0; y < h; y++) {
                if (sampleTiles[x][y] == TileType.WATER && !visited[x][y]) {
                    // We fill it with some land tile, e.g. grass
                    sampleTiles[x][y] = TileType.GRASS; // or pick something random
                }
            }
        }
    }

    /**
     * If the chunk's main biome calls for mountains, we generate them and apply
     * them to the chunk's tile array.
     */
    private static void applyMountainsIfNeeded(Chunk chunk, int[][] tiles, long worldSeed) {
        // We'll skip if the chunk is purely ocean or purely beach
        BiomeType mainBiome = chunk.getBiome().getType();
        if (mainBiome == BiomeType.OCEAN || mainBiome == BiomeType.BEACH) {
            return;
        }
        // Decide how many layers
        long chunkSeed = generateChunkSeed(worldSeed, chunk.getChunkX(), chunk.getChunkY());
        Random rng = new Random(chunkSeed);

        int maxLayers = ElevationLogic.determineLayersForBiome(rng, mainBiome);
        if (maxLayers <= 0) {
            return;
        }

        // Build an array for mountain bands
        int[][] elevationBands = new int[CHUNK_SIZE][CHUNK_SIZE];
        // Zero out ocean & beach
        for (int lx = 0; lx < CHUNK_SIZE; lx++) {
            for (int ly = 0; ly < CHUNK_SIZE; ly++) {
                if (tiles[lx][ly] == TileType.WATER || tiles[lx][ly] == TileType.BEACH_SAND) {
                    elevationBands[lx][ly] = 0;
                }
            }
        }

        // Actually generate the shape
        ElevationLogic.generateMountainShape(
            maxLayers, rng, elevationBands, chunk.getChunkX(), chunk.getChunkY(), worldSeed
        );

        // Additional smoothing if needed
        ElevationLogic.smoothElevationBands(elevationBands, rng);

        // Now apply the mountain tile-IDs to the chunk's tile array
        ElevationLogic.applyMountainTiles(tiles, elevationBands);
        ElevationLogic.autotileCliffs(elevationBands, tiles);
        ElevationLogic.addStairsBetweenLayers(elevationBands, tiles);
        ElevationLogic.finalizeStairAccess(tiles, elevationBands);
        ElevationLogic.maybeAddCaveEntrance(elevationBands, tiles, rng);

    }

    /**
     * Figure out which biome is "dominant" in this chunk by counting tile frequencies.
     */
    private static Biome findDominantBiomeInChunk(Chunk chunk, BiomeManager biomeManager) {
        Map<Biome, Integer> freq = new HashMap<>();
        int[][] tileData = chunk.getTileData();
        for (int lx = 0; lx < CHUNK_SIZE; lx++) {
            for (int ly = 0; ly < CHUNK_SIZE; ly++) {
                float worldX = (chunk.getChunkX() * CHUNK_SIZE + lx) * World.TILE_SIZE;
                float worldY = (chunk.getChunkY() * CHUNK_SIZE + ly) * World.TILE_SIZE;
                BiomeTransitionResult btr = biomeManager.getBiomeAt(worldX, worldY);
                Biome tileBiome = btr.getPrimaryBiome();
                freq.merge(tileBiome, 1, Integer::sum);
            }
        }

        Biome best = null;
        int bestCount = 0;
        for (Map.Entry<Biome, Integer> e : freq.entrySet()) {
            if (e.getValue() > bestCount) {
                bestCount = e.getValue();
                best = e.getKey();
            }
        }
        if (best == null) {
            best = biomeManager.getBiome(BiomeType.PLAINS);
        }
        return best;
    }

    private static boolean isTreeType(WorldObject.ObjectType type) {
        return type == WorldObject.ObjectType.TREE_0 ||
            type == WorldObject.ObjectType.TREE_1 ||
            type == WorldObject.ObjectType.SNOW_TREE ||
            type == WorldObject.ObjectType.HAUNTED_TREE ||
            type == WorldObject.ObjectType.RUINS_TREE ||
            type == WorldObject.ObjectType.APRICORN_TREE ||
            type == WorldObject.ObjectType.RAIN_TREE ||
            type == WorldObject.ObjectType.CHERRY_TREE ||
            type == WorldObject.ObjectType.BEACH_TREE;
    }


    public static boolean canPlaceWorldObject(Chunk chunk, int localX, int localY,
                                              List<WorldObject> currentChunkObjects,
                                              Biome biome,
                                              WorldObject.ObjectType objectType) {
        // Convert local coordinates (within this chunk) to world tile coordinates.
        int worldTileX = chunk.getChunkX() * Chunk.CHUNK_SIZE + localX;
        int worldTileY = chunk.getChunkY() * Chunk.CHUNK_SIZE + localY;
        int tileType = chunk.getTileType(localX, localY);

        // Basic checks
        if (!chunk.isPassable(localX, localY)) {
            return false;
        }
        if (!biome.getAllowedTileTypes().contains(tileType)) {
            return false;
        }
        // Extra restrictions: do not place on disallowed terrain types.
        if (tileType == TileType.ROCK ||
            tileType == TileType.BEACH_STARFISH ||
            tileType == TileType.BEACH_SHELL ||
            tileType == TileType.WATER) {
            return false;
        }
        if (TileType.isMountainTile(tileType)) {
            return false;
        }
        if (tileType == TileType.FLOWER ||
            tileType == TileType.FLOWER_1 ||
            tileType == TileType.FLOWER_2) {
            return false;
        }
        // Create a candidate object at the desired location.
        WorldObject candidate = new WorldObject(worldTileX, worldTileY, null, objectType);
        candidate.ensureTexture();


        return true;
    }

    private static boolean collidesWithAny(WorldObject candidate, List<WorldObject> existing) {
        // Use the placement bounding box for overlap checks
        Rectangle candidateBounds = candidate.getPlacementBoundingBox();
        // Define a spacing margin equal to one tile
        float spacing = (float) (World.TILE_SIZE * 1.5);

        // Inflate candidate bounds by the spacing margin
        Rectangle paddedCandidate = new Rectangle(
            candidateBounds.x - spacing,
            candidateBounds.y - spacing,
            candidateBounds.width + 2 * spacing,
            candidateBounds.height + 2 * spacing
        );

        // Check overlap against every placed object using their placement bounding boxes
        for (WorldObject other : existing) {
            if (paddedCandidate.overlaps(other.getPlacementBoundingBox())) {
                return true;
            }
        }
        return false;
    }



    /**
     * If we want a buffer from water, we skip placing an object if
     * adjacent tile is water or beach. This is purely for aesthetics.
     */
    private static boolean isNextToWater(int[][] tiles, int x, int y) {
        int[][] offsets = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        for (int[] off : offsets) {
            int nx = x + off[0];
            int ny = y + off[1];
            if (nx < 0 || ny < 0 || nx >= tiles.length || ny >= tiles[0].length) {
                continue;
            }
            if (tiles[nx][ny] == TileType.WATER || tiles[nx][ny] == TileType.BEACH_SAND) {
                return true;
            }
        }
        return false;
    }

    /**
     * A stable hash method to produce a chunk seed from worldSeed + chunk coords.
     */
    private static long generateChunkSeed(long worldSeed, int cx, int cy) {
        long h = worldSeed;
        h = (h * 31) + cx;
        h = (h * 31) + cy;
        return h;
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Below: Smaller "helper classes" (TileDataPicker, ElevationLogic, BFS, etc.)
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * A simpler tile–picking approach for land vs. beach. This is basically
     * your earlier logic, but fully separated for clarity.
     */
    private static class TileDataPicker {

        /**
         * If there's no secondary biome, pick from primary. Otherwise blend.
         */
        public static int pickTileFromBiomeOrBlend(
            BiomeTransitionResult btr, float wx, float wy, long worldSeed
        ) {
            Biome p = btr.getPrimaryBiome();
            Biome s = btr.getSecondaryBiome();
            if (s == null) {
                return pickTileFromBiome(p, wx, wy, worldSeed);
            }
            float factor = btr.getTransitionFactor();
            return pickBlendedTile(p, s, factor, wx, wy, worldSeed);
        }

        /**
         * Single–biome tile distribution.
         */
        public static int pickTileFromBiome(Biome biome, float wx, float wy, long seed) {
            Map<Integer, Integer> dist = biome.getTileDistribution();
            List<Integer> allowed = biome.getAllowedTileTypes();
            if (dist == null || dist.isEmpty() || allowed == null || allowed.isEmpty()) {
                GameLogger.error("Biome " + biome.getName()
                    + " is missing tileDistribution or allowedTileTypes!");
                return TileType.GRASS;
            }
            double sum = 0;
            for (int v : dist.values()) {
                sum += v;
            }
            double noiseValue = NoiseCache.getNoise(seed + 1000, wx, wy, 0.5f);
            double roll = noiseValue * sum;
            double running = 0;
            for (Map.Entry<Integer, Integer> e : dist.entrySet()) {
                running += e.getValue();
                if (roll <= running) {
                    return e.getKey();
                }
            }
            return allowed.get(0);
        }

        /**
         * If we are in the beach ring, possibly pick from "beachTileDistribution."
         */
        public static int pickBeachTile(
            BiomeTransitionResult btr, float wx, float wy, long seed
        ) {
            Biome primary = btr.getPrimaryBiome();
            if (primary != null) {
                Map<Integer, Integer> beachDist = primary.getBeachTileDistribution();
                if (beachDist != null && !beachDist.isEmpty()) {
                    // Weighted random pick
                    int total = 0;
                    for (int v : beachDist.values()) {
                        total += v;
                    }
                    long localSeed = seed
                        ^ Float.floatToIntBits(wx)
                        ^ Float.floatToIntBits(wy);
                    Random rng = new Random(localSeed);
                    int roll = rng.nextInt(total);
                    int cumul = 0;
                    for (Map.Entry<Integer, Integer> e : beachDist.entrySet()) {
                        cumul += e.getValue();
                        if (roll < cumul) {
                            return e.getKey();
                        }
                    }
                }
            }
            // fallback
            return TileType.BEACH_SAND;
        }

        /**
         * Blends two biome distributions using transition factor.
         */
        private static int pickBlendedTile(
            Biome p, Biome s, float blend, float wx, float wy, long seed
        ) {
            Map<Integer, Integer> pDist = p.getTileDistribution();
            Map<Integer, Integer> sDist = s.getTileDistribution();
            Map<Integer, Integer> pTrans = p.getTransitionTileDistribution();
            Map<Integer, Integer> sTrans = s.getTransitionTileDistribution();
            Set<Integer> allKeys = new HashSet<>();
            if (pDist != null) allKeys.addAll(pDist.keySet());
            if (sDist != null) allKeys.addAll(sDist.keySet());
            if (pTrans != null) allKeys.addAll(pTrans.keySet());
            if (sTrans != null) allKeys.addAll(sTrans.keySet());

            double totalWeight = 0;
            Map<Integer, Double> finalDist = new HashMap<>();

            for (Integer tileId : allKeys) {
                double wp = (pDist != null) ? pDist.getOrDefault(tileId, 0) : 0;
                double ws = (sDist != null) ? sDist.getOrDefault(tileId, 0) : 0;
                double w = blend * wp + (1 - blend) * ws;

                if (pTrans != null && pTrans.containsKey(tileId)) {
                    w += pTrans.get(tileId) * blend; // slight boost for transitions
                }
                if (sTrans != null && sTrans.containsKey(tileId)) {
                    w += sTrans.get(tileId) * (1 - blend);
                }
                if (w > 0) {
                    finalDist.put(tileId, w);
                    totalWeight += w;
                }
            }
            double noiseVal = NoiseCache.getNoise(seed + 999, wx, wy, 0.5f);
            double roll = noiseVal * totalWeight;
            double cum = 0;
            for (Map.Entry<Integer, Double> e : finalDist.entrySet()) {
                cum += e.getValue();
                if (roll <= cum) {
                    return e.getKey();
                }
            }

            // fallback
            List<Integer> fallback = p.getAllowedTileTypes();
            if (fallback != null && !fallback.isEmpty()) {
                return fallback.get(0);
            }
            return TileType.GRASS;
        }
    }

    /**
     * Slightly simpler "ElevationLogic" with BFS-based smoothing
     * for consistent mountain shapes. Derived from your code.
     */
    private static class ElevationLogic {

        public static int determineLayersForBiome(Random rand, BiomeType biome) {
            // Simple logic: reduce the chance of random lumps
            float baseChance;
            switch (biome) {
                case SNOW:
                    baseChance = 0.83f;
                    break;
                case DESERT:
                    baseChance = 0.88f;
                    break;
                case PLAINS:
                    baseChance = 0.85f;
                    break;
                default:
                    baseChance = 0.93f;
            }
            float r = rand.nextFloat();
            if (r < baseChance) return 0;
            if (r < baseChance + 0.10f) return 1;
            if (r < baseChance + 0.13f) return 2;
            return 0;
        }

        public static void generateMountainShape(
            int maxLayers, Random rand, int[][] bands,
            int chunkX, int chunkY, long worldSeed
        ) {
            int size = CHUNK_SIZE;
            int peakCount = rand.nextInt(2) + 1;

            List<Point> peaks = new ArrayList<>();
            for (int i = 0; i < peakCount; i++) {
                int px = size / 4 + rand.nextInt(size / 2);
                int py = size / 4 + rand.nextInt(size / 2);
                peaks.add(new Point(px, py));
            }
            float baseRadius = size * (0.25f + 0.1f * maxLayers);

            for (int x = 0; x < size; x++) {
                for (int y = 0; y < size; y++) {
                    // Dist from nearest peak
                    double minDist = Double.MAX_VALUE;
                    for (Point p : peaks) {
                        double dx = x - p.x;
                        double dy = y - p.y;
                        double dd = Math.sqrt(dx * dx + dy * dy);
                        if (dd < minDist) {
                            minDist = dd;
                        }
                    }
                    // Convert distance to an "elevation" 0..1
                    double distFactor = minDist / baseRadius;
                    double elev = Math.max(0, 1.0 - distFactor);

                    // Add some noise
                    float tileWX = (chunkX * size + x) * 0.5f;
                    float tileWY = (chunkY * size + y) * 0.5f;
                    double coarse = OpenSimplex2.noise2(worldSeed + 777, tileWX * 0.05f, tileWY * 0.05f) * 0.15;
                    double detail = OpenSimplex2.noise2(worldSeed + 999, tileWX * 0.1f, tileWY * 0.1f) * 0.1;
                    elev += coarse + detail;

                    elev = Math.max(0, Math.min(1, elev));

                    // band thresholds
                    int band = 0;
                    if (maxLayers == 1) {
                        if (elev > 0.3) band = 1;
                    } else if (maxLayers == 2) {
                        if (elev > 0.65) band = 2;
                        else if (elev > 0.3) band = 1;
                    }
                    bands[x][y] = band;
                }
            }
            // Erode + smooth
            applyErosion(bands, rand);
            smoothForCohesion(bands);
        }

        public static void smoothElevationBands(int[][] bands, Random rand) {
            applyErosion(bands, rand);
            smoothForCohesion(bands);
            applyErosion(bands, rand);
            smoothForCohesion(bands);
        }

        /**
         * Slight erosion pass: if a tile is higher than most neighbors, or lower, we adjust it.
         */
        private static void applyErosion(int[][] bands, Random rand) {
            int size = bands.length;
            int[][] temp = smoothingTemp.get();

            for (int x = 1; x < size - 1; x++) {
                for (int y = 1; y < size - 1; y++) {
                    int band = bands[x][y];
                    if (band == 0) {
                        temp[x][y] = 0;
                        continue;
                    }
                    int higher = 0, lower = 0, same = 0;
                    for (int dx = -1; dx <= 1; dx++) {
                        for (int dy = -1; dy <= 1; dy++) {
                            if (dx == 0 && dy == 0) continue;
                            int nx = x + dx, ny = y + dy;
                            if (nx >= size || ny >= size) continue;
                            int nb = bands[nx][ny];
                            if (nb > band) higher++;
                            else if (nb < band) lower++;
                            else same++;
                        }
                    }
                    if (band > 1 && lower > higher + same) {
                        temp[x][y] = band - 1;
                    } else if (higher > lower + same && rand.nextFloat() < 0.1f) {
                        temp[x][y] = band + 1;
                    } else {
                        temp[x][y] = band;
                    }
                }
            }

            for (int x = 1; x < size - 1; x++) {
                System.arraycopy(temp[x], 1, bands[x], 1, size - 2);
            }
        }

        private static void smoothForCohesion(int[][] bands) {
            int size = bands.length;
            int[][] temp = new int[size][size];

            for (int x = 1; x < size - 1; x++) {
                for (int y = 1; y < size - 1; y++) {
                    int band = bands[x][y];
                    if (band == 0) {
                        temp[x][y] = 0;
                        continue;
                    }
                    int sameCount = 0;
                    for (int dx = -1; dx <= 1; dx++) {
                        for (int dy = -1; dy <= 1; dy++) {
                            int nx = x + dx, ny = y + dy;
                            if (nx >= size || ny >= size) continue;
                            if (bands[nx][ny] == band) sameCount++;
                        }
                    }
                    // if it’s too isolated, reduce band
                    if (sameCount < 4 && band > 1) {
                        temp[x][y] = band - 1;
                    } else {
                        temp[x][y] = band;
                    }
                }
            }

            for (int x = 1; x < size - 1; x++) {
                System.arraycopy(temp[x], 1, bands[x], 1, size - 2);
            }
        }

        public static void applyMountainTiles(int[][] tiles, int[][] bands) {
            int size = tiles.length;
            for (int x = 0; x < size; x++) {
                for (int y = 0; y < size; y++) {
                    int b = bands[x][y];
                    if (b > 0) {
                        int originalTile = tiles[x][y];
                        if (originalTile == TileType.WATER || originalTile == TileType.BEACH_SAND) {
                            continue;
                        }
                        assignMountainTile(x, y, tiles, bands);
                    }
                }
            }
        }

        private static void assignMountainTile(int x, int y, int[][] tiles, int[][] bands) {
            int band = bands[x][y];
            if (band <= 0) return;
            boolean isLowest = (band == 1);

            // We'll do your same approach of checking neighbors
            int n = getBand(x, y + 1, bands);
            int s = getBand(x, y - 1, bands);
            int e = getBand(x + 1, y, bands);
            int w = getBand(x - 1, y, bands);
            boolean topLower = n < band;
            boolean botLower = s < band;
            boolean leftLower = w < band;
            boolean rightLower = e < band;

            int topLeftCorner = isLowest
                ? TileType.MOUNTAIN_TILE_TOP_LEFT_GRASS_BG
                : TileType.MOUNTAIN_TILE_TOP_LEFT_ROCK_BG;

            int topRightCorner = isLowest
                ? TileType.MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG
                : TileType.MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG;

            int botLeftCorner = isLowest
                ? TileType.MOUNTAIN_TILE_BOT_LEFT_GRASS_BG
                : TileType.MOUNTAIN_TILE_BOT_LEFT_ROCK_BG;

            int botRightCorner = isLowest
                ? TileType.MOUNTAIN_TILE_BOT_RIGHT_GRASS_BG
                : TileType.MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG;

            // Then the usual set of conditions (same as your code)
            if (!topLower && !botLower && !leftLower && !rightLower) {
                tiles[x][y] = TileType.MOUNTAIN_TILE_CENTER;
                return;
            }
            if (topLower && leftLower && !botLower && !rightLower) {
                tiles[x][y] = topLeftCorner;
                return;
            }
            if (topLower && rightLower && !botLower && !leftLower) {
                tiles[x][y] = topRightCorner;
                return;
            }
            if (botLower && leftLower && !topLower && !rightLower) {
                tiles[x][y] = botLeftCorner;
                return;
            }
            if (botLower && rightLower && !topLower && !leftLower) {
                tiles[x][y] = botRightCorner;
                return;
            }
            if (topLower && !(leftLower || rightLower || botLower)) {
                tiles[x][y] = TileType.MOUNTAIN_TILE_TOP_MID;
                return;
            }
            if (botLower && !(leftLower || rightLower || topLower)) {
                tiles[x][y] = TileType.MOUNTAIN_TILE_BOT_MID;
                return;
            }
            if (leftLower && !(topLower || botLower || rightLower)) {
                tiles[x][y] = TileType.MOUNTAIN_TILE_MID_LEFT;
                return;
            }
            if (rightLower && !(topLower || botLower || leftLower)) {
                tiles[x][y] = TileType.MOUNTAIN_TILE_MID_RIGHT;
                return;
            }
            tiles[x][y] = TileType.MOUNTAIN_TILE_CENTER;
        }

        public static void autotileCliffs(int[][] bands, int[][] tiles) {
            int size = bands.length;
            for (int x = 0; x < size; x++) {
                for (int y = 0; y < size; y++) {
                    int b = getBand(x, y, bands);
                    if (b <= 0) continue;
                    int up = getBand(x, y + 1, bands);
                    int down = getBand(x, y - 1, bands);
                    int left = getBand(x - 1, y, bands);
                    int right = getBand(x + 1, y, bands);

                    boolean topLower = (up < b);
                    boolean botLower = (down < b);
                    boolean leftLower = (left < b);
                    boolean rightLower = (right < b);
                    tiles[x][y] = pickCliffTile(topLower, botLower, leftLower, rightLower, tiles[x][y]);
                }
            }
        }

        private static int pickCliffTile(boolean top, boolean bot, boolean left, boolean right, int original) {
            // Same logic as your "chooseCliffTile" snippet
            int lowers = 0;
            if (top) lowers++;
            if (bot) lowers++;
            if (left) lowers++;
            if (right) lowers++;
            if (top && left && !bot && !right) return TileType.MOUNTAIN_TILE_TOP_LEFT_ROCK_BG;
            if (top && right && !bot && !left) return TileType.MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG;
            if (bot && left && !top && !right) return TileType.MOUNTAIN_TILE_BOT_LEFT_ROCK_BG;
            if (bot && right && !top && !left) return TileType.MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG;
            if (lowers == 0) return TileType.MOUNTAIN_TILE_CENTER; // no edges
            if (top && lowers == 1) return TileType.MOUNTAIN_TILE_TOP_MID;
            if (bot && lowers == 1) return TileType.MOUNTAIN_TILE_BOT_MID;
            if (left && lowers == 1) return TileType.MOUNTAIN_TILE_MID_LEFT;
            if (right && lowers == 1) return TileType.MOUNTAIN_TILE_MID_RIGHT;
            // fallback
            return original;
        }

        public static void addStairsBetweenLayers(int[][] bands, int[][] tiles) {
            // same BFS approach as your original code for placing stairs
            int size = bands.length;
            for (int from = 0; from < 2; from++) {
                int to = from + 1;
                if (!layerExists(bands, to)) continue;
                int stairsPlaced = 0;
                int required = (from == 0) ? 4 : 2;
                if (tryPlaceStairsSide(bands, tiles, from, to, "north")) stairsPlaced++;
                if (tryPlaceStairsSide(bands, tiles, from, to, "south")) stairsPlaced++;
                if (tryPlaceStairsSide(bands, tiles, from, to, "east")) stairsPlaced++;
                if (tryPlaceStairsSide(bands, tiles, from, to, "west")) stairsPlaced++;
                while (stairsPlaced < required) {
                    if (tryPlaceStairsRandom(bands, tiles, from, to)) stairsPlaced++;
                    else break;
                }
            }
        }

        public static void finalizeStairAccess(int[][] tiles, int[][] bands) {
            // same idea as your code
            int size = tiles.length;
            for (int x = 0; x < size; x++) {
                for (int y = 0; y < size; y++) {
                    if (tiles[x][y] == TileType.STAIRS) {
                        int band = getBand(x, y, bands);
                        int ny = y + 1;
                        if (ny < size) {
                            int upband = getBand(x, ny, bands);
                            if (upband == band + 1) {
                                tiles[x][ny] = TileType.MOUNTAIN_TILE_CENTER;
                            }
                        }
                    }
                }
            }
        }

        public static void maybeAddCaveEntrance(int[][] bands, int[][] tiles, Random rand) {
            if (rand.nextFloat() > 0.025f) return; // small chance
            int size = tiles.length;
            for (int x = 1; x < size - 1; x++) {
                for (int y = 1; y < size - 1; y++) {
                    int band = getBand(x, y, bands);
                    if (band >= 2 && isCliffTile(tiles[x][y])) {
                        if (isStraightCliffEdge(x, y, bands)) {
                            tiles[x][y] = TileType.CAVE_ENTRANCE;
                            return;
                        }
                    }
                }
            }
        }

        private static boolean isStraightCliffEdge(int x, int y, int[][] bands) {
            int band = getBand(x, y, bands);
            int up = getBand(x, y + 1, bands);
            int down = getBand(x, y - 1, bands);
            int left = getBand(x - 1, y, bands);
            int right = getBand(x + 1, y, bands);
            // if top < band but bottom=band, left=band, right=band => let's call it an "edge"
            // etc
            if (up < band && down == band && left == band && right == band) return true;
            if (down < band && up == band && left == band && right == band) return true;
            if (left < band && right == band && up == band && down == band) return true;
            return right < band && left == band && up == band && down == band;
        }

        // same as your code
        private static boolean isCliffTile(int tile) {
            return tile != TileType.MOUNTAIN_TILE_CENTER
                && tile != TileType.GRASS
                && tile != TileType.MOUNTAIN_PEAK
                && tile != TileType.MOUNTAIN_SNOW_BASE
                && tile != TileType.STAIRS
                && tile != TileType.CAVE_ENTRANCE
                && tile != TileType.FLOWER && tile != TileType.FLOWER_1 && tile != TileType.FLOWER_2
                && tile != TileType.GRASS_2 && tile != TileType.GRASS_3
                && tile != TileType.TALL_GRASS && tile != TileType.TALL_GRASS_2 && tile != TileType.TALL_GRASS_3
                && tile != TileType.SAND && tile != TileType.DESERT_SAND
                && tile != TileType.HAUNTED_GRASS && tile != TileType.HAUNTED_TALL_GRASS
                && tile != TileType.RAIN_FOREST_GRASS && tile != TileType.RAIN_FOREST_TALL_GRASS
                && tile != TileType.FOREST_GRASS && tile != TileType.FOREST_TALL_GRASS
                && tile != TileType.SNOW && tile != TileType.SNOW_2 && tile != TileType.SNOW_3 && tile != TileType.SNOW_TALL_GRASS
                && tile != TileType.RUINS_GRASS && tile != TileType.RUINS_GRASS_0 && tile != TileType.RUINS_TALL_GRASS
                && tile != TileType.RUINS_BRICKS;
        }

        private static boolean tryPlaceStairsSide(int[][] bands, int[][] tiles, int from, int to, String side) {
            int size = bands.length;
            int startX, endX, startY, endY;
            switch (side) {
                case "north":
                    startX = 1;
                    endX = size - 1;
                    startY = size - 2;
                    endY = size - 1;
                    break;
                case "south":
                    startX = 1;
                    endX = size - 1;
                    startY = 1;
                    endY = 2;
                    break;
                case "east":
                    startX = size - 2;
                    endX = size - 1;
                    startY = 1;
                    endY = size - 1;
                    break;
                case "west":
                    startX = 1;
                    endX = 2;
                    startY = 1;
                    endY = size - 1;
                    break;
                default:
                    return false;
            }
            for (int x = startX; x < endX; x++) {
                for (int y = startY; y < endY; y++) {
                    if (canPlaceStairsHere(x, y, bands, tiles, from, to)) {
                        tiles[x][y] = TileType.STAIRS;
                        return true;
                    }
                }
            }
            return false;
        }

        private static boolean tryPlaceStairsRandom(int[][] bands, int[][] tiles, int from, int to) {
            int size = bands.length;
            for (int x = 1; x < size - 1; x++) {
                for (int y = 1; y < size - 1; y++) {
                    if (canPlaceStairsHere(x, y, bands, tiles, from, to)) {
                        tiles[x][y] = TileType.STAIRS;
                        return true;
                    }
                }
            }
            return false;
        }

        private static boolean canPlaceStairsHere(int x, int y, int[][] bands, int[][] tiles, int fromBand, int toBand) {
            if (bands[x][y] != fromBand) return false;
            if (!isCliffTile(tiles[x][y])) return false;
            if (!hasAdjacentBand(x, y, toBand, bands)) return false;
            return !hasNearbyStairs(x, y, tiles);
        }

        private static boolean hasAdjacentBand(int x, int y, int target, int[][] bands) {
            int up = getBand(x, y + 1, bands);
            int down = getBand(x, y - 1, bands);
            int left = getBand(x - 1, y, bands);
            int right = getBand(x + 1, y, bands);
            return (up == target || down == target || left == target || right == target);
        }

        private static boolean hasNearbyStairs(int x, int y, int[][] tiles) {
            int size = tiles.length;
            for (int dx = -3; dx <= 3; dx++) {
                for (int dy = -3; dy <= 3; dy++) {
                    int nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < size && ny >= 0 && ny < size) {
                        if (tiles[nx][ny] == TileType.STAIRS) return true;
                    }
                }
            }
            return false;
        }

        private static boolean layerExists(int[][] bands, int target) {
            for (int[] row : bands) {
                for (int b : row) {
                    if (b == target) return true;
                }
            }
            return false;
        }

        private static int getBand(int x, int y, int[][] arr) {
            if (x < 0 || y < 0 || x >= arr.length || y >= arr[0].length) return -1;
            return arr[x][y];
        }
    }

    // Simple BFS point
    private static class Point {
        int x, y;

        Point(int xx, int yy) {
            x = xx;
            y = yy;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/WeatherAudioSystem.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

public class WeatherAudioSystem {
    private static final float THUNDER_MIN_INTERVAL = 5f;
    private static final float THUNDER_MAX_INTERVAL = 15f;

    private float thunderTimer;
    private float nextThunderTime;
    private boolean isThundering;
    private float lightningAlpha;
    private final AudioManager audioManager;

    public WeatherAudioSystem(AudioManager audioManager) {
        this.audioManager = audioManager;
        resetThunderTimer();
    }

    private void resetThunderTimer() {
        nextThunderTime = MathUtils.random(THUNDER_MIN_INTERVAL, THUNDER_MAX_INTERVAL);
        thunderTimer = 0;
    }

    public void update(float delta, WeatherSystem.WeatherType currentWeather, float intensity) {
        updateThunderAndLightning(delta, currentWeather, intensity);
        updateWeatherSounds(currentWeather, intensity);
    }
    private void updateThunderAndLightning(float delta, WeatherSystem.WeatherType currentWeather, float intensity) {
        if (currentWeather == WeatherSystem.WeatherType.THUNDERSTORM) {
            thunderTimer += delta;

            if (isThundering) {
                lightningTimer += delta;
                // For the first 0.05 seconds, keep the flash at full intensity.
                if (lightningTimer < 0.05f) {
                    lightningAlpha = 1.0f; // full flash
                }
                // Then fade out over the remainder of the flash duration.
                else if (lightningTimer < lightningDuration) {
                    float t = (lightningTimer - 0.05f) / (lightningDuration - 0.05f);
                    lightningAlpha = MathUtils.lerp(1.0f, 0f, t);
                } else {
                    // End of flash effect.
                    isThundering = false;
                    lightningAlpha = 0;
                    lightningTimer = 0;
                }
            }

            // Trigger a new thunder flash if the timer has reached the next scheduled thunder.
            if (thunderTimer >= nextThunderTime) {
                triggerThunderAndLightning(intensity);
                resetThunderTimer();
            }
        } else {
            // Reset lightning variables if the weather changes.
            lightningAlpha = 0;
            isThundering = false;
            lightningTimer = 0;
            resetThunderTimer();
        }
    }
private float lightningTimer = 0f;
    private final float lightningDuration = 0.2f; // total flash duration of 200 ms

    private void triggerThunderAndLightning(float intensity) {
        isThundering = true;
        lightningTimer = 0;
        // Start with a full-intensity flash.
        lightningAlpha = 1.0f;

        // (Optionally, if you want to modulate by intensity, you could do:
        // lightningAlpha = Math.min(1.0f, 0.7f * intensity);
        // but a full flash often looks best.)

        // Play thunder sound with random variation.
        float volume = 0.5f + (intensity * 0.5f);
        float pitch = 0.9f + (MathUtils.random() * 0.2f);
        audioManager.playWeatherSound(AudioManager.WeatherSoundEffect.THUNDER, volume, pitch);
    }

    private void updateWeatherSounds(WeatherSystem.WeatherType currentWeather, float intensity) {
        // Update looping weather sounds
        switch (currentWeather) {
            case RAIN:
                audioManager.updateWeatherLoop(AudioManager.WeatherSoundEffect.LIGHT_RAIN, intensity * 0.6f);
                break;

            case HEAVY_RAIN:
            case THUNDERSTORM:
                audioManager.stopWeatherLoop(AudioManager.WeatherSoundEffect.LIGHT_RAIN);
                break;

            case SNOW:
            case BLIZZARD:
                audioManager.updateWeatherLoop(AudioManager.WeatherSoundEffect.WIND, intensity * 0.4f);
                break;

            case SANDSTORM:
                audioManager.updateWeatherLoop(AudioManager.WeatherSoundEffect.SAND_WIND, intensity * 0.7f);
                break;

            default:
                // Stop all weather loops for clear weather
                audioManager.stopAllWeatherLoops();
                break;
        }
    }

    public void renderLightningEffect(SpriteBatch batch, float screenWidth, float screenHeight) {
        if (lightningAlpha > 0) {
            Color oldColor = batch.getColor();
            batch.setColor(1, 1, 1, lightningAlpha);

            // Save blend function
            int srcFunc = batch.getBlendSrcFunc();
            int dstFunc = batch.getBlendDstFunc();

            // Use additive blending for lightning
            batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE);

            // Draw full screen white rectangle for lightning flash
            batch.draw(TextureManager.getWhitePixel(), 0, 0, screenWidth, screenHeight);

            // Restore original blend function and color
            batch.setBlendFunction(srcFunc, dstFunc);
            batch.setColor(oldColor);
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/WeatherSystem.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Rectangle; // Import Rectangle
import com.badlogic.gdx.utils.Pool;
import io.github.pokemeetup.managers.BiomeTransitionResult;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.*;

import static com.badlogic.gdx.math.MathUtils.random;

public class WeatherSystem {
    private static final float SPAWN_MARGIN = 150f;
    private static final int MAX_PARTICLES = 200; // Reduced for better performance
    private static final float MAX_PARTICLE_SPAWN_RATE = 150f; // Reduced spawn rate
    private static final float PARTICLE_DESPAWN_MARGIN = 150f;
    private static final float RAIN_SPEED = 600f; // Slightly slower for realism
    private static final float RAIN_ANGLE = 82f; // More vertical
    private static final float RAIN_SCALE = 0.5f; // Smaller droplets
    private static final float RAIN_BASE_ALPHA = 0.6f;
    private static final float SNOW_SPEED = 150f; // Much slower for realistic snow
    private static final float SNOW_SWAY_AMPLITUDE = 30f; // Gentle swaying
    private static final float SNOW_SWAY_FREQUENCY = 1.5f;
    private static final float SAND_SPEED = 400f;
    private static final float WEATHER_CHECK_INTERVAL = 45f; // Check every 45 seconds instead of 10
    private static final float WEATHER_TRANSITION_DURATION = 5f; // Smooth transitions
    private static final int LANDING_EFFECT_POOL_SIZE = 50;
    private static final float LANDING_EFFECT_DURATION = 0.3f;

    private final List<WeatherParticle> particles;
    private final Pool<WeatherParticle> particlePool;
    private final List<LandingEffect> activeLandingEffects;
    private final Pool<LandingEffect> landingEffectPool;
    private final TextureRegion rainDrop;
    private final TextureRegion snowflake;
    private final TextureRegion sandParticle;
    private final TextureRegion rainSplash;
    private final TextureRegion snowPoof;
    private float fogOffsetX = 0f;
    private float fogOffsetY = 0f;
    private float particleSpawnAccumulator = 0f;
    private WeatherType currentWeather;
    private WeatherType targetWeather;
    private float intensity;
    private float targetIntensity;
    private float transitionProgress = 1f;
    private float accumulation;
    private float weatherCheckTimer = 0f;
    private float manualOverrideTimer = 0f;
    private World world;

    public WeatherSystem() {
        this.particles = new ArrayList<>();
        this.activeLandingEffects = new ArrayList<>();
        this.currentWeather = WeatherType.CLEAR;
        this.targetWeather = WeatherType.CLEAR;
        this.intensity = 0f;
        this.targetIntensity = 0f;
        this.accumulation = 0f;

        // Initialize textures
        if (TextureManager.effects != null) {
            this.rainDrop = TextureManager.effects.findRegion("rain_drop");
            this.snowflake = TextureManager.effects.findRegion("snowflake");
            this.sandParticle = TextureManager.effects.findRegion("sand_particle");
            this.rainSplash = TextureManager.owFx.findRegion("rain_splash");
            this.snowPoof = TextureManager.owFx.findRegion("snowflake");
        } else {
            this.rainDrop = null;
            this.snowflake = null;
            this.sandParticle = null;
            this.rainSplash = null;
            this.snowPoof = null;
        }

        // Initialize particle pool for performance
        this.particlePool = new Pool<WeatherParticle>() {
            @Override
            protected WeatherParticle newObject() {
                return new WeatherParticle();
            }
        };

        // Initialize landing effect pool
        this.landingEffectPool = new Pool<LandingEffect>(LANDING_EFFECT_POOL_SIZE) {
            @Override
            protected LandingEffect newObject() {
                return new LandingEffect();
            }
        };
    }

    public void setWorld(World world) {
        this.world = world;
    }

    public void setManualOverrideTimer(float duration) {
        this.manualOverrideTimer = duration;
    }

    /**
     * Enhanced weather decision logic with more realistic patterns and rarer weather
     */
    private void updateWeatherType(BiomeTransitionResult biomeTransition, float temperature, float timeOfDay) {
        float randomValue = MathUtils.random();

        // Apply weather rarity modifiers
        float weatherChance = 0.3f; // Base 30% chance of weather vs clear

        // Time of day modifiers
        if (timeOfDay >= 6 && timeOfDay < 10) {
            weatherChance *= 0.7f; // Less weather in morning
        } else if (timeOfDay >= 16 && timeOfDay < 20) {
            weatherChance *= 1.2f; // More weather in evening
        } else if (timeOfDay >= 20 || timeOfDay < 6) {
            weatherChance *= 1.1f; // Slightly more at night
        }

        // Temperature modifiers
        if (temperature > 30) {
            weatherChance *= 0.8f; // Less weather when hot
        } else if (temperature < 10) {
            weatherChance *= 1.1f; // More weather when cold
        }

        boolean shouldHaveWeather = randomValue < weatherChance;

        switch (biomeTransition.getPrimaryBiome().getType()) {
            case RAIN_FOREST:
                if (shouldHaveWeather) {
                    if (randomValue < 0.2f) {
                        setWeatherWithTransition(WeatherType.HEAVY_RAIN, 0.7f);
                    } else {
                        setWeatherWithTransition(WeatherType.RAIN, 0.5f);
                    }
                } else {
                    setWeatherWithTransition(WeatherType.CLEAR, 0f);
                }
                break;

            case HAUNTED:
                if (timeOfDay >= 18 || timeOfDay < 6) {
                    if (randomValue < 0.5f) {
                        setWeatherWithTransition(WeatherType.FOG, 0.7f);
                    } else if (randomValue < 0.6f) {
                        setWeatherWithTransition(WeatherType.THUNDERSTORM, 0.8f);
                    } else {
                        setWeatherWithTransition(WeatherType.CLEAR, 0f);
                    }
                } else {
                    if (randomValue < 0.3f) {
                        setWeatherWithTransition(WeatherType.FOG, 0.5f);
                    } else {
                        setWeatherWithTransition(WeatherType.CLEAR, 0f);
                    }
                }
                break;

            case SNOW:
                if (temperature < -5) {
                    if (shouldHaveWeather && randomValue < 0.3f) {
                        setWeatherWithTransition(WeatherType.BLIZZARD, 0.6f);
                    } else if (shouldHaveWeather) {
                        setWeatherWithTransition(WeatherType.SNOW, 0.4f);
                    } else {
                        setWeatherWithTransition(WeatherType.CLEAR, 0f);
                    }
                } else {
                    if (shouldHaveWeather && randomValue < 0.5f) {
                        setWeatherWithTransition(WeatherType.SNOW, 0.3f);
                    } else {
                        setWeatherWithTransition(WeatherType.CLEAR, 0f);
                    }
                }
                break;

            case DESERT:
                if (temperature > 35 && randomValue < 0.15f) { // Rare sandstorms
                    setWeatherWithTransition(WeatherType.SANDSTORM, 0.6f);
                } else {
                    setWeatherWithTransition(WeatherType.CLEAR, 0f);
                }
                break;

            case FOREST:
                if (shouldHaveWeather && randomValue < 0.3f) {
                    setWeatherWithTransition(WeatherType.RAIN, 0.3f);
                } else {
                    setWeatherWithTransition(WeatherType.CLEAR, 0f);
                }
                break;

            default:
                setWeatherWithTransition(WeatherType.CLEAR, 0f);
                break;
        }
    }

    private void setWeatherWithTransition(WeatherType type, float newIntensity) {
        if (this.currentWeather != type || Math.abs(this.intensity - newIntensity) > 0.1f) {
            this.targetWeather = type;
            this.targetIntensity = newIntensity;
            this.transitionProgress = 0f;
        }
    }

    public void update(float delta, BiomeTransitionResult biomeTransition, float temperature, float timeOfDay, GameScreen gameScreen) {
        // Handle manual override
        if (manualOverrideTimer > 0) {
            manualOverrideTimer -= delta;
        } else {
            weatherCheckTimer += delta;
            if (weatherCheckTimer >= WEATHER_CHECK_INTERVAL) {
                updateWeatherType(biomeTransition, temperature, timeOfDay);
                weatherCheckTimer = 0f;
                GameLogger.info(String.format("Weather Updated - Type: %s, Intensity: %.2f, Temperature: %.1f",
                    currentWeather, intensity, temperature));
            }
        }

        // Handle smooth weather transitions
        if (transitionProgress < 1f) {
            transitionProgress = Math.min(1f, transitionProgress + delta / WEATHER_TRANSITION_DURATION);

            // Smooth intensity transition
            intensity = MathUtils.lerp(intensity, targetIntensity, transitionProgress);

            // Switch weather type at midpoint
            if (transitionProgress >= 0.5f && currentWeather != targetWeather) {
                currentWeather = targetWeather;
                // Clear particles when switching weather types
                clearParticles();
            }
        }

        updateParticles(delta, gameScreen.getCamera());
        updateLandingEffects(delta);
        generateParticles(delta, gameScreen);
        updateAccumulation(delta);

        if (currentWeather == WeatherType.FOG) {
            float fogSpeedX = 15f;
            float fogSpeedY = 8f;
            fogOffsetX += fogSpeedX * delta;
            fogOffsetY += fogSpeedY * delta;
        }
    }

    private void clearParticles() {
        for (WeatherParticle particle : particles) {
            particlePool.free(particle);
        }
        particles.clear();
    }

    public void setWeather(WeatherType type, float intensity) {
        if (this.currentWeather != type) {
            clearParticles();
        }
        this.currentWeather = type;
        this.targetWeather = type;
        this.intensity = intensity;
        this.targetIntensity = intensity;
        this.transitionProgress = 1f;
    }

    public WeatherType getCurrentWeather() {
        return currentWeather;
    }

    public void updateParticles(float delta, OrthographicCamera camera) {
        float left = camera.position.x - (camera.viewportWidth / 2 + PARTICLE_DESPAWN_MARGIN) * camera.zoom;
        float right = camera.position.x + (camera.viewportWidth / 2 + PARTICLE_DESPAWN_MARGIN) * camera.zoom;
        float bottom = camera.position.y - (camera.viewportHeight / 2 + PARTICLE_DESPAWN_MARGIN) * camera.zoom;
        float top = camera.position.y + (camera.viewportHeight / 2 + PARTICLE_DESPAWN_MARGIN) * camera.zoom;

        Iterator<WeatherParticle> iter = particles.iterator();
        while (iter.hasNext()) {
            WeatherParticle particle = iter.next();
            particle.update(delta);

            // Check if particle has landed
            if (world != null && shouldCheckLanding(particle)) {
                int tileX = (int)(particle.x / World.TILE_SIZE);
                int tileY = Math.floorDiv((int)particle.y, World.TILE_SIZE);

                if (world.isPositionLoaded(tileX, tileY)) {
                    int tileType = world.getTileTypeAt(tileX, tileY);

                    // Check if particle should land on this tile
                    if (particle.y <= tileY * World.TILE_SIZE + getParticleLandingHeight(tileType)) {
                        createLandingEffect(particle);
                        iter.remove();
                        particlePool.free(particle);
                        continue;
                    }
                }
            }

            // Remove if out of bounds
            if (particle.isOutOfBounds(left, right, bottom, top)) {
                iter.remove();
                particlePool.free(particle);
            }
        }
    }

    private boolean shouldCheckLanding(WeatherParticle particle) {
        // Only check landing for rain and snow
        return currentWeather == WeatherType.RAIN ||
            currentWeather == WeatherType.HEAVY_RAIN ||
            currentWeather == WeatherType.SNOW ||
            currentWeather == WeatherType.BLIZZARD;
    }

    private float getParticleLandingHeight(int tileType) {
        // Different landing heights for different tile types
        if (TileType.isWaterPuddle(tileType) || tileType==TileType.WATER) {
            return 2f; // Land slightly above water
        } else if (tileType == TileType.TALL_GRASS || tileType == TileType.FOREST_TALL_GRASS) {
            return 8f; // Land on top of grass
        }
        return 0f; // Land on ground level
    }

    private void createLandingEffect(WeatherParticle particle) {
        if (activeLandingEffects.size() >= LANDING_EFFECT_POOL_SIZE) {
            return; // Don't create more effects if pool is full
        }

        LandingEffect effect = landingEffectPool.obtain();
        effect.init(particle.x, particle.y, currentWeather);
        activeLandingEffects.add(effect);
    }

    private void updateLandingEffects(float delta) {
        Iterator<LandingEffect> iter = activeLandingEffects.iterator();
        while (iter.hasNext()) {
            LandingEffect effect = iter.next();
            effect.update(delta);

            if (effect.isFinished()) {
                iter.remove();
                landingEffectPool.free(effect);
            }
        }
    }

    private void generateParticles(float delta, GameScreen gameScreen) {
        if (currentWeather == WeatherType.CLEAR || currentWeather == WeatherType.FOG) {
            return;
        }

        float particleSpawnRate = intensity * MAX_PARTICLE_SPAWN_RATE;

        // Adjust spawn rate for heavy weather types
        if (currentWeather == WeatherType.HEAVY_RAIN || currentWeather == WeatherType.THUNDERSTORM) {
            particleSpawnRate *= 1.3f; // Less aggressive multiplier
        } else if (currentWeather == WeatherType.BLIZZARD) {
            particleSpawnRate *= 1.2f;
        }

        particleSpawnAccumulator += delta * particleSpawnRate;
        int particlesToGenerate = (int) particleSpawnAccumulator;
        particleSpawnAccumulator -= particlesToGenerate;
        particlesToGenerate = Math.min(particlesToGenerate, MAX_PARTICLES - particles.size());

        for (int i = 0; i < particlesToGenerate; i++) {
            WeatherParticle particle = createParticle(gameScreen);
            if (particle != null) {
                particles.add(particle);
            }
        }
    }

    private WeatherParticle createParticle(GameScreen gameScreen) {
        OrthographicCamera camera = gameScreen.getCamera();
        // 1. Define the landing area on the ground (the camera's view)
        Rectangle landingZone = new Rectangle(
            camera.position.x - camera.viewportWidth * camera.zoom / 2,
            camera.position.y - camera.viewportHeight * camera.zoom / 2,
            camera.viewportWidth * camera.zoom,
            camera.viewportHeight * camera.zoom
        );

        // 2. Pick a random landing spot (target) within this zone
        float targetX = MathUtils.random(landingZone.x, landingZone.x + landingZone.width);
        float targetY = MathUtils.random(landingZone.y, landingZone.y + landingZone.height);

        float spawnX, spawnY;
        float velocityX, velocityY;
        float fallDuration;

        WeatherParticle particle = particlePool.obtain();

        switch (currentWeather) {
            case RAIN:
            case HEAVY_RAIN:
            case THUNDERSTORM:
                float speed = RAIN_SPEED * (currentWeather == WeatherType.HEAVY_RAIN ? 1.15f : 1f);
                velocityX = -speed * MathUtils.cosDeg(RAIN_ANGLE);
                velocityY = -speed * MathUtils.sinDeg(RAIN_ANGLE);

                if (velocityY >= 0) { // Should be negative, but as a safeguard
                    particlePool.free(particle);
                    return null;
                }

                // Randomize the fall duration to de-synchronize particles
                fallDuration = MathUtils.random(0.1f, 1.5f);

                // Calculate spawn position based on target and randomized fall duration
                spawnX = targetX - (velocityX * fallDuration);
                spawnY = targetY - (velocityY * fallDuration);

                particle.init(spawnX, spawnY, velocityX, velocityY, rainDrop, false, RAIN_SCALE);
                break;

            case SNOW:
            case BLIZZARD:
                float baseVelocityX = (currentWeather == WeatherType.BLIZZARD) ? random(-100, -50) : random(-30, 30);
                velocityY = -SNOW_SPEED - random(0, 30);

                if (velocityY >= 0) {
                    particlePool.free(particle);
                    return null;
                }

                // Randomize fall duration for snow as well
                fallDuration = MathUtils.random(1.0f, 4.0f); // Snow falls slower, so longer duration range

                spawnX = targetX - (baseVelocityX * fallDuration);
                spawnY = targetY - (velocityY * fallDuration);

                float scale = 0.4f + random() * 0.6f;
                particle.init(spawnX, spawnY, baseVelocityX, velocityY, snowflake, true, scale);
                particle.swayOffset = random(0, MathUtils.PI2);
                break;

            case SANDSTORM:
                // Sandstorms blow horizontally, so this logic is different
                float viewWidth = camera.viewportWidth * camera.zoom;
                float viewHeight = camera.viewportHeight * camera.zoom;

                spawnX = camera.position.x + viewWidth / 2 + SPAWN_MARGIN;
                spawnY = MathUtils.random(
                    camera.position.y - viewHeight / 2 - SPAWN_MARGIN,
                    camera.position.y + viewHeight / 2 + SPAWN_MARGIN);

                particle.init(spawnX, spawnY,
                    -SAND_SPEED - random(0, 100),
                    random(-60, 60),
                    sandParticle, true, 0.5f + random() * 0.5f);
                break;

            default:
                particlePool.free(particle);
                return null;
        }

        return particle;
    }

    public void render(SpriteBatch batch, OrthographicCamera camera) {
        if (currentWeather == WeatherType.CLEAR) return;

        Color prevColor = batch.getColor().cpy();
        int prevSrcFunc = batch.getBlendSrcFunc();
        int prevDstFunc = batch.getBlendDstFunc();

        // Set appropriate blending for weather
        if (currentWeather == WeatherType.RAIN ||
            currentWeather == WeatherType.HEAVY_RAIN ||
            currentWeather == WeatherType.THUNDERSTORM) {
            batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);
            batch.setColor(1, 1, 1, RAIN_BASE_ALPHA * intensity);
        } else {
            batch.setColor(1, 1, 1, intensity * 0.8f);
        }

        // Render particles
        for (WeatherParticle particle : particles) {
            particle.render(batch);
        }

        // Render landing effects
        for (LandingEffect effect : activeLandingEffects) {
            effect.render(batch);
        }

        batch.setBlendFunction(prevSrcFunc, prevDstFunc);
        batch.setColor(prevColor);

        // Render fog
        if (currentWeather == WeatherType.FOG) {
            renderFog(batch,
                camera.position.x - camera.viewportWidth / 2,
                camera.position.y - camera.viewportHeight / 2,
                camera.viewportWidth,
                camera.viewportHeight);
        }
    }

    private void renderFog(SpriteBatch batch, float x, float y, float width, float height) {
        batch.setColor(1, 1, 1, 0.3f * intensity);
        TextureRegion fogTexture = TextureManager.effects.findRegion("fog");
        if (fogTexture == null) return;

        float fogTextureWidth = fogTexture.getRegionWidth();
        float fogTextureHeight = fogTexture.getRegionHeight();
        float startX = x - (fogOffsetX % fogTextureWidth) - fogTextureWidth;
        float startY = y - (fogOffsetY % fogTextureHeight) - fogTextureHeight;

        for (float posX = startX; posX < x + width; posX += fogTextureWidth) {
            for (float posY = startY; posY < y + height; posY += fogTextureHeight) {
                batch.draw(fogTexture, posX, posY, fogTextureWidth, fogTextureHeight);
            }
        }
        batch.setColor(1, 1, 1, 1);
    }

    private void updateAccumulation(float delta) {
        float accumulationRate;
        if (currentWeather == WeatherType.SNOW || currentWeather == WeatherType.BLIZZARD) {
            accumulationRate = 0.05f * intensity; // Slower accumulation
        } else if (currentWeather == WeatherType.RAIN) {
            accumulationRate = 0.03f * intensity;
        } else if (currentWeather == WeatherType.HEAVY_RAIN || currentWeather == WeatherType.THUNDERSTORM) {
            accumulationRate = 0.08f * intensity;
        } else {
            accumulationRate = -0.02f; // Slower dissipation
        }
        accumulation = MathUtils.clamp(accumulation + accumulationRate * delta, 0, 1);
    }

    public float getIntensity() {
        return intensity;
    }

    public float getAccumulation() {
        return accumulation;
    }

    public void setAccumulation(float accumulation) {
        this.accumulation = accumulation;
    }

    public enum WeatherType {
        CLEAR,
        RAIN,
        HEAVY_RAIN,
        SNOW,
        BLIZZARD,
        SANDSTORM,
        FOG,
        THUNDERSTORM
    }

    /**
     * Enhanced weather particle with pooling support and sway for snow
     */
    public static class WeatherParticle implements Pool.Poolable {
        private TextureRegion texture;
        private float x, y;
        private float velocityX, velocityY;
        private float rotation;
        private float rotationSpeed;
        private float scale;
        private boolean rotating;
        private float swayOffset;
        private float lifetime;

        public void init(float x, float y, float velocityX, float velocityY,
                         TextureRegion texture, boolean rotating, float scale) {
            this.x = x;
            this.y = y;
            this.velocityX = velocityX;
            this.velocityY = velocityY;
            this.texture = texture;
            this.rotating = rotating;
            this.scale = scale;
            this.rotation = 0f;
            this.rotationSpeed = rotating ? (float) (15 + Math.random() * 60) : 0f;
            this.swayOffset = 0f;
            this.lifetime = 0f;
        }

        public void update(float delta) {
            // Basic movement
            x += velocityX * delta;
            y += velocityY * delta;
            lifetime += delta;

            // Add sway for snow particles
            if (texture != null && velocityY < -100 && velocityY > -200) { // Snow particles
                float swayAmount = MathUtils.sin(lifetime * SNOW_SWAY_FREQUENCY + swayOffset) * SNOW_SWAY_AMPLITUDE;
                x += swayAmount * delta;
            }

            if (rotating) {
                rotation += rotationSpeed * delta;
            }
        }

        public void render(SpriteBatch batch) {
            if (texture == null) return;

            if (rotating) {
                batch.draw(texture,
                    x, y,
                    texture.getRegionWidth() / 2f,
                    texture.getRegionHeight() / 2f,
                    texture.getRegionWidth(),
                    texture.getRegionHeight(),
                    scale, scale,
                    rotation);
            } else {
                batch.draw(texture,
                    x, y,
                    texture.getRegionWidth() * scale,
                    texture.getRegionHeight() * scale);
            }
        }

        public boolean isOutOfBounds(float left, float right, float bottom, float top) {
            return x < left || x > right || y < bottom || y > top;
        }

        @Override
        public void reset() {
            x = 0;
            y = 0;
            velocityX = 0;
            velocityY = 0;
            rotation = 0;
            rotationSpeed = 0;
            scale = 1;
            rotating = false;
            texture = null;
            swayOffset = 0;
            lifetime = 0;
        }
    }

    /**
     * Landing effect for rain splashes and snow poofs
     */
    private static class LandingEffect implements Pool.Poolable {
        private float x, y;
        private float lifetime;
        private float alpha;
        private TextureRegion texture;
        private WeatherType type;
        private float scale;

        public void init(float x, float y, WeatherType weatherType) {
            this.x = x;
            this.y = y;
            this.lifetime = 0f;
            this.alpha = 1f;
            this.type = weatherType;

            // Set texture and scale based on weather type
            if (weatherType == WeatherType.RAIN || weatherType == WeatherType.HEAVY_RAIN) {
                this.texture = TextureManager.owFx.findRegion("rain_splash");
                this.scale = 0.5f + MathUtils.random() * 0.3f;
            } else if (weatherType == WeatherType.SNOW || weatherType == WeatherType.BLIZZARD) {
                this.texture = TextureManager.owFx.findRegion("snow_poof");
                this.scale = 0.3f + MathUtils.random() * 0.2f;
            }
        }

        public void update(float delta) {
            lifetime += delta;
            // Fade out over the duration
            alpha = 1f - (lifetime / LANDING_EFFECT_DURATION);

            // Expand slightly for splash effect
            if (type == WeatherType.RAIN || type == WeatherType.HEAVY_RAIN) {
                scale += delta * 0.5f;
            }
        }

        public void render(SpriteBatch batch) {
            if (texture == null || alpha <= 0) return;

            Color prevColor = batch.getColor();
            batch.setColor(1, 1, 1, alpha * 0.6f);

            float width = texture.getRegionWidth() * scale;
            float height = texture.getRegionHeight() * scale;
            batch.draw(texture, x - width/2, y - height/2, width, height);

            batch.setColor(prevColor);
        }

        public boolean isFinished() {
            return lifetime >= LANDING_EFFECT_DURATION;
        }

        @Override
        public void reset() {
            x = 0;
            y = 0;
            lifetime = 0;
            alpha = 1;
            texture = null;
            type = null;
            scale = 1;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/World.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Intersector;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonValue;
import com.badlogic.gdx.utils.JsonWriter;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.blocks.BlockManager;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.*;
import io.github.pokemeetup.multiplayer.OtherPlayer;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.*;
import io.github.pokemeetup.system.gameplay.inventory.ItemEntityManager;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.system.gameplay.overworld.mechanics.AutoTileSystem;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.PokemonSpawnManager;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.JsonConfig;
import io.github.pokemeetup.utils.textures.BlockTextureManager;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.textures.TileType;

import java.lang.reflect.Field;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

public class World {
    public static final int INITIAL_LOAD_RADIUS = 2;
    public static final int TILE_SIZE = 32;
    public static final int WORLD_SIZE = 100000 * TILE_SIZE;
    public static final int HALF_WORLD_SIZE = WORLD_SIZE / 2;
    public static final int CHUNK_SIZE = 16;
    public static final float INTERACTION_RANGE = TILE_SIZE * 1.6f;
    private static final float COLOR_TRANSITION_SPEED = 2.0f;
    private static final int MAX_CHUNK_LOAD_RADIUS = 16;  // or 10, adjust as needed
    private static final int MAX_LOADED_CHUNKS = 200;         // or whatever limit you want
    private static final long UNLOAD_IDLE_THRESHOLD_MS = 30000;
    private static final int MAX_CHUNKS_INTEGRATED_PER_FRAME = 8;
    // Maximum number of asynchronous retries per chunk
    private static final int MAX_CHUNK_RETRY = 3;
    public static int DEFAULT_X_POSITION = 0;
    public static int DEFAULT_Y_POSITION = 0;
    private final Map<Vector2, Long> lastChunkAccess = new ConcurrentHashMap<>();
    private final Set<Vector2> dirtyChunks = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final BiomeRenderer biomeRenderer;
    private final WeatherSystem weatherSystem;
    private final WeatherAudioSystem weatherAudioSystem;
    private final Map<Vector2, BiomeTransitionResult> biomeTransitions = new ConcurrentHashMap<>();
    private final Rectangle tempChunkRect = new Rectangle();
    private final WaterEffectsRenderer waterEffectsRendererForOthers = new WaterEffectsRenderer();
    private final ConcurrentLinkedQueue<Map.Entry<Vector2, Chunk>> integrationQueue = new ConcurrentLinkedQueue<>();
    public Map<Vector2, Chunk> chunks;
    private FootstepEffectManager footstepEffectManager;
    private Color currentWorldColor = new Color(1, 1, 1, 1);
    private Color previousWorldColor = null;
    private float colorTransitionProgress = 1.0f;
    private volatile boolean initialChunksRequested = false;
    private Map<Vector2, Future<Chunk>> loadingChunks;
    private Queue<Vector2> initialChunkLoadQueue = new LinkedList<>();
    private ExecutorService chunkLoadExecutor = Executors.newFixedThreadPool(2); // limit to 2 threads
    private PlayerData currentPlayerData;
    private WorldObject nearestPokeball;
    private long lastPlayed;
    private BlockManager blockManager;
    private String name;
    private WorldData worldData;
    private PokemonSpawnManager pokemonSpawnManager;
    private long worldSeed;
    private WorldObject.WorldObjectManager objectManager;
    private BiomeTransitionResult currentBiomeTransition;
    private Map<Vector2, Float> lightLevelMap = new HashMap<>();
    private boolean isDisposed = false;
    private WaterEffectManager waterEffectManager;
    private WaterEffectsRenderer waterEffects;
    private ItemEntityManager itemEntityManager;
    private List<Map.Entry<Vector2, Chunk>> cachedSortedChunks = null;
    private int cachedChunkCount = 0;
    private float lightLevelUpdateTimer = 0f;
    private float manageChunksTimer = 0f;
    private long initialChunkRequestTime;
    private BitmapFont loadingFont;

    public World(WorldData worldData) {
        try {
            GameLogger.info("Initializing multiplayer world: " + worldData.getName());
            this.worldData = worldData;
            this.name = worldData.getName();
            this.worldSeed = worldData.getConfig().getSeed();
            this.blockManager = new BlockManager();
            GameContext.get().setBiomeManager(new BiomeManager(this.worldSeed));
            this.biomeRenderer = new BiomeRenderer();
            this.chunks = new ConcurrentHashMap<>();
            this.loadingChunks = new ConcurrentHashMap<>();
            this.initialChunkLoadQueue = new LinkedList<>();
            this.chunkLoadExecutor = Executors.newFixedThreadPool(2);
            if (!GameContext.get().isMultiplayer()) {
                loadChunksFromWorldData();
                if (worldData.getBlockData() != null) {
                    migrateBlocksToChunks();
                }
            }

            this.objectManager = new WorldObject.WorldObjectManager(worldSeed);
            this.pokemonSpawnManager = new PokemonSpawnManager(TextureManager.pokemonoverworld);
            this.weatherSystem = new WeatherSystem();
            this.weatherSystem.setWorld(this);
            this.weatherAudioSystem = new WeatherAudioSystem(AudioManager.getInstance());

            GameLogger.info("Multiplayer world initialization complete");

        } catch (Exception e) {
            GameLogger.error("Failed to initialize multiplayer world: " + e.getMessage());
            throw new RuntimeException("World initialization failed", e);
        }
        footstepEffectManager = new FootstepEffectManager();
        this.itemEntityManager = new ItemEntityManager();
        this.waterEffectManager = new WaterEffectManager();
        waterEffects = new WaterEffectsRenderer();
    }

    public World(String name, long seed) {
        try {
            GameLogger.info("Initializing singleplayer world: " + name);
            this.name = name;
            this.itemEntityManager = new ItemEntityManager();
            this.worldSeed = seed;

            this.worldData = new WorldData(name);
            WorldData.WorldConfig config = new WorldData.WorldConfig(seed);
            this.worldData.setConfig(config);
            // Initialize basic managers
            this.blockManager = new BlockManager();
            this.biomeRenderer = new BiomeRenderer();
            loadingFont = new BitmapFont();

            footstepEffectManager = new FootstepEffectManager();
            this.chunks = new ConcurrentHashMap<>();
            this.loadingChunks = new ConcurrentHashMap<>();

            WorldData existingData = JsonConfig.loadWorldData(name);
            if (existingData != null) {
                GameLogger.info("Found existing world data for: " + name);
                this.worldData = existingData;
                loadChunksFromWorldData();
                if (worldData != null && worldData.getBlockData() != null) {
                    migrateBlocksToChunks();
                }
            }

            this.weatherSystem = new WeatherSystem();
            this.weatherSystem.setWorld(this);
            this.weatherAudioSystem = new WeatherAudioSystem(AudioManager.getInstance());
            this.objectManager = new WorldObject.WorldObjectManager(worldSeed);
            this.pokemonSpawnManager = new PokemonSpawnManager(TextureManager.pokemonoverworld);

            footstepEffectManager = new FootstepEffectManager();
            // Generate initial chunks if needed
            if (chunks.isEmpty()) {
                initializeChunksAroundOrigin();
            }

        } catch (Exception e) {
            GameLogger.error("Failed to initialize singleplayer world: " + e.getMessage());
            throw new RuntimeException("World initialization failed", e);
        }
        this.waterEffectManager = new WaterEffectManager();

        waterEffects = new WaterEffectsRenderer();
    }


    private enum RenderableType {
        TREE_BASE(0),
        WORLD_OBJECT(1),
        PLAYER(2),
        OTHER_PLAYER(2),
        WILD_POKEMON(2),
        TALL_GRASS_TOP(3),
        TREE_TOP(4);

        final int layerIndex;

        RenderableType(int index) {
            this.layerIndex = index;
        }
    }

    private static class RenderableEntity implements Comparable<RenderableEntity> {
        final Object entity;
        final float y;
        final RenderableType type;

        RenderableEntity(Object entity, float y, RenderableType type) {
            this.entity = entity;
            this.y = y;
            this.type = type;
        }

        @Override
        public int compareTo(RenderableEntity other) {
            int yCompare = Float.compare(other.y, this.y);
            if (yCompare != 0) {
                return yCompare;
            }

            return Integer.compare(this.type.layerIndex, other.type.layerIndex);
        }
    }
    private void renderTallGrassLowerHalf(SpriteBatch batch, List<WorldObject> tallGrassObjects) {
        for (WorldObject obj : tallGrassObjects) {
            TextureRegion region = obj.getTexture();
            if (region == null) continue;
            int regionWidth = region.getRegionWidth();
            int regionHeight = region.getRegionHeight();
            // Source: bottom half of the texture
            int srcX = region.getRegionX();
            int srcY = region.getRegionY() + regionHeight / 2;
            int srcHeight = regionHeight / 2;
            // Destination: same width as a tile; lower half drawn at object's pixel position.
            float destX = obj.getPixelX();
            float destY = obj.getPixelY();
            batch.draw(region.getTexture(), destX, destY, World.TILE_SIZE, World.TILE_SIZE / 2f,
                srcX, srcY, regionWidth, srcHeight, false, false);
        }
    }

    private void renderTallGrassUpperHalf(SpriteBatch batch, List<WorldObject> tallGrassObjects) {
        for (WorldObject obj : tallGrassObjects) {
            TextureRegion region = obj.getTexture();
            if (region == null) continue;
            int regionWidth = region.getRegionWidth();
            int regionHeight = region.getRegionHeight();
            // Source: top half of the texture
            int srcX = region.getRegionX();
            int srcY = region.getRegionY();
            int srcHeight = regionHeight / 2;
            // Destination: draw the upper half offset upward by half a tile.
            float destX = obj.getPixelX();
            float destY = obj.getPixelY() + World.TILE_SIZE / 2f;
            batch.draw(region.getTexture(), destX, destY, World.TILE_SIZE, World.TILE_SIZE / 2f,
                srcX, srcY, regionWidth, srcHeight, false, false);
        }
    }
    /**
     * Returns true if the given tile coordinates are within the world border.
     * This implementation assumes that the world is centered at (0,0).
     */
    public boolean isWithinWorldBounds(int tileX, int tileY) {
        int halfTiles = (HALF_WORLD_SIZE) / TILE_SIZE;
        // Valid tiles are from -halfTiles (inclusive) to halfTiles (exclusive)
        return tileX >= -halfTiles && tileX < halfTiles && tileY >= -halfTiles && tileY < halfTiles;
    }

    public int getTileTypeAt(int tileX, int tileY) {
        int chunkX = Math.floorDiv(tileX, Chunk.CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, Chunk.CHUNK_SIZE);
        Vector2 chunkPos = new Vector2(chunkX, chunkY);
        Chunk chunk = chunks.get(chunkPos);
        if (chunk != null) {
            int localX = Math.floorMod(tileX, Chunk.CHUNK_SIZE);
            int localY = Math.floorMod(tileY, Chunk.CHUNK_SIZE);
            return chunk.getTileType(localX, localY);
        }
        return -1;
    }

    public FootstepEffectManager getFootstepEffectManager() {
        return footstepEffectManager;
    }

    public ItemEntityManager getItemEntityManager() {
        return itemEntityManager;
    }

    public Float getLightLevelAtTile(Vector2 tilePos) {
        return lightLevelMap.get(tilePos);
    }

    public Color getCurrentWorldColor() {
        return currentWorldColor;
    }

    private void loadChunksFromWorldData() {
        if (GameContext.get().getGameClient() != null && GameContext.get().isMultiplayer()) {
            GameLogger.info("Multiplayer mode: skipping local chunk loading.");
            return;
        }
        try {
            Map<Vector2, Chunk> worldChunks = worldData.getChunks();
            if (worldChunks != null) {
                chunks.clear();
                this.chunks.putAll(worldChunks);
                GameLogger.info("Loaded " + chunks.size() + " chunks from disk.");
            }

            Map<Vector2, List<WorldObject>> worldObjects = worldData.getChunkObjects();
            if (worldObjects != null) {
                int objectCount = 0;
                for (Map.Entry<Vector2, List<WorldObject>> entry : worldObjects.entrySet()) {
                    Vector2 chunkPos = entry.getKey();
                    List<WorldObject> objects = entry.getValue();
                    if (objects != null) {
                        objectManager.setObjectsForChunk(chunkPos, objects);
                        objectCount += objects.size();
                    }
                }
                GameLogger.info("Loaded " + objectCount + " world objects from disk.");
            }
        } catch (Exception e) {
            GameLogger.error("Failed to load world data: " + e.getMessage());
            throw new RuntimeException("World data loading failed", e);
        }
    }

    public WeatherSystem getWeatherSystem() {
        return weatherSystem;
    }

    private List<Vector2> generateSpiralChunkOrder(int centerX, int centerY, int radius) {
        List<Vector2> order = new ArrayList<>();
        int x = 0, y = 0, dx = 0, dy = -1;
        int maxSteps = (2 * radius + 1) * (2 * radius + 1);
        int steps = 0;

        while (steps < maxSteps) {
            if ((-radius <= x && x <= radius) && (-radius <= y && y <= radius)) {
                order.add(new Vector2(centerX + x, centerY + y));
                steps++;
            }

            if (x == y || (x < 0 && x == -y) || (x > 0 && x == 1 - y)) {
                int temp = dx;
                dx = -dy;
                dy = temp;
            }
            x += dx;
            y += dy;
        }

        return order;
    }

    public void savePlayerData(String username, PlayerData data) {
        if (worldData != null) {
            boolean isMultiplayer = false;
            if (GameContext.get().getGameClient() != null) {
                isMultiplayer = GameContext.get().isMultiplayer();
            }

            if (isMultiplayer) {
                UUID playerUUID = UUID.nameUUIDFromBytes(username.getBytes());
                GameContext.get().getGameClient().savePlayerData(playerUUID, data);
            } else {
                worldData.savePlayerData(username, data, false);
            }
        }
    }

    private boolean isMultiplayerOperation() {
        return GameContext.get().isMultiplayer();
    }

    public BiomeTransitionResult getBiomeTransitionAt(float worldX, float worldY) {
        int chunkX = Math.floorDiv((int) worldX, Chunk.CHUNK_SIZE * World.TILE_SIZE);
        int chunkY = Math.floorDiv((int) worldY, Chunk.CHUNK_SIZE * World.TILE_SIZE);
        Vector2 chunkPos = new Vector2(chunkX, chunkY);

        // First check if we have a stored transition for this chunk
        BiomeTransitionResult stored = biomeTransitions.get(chunkPos);
        if (stored != null) {
            return stored;
        }

        // If not found in stored transitions, use BiomeManager to calculate
        return GameContext.get().getBiomeManager().getBiomeAt(worldX, worldY);
    }

    // Fix in World.java - processChunkData method
    public void processChunkData(NetworkProtocol.ChunkData chunkData) {
        Vector2 chunkPos = new Vector2(chunkData.chunkX, chunkData.chunkY);
        try {
            // Step 1: Get or create biome based on data from server
            Biome primaryBiome = GameContext.get().getBiomeManager().getBiome(chunkData.primaryBiomeType);
            if (primaryBiome == null) {
                primaryBiome = GameContext.get().getBiomeManager().getBiome(BiomeType.PLAINS);
                GameLogger.error("Using fallback PLAINS biome for null type: " + chunkData.primaryBiomeType);
            }

            // Step 2: Create the chunk with proper biome and server seed
            Chunk chunk = new Chunk(chunkData.chunkX, chunkData.chunkY, primaryBiome, chunkData.generationSeed);

            // Step 3: Set the provided tile data with validation
            if (chunkData.tileData != null && chunkData.tileData.length == Chunk.CHUNK_SIZE) {
                // Validate and clone the tile data
                int[][] validatedTiles = new int[Chunk.CHUNK_SIZE][Chunk.CHUNK_SIZE];
                for (int x = 0; x < Chunk.CHUNK_SIZE; x++) {
                    if (chunkData.tileData[x] != null && chunkData.tileData[x].length == Chunk.CHUNK_SIZE) {
                        System.arraycopy(chunkData.tileData[x], 0, validatedTiles[x], 0, Chunk.CHUNK_SIZE);
                    } else {
                        // Fill invalid rows with default tiles based on biome
                        Arrays.fill(validatedTiles[x], getDefaultTileForBiome(primaryBiome));
                        GameLogger.error("Invalid tile data row at " + x + " for chunk " + chunkPos);
                    }
                }
                chunk.setTileData(validatedTiles);
            } else {
                GameLogger.error("Invalid tile data for chunk " + chunkPos + ", generating fallback tiles");
                // Generate fallback tile data
                generateFallbackTileData(chunk, primaryBiome);
            }

            // Step 4: Process blocks with error handling
            if (chunkData.blockData != null) {
                for (BlockSaveData.BlockData bd : chunkData.blockData) {
                    try {
                        processBlockData(chunk, bd);
                    } catch (Exception e) {
                        GameLogger.error("Failed to process block data in chunk " + chunkPos + ": " + e.getMessage());
                    }
                }
            }

            // Step 5: Process and place world objects with validation
            List<WorldObject> objects = new ArrayList<>();
            if (chunkData.worldObjects != null) {
                for (Map<String, Object> objData : chunkData.worldObjects) {
                    try {
                        if (objData != null) {
                            WorldObject obj = new WorldObject();
                            obj.updateFromData(objData);
                            obj.ensureTexture();
                            objects.add(obj);
                        }
                    } catch (Exception e) {
                        GameLogger.error("Failed to process world object in chunk " + chunkPos + ": " + e.getMessage());
                    }
                }
            }

            // Step 6: Register objects with world object manager
            getObjectManager().setObjectsForChunk(chunkPos, objects);

            // Step 7: Handle existing chunk if present
            Chunk existingChunk = chunks.get(chunkPos);
            if (existingChunk != null && existingChunk.isDirty()) {
                mergeChunkData(existingChunk, chunk);
            }

            // Store the new/merged chunk
            chunks.put(chunkPos, chunk);

            // Step 8: CRITICAL FIX - Create and store biome transition for consistent rendering
            BiomeTransitionResult transition = new BiomeTransitionResult(
                primaryBiome,
                chunkData.secondaryBiomeType != null ?
                    GameContext.get().getBiomeManager().getBiome(chunkData.secondaryBiomeType) : null,
                chunkData.secondaryBiomeType != null ?
                    MathUtils.clamp(chunkData.biomeTransitionFactor, 0f, 1f) : 1f
            );

            // Store biome transition in global map for consistent rendering
            storeBiomeTransition(chunkPos, transition);

            // Step 9: Apply auto-tiling for visual consistency
            try {
                new AutoTileSystem().applyShorelineAutotiling(chunk, 0, this);
            } catch (Exception e) {
                GameLogger.error("Failed to apply auto-tiling for chunk " + chunkPos + ": " + e.getMessage());
            }

            // Step 10: Mark chunk as clean
            chunk.setDirty(false);

            GameLogger.info("Successfully processed chunk " + chunkPos +
                " with biome " + primaryBiome.getType() +
                (transition.getSecondaryBiome() != null ?
                    " blended with " + transition.getSecondaryBiome().getType() +
                        " at " + transition.getTransitionFactor() : ""));

        } catch (Exception e) {
            GameLogger.error("Error processing chunk data for " + chunkPos + ": " + e.getMessage());
            e.printStackTrace();
        }
    }

    // Improve storeBiomeTransition method
    public void storeBiomeTransition(Vector2 chunkPos, BiomeTransitionResult transition) {
        if (chunkPos != null && transition != null && transition.getPrimaryBiome() != null) {
            biomeTransitions.put(chunkPos, transition);
            // Optional: Log storing
            // GameLogger.info("Stored biome transition for chunk " + chunkPos + ": " + transition.getPrimaryBiome().getType());
        } else {
            GameLogger.error("Attempted to store invalid biome transition for chunk: " + chunkPos);
        }
    }
    private int getDefaultTileForBiome(Biome biome) {
        if (biome == null) return TileType.GRASS;

        List<Integer> allowedTiles = biome.getAllowedTileTypes();
        if (allowedTiles != null && !allowedTiles.isEmpty()) {
            return allowedTiles.get(0);
        }

        // Fallbacks based on biome type
        switch (biome.getType()) {
            case SNOW: return TileType.SNOW;
            case DESERT: return TileType.DESERT_SAND;
            case BEACH: return TileType.BEACH_SAND;
            case FOREST: return TileType.FOREST_GRASS;
            case HAUNTED: return TileType.HAUNTED_GRASS;
            case RAIN_FOREST: return TileType.RAIN_FOREST_GRASS;
            case RUINS: return TileType.RUINS_GRASS;
            case OCEAN: return TileType.WATER;
            default: return TileType.GRASS;
        }
    }

    /**
     * Generates fallback tile data for a chunk when server data is invalid
     */
    private void generateFallbackTileData(Chunk chunk, Biome biome) {
        int defaultTile = getDefaultTileForBiome(biome);
        int[][] tiles = new int[Chunk.CHUNK_SIZE][Chunk.CHUNK_SIZE];

        for (int x = 0; x < Chunk.CHUNK_SIZE; x++) {
            for (int y = 0; y < Chunk.CHUNK_SIZE; y++) {
                tiles[x][y] = defaultTile;
            }
        }

        chunk.setTileData(tiles);
    }

    private void mergeChunkData(Chunk source, Chunk target) {
        if (source == null || target == null) {
            GameLogger.error("Cannot merge chunks: null chunk provided");
            return;
        }

        try {
            // Preserve the target's basic properties (from server)
            Vector2 chunkPos = new Vector2(target.getChunkX(), target.getChunkY());

            // 1. Tile data - Server is authoritative but handle missing/corrupted data
            if (source.getTileData() != null && target.getTileData() == null) {
                // If target has no tile data but source does, use source's data as fallback
                GameLogger.error("Target chunk missing tile data, using source data");
                target.setTileData(cloneTileData(source.getTileData()));
            }

            // 2. Preserve elevation bands from client - these are client-generated for mountains
            int[][] sourceBands = getElevationBands(source);
            if (sourceBands != null) {
                GameLogger.info("Preserved elevation bands for chunk " + chunkPos);
            }

            // 3. Auto-tile regions (texture mapping) - client-side rendering data
            if (source.getAutotileRegions() != null && target.getAutotileRegions() == null) {
                target.setAutotileRegions(source.getAutotileRegions());
            }

            // 4. Sea-tile regions (water animations) - client-side rendering data
            if (source.getSeatileRegions() != null && target.getSeatileRegions() == null) {
                target.setSeatileRegions(source.getSeatileRegions());
            }

            // 5. Handle blocks - merge any client blocks not in the server data
            mergeBlockData(source, target);

            // 6. Biome handling - server is authoritative, but handle edge cases
            if (target.getBiome() == null && source.getBiome() != null) {
                // If target has no biome (shouldn't happen), use source's as fallback
                target.setBiome(source.getBiome());
                GameLogger.error("Target chunk missing biome, using source biome: " + source.getBiome().getType());
            }

            // 7. Handle world objects - server is authoritative
            // We don't need to do anything here as the server's objects are already in the target

            // 8. Mark as dirty to ensure proper rendering
            target.setDirty(true);

            GameLogger.info("Successfully merged chunk data for " + chunkPos);
        } catch (Exception e) {
            GameLogger.error("Error merging chunk data: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Retrieves elevation bands from a chunk, handling potential reflection if not directly accessible
     */
    private int[][] getElevationBands(Chunk chunk) {
        // First attempt direct access if there's a getter
        try {
            // This is the preferred approach if you've added a getter method to Chunk
            // return chunk.getElevationBands();

            // If there's no getter, we'll use reflection as a fallback
            Field elevationField = Chunk.class.getDeclaredField("elevationBands");
            elevationField.setAccessible(true);
            return (int[][]) elevationField.get(chunk);
        } catch (Exception e) {
            // Elevation bands might not exist or be accessible
            return null;
        }
    }

    /**
     * Creates a deep copy of tile data to prevent cross-reference issues
     */
    private int[][] cloneTileData(int[][] source) {
        if (source == null) return null;

        int[][] clone = new int[source.length][];
        for (int i = 0; i < source.length; i++) {
            if (source[i] != null) {
                clone[i] = source[i].clone();
            }
        }
        return clone;
    }

    /**
     * Creates a deep copy of elevation bands
     */
    private int[][] cloneElevationBands(int[][] source) {
        return cloneTileData(source); // Reuse the same cloning logic
    }

    /**
     * Merges block data between chunks, preserving client-side blocks that aren't in server data
     */
    private void mergeBlockData(Chunk source, Chunk target) {
        Map<Vector2, PlaceableBlock> sourceBlocks = source.getBlocks();
        Map<Vector2, PlaceableBlock> targetBlocks = target.getBlocks();

        if (sourceBlocks == null || sourceBlocks.isEmpty()) {
            return; // No source blocks to merge
        }

        if (targetBlocks == null) {
            // Create blocks map if needed
            targetBlocks = new HashMap<>();
            target.setBlocks(targetBlocks);
        }

        // For each source block, check if it exists in target
        for (Map.Entry<Vector2, PlaceableBlock> entry : sourceBlocks.entrySet()) {
            Vector2 blockPos = entry.getKey();
            PlaceableBlock sourceBlock = entry.getValue();

            // Only preserve blocks that aren't in the target (server data is authoritative)
            if (!targetBlocks.containsKey(blockPos)) {
                // Clone the block to avoid sharing references
                PlaceableBlock clonedBlock = cloneBlock(sourceBlock);
                if (clonedBlock != null) {
                    targetBlocks.put(blockPos, clonedBlock);
                }
            } else {
                // Block exists in both - merge any client-specific data like chest contents
                PlaceableBlock targetBlock = targetBlocks.get(blockPos);
                mergeBlockProperties(sourceBlock, targetBlock);
            }
        }
    }

    /**
     * Creates a clone of a PlaceableBlock with all its properties
     */
    private PlaceableBlock cloneBlock(PlaceableBlock source) {
        if (source == null) return null;

        try {
            // Create a new block of the same type and position
            PlaceableBlock clone = new PlaceableBlock(
                source.getType(),
                new Vector2(source.getPosition()),
                source.getTexture(),
                source.isFlipped()
            );

            // Copy chest data if it exists
            if (source.getType() == PlaceableBlock.BlockType.CHEST && source.getChestData() != null) {
                clone.setChestData(source.getChestData().copy());
                clone.setChestOpen(source.isChestOpen());
            }

            return clone;
        } catch (Exception e) {
            GameLogger.error("Failed to clone block: " + e.getMessage());
            return null;
        }
    }

    /**
     * Merges properties from a source block to a target block
     */
    private void mergeBlockProperties(PlaceableBlock source, PlaceableBlock target) {
        if (source == null || target == null || source.getType() != target.getType()) {
            return;
        }

        // For chest blocks, we want to merge chest contents if appropriate
        if (source.getType() == PlaceableBlock.BlockType.CHEST) {
            // Preserve chest state and data if target doesn't have it
            if (target.getChestData() == null && source.getChestData() != null) {
                target.setChestData(source.getChestData().copy());
                target.setChestOpen(source.isChestOpen());
            }
        }

        // Set the texture if needed
        if (target.getTexture() == null && source.getTexture() != null) {
            target.setTexture(source.getTexture());
        }
    }

    private void processBlockData(Chunk chunk, BlockSaveData.BlockData bd) {
        PlaceableBlock.BlockType blockType = PlaceableBlock.BlockType.fromId(bd.type);
        if (blockType != null) {
            Vector2 pos = new Vector2(bd.x, bd.y);
            PlaceableBlock block = new PlaceableBlock(blockType, pos, null, bd.isFlipped);
            if (blockType == PlaceableBlock.BlockType.CHEST && bd.chestData != null) {
                block.setChestData(bd.chestData.copy());
            }


            chunk.addBlock(block);
        }
    }


    public boolean areAllChunksLoaded() {
        // Get the player's current chunk coordinates:
        int playerTileX = GameContext.get().getPlayer().getTileX();
        int playerTileY = GameContext.get().getPlayer().getTileY();
        int playerChunkX = Math.floorDiv(playerTileX, Chunk.CHUNK_SIZE);
        int playerChunkY = Math.floorDiv(playerTileY, Chunk.CHUNK_SIZE);

        int totalChunks = (INITIAL_LOAD_RADIUS * 2 + 1) * (INITIAL_LOAD_RADIUS * 2 + 1);
        int loadedChunks = 0;

        // Check chunks relative to the player's chunk coordinate.
        for (int dx = -INITIAL_LOAD_RADIUS; dx <= INITIAL_LOAD_RADIUS; dx++) {
            for (int dy = -INITIAL_LOAD_RADIUS; dy <= INITIAL_LOAD_RADIUS; dy++) {
                Vector2 expectedKey = new Vector2(playerChunkX + dx, playerChunkY + dy);
                if (chunks.containsKey(expectedKey)) {
                    loadedChunks++;
                }
            }
        }

        return loadedChunks == totalChunks;
    }

    public void clearChunks() {
        if (chunks != null) {
            chunks.clear();
            // Reset the flag so that new initial chunk requests will occur
            initialChunksRequested = false;
            GameLogger.info("Cleared all loaded chunks and reset initialChunksRequested flag.");
        }
    }
    public void loadChunksAroundPlayer() {
        Player player = GameContext.get().getPlayer();
        if (player == null) return;

        int playerTileX = player.getTileX();
        int playerTileY = player.getTileY();
        int playerChunkX = Math.floorDiv(playerTileX, CHUNK_SIZE);
        int playerChunkY = Math.floorDiv(playerTileY, CHUNK_SIZE);

        // Log the player's position for debugging
        GameLogger.info("Loading chunks around player at tile (" + playerTileX + "," + playerTileY +
            "), chunk (" + playerChunkX + "," + playerChunkY + ")");

        // Generate loading order using optimized spiral pattern
        List<Vector2> spiralOrder = generateOptimizedSpiralOrder(playerChunkX, playerChunkY, INITIAL_LOAD_RADIUS);

        // First ensure the player's current chunk is loaded first
        Vector2 currentChunk = new Vector2(playerChunkX, playerChunkY);
        if (!chunks.containsKey(currentChunk)) {
            if (GameContext.get().isMultiplayer()) {
                GameLogger.info("Requesting player's current chunk at: " + currentChunk + " (PRIORITY)");
                GameContext.get().getGameClient().requestChunk(currentChunk);

                // Give a small delay to prioritize the current chunk request
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            } else {
                loadChunkAsync(currentChunk);
            }
        }

        // Then start loading the rest in spiral order
        int requestCount = 0;
        for (Vector2 chunkKey : spiralOrder) {
            if (!chunks.containsKey(chunkKey)) {
                if (GameContext.get().isMultiplayer()) {
                    GameLogger.info("Requesting chunk at: " + chunkKey);
                    GameContext.get().getGameClient().requestChunk(chunkKey);

                    // Limit request rate to prevent network flooding
                    requestCount++;
                    if (requestCount % 3 == 0) {
                        try {
                            Thread.sleep(30);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                } else {
                    loadChunkAsync(chunkKey);
                }
            }
        }
    }

    /**
     * Generates an optimized spiral loading order that prioritizes the closest chunks
     * but still follows a spiral pattern for aesthetic loading
     */
    private List<Vector2> generateOptimizedSpiralOrder(int centerX, int centerY, int radius) {
        List<Vector2> order = new ArrayList<>();

        // Start at center and spiral outward
        int x = 0, y = 0, dx = 0, dy = -1;
        int maxSteps = (2 * radius + 1) * (2 * radius + 1);
        int steps = 0;

        while (steps < maxSteps) {
            if ((-radius <= x && x <= radius) && (-radius <= y && y <= radius)) {
                order.add(new Vector2(centerX + x, centerY + y));
                steps++;
            }

            // Classic spiral algorithm
            if (x == y || (x < 0 && x == -y) || (x > 0 && x == 1 - y)) {
                int temp = dx;
                dx = -dy;
                dy = temp;
            }
            x += dx;
            y += dy;
        }

        // Remove the center point as we'll load it separately
        order.removeIf(v -> v.x == centerX && v.y == centerY);

        // Sort by Manhattan distance from center for better loading priority
        order.sort((a, b) -> {
            float distA = Math.abs(a.x - centerX) + Math.abs(a.y - centerY);
            float distB = Math.abs(b.x - centerX) + Math.abs(b.y - centerY);
            return Float.compare(distA, distB);
        });

        return order;
    }

    /**
     * Forces loading of missing chunks in the area around the player
     * with intelligent prioritization and error recovery
     */
    public void forceLoadMissingChunks() {
        GameLogger.info("Forcing load of any missing chunks...");
        Player player = GameContext.get().getPlayer();
        if (player == null) return;

        int playerChunkX = Math.floorDiv(player.getTileX(), Chunk.CHUNK_SIZE);
        int playerChunkY = Math.floorDiv(player.getTileY(), Chunk.CHUNK_SIZE);
        Vector2 playerChunkPos = new Vector2(playerChunkX, playerChunkY);

        // Collect all chunks that need loading
        List<Vector2> missingChunks = new ArrayList<>();
        for (int dx = -INITIAL_LOAD_RADIUS; dx <= INITIAL_LOAD_RADIUS; dx++) {
            for (int dy = -INITIAL_LOAD_RADIUS; dy <= INITIAL_LOAD_RADIUS; dy++) {
                Vector2 chunkPos = new Vector2(playerChunkX + dx, playerChunkY + dy);
                if (!chunks.containsKey(chunkPos)) {
                    missingChunks.add(chunkPos);
                }
            }
        }

        // Sort by distance to player for priority loading
        missingChunks.sort((a, b) -> {
            float distA = Vector2.dst(a.x, a.y, playerChunkPos.x, playerChunkPos.y);
            float distB = Vector2.dst(b.x, b.y, playerChunkPos.x, playerChunkPos.y);
            return Float.compare(distA, distB);
        });

        // First make sure the player's immediate chunk is loaded
        if (!chunks.containsKey(playerChunkPos)) {
            Chunk playerChunk = loadOrGenerateChunk(playerChunkPos);
            if (playerChunk != null) {
                chunks.put(playerChunkPos, playerChunk);
                GameLogger.info("Force-loaded player's current chunk " + playerChunkPos);
            }
        }

        // Then load a limited number of missing chunks per frame
        final int MAX_CHUNKS_PER_SYNC = 4;
        int loadedThisFrame = 0;
        Iterator<Vector2> iter = missingChunks.iterator();

        while (iter.hasNext() && loadedThisFrame < MAX_CHUNKS_PER_SYNC) {
            Vector2 chunkPos = iter.next();
            // Skip player's chunk as we already handled it
            if (chunkPos.equals(playerChunkPos)) continue;

            try {
                Chunk chunk;
                if (GameContext.get().isMultiplayer()) {
                    // In multiplayer, we request from server and continue
                    GameContext.get().getGameClient().requestChunk(chunkPos);
                    GameLogger.info("Requested missing chunk " + chunkPos + " from server");
                } else {
                    // In singleplayer, we load/generate synchronously
                    chunk = loadOrGenerateChunk(chunkPos);
                    if (chunk != null) {
                        chunks.put(chunkPos, chunk);
                        loadedThisFrame++;
                        GameLogger.info("Force-loaded chunk " + chunkPos);
                    }
                }
            } catch (Exception e) {
                GameLogger.error("Failed to force-load chunk " + chunkPos + ": " + e.getMessage());
            }
        }
    }



    public WildPokemon getNearestInteractablePokemon(Player player) {
        // Convert player position to pixels
        float playerPixelX = player.getTileX() * TILE_SIZE + (Player.FRAME_WIDTH / 2f);
        float playerPixelY = player.getTileY() * TILE_SIZE + (Player.FRAME_HEIGHT / 2f);

        float checkX = playerPixelX;
        float checkY = playerPixelY;
        float interactionDistance = TILE_SIZE * 1.5f;

        // Adjust check position based on facing direction
        switch (player.getDirection()) {
            case "up":
                checkY += interactionDistance;
                break;
            case "down":
                checkY -= interactionDistance;
                break;
            case "left":
                checkX -= interactionDistance;
                break;
            case "right":
                checkX += interactionDistance;
                break;
        }

        WildPokemon nearest = null;
        float shortestDistance = interactionDistance;

        Collection<WildPokemon> nearbyPokemon = pokemonSpawnManager.getPokemonInRange(checkX, checkY, interactionDistance);

        for (WildPokemon pokemon : nearbyPokemon) {
            float distance = Vector2.dst(checkX, checkY, pokemon.getX(), pokemon.getY());

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearest = pokemon;
            }
        }

        return nearest;
    }

    public BlockManager getBlockManager() {

        return blockManager;
    }


    public void save() {
        if (isMultiplayerOperation()) {
            return;
        }

            try {
                GameLogger.info("Saving world data for '" + name + "'...");

                // Update and save player data into the world data object
                if (GameContext.get().getPlayer() != null) {
                    PlayerData currentState = new PlayerData(GameContext.get().getPlayer().getUsername());
                    currentState.updateFromPlayer(GameContext.get().getPlayer());
                    worldData.savePlayerData(GameContext.get().getPlayer().getUsername(), currentState, false);
                }

                // Save all dirty chunks
                for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
                    if (entry.getValue().isDirty()) {
                        saveChunkData(entry.getKey(), entry.getValue());
                        entry.getValue().setDirty(false); // Mark as clean after saving
                    }
                }

                // Update last played time and save the main world file
                worldData.setLastPlayed(System.currentTimeMillis());
                worldData.setDirty(true);
                WorldManager.getInstance().saveWorld(worldData);

                GameLogger.info("Successfully saved world: " + name);

            } catch (Exception e) {
                GameLogger.error("Failed to save world '" + name + "': " + e.getMessage());
                e.printStackTrace();
            }
    }


    public void dispose() {
        try {
            GameLogger.info("Disposing world: " + name);

            // Final save
            save();

            // Clear collections
            chunks.clear();
            biomeTransitions.clear();
            loadingChunks.clear();
            lastChunkAccess.clear();
            dirtyChunks.clear();
            if (waterEffects != null) {
                waterEffects.dispose();
            }
            // Dispose executors
            if (chunkLoadExecutor != null) {
                chunkLoadExecutor.shutdown();
                try {
                    if (!chunkLoadExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                        chunkLoadExecutor.shutdownNow();
                    }
                } catch (InterruptedException e) {
                    chunkLoadExecutor.shutdownNow();
                }
            }

            isDisposed = true;
        } catch (Exception e) {
            GameLogger.error("Error disposing world: " + e.getMessage());
        }
    }

    public long getLastPlayed() {
        return lastPlayed;
    }

    public void setLastPlayed(long lastPlayed) {
        this.lastPlayed = lastPlayed;
    }

    public Player getPlayer() {
        return GameContext.get().getPlayer();
    }

    public void setPlayer(Player player) {
        GameContext.get().setPlayer(player);
        // Initialize player data
        if (player != null) {
            this.currentPlayerData = new PlayerData(player.getUsername());
            this.currentPlayerData.updateFromPlayer(player);
        }
    }

    /**
     * Unloads any chunks that are far away and old, or if we exceed budget.
     */
    private void unloadDistantChunks(int playerChunkX, int playerChunkY) {
        if (chunks.isEmpty()) return;

        long now = System.currentTimeMillis();

        // 1) Build a list of all loaded chunks along with how far and how "old" they are.
        List<Vector2> candidates = new ArrayList<>(chunks.keySet());

        // We’ll sort by distance first:
        candidates.sort(Comparator.comparingDouble(cp -> Vector2.dst2(cp.x, cp.y, playerChunkX, playerChunkY)));

        // 2) We'll keep track of chunks that are beyond maxRadius
        //    AND haven't been accessed in UNLOAD_IDLE_THRESHOLD_MS.
        List<Vector2> toUnload = new ArrayList<>();

        int maxRadius = MAX_CHUNK_LOAD_RADIUS;

        for (Vector2 chunkPos : candidates) {
            float dist2 = Vector2.dst2(chunkPos.x, chunkPos.y, playerChunkX, playerChunkY);
            Long lastAccessTime = lastChunkAccess.getOrDefault(chunkPos, 0L);
            long idleTime = now - lastAccessTime;

            boolean beyondDistance = dist2 > (maxRadius * maxRadius);
            boolean oldEnough = (idleTime >= UNLOAD_IDLE_THRESHOLD_MS);

            // If chunk is both far AND old, we can unload it
            if (beyondDistance && oldEnough) {
                toUnload.add(chunkPos);
            }
        }

        // 3) If we’re still above the chunk budget, we also pick extra chunks to unload
        //    based on who’s oldest lastAccess, even if they’re within radius.
        int currentCount = chunks.size();
        if (currentCount > MAX_LOADED_CHUNKS) {
            // Sort everything by last‐access time, oldest first:
            candidates.sort((a, b) -> {
                long aTime = lastChunkAccess.getOrDefault(a, 0L);
                long bTime = lastChunkAccess.getOrDefault(b, 0L);
                return Long.compare(aTime, bTime);
            });

            // Then keep removing oldest chunks until we’re under budget
            // — but skip any chunk that is REALLY close to the player.
            for (Vector2 chunkPos : candidates) {
                if (currentCount <= MAX_LOADED_CHUNKS) break;

                // Don’t remove if it’s inside MAX_CHUNK_LOAD_RADIUS
                float dist2 = Vector2.dst2(chunkPos.x, chunkPos.y, playerChunkX, playerChunkY);
                if (dist2 <= (maxRadius * maxRadius)) {
                    continue;
                }
                // We’ve already included far + old chunks in 'toUnload'
                // so only forcibly remove if we still need to free memory.
                if (!toUnload.contains(chunkPos)) {
                    toUnload.add(chunkPos);
                    currentCount--;
                }
            }
        }

        // 4) Actually unload (and save if singleplayer).
        for (Vector2 chunkPos : toUnload) {
            Chunk chunk = chunks.get(chunkPos);
            if (chunk != null) {
                // Singleplayer: save if dirty
                if (!GameContext.get().isMultiplayer() && chunk.isDirty()) {
                    saveChunkData(chunkPos, chunk);
                }
            }
            chunks.remove(chunkPos);
            biomeTransitions.remove(chunkPos);
            loadingChunks.remove(chunkPos);
            lastChunkAccess.remove(chunkPos);
        }

        if (!toUnload.isEmpty()) {
            GameLogger.info("Unloaded " + toUnload.size() + " distant/old chunks. " + "Remaining loaded: " + chunks.size());
        }
    }

    public void saveChunkData(Vector2 chunkPos, Chunk chunk) {
        if (GameContext.get().getGameClient() != null && GameContext.get().isMultiplayer()) {
            // Skip saving in multiplayer.
            return;
        }

        try {
            ChunkData data = new ChunkData();
            data.x = (int) chunkPos.x;
            data.y = (int) chunkPos.y;
            data.biomeType = chunk.getBiome().getType();
            data.tileData = chunk.getTileData();
            data.blocks = chunk.getBlockDataForSave();
            List<WorldObject> objects = objectManager.getObjectsForChunk(chunkPos);
            data.objects = objects.stream().map(WorldObjectData::new).collect(Collectors.toList());

            Json json = new Json();
            json.setOutputType(JsonWriter.OutputType.json);
            registerCustomSerializers(json);

            String baseDir = "worlds/singleplayer/" + name + "/chunks/";
            String filename = String.format("chunk_%d_%d.json", (int) chunkPos.x, (int) chunkPos.y);
            FileHandle chunkFile = Gdx.files.local(baseDir + filename);

            chunkFile.parent().mkdirs();

            // Write json
            String jsonString = json.prettyPrint(data);
            chunkFile.writeString(jsonString, false);

            // Update in-memory data
            chunks.put(chunkPos, chunk);
            worldData.getChunks().put(chunkPos, chunk);
            worldData.addChunkObjects(chunkPos, objects);
            worldData.setDirty(true);

        } catch (Exception e) {
            GameLogger.error("Failed to save chunk at " + chunkPos + ": " + e.getMessage());
            e.printStackTrace();
        }
    }

    private Chunk loadChunkData(Vector2 chunkPos) {
        if (GameContext.get().isMultiplayer()) {
            return null;
        }
        try {
            String baseDir = "worlds/singleplayer/" + name + "/chunks/";

            String filename = String.format("chunk_%d_%d.json", (int) chunkPos.x, (int) chunkPos.y);
            FileHandle chunkFile = Gdx.files.local(baseDir + filename);

            if (!chunkFile.exists()) {
                return null;
            }

            // Load and parse raw JSON
            String jsonContent = chunkFile.readString();
            Json json = new Json();
            registerCustomSerializers(json);

            // Read the ChunkData object
            ChunkData chunkData = json.fromJson(ChunkData.class, jsonContent);

            // Create chunk with original biome
            BiomeType biomeType = chunkData.biomeType;
            Biome biome = GameContext.get().getBiomeManager().getBiome(biomeType);
            Chunk chunk = new Chunk((int) chunkPos.x, (int) chunkPos.y, biome, worldSeed);

            // Load tile data
            chunk.setTileData(chunkData.tileData);

            // Load blocks
            if (chunkData.blocks != null) {

                for (BlockSaveData.BlockData blockDataItem : chunkData.blocks) {
                    try {
                        PlaceableBlock.BlockType blockType = PlaceableBlock.BlockType.fromId(blockDataItem.type);
                        if (blockType == null) {
                            GameLogger.error("Unknown block type: " + blockDataItem.type);
                            continue;
                        }

                        int x = blockDataItem.x;
                        int y = blockDataItem.y;
                        Vector2 pos = new Vector2(x, y);

                        // Create the PlaceableBlock instance without texture
                        PlaceableBlock block = new PlaceableBlock(blockType, pos, null, blockDataItem.isFlipped);

                        // Set isChestOpen for chests
                        if (blockType == PlaceableBlock.BlockType.CHEST) {
                            block.setChestOpen(blockDataItem.isChestOpen);

                            // Handle chest data
                            if (blockDataItem.chestData != null) {
                                block.setChestData(blockDataItem.chestData);
                                GameLogger.info("Loaded chest at " + pos + " with " + blockDataItem.chestData.items.stream().filter(Objects::nonNull).count() + " items");
                            }
                        }

                        // In loadChunkData or processChunkData when setting the block texture:
                        TextureRegion baseRegion = BlockTextureManager.getBlockFrame(block, 0);
                        if (baseRegion != null) {
                            // Create a new TextureRegion to avoid flipping the shared atlas region
                            TextureRegion texture = new TextureRegion(baseRegion);
                            // Don't call texture.flip(). We'll rely solely on PlaceableBlock.render() for flipping visuals.
                            block.setTexture(texture);
                        } else {
                            GameLogger.error("No texture found for block type: " + block.getId());
                        }
                        chunk.addBlock(block);


                    } catch (Exception e) {
                        GameLogger.error("Failed to load block: " + e.getMessage());
                    }
                }
            }
            if (chunkData.objects != null) {
                List<WorldObject> objects = new ArrayList<>();
                for (WorldObjectData objData : chunkData.objects) {
                    try {
                        WorldObject.ObjectType type = objData.type;
                        float x = objData.x;
                        float y = objData.y;
                        WorldObject obj = objectManager.createObject(type, x, y);
                        if (obj != null) {
                            objects.add(obj);
                        }
                    } catch (Exception e) {
                        GameLogger.error("Failed to load object: " + e.getMessage());
                    }
                }
                objectManager.setObjectsForChunk(chunkPos, objects);
            }

            return chunk;

        } catch (Exception e) {
            GameLogger.error("Error loading chunk at " + chunkPos + ": " + e.getMessage());
            return null;
        }
    }

    private void registerCustomSerializers(Json json) {
        // Serializer for UUID
        json.setSerializer(UUID.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, UUID object, Class knownType) {
                json.writeValue(object.toString());
            }

            @Override
            public UUID read(Json json, JsonValue jsonData, Class type) {
                return UUID.fromString(jsonData.asString());
            }
        });

        json.setSerializer(Vector2.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, Vector2 object, Class knownType) {
                json.writeObjectStart();
                json.writeValue("x", object.x);
                json.writeValue("y", object.y);
                json.writeObjectEnd();
            }

            @Override
            public Vector2 read(Json json, JsonValue jsonData, Class type) {
                float x = jsonData.getFloat("x");
                float y = jsonData.getFloat("y");
                return new Vector2(x, y);
            }
        });


        json.setSerializer(ItemData.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, ItemData object, Class knownType) {
                json.writeObjectStart();
                json.writeValue("itemId", object.getItemId());
                json.writeValue("count", object.getCount());
                json.writeValue("uuid", object.getUuid().toString());
                json.writeValue("durability", object.getDurability());
                json.writeValue("maxDurability", object.getMaxDurability());
                json.writeObjectEnd();
            }

            @Override
            public ItemData read(Json json, JsonValue jsonData, Class type) {
                ItemData item = new ItemData();
                // Handle both "itemId" and "id" fields for backward compatibility
                if (jsonData.has("itemId")) {
                    item.setItemId(jsonData.getString("itemId"));
                } else if (jsonData.has("id")) {
                    // Backward compatibility with old data
                    item.setItemId(jsonData.getString("id"));
                } else {
                    // Handle missing itemId/id
                    GameLogger.error("ItemData missing 'itemId' or 'id' field during deserialization. Skipping item.");
                    return null; // Skip this item or set a default value
                }
                item.setCount(jsonData.getInt("count", 1));
                String uuidStr = jsonData.getString("uuid", null);
                if (uuidStr != null) {
                    item.setUuid(UUID.fromString(uuidStr));
                } else {
                    item.setUuid(UUID.randomUUID());
                }
                item.setDurability(jsonData.getInt("durability", -1));
                item.setMaxDurability(jsonData.getInt("maxDurability", -1));
                return item;
            }
        });
        json.setSerializer(ChunkData.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, ChunkData object, Class knownType) {
                object.write(json);
            }

            @Override
            public ChunkData read(Json json, JsonValue jsonData, Class type) {
                ChunkData data = new ChunkData();
                data.read(jsonData, json);
                return data;
            }
        });

    }

    public Map<Vector2, Chunk> getChunks() {
        return chunks;
    }

    public void updatePlayerData() {
        if (GameContext.get().getPlayer() != null && currentPlayerData != null) {
            currentPlayerData.updateFromPlayer(GameContext.get().getPlayer());
        }
    }

    public PlayerData getPlayerData() {
        updatePlayerData();
        return currentPlayerData;
    }

    public String getName() {
        return name;
    }

    public WorldData getWorldData() {
        return worldData;
    }

    public void setWorldData(WorldData data) {
        if (data == null) {
            throw new IllegalArgumentException("WorldData cannot be null");
        }
        this.worldData = data;
        this.name = data.getName();
        this.worldSeed = data.getConfig().getSeed();
        GameContext.get().setBiomeManager(new BiomeManager(this.worldSeed));

        // Clear existing chunks and objects
        this.chunks.clear();
        if (GameContext.get().getGameClient() == null || !GameContext.get().isMultiplayer()) {
            loadChunksFromWorldData();
            if (worldData.getBlockData() != null) {
                migrateBlocksToChunks();
            }
        }

        GameLogger.info("Set WorldData for world: " + name + " Time: " + data.getWorldTimeInMinutes() + " Played: " + data.getPlayedTime());
    }

    public BiomeManager getBiomeManager() {
        return GameContext.get().getBiomeManager();
    }


    public Biome getBiomeAt(int tileX, int tileY) {
        int chunkX = Math.floorDiv(tileX, CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, CHUNK_SIZE);
        Vector2 chunkPos = new Vector2(chunkX, chunkY);

        // 1. Check stored transitions first (most authoritative for MP)
        BiomeTransitionResult storedTransition = biomeTransitions.get(chunkPos);
        if (storedTransition != null && storedTransition.getPrimaryBiome() != null) {
            return storedTransition.getPrimaryBiome();
        }

        // 2. Check the chunk's assigned biome (useful for SP or if transition data missing)
        Chunk chunk = chunks.get(chunkPos);
        if (chunk != null && chunk.getBiome() != null) {
            // Optional: Store this as a transition if not already stored
            if (!biomeTransitions.containsKey(chunkPos)) {
                storeBiomeTransition(chunkPos, new BiomeTransitionResult(chunk.getBiome(), null, 1f));
            }
            return chunk.getBiome();
        }

        // 3. Fallback to BiomeManager calculation (less reliable for MP consistency)
        // GameLogger.info("Falling back to BiomeManager for biome at tile: " + tileX + "," + tileY); // Add logging
        BiomeManager bm = GameContext.get().getBiomeManager();
        if (bm != null) {
            BiomeTransitionResult calculatedResult = bm.getBiomeAtTile(tileX, tileY); // Use tile-based query
            if (calculatedResult != null && calculatedResult.getPrimaryBiome() != null) {
                // Store the calculated result for future queries on this chunk
                storeBiomeTransition(chunkPos, calculatedResult);
                return calculatedResult.getPrimaryBiome();
            }
        }

        // 4. Absolute fallback
        // GameLogger.error("Absolute fallback to PLAINS biome for tile: " + tileX + "," + tileY); // Add logging
        return GameContext.get().getBiomeManager() != null
            ? GameContext.get().getBiomeManager().getBiome(BiomeType.PLAINS)
            : null; // Or handle null case appropriately
    }



    private void initializeChunksAroundOrigin() {
        validateChunkState();
        GameLogger.info("Starting chunk initialization around player");
        Player player = GameContext.get().getPlayer();
        if (player == null) return;
        int playerChunkX = Math.floorDiv(player.getTileX(), Chunk.CHUNK_SIZE);
        int playerChunkY = Math.floorDiv(player.getTileY(), Chunk.CHUNK_SIZE);
        for (int radius = 0; radius <= INITIAL_LOAD_RADIUS; radius++) {
            for (int dx = -radius; dx <= radius; dx++) {
                for (int dy = -radius; dy <= radius; dy++) {
                    if (Math.max(Math.abs(dx), Math.abs(dy)) == radius) {
                        Vector2 chunkPos = new Vector2(playerChunkX + dx, playerChunkY + dy);
                        if (GameContext.get().isMultiplayer()) {
                            GameContext.get().getGameClient().requestChunk(chunkPos);
                        } else {
                            loadChunkAsync(chunkPos);
                        }

                    }
                }
            }
        }
    }

    public Chunk loadOrGenerateChunk(Vector2 chunkPos) {
        // If we're in multiplayer, try to get the chunk from the server.
        // But if after a timeout no chunk is available in our local chunks map,
        // generate it locally as a fallback.
        if (GameContext.get().isMultiplayer()) {
            // First, check if a chunk was already received from the server.
            if (chunks.containsKey(chunkPos)) {
                return chunks.get(chunkPos);
            }
            // If not, check if enough time has passed since the initial chunk request.
            // (initialChunkRequestTime is recorded when requestInitialChunks() is called.)
            if (System.currentTimeMillis() - initialChunkRequestTime > 5000) {
                GameLogger.info("Fallback: generating chunk locally for " + chunkPos + " in multiplayer mode.");
                Chunk generated = UnifiedWorldGenerator.generateChunk(
                    (int) chunkPos.x,
                    (int) chunkPos.y,
                    this.worldSeed,
                    GameContext.get().getBiomeManager()
                );
                getObjectManager().setObjectsForChunk(chunkPos, generated.getWorldObjects());
                // Save the chunk locally so that future loads will get it.
                saveChunkData(chunkPos, generated);
                // Also add it to our local chunks map
                chunks.put(chunkPos, generated);
                return generated;
            }
            // Otherwise, request the chunk from the server and return null for now.
            GameContext.get().getGameClient().requestChunk(chunkPos);
            return null;
        }

        // Singleplayer: try to load from disk first...
        Chunk loaded = loadChunkData(chunkPos);
        if (isChunkValid(loaded)) {
            return loaded;
        }
        // ...and if that fails, generate it.
        Chunk generated = UnifiedWorldGenerator.generateChunk(
            (int) chunkPos.x,
            (int) chunkPos.y,
            this.worldSeed,
            GameContext.get().getBiomeManager()
        );
        getObjectManager().setObjectsForChunk(chunkPos, generated.getWorldObjects());
        saveChunkData(chunkPos, generated);
        return generated;
    }

    public void requestInitialChunks() {
        if (GameContext.get().isMultiplayer()) {
            if (initialChunksRequested) {
                return;
            }
            initialChunksRequested = true;
        }
        // Record the time at which we began requesting initial chunks.
        initialChunkRequestTime = System.currentTimeMillis();

        int playerTileX = GameContext.get().getPlayer().getTileX();
        int playerTileY = GameContext.get().getPlayer().getTileY();
        int playerChunkX = Math.floorDiv(playerTileX, CHUNK_SIZE);
        int playerChunkY = Math.floorDiv(playerTileY, CHUNK_SIZE);
        List<Vector2> chunkOrder = generateSpiralChunkOrder(playerChunkX, playerChunkY, INITIAL_LOAD_RADIUS);
        for (Vector2 chunkPos : chunkOrder) {
            if (!chunks.containsKey(chunkPos)) {
                if (GameContext.get().getGameClient() != null && GameContext.get().isMultiplayer()) {
                    GameContext.get().getGameClient().requestChunk(chunkPos);
                } else {
                    loadChunkAsync(chunkPos);
                }
            }
        }
    }


    private void updateWorldColor() {
        float hourOfDay = DayNightCycle.getHourOfDay(worldData.getWorldTimeInMinutes());
        Color targetColor = DayNightCycle.getWorldColor(hourOfDay);

        if (currentWorldColor == null) {
            currentWorldColor = new Color(targetColor);
        }
        if (previousWorldColor == null) {
            previousWorldColor = new Color(targetColor);
            colorTransitionProgress = 1.0f;
        }


        if (!targetColor.equals(currentWorldColor) && colorTransitionProgress >= 1.0f) {
            previousWorldColor.set(currentWorldColor);
            colorTransitionProgress = 0.0f;
        }

        // Update transition
        if (colorTransitionProgress < 1.0f) {
            colorTransitionProgress = Math.min(1.0f, colorTransitionProgress + Gdx.graphics.getDeltaTime() * COLOR_TRANSITION_SPEED);

            // Interpolate between colors
            currentWorldColor.r = previousWorldColor.r + (targetColor.r - previousWorldColor.r) * colorTransitionProgress;
            currentWorldColor.g = previousWorldColor.g + (targetColor.g - previousWorldColor.g) * colorTransitionProgress;
            currentWorldColor.b = previousWorldColor.b + (targetColor.b - previousWorldColor.b) * colorTransitionProgress;
            currentWorldColor.a = 1f;
        } else if (!currentWorldColor.equals(targetColor)) {
            // Ensure we reach the target color exactly
            currentWorldColor.set(targetColor);
        }
    }

    private void validateChunkState() {
        if (chunks == null) {
            chunks = new ConcurrentHashMap<>();
        }
        if (loadingChunks == null) {
            loadingChunks = new ConcurrentHashMap<>();
        }
        if (initialChunkLoadQueue == null) {
            initialChunkLoadQueue = new LinkedList<>();
        }
    }

    public void loadChunkAsync(final Vector2 chunkPos) {
        loadChunkAsyncWithRetry(chunkPos, 0);
    }

    private void loadChunkAsyncWithRetry(final Vector2 chunkPos, int retryCount) {
        if (isDisposed || (chunkLoadExecutor != null && chunkLoadExecutor.isShutdown())) {
            return;
        }
        if (loadingChunks.containsKey(chunkPos)) return;

        // Mark this chunk as being loaded
        loadingChunks.put(chunkPos, CompletableFuture.completedFuture(null));

        try {
            CompletableFuture.supplyAsync(() -> {
                    // Heavy work: load or generate the chunk.
                    return loadOrGenerateChunk(chunkPos);
                }, chunkLoadExecutor)
                .thenApply(chunk -> {
                    // If chunk is invalid or null, check if we can retry.
                    if (chunk == null || !isChunkValid(chunk)) {
                        if (retryCount < MAX_CHUNK_RETRY) {
                            throw new RuntimeException("Chunk invalid on retry " + retryCount);
                        } else {
                            // Last resort: generate synchronously.
                            return loadOrGenerateChunk(chunkPos);
                        }
                    }
                    return chunk;
                })
                .thenAccept(chunk -> {
                    // Enqueue the loaded chunk for integration on the main thread.
                    Gdx.app.postRunnable(() -> {
                        if (chunk != null) {
                            integrationQueue.add(new AbstractMap.SimpleEntry<>(chunkPos, chunk));
                        }
                        loadingChunks.remove(chunkPos);
                    });
                })
                .exceptionally(ex -> {
                    GameLogger.error("Error loading chunk at " + chunkPos + " on retry " + retryCount + ": " + ex.getMessage());
                    loadingChunks.remove(chunkPos);
                    if (retryCount < MAX_CHUNK_RETRY) {
                        // Schedule a retry after a short delay.
                        Gdx.app.postRunnable(() -> loadChunkAsyncWithRetry(chunkPos, retryCount + 1));
                    } else {
                        // Final fallback: perform synchronous load.
                        Gdx.app.postRunnable(() -> {
                            Chunk chunk = loadOrGenerateChunk(chunkPos);
                            if (chunk != null) {
                                integrationQueue.add(new AbstractMap.SimpleEntry<>(chunkPos, chunk));
                            }
                        });
                    }
                    return null;
                });
        } catch (RejectedExecutionException e) {
            GameLogger.error("Rejected execution for chunk " + chunkPos + ": " + e.getMessage());
            loadingChunks.remove(chunkPos);
        }
    }
    // --- In your World class ---

    // 1. Modify getChunkAtPosition() to force a synchronous load if needed.
    public Chunk getChunkAtPosition(float x, float y) {
        int chunkX = Math.floorDiv((int) x, Chunk.CHUNK_SIZE);
        int chunkY = Math.floorDiv((int) y, Chunk.CHUNK_SIZE);
        Vector2 pos = new Vector2(chunkX, chunkY);
        Chunk chunk = chunks.get(pos);

        if (chunk == null) {
            // In singleplayer, load the chunk synchronously
            chunk = loadOrGenerateChunk(pos);
            if (chunk != null) {
                chunks.put(pos, chunk);
            }
        } else if (!isChunkValid(chunk)) {
            // If the chunk exists but is invalid, regenerate it synchronously.
            chunk = loadOrGenerateChunk(pos);
            if (chunk != null) {
                chunks.put(pos, chunk);
            }
        }
        return chunk;
    }

    public boolean areInitialChunksLoaded() {
        int playerTileX = GameContext.get().getPlayer().getTileX();
        int playerTileY = GameContext.get().getPlayer().getTileY();
        int playerChunkX = Math.floorDiv(playerTileX, Chunk.CHUNK_SIZE);
        int playerChunkY = Math.floorDiv(playerTileY, Chunk.CHUNK_SIZE);
        Vector2 currentChunk = new Vector2(playerChunkX, playerChunkY);
        return chunks.containsKey(currentChunk);
    }


    public void update(float delta, Vector2 playerPosition, float viewportWidth, float viewportHeight, GameScreen gameScreen) {
        if (isDisposed) {
            return;
        }

        // Integrate a limited number of newly loaded chunks each frame
        int integratedThisFrame = 0;
        while (!integrationQueue.isEmpty() && integratedThisFrame < MAX_CHUNKS_INTEGRATED_PER_FRAME) {
            Map.Entry<Vector2, Chunk> entry = integrationQueue.poll();
            if (entry != null && entry.getValue() != null) {
                chunks.put(entry.getKey(), entry.getValue());
            }
            integratedThisFrame++;
        }

        validateChunkState();
        itemEntityManager.update(delta);

        if (!GameContext.get().isMultiplayer() && !isPlayerChunkLoaded()) {
            if (initialChunkRequestTime == 0) {
                requestInitialChunks();
            }
            // After 5 seconds, force-load the player’s current chunk synchronously.
            if (System.currentTimeMillis() - initialChunkRequestTime > 5000) {
                GameLogger.info("Forcing synchronous load for player's current chunk");
                int playerTileX = GameContext.get().getPlayer().getTileX();
                int playerTileY = GameContext.get().getPlayer().getTileY();
                int playerChunkX = Math.floorDiv(playerTileX, Chunk.CHUNK_SIZE);
                int playerChunkY = Math.floorDiv(playerTileY, Chunk.CHUNK_SIZE);
                Vector2 currentChunk = new Vector2(playerChunkX, playerChunkY);
                Chunk chunk = loadOrGenerateChunk(currentChunk);
                if (chunk != null) {
                    chunks.put(currentChunk, chunk);
                }
            }
        }


        // Update world time and color transitions
        if (worldData != null) {
            worldData.updateTime(delta);
        }
        updateWorldColor();

        // Throttle light level updates
        lightLevelUpdateTimer += delta;
        if (lightLevelUpdateTimer >= 2.0f) {
            updateLightLevels();
            lightLevelUpdateTimer = 0f;
        }

        // Weather and footstep updates
        updateWeather(delta, playerPosition, gameScreen);
        footstepEffectManager.update(delta);

        // Manage chunk loading/unloading every 0.2s
        manageChunksTimer += delta;
        if (manageChunksTimer >= 0.2f) {
            int currentChunkX = GameContext.get().getPlayer().getTileX() / CHUNK_SIZE;
            int currentChunkY = GameContext.get().getPlayer().getTileY() / CHUNK_SIZE;
            manageChunks(currentChunkX, currentChunkY);
            manageChunksTimer = 0f;
        }

        waterEffectManager.update(delta);

        // Optional water ripple effect…
        int playerTileX = (int) playerPosition.x;
        int playerTileY = (int) playerPosition.y;
        Chunk currentChunk = getChunkAtPosition(playerTileX, playerTileY);
        if (currentChunk != null) {
            int localX = Math.floorMod(playerTileX, CHUNK_SIZE);
            int localY = Math.floorMod(playerTileY, CHUNK_SIZE);
            if (TileType.isWaterPuddle(currentChunk.getTileType(localX, localY))) {
                if (GameContext.get().getPlayer() != null && GameContext.get().getPlayer().isMoving()) {
                    waterEffectManager.createRipple(
                        playerTileX * TILE_SIZE + (float) Player.FRAME_WIDTH / 2,
                        playerTileY * TILE_SIZE + (float) Player.FRAME_HEIGHT / 2
                    );
                }
            }
        }

        // Update other game systems
        updateGameSystems(delta, playerPosition);
    }

    public boolean isPlayerChunkLoaded() {
        int playerTileX = GameContext.get().getPlayer().getTileX();
        int playerTileY = GameContext.get().getPlayer().getTileY();
        int playerChunkX = Math.floorDiv(playerTileX, Chunk.CHUNK_SIZE);
        int playerChunkY = Math.floorDiv(playerTileY, Chunk.CHUNK_SIZE);
        Vector2 currentChunk = new Vector2(playerChunkX, playerChunkY);
        return chunks.containsKey(currentChunk);
    }

    public long getInitialChunkRequestTime() {
        return initialChunkRequestTime;
    }



    public void updateGameSystems(float delta, Vector2 playerPosition) {
        BiomeTransitionResult currentBiomeTransition = GameContext.get().getBiomeManager().getBiomeAt(playerPosition.x * TILE_SIZE, playerPosition.y * TILE_SIZE);

        Biome currentBiome = currentBiomeTransition.getPrimaryBiome();

        if (AudioManager.getInstance() != null) {
            AudioManager.getInstance().updateBiomeMusic(currentBiome.getType());
            AudioManager.getInstance().update(delta);
        }
        // Update other systems
        pokemonSpawnManager.update(delta, playerPosition);

        objectManager.update(chunks);
        checkPlayerInteractions(playerPosition);
    }// --- Modified manageChunks method in World.java ---

    private void manageChunks(int playerChunkX, int playerChunkY) {
        int loadRadius = INITIAL_LOAD_RADIUS + 1;
        PriorityQueue<Vector2> chunkQueue = new PriorityQueue<>(Comparator.comparingDouble(
            cp -> Vector2.dst2(cp.x, cp.y, playerChunkX, playerChunkY)
        ));
        // Gather the positions for chunks we care about
        for (int dx = -loadRadius; dx <= loadRadius; dx++) {
            for (int dy = -loadRadius; dy <= loadRadius; dy++) {
                chunkQueue.add(new Vector2(playerChunkX + dx, playerChunkY + dy));
            }
        }

        // Lower the number of chunks to initiate per frame (e.g. 8 instead of 32)
        final int MAX_CHUNKS_PER_FRAME = 8;
        int loadedThisFrame = 0;
        long now = System.currentTimeMillis();

        while (!chunkQueue.isEmpty() && loadedThisFrame < MAX_CHUNKS_PER_FRAME) {
            Vector2 chunkPos = chunkQueue.poll();
            Chunk existing = chunks.get(chunkPos);
            if (!isChunkValid(existing)) {
                if (GameContext.get().isMultiplayer()) {
                    GameContext.get().getGameClient().requestChunk(chunkPos);
                } else {
                    // Only schedule asynchronous load if one isn’t already in progress
                    if (!loadingChunks.containsKey(chunkPos)) {
                        loadChunkAsync(chunkPos);
                    }
                }
                loadedThisFrame++;
            }
            lastChunkAccess.put(chunkPos, now);
        }
        unloadDistantChunks(playerChunkX, playerChunkY);
    }

    private void renderLoadingOverlay(SpriteBatch batch) {
        // Here you can also draw a semi-transparent rectangle background if desired.
        loadingFont.draw(batch, "Loading world...", Gdx.graphics.getWidth() / 2f - 50, Gdx.graphics.getHeight() / 2f);

    }

    public PokemonSpawnManager getPokemonSpawnManager() {
        return pokemonSpawnManager;
    }

    public void render(SpriteBatch batch, Rectangle viewBounds, Player player) {

        if (chunks.isEmpty()) {
            renderLoadingOverlay(batch);
            return;
        }
        Color originalColor = batch.getColor().cpy();

        // Set the blending function to the default before rendering
        batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        // Save the original color

        try {   // Set color BEFORE any rendering occurs
            if (currentWorldColor != null) {
                // Debug the color being applied
                batch.setColor(currentWorldColor);
            }
            Rectangle expandedBounds = getExpandedViewBounds(viewBounds);
            List<Map.Entry<Vector2, Chunk>> sortedChunks = getSortedChunks();


            sortedChunks.sort(Comparator.comparingDouble(entry -> entry.getKey().y));
            // === RENDER PASS 1: Ground and Terrain ===
            renderTerrainLayer(batch, sortedChunks, expandedBounds);

            if (blockManager != null) {
                blockManager.render(batch, worldData.getWorldTimeInMinutes());
            }

            // === RENDER PASS 2: Object Bases and Low Objects ===
            renderLowObjects(batch, expandedBounds);

            itemEntityManager.render(batch);
            footstepEffectManager.render(batch);

            // === RENDER PASS 3: Characters and Mid-Layer Objects ===
            renderMidLayer(batch, player, expandedBounds);
            // === RENDER PASS 4: High Objects and Tree Tops ===
            renderHighObjects(batch,expandedBounds);
            // === RENDER PASS 5: Effects and Overlays ===
            //            weatherSystem.render(batch, gameScreen.getCamera());

            if (waterEffects != null && waterEffects.isInitialized()) {
                waterEffects.update(Gdx.graphics.getDeltaTime());
                waterEffects.render(batch, player, this);
            }
            if (weatherAudioSystem != null) {
                weatherAudioSystem.renderLightningEffect(batch, viewBounds.width, viewBounds.height);
            }

            if (currentWorldColor != null) {
                batch.setColor(currentWorldColor);
            }
            waterEffectManager.render(batch);
        } finally {      // IMPORTANT: Always restore the original color when done
            batch.setColor(originalColor);
        }
    }

    public void render(SpriteBatch batch, Rectangle viewBounds, Player player, GameScreen gameScreen) {
        if (isDisposed) return;
        if (chunks.isEmpty()) {
            renderLoadingOverlay(batch); // Keep your loading screen logic
            return;
        }

        Color originalColor = batch.getColor().cpy();
        batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        try {
            if (currentWorldColor != null) {
                batch.setColor(currentWorldColor);
            }

            // --- PASS 1: Base Terrain and Ground-level effects ---
            Rectangle expandedBounds = getExpandedViewBounds(viewBounds);
            List<Map.Entry<Vector2, Chunk>> sortedChunks = getSortedChunks();
            renderTerrainLayer(batch, sortedChunks, expandedBounds);
            if (blockManager != null) {
                blockManager.render(batch, worldData.getWorldTimeInMinutes());
            }
            itemEntityManager.render(batch);
            footstepEffectManager.render(batch);

            // --- PASS 2: Collect, Sort, and Render All Entities ---
            renderSortedEntities(batch, player, expandedBounds);

            // --- PASS 3: Overlays and Weather Effects ---
            if (weatherSystem != null && gameScreen != null) {
                weatherSystem.render(batch, gameScreen.getCamera());
            }
            if (weatherAudioSystem != null) {
                weatherAudioSystem.renderLightningEffect(batch, viewBounds.width, viewBounds.height);
            }
            // renderWorldBorderWithBatch is fine if you need it
            renderWorldBorderWithBatch(batch, gameScreen.getCamera());

        } finally {
            batch.setColor(originalColor);
        }
    }

// In src/main/java/io/github/pokemeetup/system/gameplay/overworld/World.java

    private void renderSortedEntities(SpriteBatch batch, Player player, Rectangle expandedBounds) {
        List<RenderableEntity> renderQueue = new ArrayList<>();

        // 1. Collect all entities into the render queue
        renderQueue.add(new RenderableEntity(player, player.getY(), RenderableType.PLAYER));

        if (GameContext.get().isMultiplayer()) {
            for (OtherPlayer other : GameContext.get().getGameClient().getOtherPlayers().values()) {
                if (expandedBounds.contains(other.getX(), other.getY())) {
                    renderQueue.add(new RenderableEntity(other, other.getY(), RenderableType.OTHER_PLAYER));
                }
            }
        }

        for (WildPokemon pokemon : pokemonSpawnManager.getAllWildPokemon()) {
            if (expandedBounds.contains(pokemon.getX(), pokemon.getY())) {
                renderQueue.add(new RenderableEntity(pokemon, pokemon.getY(), RenderableType.WILD_POKEMON));
            }
        }

        for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
            if (isChunkVisible(entry.getKey(), expandedBounds)) {
                for (WorldObject obj : objectManager.getObjectsForChunk(entry.getKey())) {
                    if (isTreeObject(obj)) {
                        renderQueue.add(new RenderableEntity(obj, obj.getPixelY(), RenderableType.TREE_BASE));
                        renderQueue.add(new RenderableEntity(obj, obj.getPixelY(), RenderableType.TREE_TOP));
                    } else if (isTallGrassType(obj.getType())) {
                        renderQueue.add(new RenderableEntity(obj, obj.getPixelY(), RenderableType.WORLD_OBJECT));
                        renderQueue.add(new RenderableEntity(obj, obj.getPixelY(), RenderableType.TALL_GRASS_TOP));
                    } else {
                        renderQueue.add(new RenderableEntity(obj, obj.getPixelY(), RenderableType.WORLD_OBJECT));
                    }
                }
            }
        }

        // 2. Sort the entire queue
        Collections.sort(renderQueue);

        // 3. Render entities from the sorted queue
        for (RenderableEntity item : renderQueue) {
            switch (item.type) {
                case PLAYER:
                    ((Player) item.entity).render(batch);
                    if (waterEffects != null) waterEffects.render(batch, (Player)item.entity, this);
                    break;
                case OTHER_PLAYER:
                    ((OtherPlayer) item.entity).render(batch);
                    if (waterEffectsRendererForOthers != null) waterEffectsRendererForOthers.render(batch, (OtherPlayer)item.entity, this);
                    break;
                case WILD_POKEMON:
                    ((WildPokemon) item.entity).render(batch);
                    if (waterEffectsRendererForOthers != null) waterEffectsRendererForOthers.render(batch, (WildPokemon)item.entity, this);
                    break;
                case TREE_BASE:
                    objectManager.renderTreeBase(batch, (WorldObject) item.entity, this);
                    break;
                case WORLD_OBJECT:
                    WorldObject obj = (WorldObject) item.entity;
                    if (isTallGrassType(obj.getType())) {
                        renderTallGrassUpperHalf(batch, Collections.singletonList(obj));
                    } else {
                        objectManager.renderObject(batch, obj, this);
                    }
                    break;
                case TREE_TOP:
                    objectManager.renderTreeTop(batch, (WorldObject) item.entity, this);
                    break;
                case TALL_GRASS_TOP:
                    renderTallGrassLowerHalf(batch, Collections.singletonList((WorldObject)item.entity));
                    break;
            }
        }
    }
    private boolean isTallGrassType(WorldObject.ObjectType type) {
        return type == WorldObject.ObjectType.TALL_GRASS ||
            type == WorldObject.ObjectType.FOREST_TALL_GRASS ||
            type == WorldObject.ObjectType.RAIN_FOREST_TALL_GRASS ||
            type == WorldObject.ObjectType.SNOW_TALL_GRASS ||
            type == WorldObject.ObjectType.TALL_GRASS_2 ||
            type == WorldObject.ObjectType.TALL_GRASS_3 ||
            type == WorldObject.ObjectType.RUINS_TALL_GRASS ||
            type == WorldObject.ObjectType.DESERT_TALL_GRASS ||
            type == WorldObject.ObjectType.HAUNTED_TALL_GRASS;
    }
    public void updateLightLevels() {
        lightLevelMap.clear();
        // Only recalc lighting during night.
        float hour = DayNightCycle.getHourOfDay(worldData.getWorldTimeInMinutes());
        if (DayNightCycle.getTimePeriod(hour) != DayNightCycle.TimePeriod.NIGHT) return;

        // Update only for chunks near the player.
        int playerTileX = GameContext.get().getPlayer().getTileX();
        int playerTileY = GameContext.get().getPlayer().getTileY();
        int playerChunkX = Math.floorDiv(playerTileX, Chunk.CHUNK_SIZE);
        int playerChunkY = Math.floorDiv(playerTileY, Chunk.CHUNK_SIZE);
        int updateRadius = 5;  // Only update chunks within 5 chunks from the player.

        for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
            Vector2 chunkPos = entry.getKey();
            if (Math.abs(chunkPos.x - playerChunkX) > updateRadius || Math.abs(chunkPos.y - playerChunkY) > updateRadius)
                continue;
            Chunk chunk = entry.getValue();
            // Iterate over the blocks in the chunk.
            for (PlaceableBlock block : chunk.getBlocks().values()) {
                if (block.getId().equalsIgnoreCase("furnace")) {
                    Vector2 pos = block.getPosition();
                    int radius = 7;
                    float maxLevel = 1.0f;
                    for (int dx = -radius; dx <= radius; dx++) {
                        for (int dy = -radius; dy <= radius; dy++) {
                            Vector2 tilePos = new Vector2(pos.x + dx, pos.y + dy);
                            float dist = pos.dst(tilePos);
                            if (dist <= radius) {
                                float level = maxLevel * (1 - (dist / radius));
                                lightLevelMap.merge(tilePos, level, Math::max);
                            }
                        }
                    }
                }
            }
        }
    }


    private void renderOtherPlayers(SpriteBatch batch, Rectangle viewBounds) {
        if (GameContext.get().getGameClient() == null || GameContext.get().getGameClient().isSinglePlayer()) {
            return;
        }

        Map<String, OtherPlayer> otherPlayers = GameContext.get().getGameClient().getOtherPlayers();

        synchronized (otherPlayers) {
            // Sort players by Y position for proper depth ordering.
            List<OtherPlayer> sortedPlayers = new ArrayList<>(otherPlayers.values());
            sortedPlayers.sort((p1, p2) -> Float.compare(p2.getY(), p1.getY()));

            for (OtherPlayer otherPlayer : sortedPlayers) {
                if (otherPlayer == null) continue;

                float playerX = otherPlayer.getX();
                float playerY = otherPlayer.getY();

                // Only render if within view bounds
                if (viewBounds.contains(playerX, playerY)) {
                    otherPlayer.render(batch);
                    // Render water effects for this remote player.
                    // Pass the OtherPlayer (a Positionable) and the current World.
                    waterEffectsRendererForOthers.render(batch, otherPlayer, GameContext.get().getWorld());
                }
            }
        }
    }

    public void migrateBlocksToChunks() {
        if (worldData == null || worldData.getBlockData() == null) return;

        try {
            BlockSaveData blockData = worldData.getBlockData();
            Map<String, List<BlockSaveData.BlockData>> oldBlocks = blockData.getPlacedBlocks();

            for (Map.Entry<String, List<BlockSaveData.BlockData>> entry : oldBlocks.entrySet()) {
                for (BlockSaveData.BlockData blockDataItem : entry.getValue()) {
                    try {
                        // Get chunk for this block
                        int chunkX = Math.floorDiv(blockDataItem.x, CHUNK_SIZE);
                        int chunkY = Math.floorDiv(blockDataItem.y, CHUNK_SIZE);
                        Vector2 chunkPos = new Vector2(chunkX, chunkY);

                        // Get or create chunk
                        Chunk chunk = chunks.get(chunkPos);
                        if (chunk == null) continue;
                        PlaceableBlock.BlockType type = PlaceableBlock.BlockType.fromId(blockDataItem.type);
                        if (type == null) {
                            GameLogger.error("Failed to find block type: " + blockDataItem.type);
                            continue;
                        }
                        Vector2 pos = new Vector2(blockDataItem.x, blockDataItem.y);

                        // Create the PlaceableBlock instance without texture
                        PlaceableBlock block = new PlaceableBlock(type, pos, null, blockDataItem.isFlipped);

                        // Set isChestOpen for chests
                        if (type == PlaceableBlock.BlockType.CHEST) {
                            block.setChestOpen(blockDataItem.isChestOpen);
                        }

                        // Now get the texture using the new getBlockFrame method
                        TextureRegion texture = BlockTextureManager.getBlockFrame(block, 0);
                        if (texture != null) {
                            block.setTexture(texture);
                            chunk.addBlock(block);
                            chunk.setDirty(true);
                        }
                    } catch (Exception e) {
                        GameLogger.error("Failed to migrate block: " + e.getMessage());
                    }
                }
            }

            // Clear old block data
            worldData.setBlockData(null);

            // Save all modified chunks
            for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
                if (entry.getValue().isDirty()) {
                    saveChunkData(entry.getKey(), entry.getValue());
                }
            }

            GameLogger.info("Block migration complete");
        } catch (Exception e) {
            GameLogger.error("Block migration failed: " + e.getMessage());
        }
    }

    private List<Map.Entry<Vector2, Chunk>> getSortedChunks() {
        // If the number of chunks is unchanged, return our cached list.
        int currentCount = chunks.size();
        if (cachedSortedChunks != null && currentCount == cachedChunkCount) {
            return cachedSortedChunks;
        }
        // Otherwise, re-create and sort the list.
        cachedSortedChunks = new ArrayList<>(chunks.entrySet());
        cachedSortedChunks.sort(Comparator.comparingDouble(entry -> entry.getKey().y));
        cachedChunkCount = currentCount;
        return cachedSortedChunks;
    }

    private void renderTerrainLayer(SpriteBatch batch, List<Map.Entry<Vector2, Chunk>> sortedChunks, Rectangle expandedBounds) {
        for (Map.Entry<Vector2, Chunk> entry : sortedChunks) {
            Vector2 chunkPos = entry.getKey();
            if (isChunkVisible(chunkPos, expandedBounds)) {
                Chunk chunk = entry.getValue();
                getNeighboringBiomes(chunkPos);
                biomeRenderer.renderChunk(batch, chunk, this);
            }
        }
    }

    private Rectangle getExpandedViewBounds(Rectangle viewBounds) {
        float buffer = TILE_SIZE * 2;
        return new Rectangle(viewBounds.x - buffer, viewBounds.y - buffer, viewBounds.width + (buffer * 2), viewBounds.height + (buffer * 2));
    }

    private void renderLowObjects(SpriteBatch batch, Rectangle expandedBounds) {
        for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
            Vector2 pos = entry.getKey();
            if (isChunkVisible(pos, expandedBounds)) {
                List<WorldObject> chunkObjects = objectManager.getObjectsForChunk(pos);
                for (WorldObject obj : chunkObjects) {
                    if (obj.getType().renderLayer == WorldObject.ObjectType.RenderLayer.BELOW_PLAYER) {
                        objectManager.renderObject(batch, obj, this);
                    }
                }
            }
        }
    }

    private void renderHighObjects(SpriteBatch batch, Rectangle expandedBounds) {
        List<WorldObject> treeTopsToRender = new ArrayList<>();
        for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
            if (isChunkVisible(entry.getKey(), expandedBounds)) {
                List<WorldObject> chunkObjects = objectManager.getObjectsForChunk(entry.getKey());
                for (WorldObject obj : chunkObjects) {
                    if (isTreeObject(obj)) {
                        treeTopsToRender.add(obj);
                    }
                }
            }
        }

        // Sort tree tops by Y position
        treeTopsToRender.sort(Comparator.comparingDouble(WorldObject::getPixelY));

        // Render tree tops
        for (WorldObject tree : treeTopsToRender) {
            objectManager.renderTreeTop(batch, tree, this);
        }
    }

    private boolean isTreeObject(WorldObject obj) {
        return obj.getType() == WorldObject.ObjectType.TREE_0 || obj.getType() == WorldObject.ObjectType.TREE_1 || obj.getType() == WorldObject.ObjectType.SNOW_TREE || obj.getType() == WorldObject.ObjectType.HAUNTED_TREE || obj.getType() == WorldObject.ObjectType.RAIN_TREE || obj.getType() == WorldObject.ObjectType.RUINS_TREE || obj.getType() == WorldObject.ObjectType.APRICORN_TREE || obj.getType() == WorldObject.ObjectType.BEACH_TREE || obj.getType() == WorldObject.ObjectType.CHERRY_TREE;
    }


    private void renderMidLayer(SpriteBatch batch, Player player, Rectangle expandedBounds) {
        List<ObjectWithYPosition> behindPlayerQueue = new ArrayList<>();
        List<ObjectWithYPosition> frontPlayerQueue = new ArrayList<>();

        Color originalColor = batch.getColor().cpy();
        // First pass: Separate objects into behind and front queues
        for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
            if (isChunkVisible(entry.getKey(), expandedBounds)) {
                List<WorldObject> chunkObjects = objectManager.getObjectsForChunk(entry.getKey());
                for (WorldObject obj : chunkObjects) {
                    if (isTreeObject(obj)) {
                        // Tree bases always go behind player
                        behindPlayerQueue.add(new ObjectWithYPosition(obj.getPixelY(), obj, RenderType.TREE_BASE));

                        // <<-- BUG: REMOVE THE FOLLOWING LINE:
                        // renderWildPokemon(batch);

                        // Render tree top later – add an offset so it draws above the player.
                        frontPlayerQueue.add(new ObjectWithYPosition(obj.getPixelY() + World.TILE_SIZE * 2, obj, RenderType.TREE_TOP));
                    } else if (obj.getType().renderLayer == WorldObject.ObjectType.RenderLayer.BELOW_PLAYER) {
                        behindPlayerQueue.add(new ObjectWithYPosition(obj.getPixelY(), obj, RenderType.REGULAR_OBJECT));
                    }
                }
            }
        }
        behindPlayerQueue.sort(Comparator.comparingDouble(a -> a.y));
        frontPlayerQueue.sort(Comparator.comparingDouble(a -> a.y));

        // Render objects behind the player:
        for (ObjectWithYPosition item : behindPlayerQueue) {
            switch (item.renderType) {
                case TREE_BASE:
                    objectManager.renderTreeBase(batch, (WorldObject) item.object, this);
                    break;
                case REGULAR_OBJECT:
                    objectManager.renderObject(batch, (WorldObject) item.object, this);
                    break;
            }
        }

        renderWildPokemon(batch);
        // Render the player:
        if (GameContext.get().getGameClient() != null && GameContext.get().isMultiplayer()) {
            renderOtherPlayers(GameContext.get().getBatch(), expandedBounds);
        }
        List<WorldObject> tallGrass = getTallGrassObjects();

// -------------------
// PASS A: Draw behind
// -------------------
        for (WorldObject grass : tallGrass) {
            boolean sameTile = (grass.getTileX() == player.getTileX()
                && grass.getTileY() == player.getTileY());
            if (sameTile) {
                // Player is in the same tile => draw ONLY the top half behind the player
                renderTallGrassUpperHalf(batch, Collections.singletonList(grass));
            } else {
                // Player is not in this tile => draw the entire grass tile behind
                renderTallGrassUpperHalf(batch, Collections.singletonList(grass));
                renderTallGrassLowerHalf(batch, Collections.singletonList(grass));
            }
        }

// Always render the player once, no matter what
        player.render(batch);

// ---------------------
// PASS B: Draw in front
// ---------------------
        for (WorldObject grass : tallGrass) {
            boolean sameTile = (grass.getTileX() == player.getTileX()
                && grass.getTileY() == player.getTileY());
            if (sameTile) {
                // Draw bottom half in front of the player
                renderTallGrassLowerHalf(batch, Collections.singletonList(grass));
            }
        }

        batch.setColor(originalColor);

        // Now, render wild Pokémon in their own pass (if needed):
    }

    List<WorldObject> getTallGrassObjects() {
        List<WorldObject> tallGrass = new ArrayList<>();
        tallGrass.addAll(objectManager.getObjectsForChunkType(WorldObject.ObjectType.TALL_GRASS));
        tallGrass.addAll(objectManager.getObjectsForChunkType(WorldObject.ObjectType.TALL_GRASS_2));
        tallGrass.addAll(objectManager.getObjectsForChunkType(WorldObject.ObjectType.TALL_GRASS_3));
        tallGrass.addAll(objectManager.getObjectsForChunkType(WorldObject.ObjectType.FOREST_TALL_GRASS));
        tallGrass.addAll(objectManager.getObjectsForChunkType(WorldObject.ObjectType.RAIN_FOREST_TALL_GRASS));
        tallGrass.addAll(objectManager.getObjectsForChunkType(WorldObject.ObjectType.HAUNTED_TALL_GRASS));
        tallGrass.addAll(objectManager.getObjectsForChunkType(WorldObject.ObjectType.DESERT_TALL_GRASS));
        tallGrass.addAll(objectManager.getObjectsForChunkType(WorldObject.ObjectType.SNOW_TALL_GRASS));
        tallGrass.addAll(objectManager.getObjectsForChunkType(WorldObject.ObjectType.RUINS_TALL_GRASS));
        return tallGrass;
    }


    private Map<BiomeRenderer.Direction, Biome> getNeighboringBiomes(Vector2 chunkPos) {
        Map<BiomeRenderer.Direction, Biome> neighbors = new EnumMap<>(BiomeRenderer.Direction.class);

        for (BiomeRenderer.Direction dir : BiomeRenderer.Direction.values()) {
            Vector2 neighborPos = new Vector2(chunkPos.x + (dir == BiomeRenderer.Direction.EAST ? 1 : dir == BiomeRenderer.Direction.WEST ? -1 : 0), chunkPos.y + (dir == BiomeRenderer.Direction.NORTH ? 1 : dir == BiomeRenderer.Direction.SOUTH ? -1 : 0));

            Chunk neighborChunk = chunks.get(neighborPos);
            if (neighborChunk != null) {
                neighbors.put(dir, neighborChunk.getBiome());
            }
        }

        return neighbors;
    }

    private boolean isChunkVisible(Vector2 chunkPos, Rectangle viewBounds) {
        float chunkWorldX = chunkPos.x * CHUNK_SIZE * TILE_SIZE;
        float chunkWorldY = chunkPos.y * CHUNK_SIZE * TILE_SIZE;
        float chunkSize = CHUNK_SIZE * TILE_SIZE;
        tempChunkRect.set(chunkWorldX, chunkWorldY, chunkSize, chunkSize);
        return viewBounds.overlaps(tempChunkRect);
    }

    public WorldObject.WorldObjectManager getObjectManager() {
        return objectManager;
    }

    public boolean isPokemonAt(int worldX, int worldY) {
        // This check is now based on the tile the Pokémon is standing on, not a bounding box.
        for (WildPokemon pokemon : pokemonSpawnManager.getAllWildPokemon()) {
            if (pokemon.getTileX() == worldX && pokemon.getTileY() == worldY) {
                return true;
            }
        }
        return false;
    }

    public void loadChunksAroundPositionSynchronously(Vector2 tilePosition, int radius) {
        // Now tilePosition is already in tile coordinates.
        int chunkX = Math.floorDiv((int) tilePosition.x, CHUNK_SIZE);
        int chunkY = Math.floorDiv((int) tilePosition.y, CHUNK_SIZE);

        GameLogger.info("Loading chunks around tile position " + tilePosition + " with radius " + radius);
        for (int dx = -radius; dx <= radius; dx++) {
            for (int dy = -radius; dy <= radius; dy++) {
                Vector2 chunkPos = new Vector2(chunkX + dx, chunkY + dy);
                if (!chunks.containsKey(chunkPos)) {
                    try {
                        if (GameContext.get().isMultiplayer()) {
                            GameContext.get().getGameClient().requestChunk(chunkPos);
                        } else {
                            loadChunkAsync(chunkPos);
                        }

                    } catch (Exception e) {
                        GameLogger.error("Error loading chunk at " + chunkPos + ": " + e.getMessage());
                    }
                }
            }
        }
    }

    public boolean isPassable(int tileX, int tileY) {
        if (!isWithinWorldBounds(tileX, tileY)) {
            // Optionally, you might want to log this:
            GameLogger.info("Tile (" + tileX + "," + tileY + ") is outside world bounds.");
            return false;
        }

        // (Optional) If the tile isn’t even loaded, then return false.
        if (!isPositionLoaded(tileX, tileY)) {
            return false;
        }
        try {
            // Convert pixel coordinates to chunk coordinates

            int chunkX = Math.floorDiv(tileX, Chunk.CHUNK_SIZE);
            int chunkY = Math.floorDiv(tileY, Chunk.CHUNK_SIZE);
            Vector2 chunkPos = new Vector2(chunkX, chunkY);
            Chunk chunk = chunks.get(chunkPos);
            if (chunk == null) return false;
            int localX = Math.floorMod(tileX, Chunk.CHUNK_SIZE);
            int localY = Math.floorMod(tileY, Chunk.CHUNK_SIZE);


            String currentDirection = GameContext.get().getPlayer() != null ? GameContext.get().getPlayer().getDirection() : "down";

            // Basic tile passability
            if (!chunk.isPassable(localX, localY)) {
                handleCollision(currentDirection);
                return false;
            }
            // Check block collision
            if (blockManager != null && blockManager.hasCollisionAt(tileX, tileY)) {
                return false;
            }

            // Calculate pixel-based collision box
            Rectangle movementBounds = new Rectangle(tileX * TILE_SIZE,  // Now using actual pixel position
                tileY * TILE_SIZE, TILE_SIZE * 0.5f,    // Half tile collision size
                TILE_SIZE * 0.5f);

            // Check collisions with objects and Pokemon
            return !checkObjectCollision(movementBounds, currentDirection) && !checkPokemonCollision(tileX, tileY, currentDirection);

        } catch (Exception e) {
            GameLogger.error("Error checking passability: " + e.getMessage());
            return false;
        }
    }

    private void renderWorldBorderWithBatch(SpriteBatch batch, OrthographicCamera camera) {
        TextureRegion borderPixel = new TextureRegion(TextureManager.getWhitePixel());
        // Save the current batch color.
        Color originalColor = batch.getColor().cpy();
        batch.setColor(Color.RED);

        // Calculate the world border rectangle (in world pixels).
        float left = -HALF_WORLD_SIZE;
        float bottom = -HALF_WORLD_SIZE;
        float worldSize = WORLD_SIZE;

        // Set a line thickness (e.g., 2 pixels)
        float thickness = 2f;

        // Draw top border
        batch.draw(borderPixel, left, bottom + worldSize - thickness, worldSize, thickness);
        // Draw bottom border
        batch.draw(borderPixel, left, bottom, worldSize, thickness);
        // Draw left border
        batch.draw(borderPixel, left, bottom, thickness, worldSize);
        // Draw right border
        batch.draw(borderPixel, left + worldSize - thickness, bottom, thickness, worldSize);

        // Restore original color.
        batch.setColor(originalColor);
    }


    public GameClient getGameClient() {
        if (GameContext.get().getGameClient() == null) {
            throw new IllegalStateException("GameClient is null - World not properly initialized");
        }
        return GameContext.get().getGameClient();
    }

    boolean isPositionLoaded(int worldX, int worldY) {
        int chunkX = Math.floorDiv(worldX, Chunk.CHUNK_SIZE);
        int chunkY = Math.floorDiv(worldY, Chunk.CHUNK_SIZE);
        return chunks.containsKey(new Vector2(chunkX, chunkY));
    }

    private void handleCollision(String direction) {
        if (GameContext.get().getPlayer() != null) {
            switch (direction) {
                case "up":
                    GameContext.get().getPlayer().setDirection("up");
                    break;
                case "down":
                    GameContext.get().getPlayer().setDirection("down");
                    break;
                case "left":
                    GameContext.get().getPlayer().setDirection("left");
                    break;
                case "right":
                    GameContext.get().getPlayer().setDirection("right");
                    break;
            }
            GameContext.get().getPlayer().setMoving(false);
        }
    }

    private boolean checkObjectCollision(Rectangle movementBounds, String direction) {
        List<WorldObject> nearbyObjects = objectManager.getObjectsNearPosition(movementBounds.x + movementBounds.width / 2, movementBounds.y + movementBounds.height / 2);

        for (WorldObject obj : nearbyObjects) {
            Rectangle collisionBox = obj.getCollisionBox();
            if (collisionBox != null && collisionBox.overlaps(movementBounds)) {
                if (GameContext.get().getPlayer() != null) {
                    GameContext.get().getPlayer().setDirection(direction);
                    GameContext.get().getPlayer().setMoving(false);
                }
                return true;
            }
        }
        return false;
    }

    private boolean checkPokemonCollision(int worldX, int worldY, String direction) {
        if (isPokemonAt(worldX, worldY)) {
            if (GameContext.get().getPlayer() != null) {
                GameContext.get().getPlayer().setDirection(direction);
                GameContext.get().getPlayer().setMoving(false);
            }
            return true;
        }
        return false;
    }

    private void checkPlayerInteractions(Vector2 playerPosition) {
        // Convert player position from tile coordinates to pixel coordinates
        float playerPixelX = playerPosition.x * TILE_SIZE;
        float playerPixelY = playerPosition.y * TILE_SIZE;

        nearestPokeball = null;
        float closestDistance = Float.MAX_VALUE;

        // Check in current chunk and adjacent chunks
        int chunkX = (int) Math.floor(playerPixelX / (Chunk.CHUNK_SIZE * TILE_SIZE));
        int chunkY = (int) Math.floor(playerPixelY / (Chunk.CHUNK_SIZE * TILE_SIZE));

        // Check current and surrounding chunks
        for (int dx = -1; dx <= 1; dx++) {
            for (int dy = -1; dy <= 1; dy++) {
                Vector2 chunkPos = new Vector2(chunkX + dx, chunkY + dy);
                List<WorldObject> objects = objectManager.getObjectsForChunk(chunkPos);

                if (objects != null) {
                    for (WorldObject obj : objects) {
                        if (obj.getType() == WorldObject.ObjectType.POKEBALL) {
                            // Calculate distance using pixel coordinates
                            float dx2 = playerPixelX - obj.getPixelX();
                            float dy2 = playerPixelY - obj.getPixelY();
                            float distance = (float) Math.sqrt(dx2 * dx2 + dy2 * dy2);
                            if (distance <= INTERACTION_RANGE && distance < closestDistance) {
                                closestDistance = distance;
                                nearestPokeball = obj;
                            }
                        }
                    }
                }
            }
        }
    }


    public void initializeFromServer(long seed, double worldTimeInMinutes, float dayLength) {
        try {
            GameLogger.info("Initializing multiplayer world with seed: " + seed);

            // Create/update WorldData
            if (worldData == null) {
                worldData = new WorldData(name);
            }

            // Configure world settings
            WorldData.WorldConfig config = new WorldData.WorldConfig(seed);
            worldData.setConfig(config);
            worldData.setWorldTimeInMinutes(worldTimeInMinutes);
            worldData.setDayLength(dayLength);

            // Update core properties
            this.worldSeed = seed;

            // CRITICAL: Create a new BiomeManager with the correct seed
            BiomeManager biomeManager = new BiomeManager(seed);
            GameContext.get().setBiomeManager(biomeManager);

            // Initialize managers if needed
            if (blockManager == null) blockManager = new BlockManager();
            if (objectManager == null) objectManager = new WorldObject.WorldObjectManager(worldSeed);
            if (pokemonSpawnManager == null)
                pokemonSpawnManager = new PokemonSpawnManager(TextureManager.pokemonoverworld);

            // Clear any existing chunks to prevent singleplayer data persistence
            chunks.clear();
            biomeTransitions.clear(); // Clear biome transitions as well

            GameLogger.info("Multiplayer world initialization complete - " +
                "Time: " + worldTimeInMinutes + " Day Length: " + dayLength + " Seed: " + seed);

        } catch (Exception e) {
            GameLogger.error("Failed to initialize multiplayer world: " + e.getMessage());
            throw new RuntimeException("Multiplayer world initialization failed", e);
        }
    }

    private void renderWildPokemon(SpriteBatch batch) {
        Collection<WildPokemon> allPokemon = pokemonSpawnManager.getAllWildPokemon();

        List<WildPokemon> sortedPokemon = new ArrayList<>(allPokemon);
        sortedPokemon.sort((p1, p2) -> Float.compare(p2.getY(), p1.getY()));

        for (WildPokemon pokemon : sortedPokemon) {
            if (pokemon == null || pokemon.getAnimations() == null) {
                continue;
            }


            pokemon.render(batch);
        }
    }

    public void removeWorldObject(WorldObject obj) {
        int chunkX = (int) Math.floor(obj.getPixelX() / (Chunk.CHUNK_SIZE * TILE_SIZE));
        int chunkY = (int) Math.floor(obj.getPixelY() / (Chunk.CHUNK_SIZE * TILE_SIZE));
        Vector2 chunkPos = new Vector2(chunkX, chunkY);

        List<WorldObject> objects = objectManager.getObjectsForChunk(chunkPos);
        if (objects != null) {
            objects.remove(obj);
        }
    }

    private void updateWeather(float delta, Vector2 playerPosition, GameScreen gameScreen) {
        // Calculate world position in pixels
        float worldX = playerPosition.x * TILE_SIZE;
        float worldY = playerPosition.y * TILE_SIZE;

        // Get current biome and calculate temperature
        currentBiomeTransition = GameContext.get().getBiomeManager().getBiomeAt(worldX, worldY);
        float temperature = calculateTemperature();


        // Update weather systems
        float timeOfDay = (float) (worldData.getWorldTimeInMinutes() % (24 * 60)) / 60f;
        weatherSystem.update(delta, currentBiomeTransition, temperature, timeOfDay, gameScreen);
        weatherAudioSystem.update(delta, weatherSystem.getCurrentWeather(), weatherSystem.getIntensity());
    }

    private float calculateTemperature() {
        BiomeType biomeType = currentBiomeTransition.getPrimaryBiome().getType();
        float baseTemp;

        switch (biomeType) {
            case SNOW:
                baseTemp = 0.0f;
                break;
            case DESERT:
                baseTemp = 35.0f;
                break;
            case HAUNTED:
                baseTemp = 15.0f;
                break;
            case RAIN_FOREST:
                baseTemp = 28.0f;
                break;
            case FOREST:
                baseTemp = 22.0f;
                break;
            default:
                baseTemp = 20.0f;
        }

        float timeOfDay = (float) (worldData.getWorldTimeInMinutes() % (24 * 60)) / 60f;
        float timeVariation = (float) Math.sin((timeOfDay - 6) * Math.PI / 12) * 5.0f;

        return baseTemp + timeVariation;
    }

    private boolean isChunkValid(Chunk chunk) {
        if (chunk == null) return false;
        int[][] data = chunk.getTileData();
        if (data == null || data.length != CHUNK_SIZE) return false;
        for (int[] row : data) {
            if (row == null || row.length != CHUNK_SIZE) return false;
        }
        return true;
    }


    public WorldObject getNearestPokeball() {
        return nearestPokeball;
    }

    private enum RenderType {
        TREE_BASE, TREE_TOP, REGULAR_OBJECT, PLAYER
    }

    private static class ObjectWithYPosition {
        public float y;
        public Object object;
        public RenderType renderType;

        public ObjectWithYPosition(float y, Object object, RenderType renderType) {
            this.y = y;
            this.object = object;
            this.renderType = renderType;
        }
    }

    public static class ChunkData {
        public int x;
        public int y;
        public BiomeType biomeType;
        public int[][] tileData;
        public List<WorldObjectData> objects;
        public List<BlockSaveData.BlockData> blocks;
        public long lastModified;
        public boolean isMultiplayer;


        public ChunkData() {
            this.tileData = new int[Chunk.CHUNK_SIZE][Chunk.CHUNK_SIZE];
            this.objects = new ArrayList<>();
            this.blocks = new ArrayList<>();
        }

        public void write(Json json) {
            json.writeObjectStart();
            json.writeValue("x", x);
            json.writeValue("y", y);
            json.writeValue("biomeType", biomeType.name());
            json.writeValue("tileData", tileData);
            json.writeValue("objects", objects);
            json.writeValue("blocks", blocks, ArrayList.class, BlockSaveData.BlockData.class);
            json.writeValue("lastModified", lastModified);
            json.writeValue("isMultiplayer", isMultiplayer);
            json.writeObjectEnd();
        }

        public void read(JsonValue jsonData, Json json) {
            x = jsonData.getInt("x");
            y = jsonData.getInt("y");
            biomeType = BiomeType.valueOf(jsonData.getString("biomeType"));
            tileData = json.readValue(int[][].class, jsonData.get("tileData"));
            objects = json.readValue(ArrayList.class, WorldObjectData.class, jsonData.get("objects"));

            JsonValue blocksValue = jsonData.get("blocks");
            if (blocksValue != null && blocksValue.isArray()) {
                blocks = json.readValue(ArrayList.class, BlockSaveData.BlockData.class, blocksValue);
            } else {
                blocks = new ArrayList<>();
            }

            lastModified = jsonData.getLong("lastModified", System.currentTimeMillis());
            isMultiplayer = jsonData.getBoolean("isMultiplayer", false);
        }
    }

    public static class WorldObjectData {
        public float x;
        public float y;
        public WorldObject.ObjectType type;

        public WorldObjectData() {
        }

        public WorldObjectData(WorldObject obj) {
            this.x = obj.getPixelX();
            this.y = obj.getPixelY();
            this.type = obj.getType();
        }
    }

}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/WorldObject.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.JsonValue;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;

import static com.badlogic.gdx.math.MathUtils.random;

public class WorldObject {
    private static final float POKEBALL_DESPAWN_TIME = 300f;
    private static final Map<ObjectType, TextureRegion> textureCache = new HashMap<>();

    static {
        initializeTextures();
    }

    public ObjectType type;
    private WorldObject attachedTo;
    private float pixelX;
    private float pixelY;
    private TextureRegion texture;
    private String id;
    private boolean isCollidable;
    private float spawnTime;
    private int tileX, tileY;

    public WorldObject(int tileX, int tileY, TextureRegion texture, ObjectType type) {
        this.id = UUID.randomUUID().toString();
        this.tileX = tileX;
        this.tileY = tileY;
        this.pixelX = tileX * World.TILE_SIZE;
        this.pixelY = tileY * World.TILE_SIZE;
        this.texture = texture;
        this.attachedTo = null;
        this.type = type;
        this.isCollidable = type.isCollidable;
        this.spawnTime = type.isPermanent ? 0 : System.currentTimeMillis() / 1000f;
    }

    public WorldObject() {
        this.id = UUID.randomUUID().toString();
        this.isCollidable = false;
        this.spawnTime = 0f;
        this.attachedTo = null;
    }

    private static void initializeTextures() {
        try {
            // Initialize texture cache if not already done
            if (textureCache.isEmpty()) {
                TextureAtlas atlas = TextureManager.tiles;
                if (atlas != null) {
                    textureCache.put(ObjectType.TREE_0, atlas.findRegion("treeONE"));
                    textureCache.put(ObjectType.TREE_1, atlas.findRegion("treeTWO"));
                    textureCache.put(ObjectType.SNOW_TREE, atlas.findRegion("snow_tree"));
                    textureCache.put(ObjectType.HAUNTED_TREE, atlas.findRegion("haunted_tree"));
                    textureCache.put(ObjectType.POKEBALL, atlas.findRegion("pokeball"));
                    textureCache.put(ObjectType.CACTUS, atlas.findRegion("desert_cactus"));
                    textureCache.put(ObjectType.BUSH, atlas.findRegion("bush"));
                    textureCache.put(ObjectType.SUNFLOWER, atlas.findRegion("sunflower"));
                    textureCache.put(ObjectType.VINES, atlas.findRegion("vines"));
                    textureCache.put(ObjectType.DEAD_TREE, atlas.findRegion("dead_tree"));
                    textureCache.put(ObjectType.SMALL_HAUNTED_TREE, atlas.findRegion("small_haunted_tree"));
                    textureCache.put(ObjectType.RUIN_POLE, atlas.findRegion("ruins_pole"));
                    textureCache.put(ObjectType.RUINS_TREE, atlas.findRegion("ruins_tree"));
                    textureCache.put(ObjectType.RAIN_TREE, atlas.findRegion("rain_tree"));
                    textureCache.put(ObjectType.APRICORN_TREE, atlas.findRegion("apricorn_tree_grown"));
                    textureCache.put(ObjectType.CHERRY_TREE, atlas.findRegion("CherryTree"));
                    textureCache.put(ObjectType.BEACH_TREE, atlas.findRegion("beach_tree"));
                    textureCache.put(ObjectType.DESERT_TALL_GRASS, atlas.findRegion("desert_grass_overlay"));
                    textureCache.put(ObjectType.SNOW_TALL_GRASS, atlas.findRegion("snow_tall_grass_overlay"));
                    textureCache.put(ObjectType.TALL_GRASS, atlas.findRegion("tall_grass_overlay"));
                    textureCache.put(ObjectType.FOREST_TALL_GRASS, atlas.findRegion("forest_tall_grass_overlay"));
                    textureCache.put(ObjectType.HAUNTED_TALL_GRASS, atlas.findRegion("haunted_tall_grass_overlay"));
                    textureCache.put(ObjectType.RAIN_FOREST_TALL_GRASS, atlas.findRegion("rain_forest_tall_grass_overlay"));
                    textureCache.put(ObjectType.TALL_GRASS_2, atlas.findRegion("tall_grass_2_overlay"));
                    textureCache.put(ObjectType.TALL_GRASS_3, atlas.findRegion("tall_grass_3_overlay"));
                    textureCache.put(ObjectType.DESERT_ROCK, atlas.findRegion("desert_rock_overlay"));
                    textureCache.put(ObjectType.CRYSTAL_ROCK, atlas.findRegion("crystal_overlay"));
                    textureCache.put(ObjectType.FAIRY_ROCK, atlas.findRegion("fairy_rock_overlay"));
                    textureCache.put(ObjectType.RUINS_TALL_GRASS, atlas.findRegion("ruins_tall_grass_overlay"));
                    // Add other object types as needed
                }
            }
        } catch (Exception e) {
            GameLogger.error("Failed to initialize textures: " + e.getMessage());
        }
    }


    public void updateFromData(Map<String, Object> data) {
        if (data == null) return;
        try {
            // --- Handle tileX ---
            Object tileXObj = data.get("tileX");
            if (tileXObj instanceof JsonValue) {
                this.tileX = ((JsonValue) tileXObj).getInt("value", 0);
            } else if (tileXObj instanceof Number) {
                this.tileX = ((Number) tileXObj).intValue();
            }
            // --- Handle tileY ---
            Object tileYObj = data.get("tileY");
            if (tileYObj instanceof JsonValue) {
                this.tileY = ((JsonValue) tileYObj).getInt("value", 0);
            } else if (tileYObj instanceof Number) {
                this.tileY = ((Number) tileYObj).intValue();
            }
            this.pixelX = tileX * World.TILE_SIZE;
            this.pixelY = tileY * World.TILE_SIZE;

            // --- Handle spawnTime ---
            Object spawnTimeObj = data.get("spawnTime");
            if (spawnTimeObj instanceof JsonValue) {
                this.spawnTime = ((JsonValue) spawnTimeObj).getFloat("value", 0f);
            } else if (spawnTimeObj instanceof Number) {
                this.spawnTime = ((Number) spawnTimeObj).floatValue();
            } else {
                this.spawnTime = (type != null && type.isPermanent ? 0 : System.currentTimeMillis() / 1000f);
            }

            // --- Handle isCollidable ---
            Object collidableObj = data.get("isCollidable");
            if (collidableObj instanceof JsonValue) {
                this.isCollidable = ((JsonValue) collidableObj).getBoolean("value", (type != null && type.isCollidable));
            } else if (collidableObj instanceof Boolean) {
                this.isCollidable = (Boolean) collidableObj;
            } else {
                this.isCollidable = (type != null && type.isCollidable);
            }

            // --- Handle type ---
            Object raw = data.get("type");
            String typeStr = "";
            if (raw instanceof JsonValue) {
                // Extract the inner "value" (e.g. "SUNFLOWER")
                typeStr = ((JsonValue) raw).getString("value", "");
            } else if (raw instanceof String) {
                typeStr = (String) raw;
            } else if (raw != null) {
                typeStr = raw.toString();
            }
            if (typeStr.isEmpty()) {
                GameLogger.error("Empty type string in serialized data. Setting default type.");
                this.type = ObjectType.TREE_0;
            } else {
                try {
                    this.type = ObjectType.valueOf(typeStr.toUpperCase());
                } catch (IllegalArgumentException e) {
                    GameLogger.error("Invalid type string: " + typeStr + ". Setting default type.");
                    this.type = ObjectType.TREE_0;
                }
            }

            // --- Handle id ---
            Object idObj = data.get("id");
            if (idObj instanceof JsonValue) {
                this.id = ((JsonValue) idObj).getString("value", UUID.randomUUID().toString());
            } else if (idObj instanceof String) {
                this.id = (String) idObj;
            } else if (idObj != null) {
                this.id = idObj.toString();
            } else {
                this.id = UUID.randomUUID().toString();
            }

            // Ensure texture is set
        } catch (Exception e) {
            GameLogger.error("Error updating WorldObject from data: " + e.getMessage() + "\nData: " + data.toString());
        }
    }

    public HashMap<String, Object> getSerializableData() {
        HashMap<String, Object> data = new HashMap<>();
        data.put("tileX", tileX);
        data.put("tileY", tileY);

        data.put("type", type.name());
        data.put("spawnTime", spawnTime);
        data.put("isCollidable", isCollidable);
        data.put("id", id);
        return data;
    }


    public WorldObject copy() {
        // Create a new object with the same tile position and type
        WorldObject copy = new WorldObject(this.tileX, this.tileY, this.texture, this.type);

        // Copy all basic fields
        copy.id = this.id;  // Keep same ID for tracking
        copy.pixelX = this.pixelX;
        copy.pixelY = this.pixelY;
        copy.isCollidable = this.isCollidable;
        copy.spawnTime = this.spawnTime;

        copy.texture = this.texture;

        // If there's an attached object, copy that too
        if (this.attachedTo != null) {
            copy.attachedTo = this.attachedTo.copy();
        }

        return copy;
    }

    public TextureRegion getTexture() {
        ensureTexture();
        return texture;
    }

    public void setTexture(TextureRegion texture) {
        this.texture = texture;
    }

    public void ensureTexture() {
        if (texture == null && type != null) {
            texture = textureCache.get(type);
            if (texture == null) {

                texture = textureCache.get(ObjectType.TREE_0);
            }
        }
    }

    public boolean isStatic() {
        return type == ObjectType.TREE_0 ||
            type == ObjectType.TREE_1 ||
            type == ObjectType.BUSH || type == ObjectType.APRICORN_TREE ||
            type == ObjectType.DEAD_TREE || type == ObjectType.RAIN_TREE
            || type == ObjectType.RUINS_TREE || type == ObjectType.RUIN_POLE || type == ObjectType.SNOW_TREE || type == ObjectType.HAUNTED_TREE ||
            type == ObjectType.CACTUS;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }


    public void updateFromNetwork(NetworkProtocol.WorldObjectUpdate update) {
        this.tileX = (int) update.data.get("tileX");
        this.tileY = (int) update.data.get("tileY");
        this.pixelX = tileX * World.TILE_SIZE;
        this.pixelY = tileY * World.TILE_SIZE;
        this.spawnTime = (float) update.data.get("spawnTime");
        this.isCollidable = (boolean) update.data.get("isCollidable");
    }

    public ObjectType getType() {
        return type;
    }

    public void setType(ObjectType type) {
        this.type = type;
    }

    public boolean isExpired() {
        if (type.isPermanent) return false;
        float currentTime = System.currentTimeMillis() / 1000f;
        return currentTime - spawnTime > POKEBALL_DESPAWN_TIME;
    }

    public Rectangle getPlacementBoundingBox() {
        if (isTreeType(type)) {
            // For apricorn trees we already use a 3x3 area.
            if (type == ObjectType.APRICORN_TREE) {
                float treeBaseX = pixelX - World.TILE_SIZE;
                float treeBaseY = pixelY;
                return new Rectangle(treeBaseX, treeBaseY, World.TILE_SIZE * 3, World.TILE_SIZE * 3);
            } else {
                // For other trees, use a 2x3 area to cover the full sprite.
                float treeBaseX = pixelX - World.TILE_SIZE;
                float treeBaseY = pixelY;
                return new Rectangle(treeBaseX, treeBaseY, World.TILE_SIZE * 2, World.TILE_SIZE * 3);
            }
        }
        // For non-tree objects, the placement bounding box can be the same as their visual size.
        return new Rectangle(pixelX, pixelY, type.widthInTiles * World.TILE_SIZE, type.heightInTiles * World.TILE_SIZE);
    }


    public Rectangle getBoundingBox() {
        if (type == ObjectType.APRICORN_TREE) {
            float treeBaseX = pixelX - World.TILE_SIZE;  // Center the 3-tile width
            float treeBaseY = pixelY;  // Bottom of tree

            return new Rectangle(
                treeBaseX,
                treeBaseY,
                World.TILE_SIZE * 3,  // 3 tiles wide
                World.TILE_SIZE * 3   // 3 tiles high
            );
        }
        if (type == ObjectType.TREE_0 || type == ObjectType.RUINS_TREE || type == ObjectType.TREE_1 || type == ObjectType.SNOW_TREE || type == ObjectType.HAUNTED_TREE || type == ObjectType.RAIN_TREE) {
            // Tree collision box: 2x2 tiles at the base only
            float treeBaseX = pixelX - World.TILE_SIZE; // Center the 2-tile width base
            float treeBaseY = pixelY; // Bottom of tree

            return new Rectangle(
                treeBaseX,
                treeBaseY,
                World.TILE_SIZE * 2, // 2 tiles wide
                World.TILE_SIZE * 2  // 2 tiles high (base only)
            );
        } else {
            return new Rectangle(
                pixelX,
                pixelY,
                type.widthInTiles * World.TILE_SIZE,
                type.heightInTiles * World.TILE_SIZE
            );
        }
    }

    public float getPixelX() {
        return pixelX;
    }

    public float getPixelY() {
        return pixelY;
    }

    public int getTileX() {
        return tileX;
    }

    public void setTileX(int tileX) {
        this.tileX = tileX;
    }

    public int getTileY() {
        return tileY;
    }

    public void setTileY(int tileY) {
        this.tileY = tileY;
    }

    public Rectangle getCollisionBox() {
        if (!type.isCollidable) {
            return null;
        }

        if (type == ObjectType.APRICORN_TREE) {
            return new Rectangle(
                pixelX,               // start at center column
                pixelY,               // bottom of the tree
                World.TILE_SIZE,      // 32px wide, one tile
                World.TILE_SIZE * 2   // 64px tall, two tiles high
            );
        } else if (type == ObjectType.RUINS_TREE || type == ObjectType.CHERRY_TREE || type == ObjectType.BEACH_TREE) {
            // 2x2 collision as before
            float treeBaseX = pixelX - World.TILE_SIZE;
            float treeBaseY = pixelY;
            return new Rectangle(treeBaseX, treeBaseY, World.TILE_SIZE * 2, World.TILE_SIZE * 2);
        } else if (isTreeType(type)) {
            // Regular trees (2x2 base collision)
            float treeBaseX = pixelX - World.TILE_SIZE;
            float treeBaseY = pixelY;
            return new Rectangle(treeBaseX, treeBaseY, World.TILE_SIZE * 2, World.TILE_SIZE * 2);
        }

        // Standard objects
        return new Rectangle(
            pixelX,
            pixelY,
            type.widthInTiles * World.TILE_SIZE,
            type.heightInTiles * World.TILE_SIZE
        );
    }

    private boolean isTreeType(ObjectType type) {
        return type == ObjectType.TREE_0 ||
            type == ObjectType.TREE_1 ||
            type == ObjectType.SNOW_TREE ||
            type == ObjectType.HAUNTED_TREE ||
            type == ObjectType.RUINS_TREE ||
            type == ObjectType.APRICORN_TREE ||
            type == ObjectType.RAIN_TREE || type == ObjectType.BEACH_TREE;
    }

    // Add this to your WorldObject class
    public enum ObjectType {
        // Static objects
        TREE_0(true, true, 2, 3, RenderLayer.LAYERED, 5.0f, "wooden_planks", 1),
        TREE_1(true, true, 2, 3, RenderLayer.LAYERED, 5.0f, "wooden_planks", 1),
        SNOW_TREE(true, true, 2, 3, RenderLayer.LAYERED, 5.0f, "wooden_planks", 1),
        HAUNTED_TREE(true, true, 2, 3, RenderLayer.LAYERED, 5.0f, "wooden_planks", 1),
        RUINS_TREE(true, true, 2, 3, RenderLayer.LAYERED, 5.0f, "wooden_planks", 1),
        APRICORN_TREE(true, true, 3, 3, RenderLayer.LAYERED, 5.0f, "wooden_planks", 2),
        RAIN_TREE(true, true, 2, 3, RenderLayer.LAYERED, 5.0f, "wooden_planks", 1),
        CHERRY_TREE(true, true, 2, 3, RenderLayer.LAYERED, 5.0f, "wooden_planks", 1),
        BEACH_TREE(true, true, 2, 3, RenderLayer.LAYERED, 5.0f, "wooden_planks", 1),
        DEAD_TREE(true, true, 1, 2, RenderLayer.BELOW_PLAYER, 3.0f, "stick", 2),
        SMALL_HAUNTED_TREE(true, true, 1, 2, RenderLayer.BELOW_PLAYER, 3.0f, "stick", 2),
        CACTUS(true, true, 1, 2, RenderLayer.BELOW_PLAYER, 3.0f, "stick", 1),
        BUSH(true, true, 3,
            2, RenderLayer.BELOW_PLAYER),
        VINES(true, false, 1, 2, RenderLayer.BELOW_PLAYER),
        RUIN_POLE(true, true, 1, 3, RenderLayer.BELOW_PLAYER),
        POKEBALL(true, true, 1, 1, RenderLayer.BELOW_PLAYER),
        SUNFLOWER(true, false, 1, 2, RenderLayer.BELOW_PLAYER),
        DESERT_TALL_GRASS(true, false, 1, 1, RenderLayer.BELOW_PLAYER),
        SNOW_TALL_GRASS(true, false, 1, 1, RenderLayer.BELOW_PLAYER),
        TALL_GRASS(true, false, 1, 1, RenderLayer.BELOW_PLAYER),
        FOREST_TALL_GRASS(true, false, 1, 1, RenderLayer.BELOW_PLAYER),
        HAUNTED_TALL_GRASS(true, false, 1, 1, RenderLayer.BELOW_PLAYER),
        RAIN_FOREST_TALL_GRASS(true, false, 1, 1, RenderLayer.BELOW_PLAYER),
        RUINS_TALL_GRASS(true, false, 1, 1, RenderLayer.BELOW_PLAYER),
        TALL_GRASS_2(true, false, 1, 1, RenderLayer.BELOW_PLAYER),
        TALL_GRASS_3(true, false, 1, 1, RenderLayer.BELOW_PLAYER),
        DESERT_ROCK(true, true, 1, 1, RenderLayer.BELOW_PLAYER),
        CRYSTAL_ROCK(true, true, 1, 1, RenderLayer.BELOW_PLAYER),
        FAIRY_ROCK(true, true, 1, 1, RenderLayer.BELOW_PLAYER);

        public final boolean isPermanent;    // Permanent or temporary object
        public final boolean isCollidable;   // Has collision or not
        public final int widthInTiles;       // Width in tiles
        public final int heightInTiles;

        public final float breakTime;
        public final String dropItemId;
        public final int dropItemCount;
        public final RenderLayer renderLayer;
        ObjectType(boolean isPermanent, boolean isCollidable, int widthInTiles, int heightInTiles, RenderLayer renderLayer, float breakTime, String dropItemId, int dropItemCount) {
            this.isPermanent = isPermanent;
            this.isCollidable = isCollidable;
            this.widthInTiles = widthInTiles;
            this.heightInTiles = heightInTiles;
            this.renderLayer = renderLayer;
            this.breakTime = breakTime;
            this.dropItemId = dropItemId;
            this.dropItemCount = dropItemCount;
        }
        ObjectType(boolean isPermanent, boolean isCollidable, int widthInTiles, int heightInTiles, RenderLayer renderLayer) {
            this(isPermanent, isCollidable, widthInTiles, heightInTiles, renderLayer, 9999f, null, 0);
        }  public float getBreakTime(boolean hasAxe) {
            if (breakTime >= 9999f) {
                return Float.MAX_VALUE;
            }
            return hasAxe ? breakTime * 0.5f : breakTime * 1.5f;
        }

        public enum RenderLayer {
            BELOW_PLAYER,
            ABOVE_PLAYER,
            LAYERED,
            ABOVE_TALL_GRASS
        }

    }

    public static class WorldObjectManager {
        public static final float POKEBALL_SPAWN_CHANCE = 0.025f;
        public static final int MAX_POKEBALLS_PER_CHUNK = 1;
        private static final float POKEBALL_SPAWN_INTERVAL = 5.0f; // Try every 5 seconds
        private final Map<Vector2, List<WorldObject>> objectsByChunk = new ConcurrentHashMap<>();
        private final Map<ObjectType, TextureRegion> objectTextures;
        private final long worldSeed;
        private final ConcurrentLinkedQueue<WorldObjectOperation> operationQueue = new ConcurrentLinkedQueue<>();
        private Set<String> removedObjectIds = Collections.newSetFromMap(new ConcurrentHashMap<>());
        // New: a set to track removed objects by their base tile coordinate
        private Set<Vector2> removedObjectTiles = Collections.newSetFromMap(new ConcurrentHashMap<>());
        private float pokeballSpawnTimer = 0f;

        public WorldObjectManager(long seed) {
            this.worldSeed = seed;
            TextureAtlas atlas = TextureManager.tiles;
            this.objectTextures = new HashMap<>();
            objectTextures.put(ObjectType.TREE_0, atlas.findRegion("treeONE"));
            objectTextures.put(ObjectType.TREE_1, atlas.findRegion("treeTWO"));
            objectTextures.put(ObjectType.SNOW_TREE, atlas.findRegion("snow_tree"));
            objectTextures.put(ObjectType.HAUNTED_TREE, atlas.findRegion("haunted_tree"));
            objectTextures.put(ObjectType.POKEBALL, atlas.findRegion("pokeball"));
            objectTextures.put(ObjectType.CACTUS, atlas.findRegion("desert_cactus"));
            objectTextures.put(ObjectType.BUSH, atlas.findRegion("bush"));
            objectTextures.put(ObjectType.SUNFLOWER, atlas.findRegion("sunflower"));
            objectTextures.put(ObjectType.VINES, atlas.findRegion("vines"));
            objectTextures.put(ObjectType.DEAD_TREE, atlas.findRegion("dead_tree"));
            objectTextures.put(ObjectType.SMALL_HAUNTED_TREE, atlas.findRegion("small_haunted_tree"));
            objectTextures.put(ObjectType.RAIN_TREE, atlas.findRegion("rain_tree"));
            objectTextures.put(ObjectType.CHERRY_TREE, atlas.findRegion("CherryTree"));
            objectTextures.put(ObjectType.RUIN_POLE, atlas.findRegion("ruins_pole"));
            objectTextures.put(ObjectType.RUINS_TREE, atlas.findRegion("ruins_tree"));
            objectTextures.put(ObjectType.APRICORN_TREE, atlas.findRegion("apricorn_tree_grown"));
            objectTextures.put(ObjectType.BEACH_TREE, atlas.findRegion("beach_tree"));
            objectTextures.put(ObjectType.DESERT_TALL_GRASS, atlas.findRegion("desert_grass_overlay"));
            objectTextures.put(ObjectType.SNOW_TALL_GRASS, atlas.findRegion("snow_tall_grass_overlay"));
            objectTextures.put(ObjectType.TALL_GRASS, atlas.findRegion("tall_grass_overlay"));
            objectTextures.put(ObjectType.FOREST_TALL_GRASS, atlas.findRegion("forest_tall_grass_overlay"));
            objectTextures.put(ObjectType.HAUNTED_TALL_GRASS, atlas.findRegion("haunted_tall_grass_overlay"));
            objectTextures.put(ObjectType.RAIN_FOREST_TALL_GRASS, atlas.findRegion("rain_forest_tall_grass_overlay"));
            objectTextures.put(ObjectType.TALL_GRASS_2, atlas.findRegion("tall_grass_2_overlay"));
            objectTextures.put(ObjectType.TALL_GRASS_3, atlas.findRegion("tall_grass_3_overlay"));
            objectTextures.put(ObjectType.DESERT_ROCK, atlas.findRegion("desert_rock_overlay"));
            objectTextures.put(ObjectType.CRYSTAL_ROCK, atlas.findRegion("crystal_overlay"));
            objectTextures.put(ObjectType.FAIRY_ROCK, atlas.findRegion("fairy_rock_overlay"));
            objectTextures.put(ObjectType.RUINS_TALL_GRASS, atlas.findRegion("ruins_tall_grass_overlay"));

        }

        public List<WorldObject> getObjectsForChunkType(WorldObject.ObjectType type) {
            List<WorldObject> filteredObjects = new ArrayList<>();
            for (List<WorldObject> objects : objectsByChunk.values()) {
                for (WorldObject obj : objects) {
                    if (obj.getType() == type) {
                        filteredObjects.add(obj);
                    }
                }
            }
            return filteredObjects;
        }

        private void sendChunkObjectSync(List<WorldObject> objects) {
            try {
                for (WorldObject obj : objects) {
                    NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
                    update.objectId = obj.getId();
                    update.type = NetworkProtocol.NetworkObjectUpdateType.ADD;
                    update.data = obj.getSerializableData();

                    GameContext.get().getGameClient().getClient().sendTCP(update);
                }
            } catch (Exception e) {
                GameLogger.error("Failed to send chunk object sync: " + e.getMessage());
            }
        }

        public void removeObjectFromChunk(Vector2 chunkPos, String objectId, int tileX, int tileY) {
            // Record that this object (at this tile) was removed.
            removedObjectIds.add(objectId);
            removedObjectTiles.add(new Vector2(tileX, tileY));
            List<WorldObject> objects = objectsByChunk.get(chunkPos);
            if (objects != null) {
                objects.removeIf(obj -> obj.getId().equals(objectId));
            }
        }

        public boolean isRemovedTile(int tileX, int tileY) {
            return removedObjectTiles.contains(new Vector2(tileX, tileY));
        }

        /**
         * Record that an object was removed at the given tile coordinate.
         */


        public void addObjectToChunk(WorldObject object) {
            int actualChunkX = (int) Math.floor(object.getPixelX() / (Chunk.CHUNK_SIZE * World.TILE_SIZE));
            int actualChunkY = (int) Math.floor(object.getPixelY() / (Chunk.CHUNK_SIZE * World.TILE_SIZE));
            Vector2 actualChunkPos = new Vector2(actualChunkX, actualChunkY);
            if (removedObjectIds.contains(object.getId())) {
                return;
            }
            objectsByChunk.computeIfAbsent(actualChunkPos, k -> new CopyOnWriteArrayList<>()).add(object);
        }

        public void setObjectsForChunk(Vector2 chunkPos, List<WorldObject> objects) {
            if (objects == null) {
                objectsByChunk.remove(chunkPos);
            } else {
                List<WorldObject> filtered = new ArrayList<>();
                for (WorldObject obj : objects) {
                    if (!removedObjectIds.contains(obj.getId())) {
                        filtered.add(obj);
                    }
                }
                objectsByChunk.put(chunkPos, new CopyOnWriteArrayList<>(filtered));
            }
        }

        private WorldObject createObject(ObjectType type, int localX, int localY, Vector2 chunkPos) {
            try {
                int worldTileX = (int) (chunkPos.x * Chunk.CHUNK_SIZE + localX);
                int worldTileY = (int) (chunkPos.y * Chunk.CHUNK_SIZE + localY);
                TextureRegion texture = objectTextures.get(type);
                if (texture != null) {
                    WorldObject object = new WorldObject(worldTileX, worldTileY, texture, type);
                    // IMPORTANT: When creating the object we generate a new UUID.
                    // (This is why tracking by removed tile is necessary.)
                    object.setId(UUID.randomUUID().toString());
                    return object;
                }
            } catch (Exception e) {
                GameLogger.error("Error creating object: " + e.getMessage());
            }
            return null;
        }


        private Rectangle getObjectBounds(int tileX, int tileY, ObjectType type) {
            float width = type.widthInTiles * World.TILE_SIZE;
            float height = type.heightInTiles * World.TILE_SIZE;

            // Special handling for trees which have different base positions
            float xOffset = 0;
            if (isTreeType(type)) {
                if (type == ObjectType.APRICORN_TREE) {
                    width = World.TILE_SIZE * 3;
                    height = World.TILE_SIZE * 3;
                    xOffset = -World.TILE_SIZE; // Center the 3-tile width
                } else {
                    width = World.TILE_SIZE * 2;
                    height = World.TILE_SIZE * 2;
                    xOffset = -World.TILE_SIZE; // Center the 2-tile width
                }
            }

            return new Rectangle(
                tileX * World.TILE_SIZE + xOffset,
                tileY * World.TILE_SIZE,
                width,
                height
            );
        }

        private boolean boundsOverlapWithPadding(Rectangle bounds1, Rectangle bounds2, int spacing) {
            // Use the full spacing value so that trees (and other objects) have enough room
            float padding = World.TILE_SIZE * spacing;
            Rectangle paddedBounds = new Rectangle(
                bounds1.x - padding,
                bounds1.y - padding,
                bounds1.width + (padding * 2),
                bounds1.height + (padding * 2)
            );
            return paddedBounds.overlaps(bounds2);
        }

        private boolean isTreeType(ObjectType type) {
            return type == ObjectType.TREE_0 ||
                type == ObjectType.TREE_1 ||
                type == ObjectType.SNOW_TREE ||
                type == ObjectType.HAUNTED_TREE ||
                type == ObjectType.RUINS_TREE ||
                type == ObjectType.APRICORN_TREE ||
                type == ObjectType.RAIN_TREE || type == ObjectType.CHERRY_TREE || type == ObjectType.BEACH_TREE;
        }

        private int getRequiredSpacing(ObjectType type) {
            switch (type) {
                case APRICORN_TREE:
                    return 3; // Slightly more strict for apricorn trees
                case TREE_0:
                case TREE_1:
                case SNOW_TREE:
                case HAUNTED_TREE:
                case RAIN_TREE:
                case CHERRY_TREE:
                case RUINS_TREE:
                case BEACH_TREE:
                    return 2; // More strict than before for large trees
                default:
                    return 1; // Smaller objects remain at spacing 1
            }
        }

        public void renderTreeBase(SpriteBatch batch, WorldObject tree, World world) {
            // Get texture and handle null case
            TextureRegion treeRegion = tree.getTexture();
            if (treeRegion == null) {
                // Try to re-initialize texture
                tree.ensureTexture();
                treeRegion = tree.getTexture();

                // If still null, skip rendering
                if (treeRegion == null) {
                    GameLogger.error("Failed to load texture for tree: " + tree.getId());
                    return;
                }
            }

            boolean flipY = treeRegion.isFlipY();

            int totalWidth = treeRegion.getRegionWidth();   // For apricorn: should be 96
            int totalHeight = treeRegion.getRegionHeight(); // Also 96 for apricorn
            int baseHeight = totalHeight / 3;               // For apricorn: 96/3 = 32

            float renderX = tree.getPixelX() - World.TILE_SIZE;
            float renderY = tree.getPixelY();

            Vector2 tilePos = new Vector2(tree.getTileX(), tree.getTileY());
            Float lightLevel = world.getLightLevelAtTile(tilePos);

            Color originalColor = batch.getColor().cpy();
            try {
                if (lightLevel != null && lightLevel > 0) {
                    Color lightColor = new Color(1f, 0.8f, 0.6f, 1f);
                    Color baseColor = world.getCurrentWorldColor().cpy();
                    baseColor.lerp(lightColor, lightLevel * 0.7f);
                    batch.setColor(baseColor);
                }

                int baseY = flipY ? 0 : totalHeight - baseHeight;
                TextureRegion baseRegion = new TextureRegion(treeRegion, 0, baseY, totalWidth, baseHeight);
                if (flipY != baseRegion.isFlipY()) {
                    baseRegion.flip(false, true);
                }

                float drawWidth = tree.getType() == ObjectType.APRICORN_TREE ?
                    World.TILE_SIZE * 3 : World.TILE_SIZE * 2;
                float drawHeight = World.TILE_SIZE;

                batch.draw(baseRegion, renderX, renderY, drawWidth, drawHeight);
            } finally {
                batch.setColor(originalColor);
            }
        }

        public void renderTreeTop(SpriteBatch batch, WorldObject tree, World world) {
            // Get texture and handle null case
            TextureRegion treeRegion = tree.getTexture();
            if (treeRegion == null) {
                // Try to re-initialize texture
                tree.ensureTexture();
                treeRegion = tree.getTexture();

                // If still null, skip rendering
                if (treeRegion == null) {
                    GameLogger.error("Failed to load texture for tree: " + tree.getId());
                    return;
                }
            }

            // Now we can safely use the texture
            boolean flipY = treeRegion.isFlipY();

            int totalWidth = treeRegion.getRegionWidth();
            int totalHeight = treeRegion.getRegionHeight();
            int topHeight = (totalHeight * 2) / 3; // top 2/3
            float renderX = tree.getPixelX() - World.TILE_SIZE;
            float renderY = tree.getPixelY() + World.TILE_SIZE;

            Vector2 tilePos = new Vector2(tree.getTileX(), tree.getTileY());
            Float lightLevel = world.getLightLevelAtTile(tilePos);

            Color originalColor = batch.getColor().cpy();
            try {
                if (lightLevel != null && lightLevel > 0) {
                    Color lightColor = new Color(1f, 0.8f, 0.6f, 1f);
                    Color baseColor = world.getCurrentWorldColor().cpy();
                    baseColor.lerp(lightColor, lightLevel * 0.7f);
                    batch.setColor(baseColor);
                }

                int topY = flipY ? totalHeight - topHeight : 0;
                TextureRegion topRegion = new TextureRegion(treeRegion, 0, topY, totalWidth, topHeight);
                if (flipY != topRegion.isFlipY()) {
                    topRegion.flip(false, true);
                }

                float drawWidth = tree.getType() == ObjectType.APRICORN_TREE ?
                    World.TILE_SIZE * 3 : World.TILE_SIZE * 2;
                float drawHeight = World.TILE_SIZE * 2;

                batch.draw(topRegion, renderX, renderY, drawWidth, drawHeight);
            } finally {
                batch.setColor(originalColor);
            }
        }

        public void renderObject(SpriteBatch batch, WorldObject object, World world) {
            // Skip layered objects as they're rendered separately
            if (object.getType().renderLayer == ObjectType.RenderLayer.LAYERED) {
                return;
            }

            TextureRegion objectTexture = object.getTexture();
            if (objectTexture == null) {
                return; // Skip if texture isn't available
            }

            float renderX = object.getPixelX();
            float renderY = object.getPixelY();

            // Get the object's width and height in pixels
            float width = object.getType().widthInTiles * World.TILE_SIZE;
            float height = object.getType().heightInTiles * World.TILE_SIZE;

            // Apply lighting based on world light levels
            Vector2 tilePos = new Vector2(object.getTileX(), object.getTileY());
            Float lightLevel = world.getLightLevelAtTile(tilePos);

            // Save the original batch color
            Color originalColor = batch.getColor().cpy();

            try {
                // Apply lighting if available
                if (lightLevel != null && lightLevel > 0) {
                    Color lightColor = new Color(1f, 0.8f, 0.6f, 1f);
                    Color baseColor = world.getCurrentWorldColor().cpy();
                    baseColor.lerp(lightColor, lightLevel * 0.7f);
                    batch.setColor(baseColor);
                } else {
                    // Ensure the current world color is applied
                    batch.setColor(world.getCurrentWorldColor());
                }

                // Render the object
                batch.draw(objectTexture, renderX, renderY, width, height);
            } finally {
                // Restore the original batch color
                batch.setColor(originalColor);
            }
        }

        public List<WorldObject> getObjectsNearPosition(float x, float y) {
            List<WorldObject> nearbyObjects = new ArrayList<>();
            int searchRadius = 2; // Search in nearby chunks

            int centerChunkX = (int) Math.floor(x / (Chunk.CHUNK_SIZE * World.TILE_SIZE));
            int centerChunkY = (int) Math.floor(y / (Chunk.CHUNK_SIZE * World.TILE_SIZE));

            for (int dx = -searchRadius; dx <= searchRadius; dx++) {
                for (int dy = -searchRadius; dy <= searchRadius; dy++) {
                    Vector2 chunkPos = new Vector2(centerChunkX + dx, centerChunkY + dy);
                    List<WorldObject> chunkObjectList = objectsByChunk.get(chunkPos);

                    if (chunkObjectList != null) {
                        for (WorldObject obj : chunkObjectList) {
                            float distX = Math.abs(obj.getPixelX() - x);
                            float distY = Math.abs(obj.getPixelY() - y);

                            if (distX <= World.TILE_SIZE * 3 && distY <= World.TILE_SIZE * 3) {
                                nearbyObjects.add(obj);
                            }
                        }
                    }
                }
            }

            return nearbyObjects;
        }

        public void updateObject(NetworkProtocol.WorldObjectUpdate update) {
            for (List<WorldObject> objects : objectsByChunk.values()) {
                for (WorldObject obj : objects) {
                    if (obj.getId().equals(update.objectId)) {
                        obj.updateFromData(update.data);
                        return;
                    }
                }
            }
        }

        public List<WorldObject> getObjectsForChunk(Vector2 chunkPos) {
            List<WorldObject> objects = objectsByChunk.get(chunkPos);
            return objects != null ? objects : Collections.emptyList();
        }

        private void handlePokeballSpawning(Vector2 chunkPos, Chunk chunk) {
            // Get or create the chunk's object list
            List<WorldObject> objects = objectsByChunk.computeIfAbsent(chunkPos,
                k -> new CopyOnWriteArrayList<>());

            // Count existing pokeballs in chunk
            long pokeballCount = objects.stream()
                .filter(obj -> obj.getType() == ObjectType.POKEBALL)
                .count();

            // Check if we can spawn a pokeball
            if (pokeballCount < MAX_POKEBALLS_PER_CHUNK && random() < POKEBALL_SPAWN_CHANCE) {
                int attempts = 10;
                while (attempts > 0) {
                    // Get random position within chunk
                    int localX = random.nextInt(Chunk.CHUNK_SIZE);
                    int localY = random.nextInt(Chunk.CHUNK_SIZE);

                    // Convert to world coordinates
                    int worldTileX = (int) (chunkPos.x * Chunk.CHUNK_SIZE + localX);
                    int worldTileY = (int) (chunkPos.y * Chunk.CHUNK_SIZE + localY);

                    // Check if location is valid (grass or sand tiles)
                    int tileType = chunk.getTileType(localX, localY);
                    if (tileType == TileType.GRASS || tileType == TileType.SAND) {
                        // Check area is clear of other objects
                        boolean locationClear = true;
                        for (WorldObject obj : objects) {
                            if (Math.abs(obj.getTileX() - worldTileX) < 2 &&
                                Math.abs(obj.getTileY() - worldTileY) < 2) {
                                locationClear = false;
                                break;
                            }
                        }

                        if (locationClear) {
                            // Create and add pokeball
                            TextureRegion pokeballTexture = objectTextures.get(ObjectType.POKEBALL);
                            if (pokeballTexture != null) {
                                WorldObject pokeball = new WorldObject(
                                    worldTileX, worldTileY,
                                    pokeballTexture, ObjectType.POKEBALL
                                );
                                objects.add(pokeball);

                                // Send network update in multiplayer
                                if (
                                    GameContext.get().getGameClient() != null && GameContext.get().isMultiplayer()) {
                                    NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
                                    update.objectId = pokeball.getId();
                                    update.type = NetworkProtocol.NetworkObjectUpdateType.ADD;
                                    update.data = pokeball.getSerializableData();


                                    GameContext.get().getGameClient().sendWorldObjectUpdate(update);
                                }

                                GameLogger.info("Spawned pokeball at " + worldTileX + "," + worldTileY);
                                break;
                            }
                        }
                    }
                    attempts--;
                }
            }
        }

        public void update(Map<Vector2, Chunk> loadedChunks) {
            WorldObjectOperation operation;
            pokeballSpawnTimer += Gdx.graphics.getDeltaTime();
            while ((operation = operationQueue.poll()) != null) {
                try {
                    if (Objects.requireNonNull(operation.type) == WorldObjectOperation.OperationType.REMOVE) {
                        RemoveOperation removeOp = (RemoveOperation) operation;
                        List<WorldObject> removeList = objectsByChunk.get(removeOp.chunkPos);
                        if (removeList != null) {
                            removeList.removeIf(obj -> obj.getId().equals(removeOp.objectId));
                            objectsByChunk.put(removeOp.chunkPos, new CopyOnWriteArrayList<>(removeList));

                            if (GameContext.get().isMultiplayer()) {
                                if (
                                    GameContext.get().getGameClient() != null &&
                                        GameContext.get().getGameClient().getCurrentWorld() != null) {
                                    Chunk chunk =
                                        GameContext.get().getGameClient().getCurrentWorld().getChunkAtPosition(
                                            removeOp.chunkPos.x, removeOp.chunkPos.y);
                                    if (chunk != null) {

                                        GameContext.get().getGameClient().getCurrentWorld().saveChunkData(removeOp.chunkPos, chunk);
                                    }
                                }
                            }
                        }
                    }
                } catch (Exception e) {
                    GameLogger.error("Error processing operation: " + e.getMessage());
                }
            }

            if (pokeballSpawnTimer >= POKEBALL_SPAWN_INTERVAL) {
                // Update existing chunks
                for (Map.Entry<Vector2, Chunk> entry : loadedChunks.entrySet()) {
                    Vector2 chunkPos = entry.getKey();
                    List<WorldObject> objects = objectsByChunk.computeIfAbsent(chunkPos,
                        k -> new CopyOnWriteArrayList<>());

                    // Remove expired objects
                    boolean changed = objects.removeIf(WorldObject::isExpired);
                    if (changed) {
                        operationQueue.add(new PersistOperation(chunkPos, new ArrayList<>(objects)));
                    }

                    handlePokeballSpawning(chunkPos, entry.getValue());
                }

                pokeballSpawnTimer = 0f;
            }
            // Clean up unloaded chunks
            cleanupUnloadedChunks(loadedChunks);
        }



        private void cleanupUnloadedChunks(Map<Vector2, Chunk> loadedChunks) {
            // Identify chunks to remove
            List<Vector2> chunksToRemove = new ArrayList<>();
            for (Vector2 chunkPos : objectsByChunk.keySet()) {
                if (!loadedChunks.containsKey(chunkPos)) {
                    chunksToRemove.add(chunkPos);
                }
            }

            // Remove chunks and persist their final state
            for (Vector2 chunkPos : chunksToRemove) {
                List<WorldObject> objects = objectsByChunk.get(chunkPos);
                if (objects != null) {
                    // Final persist operation before removal
                    operationQueue.add(new PersistOperation(chunkPos, new ArrayList<>(objects)));
                }
                objectsByChunk.remove(chunkPos);
            }
        }

        private void updateChunkObjectsList(Vector2 chunkPos, List<WorldObject> objects) {
            // Update the runtime state
            objectsByChunk.put(chunkPos, new CopyOnWriteArrayList<>(objects));

        }

        private boolean shouldSpawnPokeball(List<WorldObject> chunkObjects) {
            long pokeballCount = chunkObjects.stream()
                .filter(obj -> obj.getType() == ObjectType.POKEBALL)
                .count();
            return pokeballCount < MAX_POKEBALLS_PER_CHUNK &&
                new Random().nextInt(101) < POKEBALL_SPAWN_CHANCE;
        }

        private void spawnPokeball(Vector2 chunkPos, List<WorldObject> objects, Chunk chunk) {
            for (int attempts = 0; attempts < 10; attempts++) {
                int localX = random.nextInt(Chunk.CHUNK_SIZE);
                int localY = random.nextInt(Chunk.CHUNK_SIZE);

                // Only spawn on grass or sand
                int tileType = chunk.getTileType(localX, localY);
                if (tileType == TileType.GRASS || tileType == TileType.SAND) {

                    int worldTileX = (int) (chunkPos.x * Chunk.CHUNK_SIZE) + localX;
                    int worldTileY = (int) (chunkPos.y * Chunk.CHUNK_SIZE) + localY;

                    boolean locationClear = true;
                    for (WorldObject obj : objects) {
                        if (Math.abs(obj.getTileX() - worldTileX) < 2 &&
                            Math.abs(obj.getTileY() - worldTileY) < 2) {
                            locationClear = false;
                            break;
                        }
                    }
                    if (shouldSpawnPokeball(objects)) {
                        if (locationClear) {
                            TextureRegion pokeballTexture = objectTextures.get(ObjectType.POKEBALL);
                            if (pokeballTexture != null) {
                                WorldObject pokeball = new WorldObject(worldTileX, worldTileY,
                                    pokeballTexture, ObjectType.POKEBALL);
                                objects.add(pokeball);

                                if (
                                    GameContext.get().getGameClient() != null && !
                                        GameContext.get().getGameClient().isSinglePlayer()) {
                                    sendObjectSpawn(pokeball);
                                }
                            }
                        }
                    }
                }
            }
        }

        private void sendObjectSpawn(WorldObject object) {
            if (
                GameContext.get().getGameClient() == null || !GameContext.get().isMultiplayer()) return;

            NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
            update.objectId = object.getId();
            update.type = NetworkProtocol.NetworkObjectUpdateType.ADD;
            update.data = object.getSerializableData();


            GameContext.get().getGameClient().sendWorldObjectUpdate(update);
        }

        public WorldObject createObject(ObjectType type, float x, float y) {
            TextureRegion texture = objectTextures.get(type);
            if (texture == null) {
                throw new IllegalStateException("No texture found for object type: " + type);
            }

            int tileX = (int) (x / World.TILE_SIZE);
            int tileY = (int) (y / World.TILE_SIZE);

            return new WorldObject(tileX, tileY, texture, type);
        }


    }

}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/overworld/WorldObjectOperation.java
================
package io.github.pokemeetup.system.gameplay.overworld;

public class WorldObjectOperation {
    public enum OperationType {
        ADD,
        REMOVE,
        UPDATE,
        PERSIST
    }

    public OperationType type;

    public WorldObjectOperation(OperationType type) {
        this.type = type;
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/PlayerAnimations.java
================
package io.github.pokemeetup.system.gameplay;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

public class PlayerAnimations {
    // Base movement time (used for movement calculations)
    public static final float BASE_MOVE_TIME = 0.25f;
    public static final float RUN_SPEED_MULTIPLIER = 2.5f;
    // Define slow durations for movement animations
    public static final float SLOW_WALK_ANIMATION_DURATION = BASE_MOVE_TIME * 1.4f;
    // Per–frame durations (4 frames per animation)
    public static final float SLOW_RUN_ANIMATION_DURATION = (BASE_MOVE_TIME / RUN_SPEED_MULTIPLIER) * 2f;
    public static final float WALK_FRAME_DURATION = 0.12f;
    public static final float RUN_FRAME_DURATION  = 0.08f;


    // Action animation durations (punch/chop)
    public static final float PUNCH_ANIMATION_DURATION = 0.8f;
    public static final float PUNCH_FRAME_DURATION = PUNCH_ANIMATION_DURATION / 4f;
    public static final float CHOP_ANIMATION_DURATION = 0.6f;
    public static final float CHOP_FRAME_DURATION = CHOP_ANIMATION_DURATION / 4f;
    // The character type ("boy" or "girl")
    private final String characterType;
    private volatile boolean isInitialized = false;
    private volatile boolean isDisposed = false;
    // Standing frames for each direction (up, down, left, right)
    private TextureRegion[] standingFrames;
    // Movement animations (non-looping so that exactly 4 frames play per step)
    private Animation<TextureRegion> walkUpAnimation;
    private Animation<TextureRegion> walkDownAnimation;
    private Animation<TextureRegion> walkLeftAnimation;
    private Animation<TextureRegion> walkRightAnimation;
    private Animation<TextureRegion> runUpAnimation;
    private Animation<TextureRegion> runDownAnimation;
    private Animation<TextureRegion> runLeftAnimation;
    private Animation<TextureRegion> runRightAnimation;
    // Action animations for punch/chop (non-looping)
    private Animation<TextureRegion>[] punchAnimations;
    private Animation<TextureRegion>[] chopAnimations;
    // Flags and timers for actions
    private boolean isPunching = false;
    private boolean isChopping = false;
    private float punchAnimationTime = 0f;
    private float chopAnimationTime = 0f;
    // –– Constructors ––
    public PlayerAnimations(String characterType) {
        this.characterType = characterType != null ? characterType.toLowerCase() : "boy";
        loadAnimations(this.characterType);
    }

    public PlayerAnimations() {
        this("boy");
    }

    /**
     * Returns the appropriate movement frame given the progress (0.0 to 1.0) of a tile move.
     * When progress is 0 or 1, the standing frame is returned.
     * For intermediate progress, one of the stepping frames is chosen.
     */
    public TextureRegion getMovementFrameForProgress(String direction, boolean isRunning, float progress) {
        // clamp in [0,1]
        progress = MathUtils.clamp(progress, 0f, 1f);

        // If the move is fully complete, show the standing frame.
        if (progress >= 1f) {
            return getStandingFrame(direction);
        }

        // The 4-step cycle is [ frames[0], frames[1], frames[2], frames[3] ] = [1,2,3,2].
        // We'll map these to intervals of size 0.25 each:
        //   0.00–0.25 → frames[0]  (the first foot-lift)
        //   0.25–0.50 → frames[1]
        //   0.50–0.75 → frames[2]
        //   0.75–1.00 → frames[3]
        float segment = 1f / 4f; // = 0.25
        int frameIdx;
        if (progress < segment) {
            frameIdx = 0;
        } else if (progress < 2f * segment) {
            frameIdx = 1;
        } else if (progress < 3f * segment) {
            frameIdx = 2;
        } else {
            frameIdx = 3;
        }

        // Each frame is spaced out by either RUN_FRAME_DURATION or WALK_FRAME_DURATION.
        float frameDuration = isRunning ? RUN_FRAME_DURATION : WALK_FRAME_DURATION;
        float timeForFrame = frameIdx * frameDuration;
        Animation<TextureRegion> anim = getAnimation(direction, isRunning);
        return anim.getKeyFrame(timeForFrame, false);
    }


    public Animation<TextureRegion> getMovementAnimation(String direction, boolean isRunning) {
        return getAnimation(direction, isRunning);  // getAnimation() is already defined privately.
    }

    public void startPunching() {
        isPunching = true;
        punchAnimationTime = 0f;
        GameLogger.info("Started punching animation");
    }

    public void stopPunching() {
        isPunching = false;
        punchAnimationTime = 0f;
        if (punchAnimations != null) {
            for (Animation<TextureRegion> anim : punchAnimations) {
                if (anim != null) {
                    anim.setPlayMode(Animation.PlayMode.NORMAL);
                }
            }
        }
        GameLogger.info("Punching animation stopped");
    }

    public void startChopping() {
        isChopping = true;
        chopAnimationTime = 0f;
        GameLogger.info("Started chopping animation");
    }

    public void stopChopping() {
        isChopping = false;
        chopAnimationTime = 0f;
        if (chopAnimations != null) {
            for (Animation<TextureRegion> anim : chopAnimations) {
                if (anim != null) {
                    anim.setPlayMode(Animation.PlayMode.NORMAL);
                }
            }
        }
        GameLogger.info("Chopping animation stopped");
    }

    /**
     * Returns the current frame based on the current action (chop, punch, or movement).
     * For movement, the caller must supply an animation time based on movement progress.
     */
    public TextureRegion getCurrentFrame(String direction, boolean isMoving, boolean isRunning, float time) {
        if (!isInitialized || isDisposed) {
            loadAnimations(characterType);
        }
        // 1) If chopping is active, it takes the highest priority.
        if (isChopping) {
            int dirIndex = getDirectionIndex(direction);
            if (chopAnimations != null && dirIndex >= 0 && dirIndex < chopAnimations.length) {
                chopAnimationTime += Gdx.graphics.getDeltaTime();
                // Use looping mode for chop animation as well.
                TextureRegion frame = chopAnimations[dirIndex].getKeyFrame(chopAnimationTime, true);
                return (frame != null) ? frame : getStandingFrame(direction);
            }
        }
        // 2) If punching is active.
        if (isPunching) {
            int dirIndex = getDirectionIndex(direction);
            if (punchAnimations != null && dirIndex >= 0 && dirIndex < punchAnimations.length) {
                punchAnimationTime += Gdx.graphics.getDeltaTime();
                // Use looping mode for punch animation as well.
                TextureRegion frame = punchAnimations[dirIndex].getKeyFrame(punchAnimationTime, true);
                return (frame != null) ? frame : getStandingFrame(direction);
            }
        }
        // 3) If not moving, simply return the standing frame.
        if (!isMoving) {
            return getStandingFrame(direction);
        }
        // 4) Otherwise, for movement animations use the provided time.
        Animation<TextureRegion> currentAnimation = getAnimation(direction, isRunning);
        // *** The key change: set looping to 'true' so the walk/run animation cycles continuously.
        return currentAnimation.getKeyFrame(time, true);
    }

    // --- New getters to expose action state ---
    public boolean isChopping() {
        return isChopping;
    }

    public boolean isPunching() {
        return isPunching;
    }

    @SuppressWarnings("unchecked")
    private synchronized void loadAnimations(String characterType) {
        try {
            TextureAtlas atlas;
            if ("girl".equalsIgnoreCase(characterType)) {
                atlas = TextureManager.getGirl();
            } else {
                atlas = TextureManager.getBoy();
            }
            if (atlas == null) {
                throw new RuntimeException("TextureAtlas is null for character type: " + characterType);
            }
            // Prepare arrays
            chopAnimations = new Animation[4];
            punchAnimations = new Animation[4];
            standingFrames = new TextureRegion[4];
            String[] directions = {"up", "down", "left", "right"};

            // Load Chop animations (4 frames each)
            int[][] chopIndices = {
                {1, 3, 0, 2},
                {2, 0, 1, 3},
                {1, 3, 0, 2},
                {1, 3, 0, 2}
            };
            for (int i = 0; i < directions.length; i++) {
                TextureRegion[] frames = new TextureRegion[4];
                for (int f = 0; f < 4; f++) {
                    TextureRegion reg = atlas.findRegion(characterType + "_axe_" + directions[i], chopIndices[i][f]);
                    if (reg == null) {
                        throw new RuntimeException("Missing chop frame: " + characterType + "_axe_" + directions[i] + " idx=" + chopIndices[i][f]);
                    }
                    frames[f] = reg;
                }
                chopAnimations[i] = new Animation<>(CHOP_FRAME_DURATION, frames);
                chopAnimations[i].setPlayMode(Animation.PlayMode.NORMAL);
            }

            // Load Punch animations (4 frames each)
            int[][] punchIndices = {
                {1, 3, 2, 0},
                {1, 3, 0, 2},
                {0, 1, 3, 2},
                {1, 3, 0, 2}
            };
            for (int i = 0; i < directions.length; i++) {
                TextureRegion[] frames = new TextureRegion[4];
                for (int f = 0; f < 4; f++) {
                    TextureRegion reg = atlas.findRegion(characterType + "_punch_" + directions[i], punchIndices[i][f]);
                    if (reg == null) {
                        throw new RuntimeException("Missing punch frame: " + characterType + "_punch_" + directions[i] + " idx=" + punchIndices[i][f]);
                    }
                    frames[f] = reg;
                }
                punchAnimations[i] = new Animation<>(PUNCH_FRAME_DURATION, frames);
                punchAnimations[i].setPlayMode(Animation.PlayMode.NORMAL);
            }

            int[][] walkIndices = {
                {1, 2, 3, 2},
                {1, 2, 3, 2},
                {1, 2, 3, 2},
                {1, 2, 3, 2}
            };
            for (int i = 0; i < directions.length; i++) {
                TextureRegion[] frames = new TextureRegion[4];
                for (int f = 0; f < 4; f++) {
                    TextureRegion reg = atlas.findRegion(characterType + "_walk_" + directions[i], walkIndices[i][f]);
                    if (reg == null) {
                        throw new RuntimeException("Missing walk frame: " + characterType + "_walk_" + directions[i] + " idx=" + walkIndices[i][f]);
                    }
                    frames[f] = reg;
                }
                Animation<TextureRegion> walkAnim = new Animation<>(WALK_FRAME_DURATION, frames);
                walkAnim.setPlayMode(Animation.PlayMode.NORMAL);
                assignWalkAnimation(i, walkAnim);
                if (standingFrames[i] == null) {
                    standingFrames[i] = frames[3];
                }
            }

            int[][] runIndices = {
                {1, 2, 3, 2},
                {1, 2, 3, 2},
                {1, 2, 3, 2},
                {1, 2, 3, 2}
            };
            for (int i = 0; i < directions.length; i++) {
                TextureRegion[] frames = new TextureRegion[4];
                for (int f = 0; f < 4; f++) {
                    TextureRegion reg = atlas.findRegion(characterType + "_run_" + directions[i], runIndices[i][f]);
                    if (reg == null) {
                        throw new RuntimeException("Missing run frame: " + characterType + "_run_" + directions[i] + " idx=" + runIndices[i][f]);
                    }
                    frames[f] = reg;
                }
                Animation<TextureRegion> runAnim = new Animation<>(RUN_FRAME_DURATION, frames);
                runAnim.setPlayMode(Animation.PlayMode.NORMAL);
                assignRunAnimation(i, runAnim);
            }

            isInitialized = true;
            isDisposed = false;
        } catch (Exception e) {
            GameLogger.error("Failed to load animations: " + e.getMessage());
            isInitialized = false;
            throw new RuntimeException("Animation loading failed", e);
        }
    }

    private void assignWalkAnimation(int index, Animation<TextureRegion> animation) {
        switch (index) {
            case 0:
                walkUpAnimation = animation;
                break;
            case 1:
                walkDownAnimation = animation;
                break;
            case 2:
                walkLeftAnimation = animation;
                break;
            case 3:
                walkRightAnimation = animation;
                break;
        }
    }

    private void assignRunAnimation(int index, Animation<TextureRegion> animation) {
        switch (index) {
            case 0:
                runUpAnimation = animation;
                break;
            case 1:
                runDownAnimation = animation;
                break;
            case 2:
                runLeftAnimation = animation;
                break;
            case 3:
                runRightAnimation = animation;
                break;
        }
    }

    /**
     * Returns an index (0: up, 1: down, 2: left, 3: right) for a given direction.
     */
    private int getDirectionIndex(String dir) {
        if (dir == null) return 1;  // default to "down"
        switch (dir.toLowerCase()) {
            case "up":
                return 0;
            case "left":
                return 2;
            case "right":
                return 3;
            default:
                return 1;
        }
    }

    private Animation<TextureRegion> getAnimation(String direction, boolean isRunning) {
        int dirIndex = getDirectionIndex(direction);
        switch (dirIndex) {
            case 0:
                return isRunning ? runUpAnimation : walkUpAnimation;
            case 1:
                return isRunning ? runDownAnimation : walkDownAnimation;
            case 2:
                return isRunning ? runLeftAnimation : walkLeftAnimation;
            case 3:
                return isRunning ? runRightAnimation : walkRightAnimation;
        }
        return walkDownAnimation;
    }

    public TextureRegion getStandingFrame(String direction) {
        if (!isInitialized || isDisposed) {
            loadAnimations(characterType);
        }
        return standingFrames[getDirectionIndex(direction)];
    }

    public synchronized void dispose() {
        isDisposed = true;
        isInitialized = false;
    }

    public boolean isDisposed() {
        return isDisposed;
    }

    public String getCharacterType() {
        return characterType;
    }
}

================
File: src/main/java/io/github/pokemeetup/system/gameplay/PokemonAnimations.java
================
package io.github.pokemeetup.system.gameplay;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.utils.GameLogger;

public class PokemonAnimations {
    public static final float IDLE_BOUNCE_DURATION = 1.0f;

    private static final int SPRITE_SHEET_SIZE = 256;
    private static final int FRAMES_PER_DIRECTION = 4;
    private static final int FRAME_WIDTH = SPRITE_SHEET_SIZE / FRAMES_PER_DIRECTION;  // 64
    private static final int FRAME_HEIGHT = SPRITE_SHEET_SIZE / FRAMES_PER_DIRECTION; // 64
    private static final float FRAME_DURATION = 0.2f;
    // The first frame in each row is used as the “standing” (idle) frame.
    private final TextureRegion[] standingFrames;
    // Animations for each direction (rows in the sprite sheet)
    private Animation<TextureRegion> walkDownAnimation;  // Row 0
    private Animation<TextureRegion> walkLeftAnimation;  // Row 1
    private Animation<TextureRegion> walkRightAnimation; // Row 2
    private Animation<TextureRegion> walkUpAnimation;    // Row 3
    // Internal clock that tracks animation progress.
    private float stateTime;
    private TextureRegion defaultFrame;

    // Used to track whether the animation should be running.
    private boolean isMoving;
    private String currentDirection;
    private boolean isInitialized;

    public PokemonAnimations(TextureRegion spriteSheet) {
        this.standingFrames = new TextureRegion[4];
        this.stateTime = 0f;

        if (spriteSheet == null) {
            GameLogger.error("Sprite sheet is null");
            createDefaultFrame();
            return;
        }

        try {
            if (spriteSheet.getRegionWidth() != SPRITE_SHEET_SIZE ||
                spriteSheet.getRegionHeight() != SPRITE_SHEET_SIZE) {
                GameLogger.error(String.format(
                    "Invalid sprite sheet dimensions. Expected %dx%d, got %dx%d",
                    SPRITE_SHEET_SIZE, SPRITE_SHEET_SIZE,
                    spriteSheet.getRegionWidth(), spriteSheet.getRegionHeight()
                ));
            }
            initializeAnimations(spriteSheet);
            isInitialized = true;
        } catch (Exception e) {
            GameLogger.error("Failed to initialize animations: " + e.getMessage());
            e.printStackTrace();
            createDefaultFrame();
        }
    }

    public boolean isMoving() {
        return isMoving;
    }

    private void initializeAnimations(TextureRegion spriteSheet) {
        // Split the sprite sheet into individual frames.
        TextureRegion[][] allFrames = new TextureRegion[4][FRAMES_PER_DIRECTION];
        for (int row = 0; row < 4; row++) {
            for (int col = 0; col < FRAMES_PER_DIRECTION; col++) {
                int x = col * FRAME_WIDTH;
                int y = row * FRAME_HEIGHT;
                allFrames[row][col] = new TextureRegion(spriteSheet, x, y, FRAME_WIDTH, FRAME_HEIGHT);

                // Store the first frame of each row for the idle/standing pose.
                if (col == 0) {
                    standingFrames[row] = new TextureRegion(allFrames[row][0]);
                }
            }
        }

        // Create the walking animations.
        walkDownAnimation = new Animation<>(FRAME_DURATION, allFrames[0]);
        walkLeftAnimation = new Animation<>(FRAME_DURATION, allFrames[1]);
        walkRightAnimation = new Animation<>(FRAME_DURATION, allFrames[2]);
        walkUpAnimation = new Animation<>(FRAME_DURATION, allFrames[3]);

        defaultFrame = standingFrames[0];
    }

    private void createDefaultFrame() {
        Pixmap pixmap = new Pixmap(FRAME_WIDTH, FRAME_HEIGHT, Pixmap.Format.RGBA8888);
        pixmap.setColor(Color.MAGENTA);
        pixmap.fill();
        Texture texture = new Texture(pixmap);
        pixmap.dispose();
        defaultFrame = new TextureRegion(texture);
        for (int i = 0; i < 4; i++) {
            standingFrames[i] = new TextureRegion(defaultFrame);
        }
    }

    /**
     * Retrieves the current frame. Note that the animation’s internal clock (stateTime)
     * is updated via the update() method (not here).
     *
     * @param direction The current facing direction ("up", "down", etc.).
     * @param isMoving  Whether the Pokémon is moving.
     * @return The TextureRegion to render.
     */
    public TextureRegion getCurrentFrame(String direction, boolean isMoving) {
        if (!isInitialized) {
            return defaultFrame;
        }

        this.isMoving = isMoving;
        this.currentDirection = direction;

        if (isMoving) {
            Animation<TextureRegion> currentAnimation = getAnimationForDirection(direction);
            return currentAnimation.getKeyFrame(stateTime, true);
        } else {
            return getStandingFrame(direction);
        }
    }

    private TextureRegion getStandingFrame(String direction) {
        switch (direction.toLowerCase()) {
            case "down":
                return standingFrames[0];
            case "left":
                return standingFrames[1];
            case "right":
                return standingFrames[2];
            case "up":
                return standingFrames[3];
            default:
                return standingFrames[0]; // default to down
        }
    }

    private Animation<TextureRegion> getAnimationForDirection(String direction) {
        switch (direction.toLowerCase()) {
            case "down":
                return walkDownAnimation;
            case "left":
                return walkLeftAnimation;
            case "right":
                return walkRightAnimation;
            case "up":
                return walkUpAnimation;
            default:
                return walkDownAnimation;
        }
    }

    public void startMoving(String direction) {
        if (!isMoving || !direction.equals(currentDirection)) {
            this.isMoving = true;
            this.currentDirection = direction;
        }
    }

    public void stopMoving() {
        this.isMoving = false;
    }

    /**
     * Updates the animation’s state time. When moving, the animation plays at normal speed.
     * When idle, it can be slowed down for a more subtle effect.
     *
     * @param delta Time elapsed since the last update.
     */
    public void update(float delta) {
        if (isMoving) {
            stateTime += delta;
        } else {
            // When idle, update stateTime more slowly.
            stateTime += delta * 0.5f;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/GlobalInputProcessor.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.Input;
import com.badlogic.gdx.InputAdapter;
import io.github.pokemeetup.utils.GameLogger;

public class GlobalInputProcessor extends InputAdapter {
    private final InputManager inputManager;

    public GlobalInputProcessor(InputManager inputManager) {
        this.inputManager = inputManager;
    }

    @Override
    public boolean keyDown(int keycode) {
        InputManager.UIState currentState = inputManager.getCurrentState();

        // Handle ESCAPE key to toggle game menu
        if (keycode == Input.Keys.ESCAPE) {
            if (currentState != InputManager.UIState.MENU) {
                inputManager.setUIState(InputManager.UIState.MENU);
            } else {
                inputManager.setUIState(InputManager.UIState.NORMAL);
            }
            return true; // Event handled
        }

        // Handle 'E' key to toggle inventory
        if (keycode == Input.Keys.E) {
            if (currentState == InputManager.UIState.INVENTORY ||
                currentState == InputManager.UIState.CRAFTING ||
                currentState == InputManager.UIState.CHEST_SCREEN) {
                inputManager.setUIState(InputManager.UIState.NORMAL);
            } else if (currentState == InputManager.UIState.NORMAL) {
                inputManager.setUIState(InputManager.UIState.INVENTORY);
            }
            return true; // Event handled
        }

        // Do not consume movement keys
        if (keycode == Input.Keys.W || keycode == Input.Keys.A ||
            keycode == Input.Keys.S || keycode == Input.Keys.D ||
            keycode == Input.Keys.UP || keycode == Input.Keys.DOWN ||
            keycode == Input.Keys.LEFT || keycode == Input.Keys.RIGHT) {
            return false; // Let InputHandler process these
        }

        return false; // Do not consume other keys
    }

    @Override
    public boolean keyUp(int keycode) {
        // Do not handle keyUp events for ESCAPE and E keys
        return false;
    }
}

================
File: src/main/java/io/github/pokemeetup/system/InputHandler.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.InputAdapter;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Stage;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.screens.otherui.BuildModeUI;
import io.github.pokemeetup.screens.otherui.PokemonPartyWindow;
import io.github.pokemeetup.system.battle.BattleInitiationHandler;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.PlayerAnimations;
import io.github.pokemeetup.system.gameplay.inventory.ChestInteractionHandler;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.keybinds.KeyBinds;
import io.github.pokemeetup.utils.GameLogger;

import java.util.List;
import java.util.UUID;

public class InputHandler extends InputAdapter {

    // Constants for chopping / swinging
    private static final float SWING_INTERVAL = 0.5f;
    private static final int DURABILITY_LOSS_PER_SWING = 1;
    private static final float TREE_CHOP_WITH_AXE_TIME = 2.0f;
    private static final float TREE_CHOP_WITHOUT_AXE_TIME = 5.0f;
    private static final float CHOP_SOUND_INTERVAL_WITH_AXE = 0.6f;
    private static final float CHOP_SOUND_INTERVAL_WITHOUT_AXE = 0.6f;

    // References to other systems
    private boolean isChoppingOrBreaking = false;
    private float breakProgress = 0f;
    private float lastSwingSoundTime = 0f;
    private WorldObject targetObject = null;
    private PlaceableBlock targetBlock = null;
    private boolean hasAxe = false;
    private final PickupActionHandler pickupHandler;
    private final BattleInitiationHandler battleInitiationHandler;
    private final GameScreen gameScreen;
    private final ChestInteractionHandler chestHandler;
    private final InputManager inputManager;

    // Movement key flags
    private boolean upPressed, downPressed, leftPressed, rightPressed;

    // Chopping / punching / breaking flags and progress
    private boolean isChopping = false;    // true while a chop action is underway
    private boolean isPunching = false;    // true if punching (when no axe)
    private boolean isBreaking = false;    // for block breaking
    // New flag to mark that the chopping action has reached the required progress
    private boolean chopComplete = false;

    private float chopProgress = 0f;
    private float swingTimer = 0f;
    private float lastChopSoundTime = 0f;
    private float lastBreakSoundTime = 0f;


    // The current target for chopping (e.g. a tree) or breaking
    private PokemonPartyWindow partyWindow;

    public InputHandler(
        PickupActionHandler pickupHandler,
        BattleInitiationHandler battleInitiationHandler,
        GameScreen gameScreen,
        ChestInteractionHandler chestHandler,
        InputManager inputManager
    ) {
        this.pickupHandler = pickupHandler;
        this.battleInitiationHandler = battleInitiationHandler;
        this.gameScreen = gameScreen;
        this.chestHandler = chestHandler;
        this.inputManager = inputManager;
    }

    /************************************************************************
     *  Interaction / chest / crafting / build logic
     ************************************************************************/
    public void handleInteraction() {
        GameLogger.info("handleInteraction() called");
        if (chestHandler.isChestOpen()) {
            GameLogger.info("Chest is already open");
            return;
        }
        if (chestHandler.canInteractWithChest()) {
            GameLogger.info("Interacting with chest");
            handleChestInteraction();
            return;
        }
        if (GameContext.get().getPlayer().isBuildMode()) {
            GameLogger.info("Player is in build mode, handling block placement");
            handleBlockPlacement();
            return;
        }
        if (canInteractWithCraftingTable()) {
            GameLogger.info("Interacting with crafting table");
            handleCraftingTableInteraction();
            return;
        }
        GameLogger.info("Handling pickup action");
        pickupHandler.handlePickupAction();
        GameLogger.info("Attempting to initiate battle");
        battleInitiationHandler.handleBattleInitiation();
    }

    private void handleChestInteraction() {
        if (chestHandler.isChestOpen()) {
            GameLogger.info("Chest is already open, not handling interaction");
            return;
        }
        if (chestHandler.canInteractWithChest()) {
            Vector2 chestPos = chestHandler.getCurrentChestPosition();
            PlaceableBlock chestBlock = GameContext.get().getWorld().getBlockManager()
                .getBlockAt((int) chestPos.x, (int) chestPos.y);
            if (chestBlock != null && chestBlock.getType() == PlaceableBlock.BlockType.CHEST) {
                chestBlock.setChestOpen(true);
                ChestData chestData = chestBlock.getChestData();
                chestHandler.setChestOpen(true);

                GameContext.get().getGameScreen().openChestScreen(chestPos, chestData);
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.CHEST_OPEN);
            } else {
                GameLogger.error("No chest block found at position: " + chestPos);
            }
        }
    }

    void handleBlockPlacement() {
        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();
        switch (GameContext.get().getPlayer().getDirection()) {
            case "up":
                targetY++;
                break;
            case "down":
                targetY--;
                break;
            case "left":
                targetX--;
                break;
            case "right":
                targetX++;
                break;
        }
        BuildModeUI buildUI = GameContext.get().getBuildModeUI();
        if (buildUI.isInBuildingMode()) {
            if (buildUI.tryPlaceBuilding(targetX, targetY)) {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_PLACE_0);
                GameLogger.info("Building placed at " + targetX + "," + targetY);
            }
        } else {
            if (buildUI.tryPlaceBlock(targetX, targetY)) {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_PLACE_0);
                GameLogger.info("Block placed at " + targetX + "," + targetY);
            }
        }
    }

    private boolean canInteractWithCraftingTable() {
        if (GameContext.get().getPlayer() == null || GameContext.get().getPlayer().getWorld() == null) {
            GameLogger.info("Cannot interact: player or world is null");
            return false;
        }
        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();
        String direction = GameContext.get().getPlayer().getDirection();
        switch (direction) {
            case "up":
                targetY++;
                break;
            case "down":
                targetY--;
                break;
            case "left":
                targetX--;
                break;
            case "right":
                targetX++;
                break;
        }
        PlaceableBlock block = GameContext.get().getPlayer().getWorld().getBlockManager().getBlockAt(targetX, targetY);
        return (block != null && block.getType() == PlaceableBlock.BlockType.CRAFTINGTABLE);
    }

    private void handleCraftingTableInteraction() {
        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();
        switch (GameContext.get().getPlayer().getDirection()) {
            case "up":
                targetY++;
                break;
            case "down":
                targetY--;
                break;
            case "left":
                targetX--;
                break;
            case "right":
                targetX++;
                break;
        }
        Vector2 craftingTablePosition = new Vector2(targetX, targetY);
        gameScreen.openExpandedCrafting(craftingTablePosition);
    }

    /************************************************************************
     *  Movement key handling
     ************************************************************************/
    public void moveUp(boolean pressed) {
        upPressed = pressed;
    }

    public void moveDown(boolean pressed) {
        downPressed = pressed;
    }

    public void moveLeft(boolean pressed) {
        leftPressed = pressed;
    }

    public void moveRight(boolean pressed) {
        rightPressed = pressed;
    }

    /************************************************************************
     *  KeyDown / KeyUp
     ************************************************************************/
    // Replace the keyDown method in InputHandler with this updated version:
    @Override
    public boolean keyDown(int keycode) {
        InputManager.UIState currentState = inputManager.getCurrentState();

        if (keycode == KeyBinds.getBinding(KeyBinds.MOVE_UP) ||
            keycode == KeyBinds.getBinding(KeyBinds.MOVE_DOWN) ||
            keycode == KeyBinds.getBinding(KeyBinds.MOVE_LEFT) ||
            keycode == KeyBinds.getBinding(KeyBinds.MOVE_RIGHT)) {
            GameContext.get().getPlayer().setInputHeld(true);
        }
        // Hotbar selection via number keys
        if (currentState == InputManager.UIState.NORMAL && keycode >= Input.Keys.NUM_1 && keycode <= Input.Keys.NUM_9) {
            int slot = keycode - Input.Keys.NUM_1;
            GameContext.get().getPlayer().getHotbarSystem().setSelectedSlot(slot);
            return true;
        }

        if (keycode == Input.Keys.O && !isChopping && !isPunching) {
            ItemData selectedItem = GameContext.get().getPlayer().getHotbarSystem().getSelectedItem();
            if (selectedItem != null) dropItem(selectedItem);
            return true;
        }
        if (currentState == InputManager.UIState.BUILD_MODE && keycode == Input.Keys.G) {
            GameContext.get().getBuildModeUI().toggleBuildingMode();
            return true;
        }

        // In build mode, numbers select from the active hotbar
        if (currentState == InputManager.UIState.BUILD_MODE && keycode >= Input.Keys.NUM_1 && keycode <= Input.Keys.NUM_9) {
            int slot = keycode - Input.Keys.NUM_1;
            BuildModeUI buildUI = GameContext.get().getBuildModeUI();
            if (buildUI.isInBuildingMode()) {
                buildUI.buildingHotbar.selectSlot(slot);
            } else {
                buildUI.selectSlot(slot);
            }
            return true;
        }

        // In build mode, handle block flipping with R
        if (currentState == InputManager.UIState.BUILD_MODE) {
            if (keycode == Input.Keys.R) {
                handleBlockFlip();
                return true;
            }
        }

        // Only process input in NORMAL or BUILD_MODE
        if (currentState != InputManager.UIState.NORMAL &&
            currentState != InputManager.UIState.BUILD_MODE) {
            return false;
        }

        // Handle customizable inputs
        if (keycode == KeyBinds.getBinding(KeyBinds.INTERACT)) {
            handleInteraction();
            return true;
        }

        if (keycode == KeyBinds.getBinding(KeyBinds.BUILD_MODE)) {
            toggleBuildMode();
            return true;
        }

        if (!isChopping && !isPunching) {
            if (keycode == KeyBinds.getBinding(KeyBinds.MOVE_UP)) {
                moveUp(true);
                GameContext.get().getPlayer().setInputHeld(true);
                return true;
            }
            if (keycode == KeyBinds.getBinding(KeyBinds.MOVE_DOWN)) {
                moveDown(true);
                GameContext.get().getPlayer().setInputHeld(true);
                return true;
            }
            if (keycode == KeyBinds.getBinding(KeyBinds.MOVE_LEFT)) {
                moveLeft(true);
                GameContext.get().getPlayer().setInputHeld(true);
                return true;
            }
            if (keycode == KeyBinds.getBinding(KeyBinds.MOVE_RIGHT)) {
                moveRight(true);
                GameContext.get().getPlayer().setInputHeld(true);
                return true;
            }
        }

        if (keycode == KeyBinds.getBinding(KeyBinds.SPRINT)) {
            GameContext.get().getPlayer().setRunning(true);
            return true;
        }

        if (keycode == KeyBinds.getBinding(KeyBinds.ACTION)) {
            startChopOrPunch();
            return true;
        }

        if (currentState == InputManager.UIState.BUILD_MODE &&
            keycode >= Input.Keys.NUM_1 && keycode <= Input.Keys.NUM_9) {
            int slot = keycode - Input.Keys.NUM_1;
            GameContext.get().getBuildModeUI().selectSlot(slot);
            GameLogger.info("Hotbar Slot Selected: " + slot);
            return true;
        }

        return false;
    }


    private void closePartyWindow() {
        if (partyWindow != null) {
            partyWindow.remove(); // Remove the actor from its parent stage.
            partyWindow = null;
        }
    }



    // Similarly update keyUp to use KeyBinds:
    @Override
    public boolean keyUp(int keycode) {
        if (keycode == KeyBinds.getBinding(KeyBinds.MOVE_UP) ||
            keycode == KeyBinds.getBinding(KeyBinds.MOVE_DOWN) ||
            keycode == KeyBinds.getBinding(KeyBinds.MOVE_LEFT) ||
            keycode == KeyBinds.getBinding(KeyBinds.MOVE_RIGHT)) {
            GameContext.get().getPlayer().setInputHeld(false);
            GameContext.get().getPlayer().clearBufferedDirection();
        }
        InputManager.UIState currentState = inputManager.getCurrentState();
        if (currentState != InputManager.UIState.NORMAL &&
            currentState != InputManager.UIState.BUILD_MODE) {
            return false;
        }

        if (keycode == KeyBinds.getBinding(KeyBinds.MOVE_UP)) {
            moveUp(false);
            return true;
        }
        if (keycode == KeyBinds.getBinding(KeyBinds.MOVE_DOWN)) {
            moveDown(false);

            return true;
        }
        if (keycode == KeyBinds.getBinding(KeyBinds.MOVE_LEFT)) {
            moveLeft(false);
            return true;
        }
        if (keycode == KeyBinds.getBinding(KeyBinds.MOVE_RIGHT)) {
            moveRight(false);
            return true;
        }
        if (keycode == KeyBinds.getBinding(KeyBinds.SPRINT)) {
            GameContext.get().getPlayer().setRunning(false);
            return true;
        }
        if (keycode == KeyBinds.getBinding(KeyBinds.ACTION)) {
            // Releasing the key stops the chopping action.
            stopChopOrPunch();
            return true;
        }
        return false;
    }

    private void dropItem(ItemData itemData) {
        if (itemData == null) return;
        Player player = GameContext.get().getPlayer();
        if (player == null) return;
        float dropX = player.getX();
        float dropY = player.getY();
        switch (player.getDirection()) {
            case "up":
                dropY += 32;
                break;
            case "down":
                dropY -= 32;
                break;
            case "left":
                dropX -= 32;
                break;
            case "right":
                dropX += 32;
                break;
        }
        if (player.getInventory().removeItem(itemData)) {
            player.getHotbarSystem().updateHotbar();
            if (GameContext.get().isMultiplayer()) {
                GameContext.get().getGameClient().sendItemDrop(itemData, new Vector2(dropX, dropY));
            } else {
                GameContext.get().getWorld().getItemEntityManager().spawnItemEntity(itemData, dropX, dropY);
            }
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP_OW);
        }
    }


    public void toggleBuildMode() {
        // Switch the UI state between NORMAL and BUILD_MODE
        if (inputManager.getCurrentState() == InputManager.UIState.BUILD_MODE) {
            inputManager.setUIState(InputManager.UIState.NORMAL);
            GameContext.get().getPlayer().setBuildMode(false);
            if (gameScreen.getHouseToggleButton() != null) {
                gameScreen.getHouseToggleButton().setVisible(false);
            }
        } else {
            inputManager.setUIState(InputManager.UIState.BUILD_MODE);
            GameContext.get().getPlayer().setBuildMode(true);
            if (gameScreen.getHouseToggleButton() != null) {
                gameScreen.getHouseToggleButton().setVisible(true);
            }
        }
    }


    /**
     * Initiates a chop/punch/break action. It identifies a target and sets the state.
     * The actual progress is handled in the update loop.
     */
    public void startChopOrPunch() {
        if (isChoppingOrBreaking) return; // Action already in progress

        // Find a target (prioritize blocks, then objects)
        targetBlock = findBreakableBlock();
        if (targetBlock != null) {
            isChoppingOrBreaking = true;
        } else {
            targetObject = findChoppableObject();
            if (targetObject != null) {
                isChoppingOrBreaking = true;
            }
        }

        if (isChoppingOrBreaking) {
            // A target was found, initialize state
            breakProgress = 0f;
            lastSwingSoundTime = 0f;
            checkForAxe();

            // Start animation locally
            PlayerAnimations anims = GameContext.get().getPlayer().getAnimations();
            if (hasAxe) {
                anims.startChopping();
            } else {
                anims.startPunching();
            }

            // Send network message to start animation for other players
            if (GameContext.get().isMultiplayer()) {
                NetworkProtocol.PlayerAction action = new NetworkProtocol.PlayerAction();
                action.playerId = GameContext.get().getPlayer().getUsername();
                action.actionType = hasAxe ? NetworkProtocol.ActionType.CHOP_START : NetworkProtocol.ActionType.PUNCH_START;

                int targetX = targetBlock != null ? (int) targetBlock.getPosition().x : targetObject.getTileX();
                int targetY = targetBlock != null ? (int) targetBlock.getPosition().y : targetObject.getTileY();
                action.tileX = targetX;
                action.tileY = targetY;
                action.direction = GameContext.get().getPlayer().getDirection();

                GameContext.get().getGameClient().sendPlayerAction(action);
            }
        }
    }


    /************************************************************************
     *  Block flipping (in build mode)
     ************************************************************************/
    private void handleBlockFlip() {
        if (!GameContext.get().getPlayer().isBuildMode()) {
            GameLogger.info("Not in build mode, can't flip");
            return;
        }

        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();
        switch (GameContext.get().getPlayer().getDirection()) {
            case "up":
                targetY++;
                break;
            case "down":
                targetY--;
                break;
            case "left":
                targetX--;
                break;
            case "right":
                targetX++;
                break;
        }

        PlaceableBlock block = GameContext.get().getWorld().getBlockManager().getBlockAt(targetX, targetY);
        if (block == null) {
            GameLogger.info("No block found at target position");
            return;
        }
        if (!block.getType().isFlippable) {
            GameLogger.info("Block is not flippable: " + block.getType().id);
            return;
        }

        GameLogger.info("Flipping block " + block.getType().id + " at " + targetX + "," + targetY);
        block.toggleFlip();

        // Save updated block in chunk
        Vector2 chunkPos = new Vector2(
            Math.floorDiv(targetX, World.CHUNK_SIZE),
            Math.floorDiv(targetY, World.CHUNK_SIZE)
        );
        Chunk chunk = GameContext.get().getWorld().getChunks().get(chunkPos);
        if (chunk != null) {
            chunk.getBlocks().put(new Vector2(targetX, targetY), block);
            GameContext.get().getWorld().saveChunkData(chunkPos, chunk);
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_PLACE_0);
        } else {
            GameLogger.error("Failed to find chunk for saving flipped block");
        }
    }


    /**
     * Stops any current chop/punch/break action, resetting all related state.
     */
    public void stopChopOrPunch() {
        if (!isChoppingOrBreaking) return;

        isChoppingOrBreaking = false;
        breakProgress = 0f;
        targetObject = null;
        targetBlock = null;

        PlayerAnimations anims = GameContext.get().getPlayer().getAnimations();
        anims.stopChopping();
        anims.stopPunching();

        if (GameContext.get().isMultiplayer()) {
            NetworkProtocol.PlayerAction action = new NetworkProtocol.PlayerAction();
            action.playerId = GameContext.get().getPlayer().getUsername();
            action.actionType = hasAxe ? NetworkProtocol.ActionType.CHOP_STOP : NetworkProtocol.ActionType.PUNCH_STOP;
            GameContext.get().getGameClient().sendPlayerAction(action);
        }
    }
    /**
     * Handles the logic for incrementing break progress while the action key is held.
     */
    private void updateBreakingProgress(float deltaTime) {
        // If the action key is released, stop the process.
        if (!Gdx.input.isKeyPressed(KeyBinds.getBinding(KeyBinds.ACTION))) {
            stopChopOrPunch();
            return;
        }

        // Validate that the target is still in range and exists.
        if (targetBlock != null) {
            if (findBreakableBlock() != targetBlock) {
                stopChopOrPunch();
                return;
            }
        } else if (targetObject != null) {
            if (findChoppableObject() != targetObject) {
                stopChopOrPunch();
                return;
            }
        } else {
            stopChopOrPunch();
            return;
        }

        breakProgress += deltaTime;
        lastSwingSoundTime += deltaTime;

        // Determine required time and sound interval based on target and tool.
        float requiredTime;
        float soundInterval = hasAxe ? CHOP_SOUND_INTERVAL_WITH_AXE : CHOP_SOUND_INTERVAL_WITHOUT_AXE;

        if (targetBlock != null) {
            requiredTime = targetBlock.getType().getBreakTime(hasAxe);
        } else {
            requiredTime = targetObject.getType().getBreakTime(hasAxe);
        }

        // Play sound effect at intervals.
        if (lastSwingSoundTime >= soundInterval) {
            AudioManager.getInstance().playSound(hasAxe ? AudioManager.SoundEffect.BLOCK_BREAK_WOOD : AudioManager.SoundEffect.BLOCK_BREAK_WOOD_HAND);
            lastSwingSoundTime = 0f;
        }

        // Check for completion.
        if (breakProgress >= requiredTime) {
            if (GameContext.get().isMultiplayer()) {
                // In multiplayer, tell the server the action is complete.
                NetworkProtocol.PlayerAction action = new NetworkProtocol.PlayerAction();
                action.playerId = GameContext.get().getPlayer().getUsername();
                action.actionType = NetworkProtocol.ActionType.CHOP_COMPLETE;
                if (targetBlock != null) {
                    action.tileX = (int) targetBlock.getPosition().x;
                    action.tileY = (int) targetBlock.getPosition().y;
                } else {
                    action.tileX = targetObject.getTileX();
                    action.tileY = targetObject.getTileY();
                }
                GameContext.get().getGameClient().sendPlayerAction(action);
            } else {
                // In single-player, destroy the object directly.
                if (targetBlock != null) {
                    destroyBlock(targetBlock);
                } else {
                    destroyObject(targetObject);
                }
            }
            // Stop the action on the client side.
            stopChopOrPunch();
        }
    }

    // This method updates the chopping progress. It now waits for an additional delay equal to the full chop animation duration
    // before calling stopChopOrPunch(), ensuring the full 4-frame chop animation is shown.
    private void updateChopping(float deltaTime) {
        if (!isValidTarget(targetObject)) {
            stopChopOrPunch();
            return;
        }
        chopProgress += deltaTime;
        lastChopSoundTime += deltaTime;
        swingTimer += deltaTime;

        // Determine chop time based on whether the player has an axe.
        ItemData axeItem = hasAxe ? findAxeInInventory() : null;
        float chopTime = (hasAxe && axeItem != null) ? TREE_CHOP_WITH_AXE_TIME : TREE_CHOP_WITHOUT_AXE_TIME;
        float soundInterval = hasAxe ? CHOP_SOUND_INTERVAL_WITH_AXE : CHOP_SOUND_INTERVAL_WITHOUT_AXE;

        if (lastChopSoundTime >= soundInterval) {
            if (hasAxe && axeItem != null) {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);
                if (swingTimer >= SWING_INTERVAL) {
                    handleToolDurabilityPerSwing(axeItem);
                    swingTimer = 0f;
                }
            } else {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD_HAND);
            }
            lastChopSoundTime = 0f;
        }

        // Once chopProgress reaches the required chop time, mark the chop as complete
        if (chopProgress >= chopTime) {
            if (!chopComplete) {
                GameLogger.info("Tree chopped down! " + (hasAxe ? "(with axe)" : "(without axe)"));
                destroyObject(targetObject);
                chopComplete = true;
            }
            // Wait until an additional duration equal to CHOP_ANIMATION_DURATION has elapsed before stopping.
            if (chopProgress >= (chopTime + PlayerAnimations.CHOP_ANIMATION_DURATION)) {
                stopChopOrPunch();
                chopComplete = false;
            }
        }
    }

    // degrade the axe durability per swing
    private void handleToolDurabilityPerSwing(ItemData axeItem) {
        if (axeItem == null) return;
        axeItem.updateDurability(-DURABILITY_LOSS_PER_SWING);
        GameContext.get().getPlayer().getInventory().notifyObservers();
        if (axeItem.isBroken()) {
            playToolBreakEffect();
            for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                ItemData item = GameContext.get().getPlayer().getInventory().getItemAt(i);
                if (item != null && item.getUuid().equals(axeItem.getUuid())) {
                    GameContext.get().getPlayer().getInventory().removeItemAt(i);
                    break;
                }
            }
            hasAxe = false;
            stopChopOrPunch();
            GameLogger.info("Axe broke during use!");
        } else {
            if (axeItem.getDurabilityPercentage() <= 0.1f) {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.DAMAGE);
            }
        }
    }

    private void playToolBreakEffect() {
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.TOOL_BREAK);
        // Switch from chop anim to punch anim
        GameContext.get().getPlayer().getAnimations().stopChopping();
        GameContext.get().getPlayer().getAnimations().startPunching();
    }

    private boolean isValidTarget(WorldObject obj) {
        if (obj == null || GameContext.get().getPlayer() == null ||
            GameContext.get().getPlayer().getWorld() == null) {
            return false;
        }
        float playerCenterX = GameContext.get().getPlayer().getTileX() * World.TILE_SIZE + (World.TILE_SIZE / 2f);
        float playerCenterY = GameContext.get().getPlayer().getTileY() * World.TILE_SIZE + (World.TILE_SIZE / 2f);
        Rectangle treeBox = obj.getCollisionBox();
        if (treeBox == null) return false;
        float treeCenterX = treeBox.x + treeBox.width / 2f;
        float treeCenterY = treeBox.y + treeBox.height / 2f;
        float distance = Vector2.dst(playerCenterX, playerCenterY, treeCenterX, treeCenterY);
        float maxRange = World.TILE_SIZE * 2.5f;
        Vector2 chunkPos = new Vector2(
            (int) Math.floor(obj.getPixelX() / (World.CHUNK_SIZE * World.TILE_SIZE)),
            (int) Math.floor(obj.getPixelY() / (World.CHUNK_SIZE * World.TILE_SIZE))
        );
        return GameContext.get().getPlayer().getWorld().getChunks().containsKey(chunkPos) && distance <= maxRange;
    }

    private boolean isChoppable(WorldObject obj) {
        return obj.getType().breakTime < 9999f; // Any object with a finite break time
    }

    private WorldObject findChoppableObject() {
        if (GameContext.get().getPlayer() == null ||
            GameContext.get().getPlayer().getWorld() == null) {
            return null;
        }
        float playerCenterX = (GameContext.get().getPlayer().getTileX() + 0.5f) * World.TILE_SIZE;
        float playerCenterY = (GameContext.get().getPlayer().getTileY() + 0.5f) * World.TILE_SIZE;
        String direction = GameContext.get().getPlayer().getDirection();
        float dirOffset = World.TILE_SIZE;
        float interactX = playerCenterX, interactY = playerCenterY;
        switch (direction) {
            case "up":
                interactY += dirOffset;
                break;
            case "down":
                interactY -= dirOffset;
                break;
            case "left":
                interactX -= dirOffset;
                break;
            case "right":
                interactX += dirOffset;
                break;
        }
        Rectangle searchArea = new Rectangle(
            interactX - World.TILE_SIZE * 1.5f,
            interactY - World.TILE_SIZE * 1.5f,
            World.TILE_SIZE * 3,
            World.TILE_SIZE * 3
        );
        List<WorldObject> nearby = GameContext.get().getPlayer().getWorld().getObjectManager()
            .getObjectsNearPosition(interactX, interactY);
        WorldObject bestObj = null;
        float bestDist = Float.MAX_VALUE;
        for (WorldObject obj : nearby) {
            if (!isChoppable(obj)) continue;
            Rectangle objBox = obj.getCollisionBox();
            if (objBox == null) continue;
            if (objBox.overlaps(searchArea)) {
                float cx = objBox.x + objBox.width / 2f;
                float cy = objBox.y + objBox.height / 2f;
                float dist = Vector2.dst(interactX, interactY, cx, cy);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestObj = obj;
                }
            }
        }
        return (bestDist <= World.TILE_SIZE * 2.5f) ? bestObj : null;
    }

    private ItemData findAxeInInventory() {
        Inventory inv = GameContext.get().getPlayer().getInventory();
        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            ItemData item = inv.getItemAt(i);
            if (item != null && item.getItemId().equals(ItemManager.ItemIDs.WOODEN_AXE)) {
                return item;
            }
        }
        return null;
    }

    private void checkForAxe() {
        List<ItemData> items = GameContext.get().getPlayer().getInventory().getAllItems();
        hasAxe = items.stream()
            .anyMatch(it -> it != null && ItemManager.ItemIDs.WOODEN_AXE.equals(it.getItemId()));
    }

    /************************************************************************
     *  Block Breaking
     ************************************************************************/
    PlaceableBlock findBreakableBlock() {
        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();
        switch (GameContext.get().getPlayer().getDirection()) {
            case "up":
                targetY++;
                break;
            case "down":
                targetY--;
                break;
            case "left":
                targetX--;
                break;
            case "right":
                targetX++;
                break;
        }
        return GameContext.get().getPlayer().getWorld().getBlockManager().getBlockAt(targetX, targetY);
    }

    void startBreaking(PlaceableBlock block) {
        if (isBreaking) return;
        checkForAxe();
        isBreaking = true;
        targetBlock = block;
        breakProgress = 0f;
        lastBreakSoundTime = 0f;
        if (hasAxe) {
            GameContext.get().getPlayer().getAnimations().startChopping();
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);
        } else {
            GameContext.get().getPlayer().getAnimations().startPunching();
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD_HAND);
        }
    }

    private void updateBreaking(float deltaTime) {
        if (targetBlock == null) {
            if (targetObject != null) {
                updateChopping(deltaTime);
            }
            return;
        }
        breakProgress += deltaTime;
        lastBreakSoundTime += deltaTime;
        float breakInterval = hasAxe ? CHOP_SOUND_INTERVAL_WITH_AXE : CHOP_SOUND_INTERVAL_WITHOUT_AXE;
        if (lastBreakSoundTime >= breakInterval) {
            if (hasAxe) {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);
            } else {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD_HAND);
            }
            lastBreakSoundTime = 0f;
        }
        float needed = targetBlock.getType().getBreakTime(hasAxe);
        if (breakProgress >= needed) {
            destroyBlock(targetBlock);
            stopChopOrPunch();
        }
    }
    private void destroyBlock(PlaceableBlock block) {
        if (block == null) return;
        World world = GameContext.get().getPlayer().getWorld();
        if (world == null) return;

        Vector2 pos = block.getPosition();
        world.getBlockManager().removeBlock((int) pos.x, (int) pos.y);

        String itemId = block.getType().itemId;
        if (itemId != null) {
            ItemData droppedItem = new ItemData(itemId, 1);
            float dropX = pos.x * World.TILE_SIZE + World.TILE_SIZE / 2f;
            float dropY = pos.y * World.TILE_SIZE + World.TILE_SIZE / 2f;
            world.getItemEntityManager().spawnItemEntity(droppedItem, dropX, dropY);
        }
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);

        if (block.getType() == PlaceableBlock.BlockType.CHEST && block.getChestData() != null) {
            world.getItemEntityManager().spawnItemsFromChest(block.getChestData(), pos.x * World.TILE_SIZE, pos.y * World.TILE_SIZE);
        }
    }



    private void destroyObject(WorldObject obj) {
        if (obj == null) return;
        World world = GameContext.get().getPlayer().getWorld();
        if (world == null) return;

        world.removeWorldObject(obj);

        String dropItemId = obj.getType().dropItemId;
        int dropCount = obj.getType().dropItemCount;
        if (dropItemId != null && dropCount > 0) {
            ItemData droppedItem = new ItemData(dropItemId, dropCount);
            world.getItemEntityManager().spawnItemEntity(droppedItem, obj.getPixelX() + (obj.getTexture().getRegionWidth() / 2f), obj.getPixelY());
        }

        AudioManager.getInstance().playSound(hasAxe ? AudioManager.SoundEffect.BLOCK_BREAK_WOOD : AudioManager.SoundEffect.BLOCK_BREAK_WOOD_HAND);
    }

    /************************************************************************
     *  Update method called each frame
     ************************************************************************/
    public void update(float deltaTime) {
        // Update any chopping/punching progress first.

        if (isChoppingOrBreaking) {
            updateBreakingProgress(deltaTime);
        }

        // Only allow movement (or direction buffering) if NOT chopping/punching.
        if (!isChopping && !isPunching &&
            (inputManager.getCurrentState() == InputManager.UIState.NORMAL ||
                inputManager.getCurrentState() == InputManager.UIState.BUILD_MODE)) {

            Player player = GameContext.get().getPlayer();
            if (!player.isMoving()) {
                if (upPressed) {
                    player.move("up");
                } else if (downPressed) {
                    player.move("down");
                } else if (leftPressed) {
                    player.move("left");
                } else if (rightPressed) {
                    player.move("right");
                }
            } else {
                if (upPressed) {
                    player.setBufferedDirection("up");
                } else if (downPressed) {
                    player.setBufferedDirection("down");
                } else if (leftPressed) {
                    player.setBufferedDirection("left");
                } else if (rightPressed) {
                    player.setBufferedDirection("right");
                }
            }
        }
        // When chopping/punching, do not update or buffer a new direction.
    }



    /************************************************************************
     *  Utility
     ************************************************************************/
    public void resetMovementFlags() {
        upPressed = downPressed = leftPressed = rightPressed = false;
        if (GameContext.get().getPlayer() != null) {
            GameContext.get().getPlayer().setRunning(false);
        }
    }

    public void setRunning(boolean running) {
        if (GameContext.get().getPlayer() != null) {
            GameContext.get().getPlayer().setRunning(running);
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/system/InputManager.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.InputProcessor;
import com.badlogic.gdx.InputMultiplexer;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.screens.ChestScreen;
import io.github.pokemeetup.screens.CraftingTableScreen;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.screens.InventoryScreen;
import io.github.pokemeetup.screens.otherui.BuildModeUI;
import io.github.pokemeetup.screens.otherui.GameMenu;
import io.github.pokemeetup.utils.GameLogger;

public class InputManager {
    private final GlobalInputProcessor globalInputProcessor;
    private final GameScreen gameScreen;
    private final InputMultiplexer inputMultiplexer;
    private UIState currentState;
    public InputManager(GameScreen gameScreen) {
        this.gameScreen = gameScreen;
        this.inputMultiplexer = new InputMultiplexer();
        this.currentState = UIState.NORMAL;
        this.globalInputProcessor = new GlobalInputProcessor(this);
        // Initialize input processors based on the initial state
        updateInputProcessors();
    }

    public void setUIState(UIState newState) {
        if (currentState != newState) {
            currentState = newState;
            handleUIStateChange();
            updateInputProcessors();
        }
    }

    public UIState getCurrentState() {
        return currentState;
    }

    private void handleUIStateChange() {
        // First, hide all UIs to ensure a clean state
        hideAllUI();

        switch (currentState) {
            case NORMAL:
                // Show the regular hotbar
                if (GameContext.get().getHotbarSystem() != null && GameContext.get().getHotbarSystem().getHotbarTable().getParent() != null) {
                    GameContext.get().getHotbarSystem().getHotbarTable().getParent().setVisible(true);
                }
                break;
            case BUILD_MODE:
                // Show the build mode UI (which contains its own hotbars)
                if (GameContext.get().getBuildModeUI() != null) {
                    GameContext.get().getBuildModeUI().setVisible(true);
                    GameContext.get().getBuildModeUI().refreshBuildInventory();
                }
                break;
            case INVENTORY:
                showInventoryScreen();
                break;
            case CRAFTING:
                showCraftingScreen();
                break;
            case MENU:
                showGameMenu();
                break;
            case CHEST_SCREEN:
                showChestScreen();
                break;
            case BATTLE:
            case STARTER_SELECTION:
                // These are managed separately
                break;
        }
        if (gameScreen.getInputHandler() != null) {
            gameScreen.getInputHandler().resetMovementFlags();
        }
    }

    public void hideAllUI() {
        // Hide regular hotbar
        if (GameContext.get().getHotbarSystem() != null && GameContext.get().getHotbarSystem().getHotbarTable().getParent() != null) {
            GameContext.get().getHotbarSystem().getHotbarTable().getParent().setVisible(false);
        }
        // Hide build mode UI
        if (GameContext.get().getBuildModeUI() != null) {
            GameContext.get().getBuildModeUI().setVisible(false);
        }
        // Hide other screens...
        if (gameScreen.getInventoryScreen() != null) {
            gameScreen.getInventoryScreen().hide();
        }
        if (gameScreen.getGameMenu() != null) {
            gameScreen.getGameMenu().hide();
        }
        if (gameScreen.getCraftingScreen() != null) {
            gameScreen.getCraftingScreen().hide();
        }
        if (gameScreen.getChestScreen() != null) {
            gameScreen.getChestScreen().hide();
        }
    }

    private void showInventoryScreen() {
        if (gameScreen.getInventoryScreen() == null) {
            GameContext.get().setInventoryScreen(new InventoryScreen(GameContext.get().getPlayer(), gameScreen.getSkin(), GameContext.get().getPlayer().getInventory(), gameScreen.getInputManager()));
        }
        gameScreen.getInventoryScreen().show();
    }


    private void showCraftingScreen() {
        if (gameScreen.getCraftingScreen() == null) {
            gameScreen.setCraftingScreen(new CraftingTableScreen(GameContext.get().getPlayer(), gameScreen.getSkin(), GameContext.get().getWorld(), GameContext.get().getGameClient(), gameScreen, this));
        }
        gameScreen.getCraftingScreen().show();
    }

    private void showGameMenu() {
        if (GameContext.get().getGameMenu() == null) {
            GameContext.get().setGameMenu(new GameMenu(
                gameScreen.getGame(),
                gameScreen.getSkin(),
                this
            ));
        }
        GameContext.get().getGameMenu().show();
    }

    private void showChestScreen() {
        if (gameScreen.getChestScreen() == null) {
            gameScreen.setChestScreen(new ChestScreen(gameScreen.getSkin(), null, null, gameScreen));
        }
        gameScreen.getChestScreen().show();
    }

    public void updateInputProcessors() {
        // Clear any previously added processors.
        inputMultiplexer.clear();

        // 1) ChatSystem first, if it exists and has a Stage
        if (GameContext.get().getChatSystem() != null &&
            GameContext.get().getChatSystem().getStage() != null) {
            inputMultiplexer.addProcessor(
                GameContext.get().getChatSystem().getStage()
            );
        }

        // 2) The main UI Stage (HUD, overlays, etc.)
        if (GameContext.get().getUiStage() != null) {
            inputMultiplexer.addProcessor(GameContext.get().getUiStage());
        }

        // 3) Add the Stage relevant to our current UI state
        switch (currentState) {
            case STARTER_SELECTION:
                // If you have a separate Stage for starter UI, add it here.
                // Otherwise, your starter selection is already a table in the UiStage, so do nothing.
                break;

            case INVENTORY:
                if (GameContext.get().getInventoryScreen() != null) {
                    inputMultiplexer.addProcessor(
                        GameContext.get().getInventoryScreen().getStage()
                    );
                }
                break;

            case CRAFTING:
                if (GameContext.get().getCraftingScreen() != null &&
                    GameContext.get().getCraftingScreen().getStage() != null) {
                    inputMultiplexer.addProcessor(
                        GameContext.get().getCraftingScreen().getStage()
                    );
                }
                break;

            case MENU:
                // If your GameMenu has its own Stage:
                if (GameContext.get().getGameMenu() != null &&
                    GameContext.get().getGameMenu().getStage() != null) {
                    inputMultiplexer.addProcessor(
                        GameContext.get().getGameMenu().getStage()
                    );
                }
                break;

            case CHEST_SCREEN:
                if (gameScreen.getChestScreen() != null &&
                    gameScreen.getChestScreen().getStage() != null) {
                    inputMultiplexer.addProcessor(
                        gameScreen.getChestScreen().getStage()
                    );
                }
                break;

            case BATTLE:
                if (gameScreen.getBattleStage() != null) {
                    inputMultiplexer.addProcessor(gameScreen.getBattleStage());
                }
                break;

            case NORMAL:
            case BUILD_MODE:
                // Nothing special to add here.
                break;
        }

        // 4) The main in‑game InputHandler (movement, chop/punch, etc.)
        if (gameScreen.getInputHandler() != null) {
            inputMultiplexer.addProcessor(gameScreen.getInputHandler());
        }

        // 5) GlobalInputProcessor last (for ESC key, or “always-listen” input)
        inputMultiplexer.addProcessor(globalInputProcessor);

        // Finally, set this multiplexer as the active input processor
        Gdx.input.setInputProcessor(inputMultiplexer);
    }



    public enum UIState {
        NORMAL,
        INVENTORY,
        BUILD_MODE,
        CRAFTING,
        MENU,
        STARTER_SELECTION,
        CHEST_SCREEN,
        BATTLE
    }
}

================
File: src/main/java/io/github/pokemeetup/system/keybinds/ControllerBinds.java
================
package io.github.pokemeetup.system.keybinds;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Preferences;

import java.util.HashMap;
import java.util.Map;

/**
 * Allows you to rebind controller buttons.
 *
 * This version maps the controls to the ROG Ally controller by default.
 * Assumptions for the default mapping (based on an XInput layout for ROG Ally):
 *   - Face Buttons are reported in the order: X, A, B, Y.
 *     • INTERACT: X button (button index 0)
 *     • ACTION (e.g., chop/punch): A button (button index 1)
 *     • SPRINT: B button (button index 2)
 *     • INVENTORY: Y button (button index 3)
 *   - Shoulder and trigger buttons remain the same:
 *     • BUILD_MODE: Left bumper (button index 4)
 *     • BREAK: Left trigger (button index 6)
 *     • PLACE: Right trigger (button index 7)
 *   - D-Pad directions are mapped to:
 *     • MOVE_UP: D-pad up (button index 19)
 *     • MOVE_DOWN: D-pad down (button index 20)
 *     • MOVE_LEFT: D-pad left (button index 21)
 *     • MOVE_RIGHT: D-pad right (button index 22)
 *
 * Modify these values as needed based on your testing with the actual device.
 */
public class ControllerBinds {
    public static final String MOVE_UP = "Move Up";
    public static final String MOVE_DOWN = "Move Down";
    public static final String MOVE_LEFT = "Move Left";
    public static final String MOVE_RIGHT = "Move Right";
    public static final String INTERACT = "Interact";
    public static final String ACTION = "Action";
    public static final String SPRINT = "Sprint";
    public static final String INVENTORY = "Inventory";
    public static final String BUILD_MODE = "Build Mode";
    public static final String BREAK = "Break";
    public static final String PLACE = "Place";

    private static final String PREF_NAME = "controller_keybinds";
    private static final Map<String, Integer> defaultBinds = new HashMap<>();
    private static Map<String, Integer> currentBinds = new HashMap<>();

    static {
        defaultBinds.put(MOVE_UP, 19);    // D-pad Up
        defaultBinds.put(MOVE_DOWN, 20);  // D-pad Down
        defaultBinds.put(MOVE_LEFT, 21);  // D-pad Left
        defaultBinds.put(MOVE_RIGHT, 22); // D-pad Right

        defaultBinds.put(INTERACT, 1);  // X button
        defaultBinds.put(ACTION, 0);  // A button for chop/punch
        defaultBinds.put(SPRINT, 2);  // B button (held for sprint)
        defaultBinds.put(INVENTORY, 3);  // Y button
        defaultBinds.put(BUILD_MODE, 4);  // Left bumper for build mode
        defaultBinds.put(BREAK, 6);  // Left trigger for breaking
        defaultBinds.put(PLACE, 7);  // Right trigger for placing blocks
        loadBindings();
    }

    public static Map<String, Integer> getCurrentBinds() {
        return currentBinds;
    }

    public static void loadBindings() {
        Preferences prefs = Gdx.app.getPreferences(PREF_NAME);
        currentBinds.clear();
        for (Map.Entry<String, Integer> entry : defaultBinds.entrySet()) {
            currentBinds.put(entry.getKey(), prefs.getInteger(entry.getKey(), entry.getValue()));
        }
    }

    public static void saveBindings() {
        Preferences prefs = Gdx.app.getPreferences(PREF_NAME);
        for (Map.Entry<String, Integer> entry : currentBinds.entrySet()) {
            prefs.putInteger(entry.getKey(), entry.getValue());
        }
        prefs.flush();
    }

    public static void resetToDefaults() {
        currentBinds.clear();
        currentBinds.putAll(defaultBinds);
        saveBindings();
    }

    public static int getBinding(String action) {
        return currentBinds.getOrDefault(action, defaultBinds.get(action));
    }

    public static void setBinding(String action, int buttonCode) {
        currentBinds.put(action, buttonCode);
    }
}

================
File: src/main/java/io/github/pokemeetup/system/keybinds/ControllerBindsDialog.java
================
package io.github.pokemeetup.system.keybinds;

import com.badlogic.gdx.Input;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.utils.Align;
import java.util.Map;
import java.util.HashMap;

/**
 * Dialog to rebind controller keys.
 * Currently shows the button code as text (you can later replace this with friendly names).
 */
public class ControllerBindsDialog extends Dialog {
    private Table bindsTable;
    private Actor waitingButton = null;
    private String waitingAction = null;

    public ControllerBindsDialog(Skin skin) {
        super("Controller Key Bindings", skin);
        bindsTable = new Table(skin);
        bindsTable.defaults().pad(5);
        createLayout(skin);
        getContentTable().add(bindsTable).grow().pad(20);

        // Reset and Close buttons
        TextButton resetButton = new TextButton("Reset to Defaults", skin);
        resetButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                ControllerBinds.resetToDefaults();
                refreshBindings();
            }
        });

        TextButton closeButton = new TextButton("Close", skin);
        closeButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                ControllerBinds.saveBindings();
                hide();
            }
        });

        Table buttonTable = new Table();
        buttonTable.add(resetButton).pad(10);
        buttonTable.add(closeButton).pad(10);
        getButtonTable().add(buttonTable);

        // Listen for numeric or other inputs to set new bindings
        addListener(new InputListener(){
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if(waitingButton != null) {
                    // For simplicity, we use the numeric value as the new binding.
                    // In a real app, you’d probably want to wait for a controller button event.
                    ControllerBinds.setBinding(waitingAction, keycode);
                    ((TextButton)waitingButton).setText(String.valueOf(ControllerBinds.getBinding(waitingAction)));
                    waitingButton = null;
                    waitingAction = null;
                    return true;
                }
                return false;
            }
        });
    }

    private void createLayout(Skin skin) {
        bindsTable.clear();
        // Create a row for each binding.
        for (Map.Entry<String, Integer> entry : ControllerBinds.getCurrentBinds().entrySet()) {
            String action = entry.getKey();
            String bindingText = String.valueOf(entry.getValue());
            Label actionLabel = new Label(action, skin);
            actionLabel.setAlignment(Align.left);
            TextButton bindButton = new TextButton(bindingText, skin);
            bindButton.addListener(new ChangeListener(){
                @Override
                public void changed(ChangeEvent event, Actor actor) {
                    if(waitingButton != null) {
                        ((TextButton)waitingButton).setText(String.valueOf(ControllerBinds.getBinding(waitingAction)));
                    }
                    waitingButton = actor;
                    waitingAction = action;
                    ((TextButton)actor).setText("Press button...");
                }
            });
            bindsTable.add(actionLabel).width(150).padRight(20);
            bindsTable.add(bindButton).width(150).row();
        }
    }

    private void refreshBindings() {
        createLayout(getSkin());
    }
}

================
File: src/main/java/io/github/pokemeetup/system/keybinds/KeyBinds.java
================
package io.github.pokemeetup.system.keybinds;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Preferences;
import java.util.HashMap;
import java.util.Map;

public class KeyBinds {
    private static final String PREF_NAME = "keybinds";
    private static Map<String, Integer> currentBinds = new HashMap<>();
    private static final Map<String, Integer> defaultBinds = new HashMap<>();

    // Action names
    public static final String MOVE_UP = "Move Up";
    public static final String MOVE_DOWN = "Move Down";
    public static final String MOVE_LEFT = "Move Left";
    public static final String MOVE_RIGHT = "Move Right";
    public static final String INTERACT = "Interact";
    public static final String BUILD_MODE = "Build Mode";
    public static final String INVENTORY = "Inventory";
    public static final String SPRINT = "Sprint";
    public static final String ACTION = "Action";

    static {
        // Set default bindings
        defaultBinds.put(MOVE_UP, Input.Keys.W);
        defaultBinds.put(MOVE_DOWN, Input.Keys.S);
        defaultBinds.put(MOVE_LEFT, Input.Keys.A);
        defaultBinds.put(MOVE_RIGHT, Input.Keys.D);
        defaultBinds.put(INTERACT, Input.Keys.X);
        defaultBinds.put(BUILD_MODE, Input.Keys.B);
        defaultBinds.put(INVENTORY, Input.Keys.E);
        defaultBinds.put(SPRINT, Input.Keys.Z);
        defaultBinds.put(ACTION, Input.Keys.Q);

        loadBindings();
    }

    public static void loadBindings() {
        Preferences prefs = Gdx.app.getPreferences(PREF_NAME);
        currentBinds.clear();

        for (Map.Entry<String, Integer> entry : defaultBinds.entrySet()) {
            currentBinds.put(entry.getKey(), prefs.getInteger(entry.getKey(), entry.getValue()));
        }
    }

    public static void saveBindings() {
        Preferences prefs = Gdx.app.getPreferences(PREF_NAME);
        for (Map.Entry<String, Integer> entry : currentBinds.entrySet()) {
            prefs.putInteger(entry.getKey(), entry.getValue());
        }
        prefs.flush();
    }

    public static void resetToDefaults() {
        currentBinds.clear();
        currentBinds.putAll(defaultBinds);
        saveBindings();
    }

    public static int getBinding(String action) {
        return currentBinds.getOrDefault(action, defaultBinds.get(action));
    }

    public static void setBinding(String action, int keycode) {
        currentBinds.put(action, keycode);
    }

    public static String getKeyName(int keycode) {
        return Input.Keys.toString(keycode);
    }

    public static Map<String, Integer> getCurrentBinds() {
        return new HashMap<>(currentBinds);
    }
}

================
File: src/main/java/io/github/pokemeetup/system/keybinds/KeyBindsDialog.java
================
package io.github.pokemeetup.system.keybinds;

import com.badlogic.gdx.Input;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.utils.Align;

public class KeyBindsDialog extends Dialog {
    private Table keyBindsTable;
    private Actor waitingButton = null;
    private String waitingAction = null;


    public KeyBindsDialog(Skin skin) {
        super("Key Bindings", skin);

        // Main container for our rows
        keyBindsTable = new Table(skin);
        keyBindsTable.defaults().pad(5);

        // Build the layout with headings
        createLayout(skin);

        // Add the entire table to the dialog
        getContentTable().add(keyBindsTable).grow().pad(20);

        // Add Reset and Close buttons at the bottom
        TextButton resetButton = new TextButton("Reset to Defaults", skin);
        resetButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                KeyBinds.resetToDefaults();
                refreshBindings();
            }
        });

        TextButton closeButton = new TextButton("Close", skin);
        closeButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                KeyBinds.saveBindings();
                hide();
            }
        });

        Table buttonTable = new Table();
        buttonTable.add(resetButton).pad(10);
        buttonTable.add(closeButton).pad(10);

        getButtonTable().add(buttonTable);

        // Capture keyboard events to set new key bindings
        addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                // If we're waiting for a key press to set a new binding:
                if (waitingButton != null) {
                    // Escape can cancel the rebind
                    if (keycode != Input.Keys.ESCAPE) {
                        KeyBinds.setBinding(waitingAction, keycode);
                    }
                    // Update button text to newly bound key (or revert if ESC)
                    ((TextButton)waitingButton).setText(
                        KeyBinds.getKeyName(KeyBinds.getBinding(waitingAction))
                    );
                    waitingButton = null;
                    waitingAction = null;
                    return true;
                }
                return false;
            }
        });
    }

    private void createLayout(Skin skin) {
        keyBindsTable.clear();

        // We'll separate actions into categories for clarity:
        keyBindsTable.add(new Label("Movement Keys", skin))
            .colspan(2).align(Align.left).padBottom(5).row();

        // Movement actions in a fixed order:
        addKeyBindRow(KeyBinds.MOVE_UP, skin);
        addKeyBindRow(KeyBinds.MOVE_DOWN, skin);
        addKeyBindRow(KeyBinds.MOVE_LEFT, skin);
        addKeyBindRow(KeyBinds.MOVE_RIGHT, skin);
        addKeyBindRow(KeyBinds.SPRINT, skin);

        // Add a small separator or extra padding
        keyBindsTable.add().colspan(2).height(15).row();

        keyBindsTable.add(new Label("Other Actions", skin))
            .colspan(2).align(Align.left).padBottom(5).row();

        // Other actions in a fixed order:
        addKeyBindRow(KeyBinds.INTERACT, skin);
        addKeyBindRow(KeyBinds.ACTION, skin);
        addKeyBindRow(KeyBinds.BUILD_MODE, skin);
        addKeyBindRow(KeyBinds.INVENTORY, skin);
    }

    /**
     * Builds a single row: Label + Rebind-Button
     */
    private void addKeyBindRow(String action, Skin skin) {
        // Safeguard if the user manually removed or changed the map
        if (!KeyBinds.getCurrentBinds().containsKey(action)) {
            return;
        }

        Label actionLabel = new Label(action, skin);
        actionLabel.setAlignment(Align.left);

        TextButton bindButton = new TextButton(
            KeyBinds.getKeyName(KeyBinds.getBinding(action)),
            skin
        );

        bindButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                // If we're already waiting for a key, revert the old button text
                if (waitingButton != null) {
                    ((TextButton)waitingButton).setText(
                        KeyBinds.getKeyName(KeyBinds.getBinding(waitingAction))
                    );
                }
                waitingButton = actor;
                waitingAction = action;
                ((TextButton)actor).setText("Press any key...");
            }
        });

        keyBindsTable.add(actionLabel).width(150).padRight(20);
        keyBindsTable.add(bindButton).width(150).row();
    }

    /**
     * Re-create the layout after a reset or other event that changes the bindings.
     */
    private void refreshBindings() {
        createLayout(getSkin());
    }
}

================
File: src/main/java/io/github/pokemeetup/system/PickupActionHandler.java
================
package io.github.pokemeetup.system;

public interface PickupActionHandler {
    void handlePickupAction();
}

================
File: src/main/java/io/github/pokemeetup/system/Player.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.*;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.FootstepEffect;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.PokemonParty;
import io.github.pokemeetup.screens.otherui.HotbarSystem;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.PokemonData;
import io.github.pokemeetup.system.gameplay.PlayerAnimations;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.ItemEntity;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.*;

import static io.github.pokemeetup.system.gameplay.overworld.World.INTERACTION_RANGE;
import static io.github.pokemeetup.system.gameplay.overworld.World.TILE_SIZE;

public class Player implements Positionable {
    // Constants
    public static final int FRAME_WIDTH = 32;    @Override
    public boolean wasOnWater() {
        return wasOnWater;
    }

    @Override
    public void setWasOnWater(boolean onWater) {
        this.wasOnWater = onWater;
    }

    @Override
    public float getWaterSoundTimer() {
        return waterSoundTimer;
    }

    @Override
    public void setWaterSoundTimer(float timer) {
        this.waterSoundTimer = timer;
    }

    @Override
    public void updateWaterSoundTimer(float delta) {
        if (this.waterSoundTimer > 0) {
            this.waterSoundTimer -= delta;
        }
    }
    private float animationSpeedMultiplier = 0.75f;
    private boolean inputHeld = false;
    private boolean wasOnWater = false;
    private float waterSoundTimer = 0f;
    public static final int FRAME_HEIGHT = 48;
    private static final float COLLISION_BOX_WIDTH_RATIO = 0.6f;
    private static final float COLLISION_BOX_HEIGHT_RATIO = 0.4f;
    private static final float COLLISION_BUFFER = 4f;
    private static final long VALIDATION_INTERVAL = 1000;
    private static final float PICKUP_RANGE = 48f;
    private static final float BUFFER_WINDOW = 0.15f;
    // Synchronization locks and layout
    private final Object movementLock = new Object();
    private final Object resourceLock = new Object();
    private final Object fontLock = new Object();
    private final Object inventoryLock = new Object();
    private final GlyphLayout layout = new GlyphLayout();
    // Player state variables
    public volatile boolean initialized = false;
    private float walkStepDuration = PlayerAnimations.SLOW_WALK_ANIMATION_DURATION;
    private float runStepDuration = PlayerAnimations.SLOW_RUN_ANIMATION_DURATION;
    private PlayerAnimations animations;
    private String username;
    private World world;
    private String bufferedDirection = null;
    private Vector2 position = new Vector2();
    private Rectangle collisionBox;
    private Rectangle nextPositionBox;
    private PokemonParty pokemonParty = new PokemonParty();
    private Inventory buildInventory = new Inventory();
    private Vector2 renderPosition = new Vector2();
    private Vector2 lastPosition = new Vector2();
    private Vector2 targetPosition = new Vector2();
    private Vector2 startPosition = new Vector2();
    private String direction = "down";
    private boolean isMoving = false;
    private boolean isRunning = false;
    private boolean buildMode = false;
    private TextureRegion currentFrame;
    private Inventory inventory = new Inventory();
    private float stateTime = 0f;
    private float x = 0f;
    private float y = 0f;
    private int tileX, tileY;
    private int targetTileX, targetTileY;
    private BitmapFont font;
    private PlayerData playerData;
    private float movementProgress;
    private boolean resourcesInitialized = false;
    private long lastValidationTime = 0;
    private volatile boolean disposed = false;
    private volatile boolean fontInitialized = false;
    private Skin skin;
    private Stage stage;
    private float bufferedTime = 0f;
    private float animationTime = 0f;

    // Constructors
    public Player(int startTileX, int startTileY, World world) {
        this(startTileX, startTileY, world, "Player");
        this.playerData = new PlayerData("Player");
        this.stage = new Stage(new ScreenViewport());
        this.skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));
    }

    public Player(String username, World world) {
        this(0, 0, world, username);
        GameLogger.info("Creating new player: " + username);
        this.animations = new PlayerAnimations(getCharacterType());
        this.world = world;
        this.position = new Vector2(0, 0);
        this.targetPosition = new Vector2(0, 0);
        this.renderPosition = new Vector2(0, 0);
        this.lastPosition = new Vector2(0, 0);
        this.startPosition = new Vector2(0, 0);
        this.stage = new Stage(new ScreenViewport());
        this.skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));

        float boxWidth = FRAME_WIDTH * COLLISION_BOX_WIDTH_RATIO;
        float boxHeight = FRAME_HEIGHT * COLLISION_BOX_HEIGHT_RATIO;
        this.collisionBox = new Rectangle(0, 0, boxWidth, boxHeight);
        this.nextPositionBox = new Rectangle(0, 0, boxWidth, boxHeight);
        this.direction = "down";
        this.inventory = new Inventory();
        this.buildInventory = new Inventory();
        this.pokemonParty = new PokemonParty();
        this.playerData = new PlayerData(username);

        initFont();
        Gdx.app.postRunnable(this::initializeGLResources);
        GameLogger.info("Player initialized: " + username + " at (0,0)");
    }

    public Player(int startTileX, int startTileY, World world, String username) {
        this.world = world;
        this.username = username != null ? username : "Player";

        float boxWidth = FRAME_WIDTH * COLLISION_BOX_WIDTH_RATIO;
        float boxHeight = FRAME_HEIGHT * COLLISION_BOX_HEIGHT_RATIO;
        this.collisionBox = new Rectangle(0, 0, boxWidth, boxHeight);
        this.nextPositionBox = new Rectangle(0, 0, boxWidth, boxHeight);
        initializePosition(startTileX, startTileY);
        this.playerData = new PlayerData("Player");
        initFont();
        this.direction = "down";
        this.inventory = new Inventory();
        this.buildInventory = new Inventory();
        this.pokemonParty = new PokemonParty();

        initializeFromSavedState();
        this.renderPosition = new Vector2(x, y);
        this.lastPosition = new Vector2(x, y);
        Gdx.app.postRunnable(this::initializeGLResources);
    }

    // Utility methods
    public String getCharacterType() {
        return (playerData != null && playerData.getCharacterType() != null) ? playerData.getCharacterType() : "boy";
    }

    public void setCharacterType(String characterType) {
        if (playerData != null) {
            playerData.setCharacterType(characterType);
        }
        if (animations != null) {
            animations.dispose();
        }
        animations = new PlayerAnimations(getCharacterType());
    }

    public HotbarSystem getHotbarSystem() {
        if (GameContext.get().getHotbarSystem() == null) {
            Stage stage = GameContext.get().getUiStage();
            if (stage == null) {
                GameLogger.error("UI Stage is null in getHotbarSystem()!");
                return null;
            }
            // Use the skin stored in GameContext if available.
            Skin hotbarSkin = GameContext.get().getSkin() != null ? GameContext.get().getSkin() : skin;
            GameContext.get().setHotbarSystem(new HotbarSystem(stage, hotbarSkin));
            GameLogger.info("HotbarSystem successfully initialized synchronously.");
        }
        return GameContext.get().getHotbarSystem();
    }


    public PlayerAnimations getAnimations() {
        return animations;
    }

    private void initializeGLResources() {
        try {
            this.stage = new Stage(new ScreenViewport());
            this.skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));
            this.font = new BitmapFont(Gdx.files.internal("Skins/default.fnt"));
            font.getData().setScale(0.8f);
            font.setColor(Color.WHITE);
            this.animations = new PlayerAnimations(getCharacterType());
            this.initialized = true;
            fontInitialized = true;
            GameLogger.info("Player GL resources initialized: " + username);
        } catch (Exception e) {
            GameLogger.error("Failed to initialize GL resources: " + e.getMessage());
        }
    }

    private void initFont() {
        this.font = new BitmapFont(Gdx.files.internal("Skins/default.fnt"));
        font.getData().setScale(0.8f);
        font.setColor(Color.WHITE);
    }

    public void initializeInWorld(World world) {
        if (world == null) {
            GameLogger.error("Cannot initialize player in null world");
            return;
        }
        this.world = world;
        updateCollisionBoxes();
        GameLogger.info("Player initialized in world: " + username);
    }

    public void setBufferedDirection(String direction) {
        synchronized (movementLock) {
            bufferedDirection = direction;
            bufferedTime = 0f;
        }
    }

    public void updateFromPlayerData(PlayerData data) {
        if (data == null) return;
        this.playerData = data;
        this.pokemonParty = new PokemonParty();
        if (data.getPartyPokemon() != null) {
            for (var pData : data.getPartyPokemon()) {
                if (pData != null) {
                    Pokemon p = pData.toPokemon();
                    if (p != null) {
                        this.pokemonParty.addPokemon(p);
                    }
                }
            }
        }
        this.inventory = new Inventory();
        if (data.getInventoryItems() != null) {
            for (ItemData item : data.getInventoryItems()) {
                if (item != null) {
                    this.inventory.addItem(item);
                }
            }
        }
        this.setX(data.getX());
        this.setY(data.getY());
        this.setDirection(data.getDirection());
        this.setMoving(data.isMoving());
        this.setRunning(data.isWantsToRun());
        this.setCharacterType(data.getCharacterType());
        GameLogger.info("Updated player '" + username + "' from PlayerData.");
    }

    private void initializePosition(int startTileX, int startTileY) {
        this.tileX = startTileX;
        this.tileY = startTileY;
        this.x = (tileX * TILE_SIZE) + (TILE_SIZE / 2f);
        this.y = (tileY * TILE_SIZE);
        this.position.set(x, y);
        this.targetPosition.set(x, y);
        this.renderPosition.set(x, y);
        this.lastPosition.set(x, y);
        this.startPosition.set(x, y);
        this.targetTileX = tileX;
        this.targetTileY = tileY;
    }

    private float tileToPixelX(int tileX) {
        return tileX * World.TILE_SIZE + (World.TILE_SIZE / 2f);
    }

    private float tileToPixelY(int tileY) {
        return tileY * World.TILE_SIZE;
    }

    private int pixelToTileX(float pixelX) {
        return (int) Math.floor(pixelX / World.TILE_SIZE);
    }

    private int pixelToTileY(float pixelY) {
        return (int) Math.floor(pixelY / World.TILE_SIZE);
    }

    private void initializeFromSavedState() {
        if (world != null && world.getWorldData() != null) {
            PlayerData savedData = world.getWorldData().getPlayerData(username, false);
            if (savedData != null) {
                savedData.applyToPlayer(this);
                GameLogger.info("Loaded saved state for player: " + username);
            } else {
                this.playerData = new PlayerData(username);
                GameLogger.info("No saved data found. Created new PlayerData for: " + username);
            }
        }
    }

    public float getX() {
        return x;
    }

    public void setX(float x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    public String getDirection() {
        return direction;
    }

    public void setDirection(String direction) {
        this.direction = direction;
    }

    public boolean isMoving() {
        return isMoving;
    }

    public void setMoving(boolean moving) {
        isMoving = moving;
        if (!moving) {
            stateTime = 0f;
        }
    }

    public boolean isRunning() {
        return isRunning;
    }

    public void setRunning(boolean running) {
        this.isRunning = running;
    }

    public boolean isBuildMode() {
        return buildMode;
    }

    public void setBuildMode(boolean buildMode) {
        this.buildMode = buildMode;
    }

    public Inventory getInventory() {
        synchronized (inventoryLock) {
            if (inventory == null) {
                GameLogger.error("Player inventory is null - creating new");
                inventory = new Inventory();
            }
            return inventory;
        }
    }

    public void setInventory(Inventory inv) {
        synchronized (inventoryLock) {
            if (inv == null) {
                GameLogger.error("Attempt to set null inventory");
                return;
            }
            if (this.inventory != null) {
                for (ItemData item : this.inventory.getAllItems()) {
                    if (item != null) {
                        inv.addItem(item.copy());
                    }
                }
            }
            this.inventory = inv;
            GameLogger.info("Set player inventory.");
        }
    }

    public Inventory getBuildInventory() {
        return buildInventory;
    }

    public PokemonParty getPokemonParty() {
        return pokemonParty;
    }

    public void setPokemonParty(PokemonParty pokemonParty) {
        this.pokemonParty = pokemonParty;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public World getWorld() {
        return world;
    }

    public void setWorld(World world) {
        synchronized (movementLock) {
            this.world = world;
        }
    }

    public PlayerData getPlayerData() {
        return playerData;
    }

    public void setPlayerData(PlayerData playerData) {
        this.playerData = playerData;
    }

    public Stage getStage() {
        return stage;
    }

    public void setStage(Stage stage) {
        this.stage = stage;
    }

    public Skin getSkin() {
        return skin;
    }

    public void setSkin(Skin skin) {
        this.skin = skin;
    }

    // The update method—modified for maximum responsiveness.
    public void update(float deltaTime) {
        if (!resourcesInitialized || disposed || animations == null || animations.isDisposed()) {
            initializeResources();
        }
        synchronized (movementLock) {
            // Update buffered input timer if any buffered direction exists.
            if (bufferedDirection != null) {
                bufferedTime += deltaTime;
                if (bufferedTime > BUFFER_WINDOW) {
                    bufferedDirection = null;
                    bufferedTime = 0f;
                }
            }

            // Highest priority: action animations (chop/punch)
            if (animations.isChopping() || animations.isPunching()) {
                stateTime += deltaTime;
                currentFrame = animations.getCurrentFrame(direction, true, isRunning, stateTime);
            }
            // When moving:
            else if (isMoving) {
                float currentDuration = isRunning ? runStepDuration : walkStepDuration;
                float progressIncrement = deltaTime / currentDuration;
                movementProgress += progressIncrement;
                if (movementProgress > 1.0f) {
                    movementProgress = 1.0f;
                }
                updatePosition(movementProgress);
                // Update animationTime for frame selection.
                animationTime += deltaTime * animationSpeedMultiplier;

                // As soon as the tile's position is reached, complete the movement immediately.
                if (movementProgress >= 1.0f) {
                    completeMovement();
                    // Immediately start a new move if a buffered direction exists...
                    if (bufferedDirection != null) {
                        move(bufferedDirection);
                        bufferedDirection = null;
                        bufferedTime = 0f;
                    }
                    // ...or if the movement key is still held.
                    else if (isInputHeld()) {
                        move(direction);
                    }
                    // Otherwise, reset and display the standing frame.
                    else {
                        animationTime = 0f;
                        currentFrame = animations.getStandingFrame(direction);
                    }
                } else {
                    currentFrame = animations.getCurrentFrame(direction, true, isRunning, animationTime);
                }
            }
            // Not moving – show standing frame.
            else {
                stateTime = 0f;
                animationTime = 0f;
                currentFrame = animations.getStandingFrame(direction);
            }

            // Existing item pickup logic.
            ItemEntity nearbyItem = world.getItemEntityManager().getClosestPickableItem(x, y, PICKUP_RANGE);
            if (nearbyItem != null) {
                if (inventory.addItem(nearbyItem.getItemData())) {
                    world.getItemEntityManager().removeItemEntity(nearbyItem.getEntityId());
                    AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP_OW);
                }
                if (GameContext.get().isMultiplayer()) {
                    NetworkProtocol.ItemPickup pickup = new NetworkProtocol.ItemPickup();
                    pickup.entityId = nearbyItem.getEntityId();
                    pickup.username = this.getUsername();
                    pickup.timestamp = System.currentTimeMillis();
                    GameContext.get().getGameClient().sendItemPickup(pickup);
                }
            }
        }
    }

    private void completeMovement() {
        x = targetPosition.x;
        y = targetPosition.y;
        tileX = targetTileX;
        tileY = targetTileY;
        position.set(x, y);
        renderPosition.set(x, y);
        isMoving = false;
        movementProgress = 0f;
        stateTime = 0f; // Reset timer for the next move.

        int tileType = GameContext.get().getWorld().getTileTypeAt(getTileX(), getTileY());
        if (tileType == TileType.SAND || tileType == TileType.SNOW ||
            tileType == TileType.DESERT_GRASS || tileType == TileType.DESERT_SAND ||
            tileType == TileType.SNOW_2 || tileType == TileType.SNOW_3 ||
            tileType == TileType.SNOW_TALL_GRASS || tileType == TileType.BEACH_GRASS || tileType == TileType.BEACH_SAND || tileType == TileType.BEACH_SHELL || tileType == TileType.BEACH_GRASS_2 || tileType == TileType.SNOWY_GRASS || tileType == TileType.BEACH_STARFISH) {
            GameContext.get().getWorld().getFootstepEffectManager()
                .addEffect(new FootstepEffect(new Vector2(x, y), direction, 1.0f));
        }
    }

    private void updatePosition(float progress) {
        float smoothProgress = smoothstep(progress);
        x = MathUtils.lerp(startPosition.x, targetPosition.x, smoothProgress);
        y = MathUtils.lerp(startPosition.y, targetPosition.y, smoothProgress);
        position.set(x, y);
        renderPosition.set(x, y);
        updateCollisionBoxes();
    }

    private void updateCollisionBoxes() {
        collisionBox.setPosition(x + (FRAME_WIDTH - collisionBox.width) / 2f, y + COLLISION_BUFFER);
        nextPositionBox.setPosition(targetPosition.x + (FRAME_WIDTH - nextPositionBox.width) / 2f, targetPosition.y + COLLISION_BUFFER);
    }

    private float smoothstep(float x) {
        x = MathUtils.clamp(x, 0f, 1f);
        return x * x * (3 - 2 * x);
    }

    public void move(String newDirection) {
        synchronized (movementLock) {
            if (isMoving) {
                // If already moving, just buffer the new direction.
                bufferedDirection = newDirection;
                bufferedTime = 0f;
                return;
            }
            direction = newDirection;
            if (world == null) {
                GameLogger.error("Cannot move - world is null! Player: " + getUsername());
                return;
            }
            int newTileX = getTileX();
            int newTileY = getTileY();
            switch (newDirection) {
                case "up":
                    newTileY++;
                    break;
                case "down":
                    newTileY--;
                    break;
                case "left":
                    newTileX--;
                    break;
                case "right":
                    newTileX++;
                    break;
                default:
                    return;
            }

            // *** Check world bounds ***
            if (!world.isWithinWorldBounds(newTileX, newTileY)) {
                // Optionally: play a “bump” sound or simply ignore the move.
                GameLogger.info("Player cannot move outside the world border: (" + newTileX + "," + newTileY + ")");
                return;
            }

            // Now check that the destination tile is passable.
            if (world.isPassable(newTileX, newTileY)) {
                targetTileX = newTileX;
                targetTileY = newTileY;
                targetPosition.set(tileToPixelX(newTileX), tileToPixelY(newTileY));
                startPosition.set(x, y);
                isMoving = true;
                movementProgress = 0f;
                bufferedDirection = null;
                bufferedTime = 0f;
            }
        }
    }

    public boolean isInputHeld() {
        return inputHeld;
    }

    public void setInputHeld(boolean held) {
        inputHeld = held;
    }

    public void clearBufferedDirection() {
        synchronized (movementLock) {
            bufferedDirection = null;
            bufferedTime = 0f;
        }
    }

    public void render(SpriteBatch batch) {
        synchronized (resourceLock) {
            if (!initialized) return;
            if (!fontInitialized) {
                initializeGLResources();
                return;
            }
            if (!resourcesInitialized || disposed || animations == null || animations.isDisposed()) {
                initializeResources();
            }
            if (currentFrame != null) {
                Color originalColor = batch.getColor().cpy();
                if (world != null) {
                    Color baseColor = world.getCurrentWorldColor();
                    batch.setColor(baseColor);
                }
                float scale = 1f;
                if (getCharacterType().equalsIgnoreCase("girl")) {
                    scale = 2f;
                }
                float regionW = currentFrame.getRegionWidth() * scale;
                float regionH = currentFrame.getRegionHeight() * scale;
                float drawX = renderPosition.x - (regionW / 2f);
                float drawY = renderPosition.y;
                batch.draw(currentFrame, drawX, drawY, regionW, regionH);
                batch.setColor(originalColor);
                if (username != null && !username.isEmpty() && !username.equals("Player") && font != null) {
                    layout.setText(font, username);
                    float textWidth = layout.width;
                    float nameX = drawX + (regionW - textWidth) / 2f;
                    float nameY = drawY + regionH + 15;
                    font.draw(batch, username, nameX, nameY);
                }
            }
        }
    }

    public void setRenderPosition(Vector2 renderPosition) {
        this.renderPosition = renderPosition;
    }

    public int getTileX() {
        return pixelToTileX(x);
    }

    public void setTileX(int tileX) {
        this.tileX = tileX;
    }

    public int getTileY() {
        return pixelToTileY(y);
    }

    public void setTileY(int tileY) {
        this.tileY = tileY;
    }

    public void selectBlockItem(int slot) {
        if (!buildMode) return;
        ItemData itemData = buildInventory.getItemAt(slot);
        Item heldBlock = null;
        if (itemData != null) {
            Item baseItem = ItemManager.getItem(itemData.getItemId());
            if (baseItem == null) {
                GameLogger.error("Failed to get base item for: " + itemData.getItemId());
                return;
            }
            heldBlock = baseItem.copy();
            heldBlock.setCount(itemData.getCount());
            GameLogger.info("Selected block item: " + itemData.getItemId() + " x" + itemData.getCount());
        } else {
            GameLogger.info("Cleared held block");
        }
    }

    public boolean canPickupItem(float itemX, float itemY) {
        float playerCenterX = x + (FRAME_WIDTH / 2f);
        float playerCenterY = y + (FRAME_HEIGHT / 2f);
        float itemCenterX = itemX + (TILE_SIZE / 2f);
        float itemCenterY = itemY + (TILE_SIZE / 2f);
        float dx = itemCenterX - playerCenterX;
        float dy = itemCenterY - playerCenterY;
        float distance = (float) Math.sqrt(dx * dx + dy * dy);
        boolean inCorrectDirection = false;
        switch (direction) {
            case "up":
                inCorrectDirection = dy > 0 && Math.abs(dx) < TILE_SIZE;
                break;
            case "down":
                inCorrectDirection = dy < 0 && Math.abs(dx) < TILE_SIZE;
                break;
            case "left":
                inCorrectDirection = dx < 0 && Math.abs(dy) < TILE_SIZE;
                break;
            case "right":
                inCorrectDirection = dx > 0 && Math.abs(dy) < TILE_SIZE;
                break;
        }
        boolean canPickup = distance <= INTERACTION_RANGE && inCorrectDirection;
        if (canPickup) {
            GameLogger.info("Can pickup item at distance: " + distance + " in direction: " + direction);
        }
        return canPickup;
    }

    public void updatePlayerData() {
        playerData.setX(x);
        playerData.setY(y);
        playerData.setDirection(direction);
        playerData.setMoving(isMoving);
        playerData.setWantsToRun(isRunning);
        playerData.setInventoryItems(inventory.getAllItems());
        var partyData = new java.util.ArrayList<PokemonData>(Collections.nCopies(PokemonParty.MAX_PARTY_SIZE, null));
        synchronized (pokemonParty.partyLock) {
            var currentParty = pokemonParty.getParty();
            GameLogger.info("Converting party of size " + currentParty.size() + " to PokemonData");
            for (int i = 0; i < PokemonParty.MAX_PARTY_SIZE; i++) {
                Pokemon pokemon = i < currentParty.size() ? currentParty.get(i) : null;
                if (pokemon != null) {
                    try {
                        PokemonData pokemonData = PokemonData.fromPokemon(pokemon);
                        if (pokemonData.verifyIntegrity()) {
                            partyData.set(i, pokemonData);
                            GameLogger.info("Added Pokemon to slot " + i + ": " + pokemon.getName());
                        } else {
                            GameLogger.error("Pokemon data failed integrity check at slot " + i);
                            partyData.set(i, null);
                        }
                    } catch (Exception e) {
                        GameLogger.error("Failed to convert Pokemon at slot " + i + ": " + e.getMessage());
                        partyData.set(i, null);
                    }
                }
            }
        }
        if (!partyData.stream().anyMatch(Objects::nonNull)) {
            GameLogger.error("No valid Pokemon found in party data!");
        }
        playerData.setPartyPokemon(partyData);
        GameLogger.info("Updated player data with party info.");
    }

    public void initializeResources() {
        synchronized (resourceLock) {
            try {
                if (skin == null) {
                    GameLogger.info("Player skin is null; loading default skin");
                    skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));
                }
                if (resourcesInitialized && !disposed && animations != null && !animations.isDisposed()) {
                    return;
                }
                GameLogger.info("Initializing player resources");
                if (animations == null || animations.isDisposed()) {
                    animations = new PlayerAnimations(getCharacterType());
                    GameLogger.info("Created new PlayerAnimations");
                }
                currentFrame = animations.getStandingFrame("down");
                if (currentFrame == null) {
                    throw new RuntimeException("Failed to get initial frame");
                }
                resourcesInitialized = true;
                disposed = false;
                GameLogger.info("Player resources initialized successfully");
                if (GameContext.get().getHotbarSystem() == null && GameContext.get().getUiStage() != null) {
                    Gdx.app.postRunnable(() -> {
                        Skin hotbarSkin = GameContext.get().getSkin() != null ? GameContext.get().getSkin() : skin;
                        GameContext.get().setHotbarSystem(new HotbarSystem(GameContext.get().getUiStage(), hotbarSkin));
                        GameLogger.info("HotbarSystem successfully initialized.");
                    });
                }
            } catch (Exception e) {
                GameLogger.error("Failed to initialize player resources: " + e.getMessage());
                resourcesInitialized = false;
                disposed = true;
                throw new RuntimeException("Resource initialization failed", e);
            }
        }
    }

    public void validateResources() {
        long currentTime = System.currentTimeMillis();
        if (currentTime - lastValidationTime > VALIDATION_INTERVAL) {
            synchronized (resourceLock) {
                if (!resourcesInitialized || disposed || animations == null || animations.isDisposed()) {
                    initializeResources();
                }
                lastValidationTime = currentTime;
            }
        }
    }

    public void dispose() {
        synchronized (resourceLock) {
            if (disposed) return;
            Gdx.app.postRunnable(() -> {
                try {
                    GameLogger.info("Disposing player resources");
                    synchronized (fontLock) {
                        if (font != null) {
                            font.dispose();
                            font = null;
                            fontInitialized = false;
                        }
                    }
                    if (animations != null) {
                        animations.dispose();
                        animations = null;
                    }
                    currentFrame = null;
                    resourcesInitialized = false;
                    disposed = true;
                    GameLogger.info("Player resources disposed successfully");
                } catch (Exception e) {
                    GameLogger.error("Error disposing player resources: " + e.getMessage());
                }
            });
        }
    }

    public Vector2 getPosition() {
        return new Vector2(position);
    }
}

================
File: src/main/java/io/github/pokemeetup/system/Positionable.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.math.Vector2;

/**
 * A minimal interface for any object that has a position and a moving state.
 */
public interface Positionable {
    float getX();
    float getY();
    void update(float deltaTime);
    Vector2 getPosition();
    boolean isMoving();
    void setCharacterType(String characterType);

    // Methods for water interaction state
    boolean wasOnWater();
    void setWasOnWater(boolean onWater);
    float getWaterSoundTimer();
    void setWaterSoundTimer(float timer);
    void updateWaterSoundTimer(float delta);
}

================
File: src/main/java/io/github/pokemeetup/system/servers/PluginContext.java
================
package io.github.pokemeetup.system.servers;

import io.github.pokemeetup.system.data.WorldData;

import java.util.Map;

public class PluginContext {
    private WorldData world;
    private Map<String, Object> config;

    public PluginContext(WorldData world, Map<String, Object> config) {
        this.world = world;
        this.config = config;
    }

    public WorldData getWorld() { return world; }
    public Map<String, Object> getConfig() { return config; }
}

================
File: src/main/java/io/github/pokemeetup/system/UITransitionManager.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.graphics.Color;

public class UITransitionManager {
    public static final float DEFAULT_TRANSITION_TIME = 0.3f;
    private final Color color = new Color(1, 1, 1, 1);
    private float alpha = 1f;
    private TransitionAction currentTransition;

    public void startShowTransition(float duration, Runnable onComplete) {
        clearTransitions();
        currentTransition = new TransitionAction(
            duration,
            0f,
            1f,
            onComplete
        );
    }

    public void startHideTransition(float duration, Runnable onComplete) {
        clearTransitions();
        currentTransition = new TransitionAction(
            duration,
            1f,
            0f,
            onComplete
        );
    }

    public void update(float delta) {
        if (currentTransition != null) {
            currentTransition.update(delta);
        }
    }

    public void clearTransitions() {
        if (currentTransition != null) {
            currentTransition.complete();
            currentTransition = null;
        }
    }

    public Color getColor() {
        return color;
    }

    public class TransitionAction {
        private final float duration;
        private final float startAlpha;
        private final float targetAlpha;
        private final Runnable onComplete;
        private float currentTime = 0;
        private boolean isComplete = false;

        public TransitionAction(float duration, float startAlpha, float targetAlpha, Runnable onComplete) {
            this.duration = duration;
            this.startAlpha = startAlpha;
            this.targetAlpha = targetAlpha;
            this.onComplete = onComplete;
        }

        public void update(float delta) {
            if (isComplete) return;

            currentTime += delta;
            float progress = Math.min(currentTime / duration, 1f);
            float smoothProgress = smoothStep(progress);
            alpha = startAlpha + (targetAlpha - startAlpha) * smoothProgress;
            color.a = alpha;

            if (progress >= 1f) {
                complete();
            }
        }

        public void complete() {
            if (isComplete) return;
            isComplete = true;
            alpha = targetAlpha;
            color.a = alpha;
            if (onComplete != null) {
                onComplete.run();
            }
        }

        private float smoothStep(float x) {
            return x * x * (3 - 2 * x);
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/utils/GameLogger.java
================
package io.github.pokemeetup.utils;

import com.badlogic.gdx.Gdx;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class GameLogger {
    public static boolean isInfoEnabled;
    public static boolean isErrorEnabled;

    private static PrintWriter fileWriter;

    static {
        // Read logging toggles from system properties (or set them manually)
        isInfoEnabled =true;// Boolean.getBoolean("game.log.info");  // default is false
        // Always enable errors unless explicitly disabled:
        isErrorEnabled = !Boolean.getBoolean("game.log.error.disabled");

        // Optionally, setup file logging. Log file will be appended.
        try {
            fileWriter = new PrintWriter(new FileWriter("game.log", true));
        } catch (IOException e) {
            // If file logging fails, fall back to console-only logging.
            System.err.println("Unable to open log file: " + e.getMessage());
        }
    }

    public static void info(String message) {
        if (isInfoEnabled) {
            if (Gdx.app != null) {
                Gdx.app.log("Game", message);
            } else {
                System.out.println("INFO: " + message);
            }
            logToFile("INFO: " + message);
        }
    }

    public static void error(String message) {
        if (isErrorEnabled) {
            if (Gdx.app != null) {
                Gdx.app.error("Game", message);
            } else {
                System.err.println("ERROR: " + message);
            }
            logToFile("ERROR: " + message);
        }
    }

    private static void logToFile(String logMessage) {
        if (fileWriter != null) {
            fileWriter.println(logMessage);
            fileWriter.flush();
        }
    }

    // Optionally, allow toggling logging at runtime
    public static void setLogging(boolean infoEnabled, boolean errorEnabled) {
        isInfoEnabled = infoEnabled;
        isErrorEnabled = errorEnabled;
    }

    // Call this on shutdown to close the log file
    public static void close() {
        if (fileWriter != null) {
            fileWriter.close();
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/utils/NoiseCache.java
================
package io.github.pokemeetup.utils;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class NoiseCache {
    private static final Map<String, Double> cache = new ConcurrentHashMap<>();

    public static double getNoise(long seed, float x, float y, float scale) {
        String key = seed + ":" + x + ":" + y + ":" + scale;
        return cache.computeIfAbsent(key, k -> (OpenSimplex2.noise2(seed, x * scale, y * scale) + 1.0) / 2.0);
    }
}

================
File: src/main/java/io/github/pokemeetup/utils/OpenSimplex2.java
================
package io.github.pokemeetup.utils;

public class OpenSimplex2 {

    private static final long PRIME_X = 0x5205402B9270C86FL;
    private static final long PRIME_Y = 0x598CD327003817B5L;
    private static final long PRIME_Z = 0x5BCC226E9FA0BACBL;
    private static final long PRIME_W = 0x56CC5227E58F554BL;
    private static final long HASH_MULTIPLIER = 0x53A3F72DEEC546F5L;
    private static final long SEED_FLIP_3D = -0x52D547B2E96ED629L;
    private static final long SEED_OFFSET_4D = 0xE83DC3E0DA7164DL;

    private static final double ROOT2OVER2 = 0.7071067811865476;
    private static final double SKEW_2D = 0.366025403784439;
    private static final double UNSKEW_2D = -0.21132486540518713;

    private static final double ROOT3OVER3 = 0.577350269189626;
    private static final double FALLBACK_ROTATE_3D = 2.0 / 3.0;
    private static final double ROTATE_3D_ORTHOGONALIZER = UNSKEW_2D;

    private static final float SKEW_4D = -0.138196601125011f;
    private static final float UNSKEW_4D = 0.309016994374947f;
    private static final float LATTICE_STEP_4D = 0.2f;

    private static final int N_GRADS_2D_EXPONENT = 7;
    private static final int N_GRADS_3D_EXPONENT = 8;
    private static final int N_GRADS_4D_EXPONENT = 9;
    private static final int N_GRADS_2D = 1 << N_GRADS_2D_EXPONENT;
    private static final int N_GRADS_3D = 1 << N_GRADS_3D_EXPONENT;
    private static final int N_GRADS_4D = 1 << N_GRADS_4D_EXPONENT;

    private static final double NORMALIZER_2D = 0.01001634121365712;
    private static final double NORMALIZER_3D = 0.07969837668935331;
    private static final double NORMALIZER_4D = 0.0220065933241897;

    private static final float RSQUARED_2D = 0.5f;
    private static final float RSQUARED_3D = 0.6f;
    private static final float RSQUARED_4D = 0.6f;


    /*
     * Noise Evaluators
     */

    /**
     * 2D Simplex noise, standard lattice orientation.
     */
    public static float noise2(long seed, double x, double y) {

        // Get points for A2* lattice
        double s = SKEW_2D * (x + y);
        double xs = x + s, ys = y + s;

        return noise2_UnskewedBase(seed, xs, ys);
    }

    /**
     * 2D Simplex noise, with Y pointing down the main diagonal.
     * Might be better for a 2D sandbox style game, where Y is vertical.
     * Probably slightly less optimal for heightmaps or continent maps,
     * unless your map is centered around an equator. It's a subtle
     * difference, but the option is here to make it an easy choice.
     */
    public static float noise2_ImproveX(long seed, double x, double y) {

        // Skew transform and rotation baked into one.
        double xx = x * ROOT2OVER2;
        double yy = y * (ROOT2OVER2 * (1 + 2 * SKEW_2D));

        return noise2_UnskewedBase(seed, yy + xx, yy - xx);
    }

    /**
     * 2D Simplex noise base.
     */
    private static float noise2_UnskewedBase(long seed, double xs, double ys) {

        // Get base points and offsets.
        int xsb = fastFloor(xs), ysb = fastFloor(ys);
        float xi = (float)(xs - xsb), yi = (float)(ys - ysb);

        // Prime pre-multiplication for hash.
        long xsbp = xsb * PRIME_X, ysbp = ysb * PRIME_Y;

        // Unskew.
        float t = (xi + yi) * (float)UNSKEW_2D;
        float dx0 = xi + t, dy0 = yi + t;

        // First vertex.
        float value = 0;
        float a0 = RSQUARED_2D - dx0 * dx0 - dy0 * dy0;
        if (a0 > 0) {
            value = (a0 * a0) * (a0 * a0) * grad(seed, xsbp, ysbp, dx0, dy0);
        }

        // Second vertex.
        float a1 = (float)(2 * (1 + 2 * UNSKEW_2D) * (1 / UNSKEW_2D + 2)) * t + ((float)(-2 * (1 + 2 * UNSKEW_2D) * (1 + 2 * UNSKEW_2D)) + a0);
        if (a1 > 0) {
            float dx1 = dx0 - (float)(1 + 2 * UNSKEW_2D);
            float dy1 = dy0 - (float)(1 + 2 * UNSKEW_2D);
            value += (a1 * a1) * (a1 * a1) * grad(seed, xsbp + PRIME_X, ysbp + PRIME_Y, dx1, dy1);
        }

        // Third vertex.
        if (dy0 > dx0) {
            float dx2 = dx0 - (float)UNSKEW_2D;
            float dy2 = dy0 - (float)(UNSKEW_2D + 1);
            float a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if (a2 > 0) {
                value += (a2 * a2) * (a2 * a2) * grad(seed, xsbp, ysbp + PRIME_Y, dx2, dy2);
            }
        }
        else
        {
            float dx2 = dx0 - (float)(UNSKEW_2D + 1);
            float dy2 = dy0 - (float)UNSKEW_2D;
            float a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if (a2 > 0) {
                value += (a2 * a2) * (a2 * a2) * grad(seed, xsbp + PRIME_X, ysbp, dx2, dy2);
            }
        }

        return value;
    }

    /**
     * 3D OpenSimplex2 noise, with better visual isotropy in (X, Y).
     * Recommended for 3D terrain and time-varied animations.
     * The Z coordinate should always be the "different" coordinate in whatever your use case is.
     * If Y is vertical in world coordinates, call noise3_ImproveXZ(x, z, Y) or use noise3_XZBeforeY.
     * If Z is vertical in world coordinates, call noise3_ImproveXZ(x, y, Z).
     * For a time varied animation, call noise3_ImproveXY(x, y, T).
     */
    public static float noise3_ImproveXY(long seed, double x, double y, double z) {

        // Re-orient the cubic lattices without skewing, so Z points up the main lattice diagonal,
        // and the planes formed by XY are moved far out of alignment with the cube faces.
        // Orthonormal rotation. Not a skew transform.
        double xy = x + y;
        double s2 = xy * ROTATE_3D_ORTHOGONALIZER;
        double zz = z * ROOT3OVER3;
        double xr = x + s2 + zz;
        double yr = y + s2 + zz;
        double zr = xy * -ROOT3OVER3 + zz;

        // Evaluate both lattices to form a BCC lattice.
        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    /**
     * 3D OpenSimplex2 noise, with better visual isotropy in (X, Z).
     * Recommended for 3D terrain and time-varied animations.
     * The Y coordinate should always be the "different" coordinate in whatever your use case is.
     * If Y is vertical in world coordinates, call noise3_ImproveXZ(x, Y, z).
     * If Z is vertical in world coordinates, call noise3_ImproveXZ(x, Z, y) or use noise3_ImproveXY.
     * For a time varied animation, call noise3_ImproveXZ(x, T, y) or use noise3_ImproveXY.
     */
    public static float noise3_ImproveXZ(long seed, double x, double y, double z) {

        // Re-orient the cubic lattices without skewing, so Y points up the main lattice diagonal,
        // and the planes formed by XZ are moved far out of alignment with the cube faces.
        // Orthonormal rotation. Not a skew transform.
        double xz = x + z;
        double s2 = xz * ROTATE_3D_ORTHOGONALIZER;
        double yy = y * ROOT3OVER3;
        double xr = x + s2 + yy;
        double zr = z + s2 + yy;
        double yr = xz * -ROOT3OVER3 + yy;

        // Evaluate both lattices to form a BCC lattice.
        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    /**
     * 3D OpenSimplex2 noise, fallback rotation option
     * Use noise3_ImproveXY or noise3_ImproveXZ instead, wherever appropriate.
     * They have less diagonal bias. This function's best use is as a fallback.
     */
    public static float noise3_Fallback(long seed, double x, double y, double z) {

        // Re-orient the cubic lattices via rotation, to produce a familiar look.
        // Orthonormal rotation. Not a skew transform.
        double r = FALLBACK_ROTATE_3D * (x + y + z);
        double xr = r - x, yr = r - y, zr = r - z;

        // Evaluate both lattices to form a BCC lattice.
        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    /**
     * Generate overlapping cubic lattices for 3D OpenSimplex2 noise.
     */
    private static float noise3_UnrotatedBase(long seed, double xr, double yr, double zr) {

        // Get base points and offsets.
        int xrb = fastRound(xr), yrb = fastRound(yr), zrb = fastRound(zr);
        float xri = (float)(xr - xrb), yri = (float)(yr - yrb), zri = (float)(zr - zrb);

        // -1 if positive, 1 if negative.
        int xNSign = (int)(-1.0f - xri) | 1, yNSign = (int)(-1.0f - yri) | 1, zNSign = (int)(-1.0f - zri) | 1;

        // Compute absolute values, using the above as a shortcut. This was faster in my tests for some reason.
        float ax0 = xNSign * -xri, ay0 = yNSign * -yri, az0 = zNSign * -zri;

        // Prime pre-multiplication for hash.
        long xrbp = xrb * PRIME_X, yrbp = yrb * PRIME_Y, zrbp = zrb * PRIME_Z;

        // Loop: Pick an edge on each lattice copy.
        float value = 0;
        float a = (RSQUARED_3D - xri * xri) - (yri * yri + zri * zri);
        for (int l = 0; ; l++) {

            // Closest point on cube.
            if (a > 0) {
                value += (a * a) * (a * a) * grad(seed, xrbp, yrbp, zrbp, xri, yri, zri);
            }

            // Second-closest point.
            if (ax0 >= ay0 && ax0 >= az0) {
                float b = a + ax0 + ax0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp - xNSign * PRIME_X, yrbp, zrbp, xri + xNSign, yri, zri);
                }
            }
            else if (ay0 > ax0 && ay0 >= az0) {
                float b = a + ay0 + ay0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp, yrbp - yNSign * PRIME_Y, zrbp, xri, yri + yNSign, zri);
                }
            }
            else
            {
                float b = a + az0 + az0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp, yrbp, zrbp - zNSign * PRIME_Z, xri, yri, zri + zNSign);
                }
            }

            // Break from loop if we're done, skipping updates below.
            if (l == 1) break;

            // Update absolute value.
            ax0 = 0.5f - ax0;
            ay0 = 0.5f - ay0;
            az0 = 0.5f - az0;

            // Update relative coordinate.
            xri = xNSign * ax0;
            yri = yNSign * ay0;
            zri = zNSign * az0;

            // Update falloff.
            a += (0.75f - ax0) - (ay0 + az0);

            // Update prime for hash.
            xrbp += (xNSign >> 1) & PRIME_X;
            yrbp += (yNSign >> 1) & PRIME_Y;
            zrbp += (zNSign >> 1) & PRIME_Z;

            // Update the reverse sign indicators.
            xNSign = -xNSign;
            yNSign = -yNSign;
            zNSign = -zNSign;

            // And finally update the seed for the other lattice copy.
            seed ^= SEED_FLIP_3D;
        }

        return value;
    }

    /**
     * 4D OpenSimplex2 noise, with XYZ oriented like noise3_ImproveXY
     * and W for an extra degree of freedom. W repeats eventually.
     * Recommended for time-varied animations which texture a 3D object (W=time)
     * in a space where Z is vertical
     */
    public static float noise4_ImproveXYZ_ImproveXY(long seed, double x, double y, double z, double w) {

        double xy = x + y;
        double s2 = xy * -0.21132486540518699998;
        double zz = z * 0.28867513459481294226;
        double ww = w * 0.2236067977499788;
        double xr = x + (zz + ww + s2), yr = y + (zz + ww + s2);
        double zr = xy * -0.57735026918962599998 + (zz + ww);
        double wr = z * -0.866025403784439 + ww;

        return noise4_UnskewedBase(seed, xr, yr, zr, wr);
    }

    /**
     * 4D OpenSimplex2 noise, with XYZ oriented like noise3_ImproveXZ
     * and W for an extra degree of freedom. W repeats eventually.
     * Recommended for time-varied animations which texture a 3D object (W=time)
     * in a space where Y is vertical
     */
    public static float noise4_ImproveXYZ_ImproveXZ(long seed, double x, double y, double z, double w) {

        double xz = x + z;
        double s2 = xz * -0.21132486540518699998;
        double yy = y * 0.28867513459481294226;
        double ww = w * 0.2236067977499788;
        double xr = x + (yy + ww + s2), zr = z + (yy + ww + s2);
        double yr = xz * -0.57735026918962599998 + (yy + ww);
        double wr = y * -0.866025403784439 + ww;

        return noise4_UnskewedBase(seed, xr, yr, zr, wr);
    }

    /**
     * 4D OpenSimplex2 noise, with XYZ oriented like noise3_Fallback
     * and W for an extra degree of freedom. W repeats eventually.
     * Recommended for time-varied animations which texture a 3D object (W=time)
     * where there isn't a clear distinction between horizontal and vertical
     */
    public static float noise4_ImproveXYZ(long seed, double x, double y, double z, double w) {

        double xyz = x + y + z;
        double ww = w * 0.2236067977499788;
        double s2 = xyz * -0.16666666666666666 + ww;
        double xs = x + s2, ys = y + s2, zs = z + s2, ws = -0.5 * xyz + ww;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    /**
     * 4D OpenSimplex2 noise, with XY and ZW forming orthogonal triangular-based planes.
     * Recommended for 3D terrain, where X and Y (or Z and W) are horizontal.
     * Recommended for noise(x, y, sin(time), cos(time)) trick.
     */
    public static float noise4_ImproveXY_ImproveZW(long seed, double x, double y, double z, double w) {

        double s2 = (x + y) * -0.178275657951399372 + (z + w) * 0.215623393288842828;
        double t2 = (z + w) * -0.403949762580207112 + (x + y) * -0.375199083010075342;
        double xs = x + s2, ys = y + s2, zs = z + t2, ws = w + t2;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    /**
     * 4D OpenSimplex2 noise, fallback lattice orientation.
     */
    public static float noise4_Fallback(long seed, double x, double y, double z, double w) {

        // Get points for A4 lattice
        double s = SKEW_4D * (x + y + z + w);
        double xs = x + s, ys = y + s, zs = z + s, ws = w + s;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    /**
     * 4D OpenSimplex2 noise base.
     */
    private static float noise4_UnskewedBase(long seed, double xs, double ys, double zs, double ws) {

        // Get base points and offsets
        int xsb = fastFloor(xs), ysb = fastFloor(ys), zsb = fastFloor(zs), wsb = fastFloor(ws);
        float xsi = (float)(xs - xsb), ysi = (float)(ys - ysb), zsi = (float)(zs - zsb), wsi = (float)(ws - wsb);

        // Determine which lattice we can be confident has a contributing point its corresponding cell's base simplex.
        // We only look at the spaces between the diagonal planes. This proved effective in all of my tests.
        float siSum = (xsi + ysi) + (zsi + wsi);
        int startingLattice = (int)(siSum * 1.25);

        // Offset for seed based on first lattice copy.
        seed += startingLattice * SEED_OFFSET_4D;

        // Offset for lattice point relative positions (skewed)
        float startingLatticeOffset = startingLattice * -LATTICE_STEP_4D;
        xsi += startingLatticeOffset; ysi += startingLatticeOffset; zsi += startingLatticeOffset; wsi += startingLatticeOffset;

        // Prep for vertex contributions.
        float ssi = (siSum + startingLatticeOffset * 4) * UNSKEW_4D;

        // Prime pre-multiplication for hash.
        long xsvp = xsb * PRIME_X, ysvp = ysb * PRIME_Y, zsvp = zsb * PRIME_Z, wsvp = wsb * PRIME_W;

        // Five points to add, total, from five copies of the A4 lattice.
        float value = 0;
        for (int i = 0; ; i++) {

            // Next point is the closest vertex on the 4-simplex whose base vertex is the aforementioned vertex.
            double score0 = 1.0 + ssi * (-1.0 / UNSKEW_4D); // Seems slightly faster than 1.0-xsi-ysi-zsi-wsi
            if (xsi >= ysi && xsi >= zsi && xsi >= wsi && xsi >= score0) {
                xsvp += PRIME_X;
                xsi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (ysi > xsi && ysi >= zsi && ysi >= wsi && ysi >= score0) {
                ysvp += PRIME_Y;
                ysi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (zsi > xsi && zsi > ysi && zsi >= wsi && zsi >= score0) {
                zsvp += PRIME_Z;
                zsi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (wsi > xsi && wsi > ysi && wsi > zsi && wsi >= score0) {
                wsvp += PRIME_W;
                wsi -= 1;
                ssi -= UNSKEW_4D;
            }

            // gradient contribution with falloff.
            float dx = xsi + ssi, dy = ysi + ssi, dz = zsi + ssi, dw = wsi + ssi;
            float a = (dx * dx + dy * dy) + (dz * dz + dw * dw);
            if (a < RSQUARED_4D) {
                a -= RSQUARED_4D;
                a *= a;
                value += a * a * grad(seed, xsvp, ysvp, zsvp, wsvp, dx, dy, dz, dw);
            }

            // Break from loop if we're done, skipping updates below.
            if (i == 4) break;

            // Update for next lattice copy shifted down by <-0.2, -0.2, -0.2, -0.2>.
            xsi += LATTICE_STEP_4D; ysi += LATTICE_STEP_4D; zsi += LATTICE_STEP_4D; wsi += LATTICE_STEP_4D;
            ssi += LATTICE_STEP_4D * 4 * UNSKEW_4D;
            seed -= SEED_OFFSET_4D;

            // Because we don't always start on the same lattice copy, there's a special reset case.
            if (i == startingLattice) {
                xsvp -= PRIME_X;
                ysvp -= PRIME_Y;
                zsvp -= PRIME_Z;
                wsvp -= PRIME_W;
                seed += SEED_OFFSET_4D * 5;
            }
        }

        return value;
    }

    /*
     * Utility
     */

    private static float grad(long seed, long xsvp, long ysvp, float dx, float dy) {
        long hash = seed ^ xsvp ^ ysvp;
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_2D_EXPONENT + 1);
        int gi = (int)hash & ((N_GRADS_2D - 1) << 1);
        return GRADIENTS_2D[gi | 0] * dx + GRADIENTS_2D[gi | 1] * dy;
    }

    private static float grad(long seed, long xrvp, long yrvp, long zrvp, float dx, float dy, float dz) {
        long hash = (seed ^ xrvp) ^ (yrvp ^ zrvp);
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_3D_EXPONENT + 2);
        int gi = (int)hash & ((N_GRADS_3D - 1) << 2);
        return GRADIENTS_3D[gi | 0] * dx + GRADIENTS_3D[gi | 1] * dy + GRADIENTS_3D[gi | 2] * dz;
    }

    private static float grad(long seed, long xsvp, long ysvp, long zsvp, long wsvp, float dx, float dy, float dz, float dw) {
        long hash = seed ^ (xsvp ^ ysvp) ^ (zsvp ^ wsvp);
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_4D_EXPONENT + 2);
        int gi = (int)hash & ((N_GRADS_4D - 1) << 2);
        return (GRADIENTS_4D[gi | 0] * dx + GRADIENTS_4D[gi | 1] * dy) + (GRADIENTS_4D[gi | 2] * dz + GRADIENTS_4D[gi | 3] * dw);
    }

    private static int fastFloor(double x) {
        int xi = (int)x;
        return x < xi ? xi - 1 : xi;
    }

    private static int fastRound(double x) {
        return x < 0 ? (int)(x - 0.5) : (int)(x + 0.5);
    }

    /*
     * gradients
     */

    private static float[] GRADIENTS_2D;
    private static float[] GRADIENTS_3D;
    private static float[] GRADIENTS_4D;
    static {

        GRADIENTS_2D = new float[N_GRADS_2D * 2];
        float[] grad2 = {
            0.38268343236509f,   0.923879532511287f,
            0.923879532511287f,  0.38268343236509f,
            0.923879532511287f, -0.38268343236509f,
            0.38268343236509f,  -0.923879532511287f,
            -0.38268343236509f,  -0.923879532511287f,
            -0.923879532511287f, -0.38268343236509f,
            -0.923879532511287f,  0.38268343236509f,
            -0.38268343236509f,   0.923879532511287f,
            //-------------------------------------//
            0.130526192220052f,  0.99144486137381f,
            0.608761429008721f,  0.793353340291235f,
            0.793353340291235f,  0.608761429008721f,
            0.99144486137381f,   0.130526192220051f,
            0.99144486137381f,  -0.130526192220051f,
            0.793353340291235f, -0.60876142900872f,
            0.608761429008721f, -0.793353340291235f,
            0.130526192220052f, -0.99144486137381f,
            -0.130526192220052f, -0.99144486137381f,
            -0.608761429008721f, -0.793353340291235f,
            -0.793353340291235f, -0.608761429008721f,
            -0.99144486137381f,  -0.130526192220052f,
            -0.99144486137381f,   0.130526192220051f,
            -0.793353340291235f,  0.608761429008721f,
            -0.608761429008721f,  0.793353340291235f,
            -0.130526192220052f,  0.99144486137381f,
        };
        for (int i = 0; i < grad2.length; i++) {
            grad2[i] = (float)(grad2[i] / NORMALIZER_2D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_2D.length; i++, j++) {
            if (j == grad2.length) j = 0;
            GRADIENTS_2D[i] = grad2[j];
        }

        GRADIENTS_3D = new float[N_GRADS_3D * 4];
        float[] grad3 = {
            2.22474487139f,       2.22474487139f,      -1.0f,                 0.0f,
            2.22474487139f,       2.22474487139f,       1.0f,                 0.0f,
            3.0862664687972017f,  1.1721513422464978f,  0.0f,                 0.0f,
            1.1721513422464978f,  3.0862664687972017f,  0.0f,                 0.0f,
            -2.22474487139f,       2.22474487139f,      -1.0f,                 0.0f,
            -2.22474487139f,       2.22474487139f,       1.0f,                 0.0f,
            -1.1721513422464978f,  3.0862664687972017f,  0.0f,                 0.0f,
            -3.0862664687972017f,  1.1721513422464978f,  0.0f,                 0.0f,
            -1.0f,                -2.22474487139f,      -2.22474487139f,       0.0f,
            1.0f,                -2.22474487139f,      -2.22474487139f,       0.0f,
            0.0f,                -3.0862664687972017f, -1.1721513422464978f,  0.0f,
            0.0f,                -1.1721513422464978f, -3.0862664687972017f,  0.0f,
            -1.0f,                -2.22474487139f,       2.22474487139f,       0.0f,
            1.0f,                -2.22474487139f,       2.22474487139f,       0.0f,
            0.0f,                -1.1721513422464978f,  3.0862664687972017f,  0.0f,
            0.0f,                -3.0862664687972017f,  1.1721513422464978f,  0.0f,
            //--------------------------------------------------------------------//
            -2.22474487139f,      -2.22474487139f,      -1.0f,                 0.0f,
            -2.22474487139f,      -2.22474487139f,       1.0f,                 0.0f,
            -3.0862664687972017f, -1.1721513422464978f,  0.0f,                 0.0f,
            -1.1721513422464978f, -3.0862664687972017f,  0.0f,                 0.0f,
            -2.22474487139f,      -1.0f,                -2.22474487139f,       0.0f,
            -2.22474487139f,       1.0f,                -2.22474487139f,       0.0f,
            -1.1721513422464978f,  0.0f,                -3.0862664687972017f,  0.0f,
            -3.0862664687972017f,  0.0f,                -1.1721513422464978f,  0.0f,
            -2.22474487139f,      -1.0f,                 2.22474487139f,       0.0f,
            -2.22474487139f,       1.0f,                 2.22474487139f,       0.0f,
            -3.0862664687972017f,  0.0f,                 1.1721513422464978f,  0.0f,
            -1.1721513422464978f,  0.0f,                 3.0862664687972017f,  0.0f,
            -1.0f,                 2.22474487139f,      -2.22474487139f,       0.0f,
            1.0f,                 2.22474487139f,      -2.22474487139f,       0.0f,
            0.0f,                 1.1721513422464978f, -3.0862664687972017f,  0.0f,
            0.0f,                 3.0862664687972017f, -1.1721513422464978f,  0.0f,
            -1.0f,                 2.22474487139f,       2.22474487139f,       0.0f,
            1.0f,                 2.22474487139f,       2.22474487139f,       0.0f,
            0.0f,                 3.0862664687972017f,  1.1721513422464978f,  0.0f,
            0.0f,                 1.1721513422464978f,  3.0862664687972017f,  0.0f,
            2.22474487139f,      -2.22474487139f,      -1.0f,                 0.0f,
            2.22474487139f,      -2.22474487139f,       1.0f,                 0.0f,
            1.1721513422464978f, -3.0862664687972017f,  0.0f,                 0.0f,
            3.0862664687972017f, -1.1721513422464978f,  0.0f,                 0.0f,
            2.22474487139f,      -1.0f,                -2.22474487139f,       0.0f,
            2.22474487139f,       1.0f,                -2.22474487139f,       0.0f,
            3.0862664687972017f,  0.0f,                -1.1721513422464978f,  0.0f,
            1.1721513422464978f,  0.0f,                -3.0862664687972017f,  0.0f,
            2.22474487139f,      -1.0f,                 2.22474487139f,       0.0f,
            2.22474487139f,       1.0f,                 2.22474487139f,       0.0f,
            1.1721513422464978f,  0.0f,                 3.0862664687972017f,  0.0f,
            3.0862664687972017f,  0.0f,                 1.1721513422464978f,  0.0f,
        };
        for (int i = 0; i < grad3.length; i++) {
            grad3[i] = (float)(grad3[i] / NORMALIZER_3D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_3D.length; i++, j++) {
            if (j == grad3.length) j = 0;
            GRADIENTS_3D[i] = grad3[j];
        }

        GRADIENTS_4D = new float[N_GRADS_4D * 4];
        float[] grad4 = {
            -0.6740059517812944f,   -0.3239847771997537f,   -0.3239847771997537f,    0.5794684678643381f,
            -0.7504883828755602f,   -0.4004672082940195f,    0.15296486218853164f,   0.5029860367700724f,
            -0.7504883828755602f,    0.15296486218853164f,  -0.4004672082940195f,    0.5029860367700724f,
            -0.8828161875373585f,    0.08164729285680945f,   0.08164729285680945f,   0.4553054119602712f,
            -0.4553054119602712f,   -0.08164729285680945f,  -0.08164729285680945f,   0.8828161875373585f,
            -0.5029860367700724f,   -0.15296486218853164f,   0.4004672082940195f,    0.7504883828755602f,
            -0.5029860367700724f,    0.4004672082940195f,   -0.15296486218853164f,   0.7504883828755602f,
            -0.5794684678643381f,    0.3239847771997537f,    0.3239847771997537f,    0.6740059517812944f,
            -0.6740059517812944f,   -0.3239847771997537f,    0.5794684678643381f,   -0.3239847771997537f,
            -0.7504883828755602f,   -0.4004672082940195f,    0.5029860367700724f,    0.15296486218853164f,
            -0.7504883828755602f,    0.15296486218853164f,   0.5029860367700724f,   -0.4004672082940195f,
            -0.8828161875373585f,    0.08164729285680945f,   0.4553054119602712f,    0.08164729285680945f,
            -0.4553054119602712f,   -0.08164729285680945f,   0.8828161875373585f,   -0.08164729285680945f,
            -0.5029860367700724f,   -0.15296486218853164f,   0.7504883828755602f,    0.4004672082940195f,
            -0.5029860367700724f,    0.4004672082940195f,    0.7504883828755602f,   -0.15296486218853164f,
            -0.5794684678643381f,    0.3239847771997537f,    0.6740059517812944f,    0.3239847771997537f,
            -0.6740059517812944f,    0.5794684678643381f,   -0.3239847771997537f,   -0.3239847771997537f,
            -0.7504883828755602f,    0.5029860367700724f,   -0.4004672082940195f,    0.15296486218853164f,
            -0.7504883828755602f,    0.5029860367700724f,    0.15296486218853164f,  -0.4004672082940195f,
            -0.8828161875373585f,    0.4553054119602712f,    0.08164729285680945f,   0.08164729285680945f,
            -0.4553054119602712f,    0.8828161875373585f,   -0.08164729285680945f,  -0.08164729285680945f,
            -0.5029860367700724f,    0.7504883828755602f,   -0.15296486218853164f,   0.4004672082940195f,
            -0.5029860367700724f,    0.7504883828755602f,    0.4004672082940195f,   -0.15296486218853164f,
            -0.5794684678643381f,    0.6740059517812944f,    0.3239847771997537f,    0.3239847771997537f,
            0.5794684678643381f,   -0.6740059517812944f,   -0.3239847771997537f,   -0.3239847771997537f,
            0.5029860367700724f,   -0.7504883828755602f,   -0.4004672082940195f,    0.15296486218853164f,
            0.5029860367700724f,   -0.7504883828755602f,    0.15296486218853164f,  -0.4004672082940195f,
            0.4553054119602712f,   -0.8828161875373585f,    0.08164729285680945f,   0.08164729285680945f,
            0.8828161875373585f,   -0.4553054119602712f,   -0.08164729285680945f,  -0.08164729285680945f,
            0.7504883828755602f,   -0.5029860367700724f,   -0.15296486218853164f,   0.4004672082940195f,
            0.7504883828755602f,   -0.5029860367700724f,    0.4004672082940195f,   -0.15296486218853164f,
            0.6740059517812944f,   -0.5794684678643381f,    0.3239847771997537f,    0.3239847771997537f,
            //------------------------------------------------------------------------------------------//
            -0.753341017856078f,    -0.37968289875261624f,  -0.37968289875261624f,  -0.37968289875261624f,
            -0.7821684431180708f,   -0.4321472685365301f,   -0.4321472685365301f,    0.12128480194602098f,
            -0.7821684431180708f,   -0.4321472685365301f,    0.12128480194602098f,  -0.4321472685365301f,
            -0.7821684431180708f,    0.12128480194602098f,  -0.4321472685365301f,   -0.4321472685365301f,
            -0.8586508742123365f,   -0.508629699630796f,     0.044802370851755174f,  0.044802370851755174f,
            -0.8586508742123365f,    0.044802370851755174f, -0.508629699630796f,     0.044802370851755174f,
            -0.8586508742123365f,    0.044802370851755174f,  0.044802370851755174f, -0.508629699630796f,
            -0.9982828964265062f,   -0.03381941603233842f,  -0.03381941603233842f,  -0.03381941603233842f,
            -0.37968289875261624f,  -0.753341017856078f,    -0.37968289875261624f,  -0.37968289875261624f,
            -0.4321472685365301f,   -0.7821684431180708f,   -0.4321472685365301f,    0.12128480194602098f,
            -0.4321472685365301f,   -0.7821684431180708f,    0.12128480194602098f,  -0.4321472685365301f,
            0.12128480194602098f,  -0.7821684431180708f,   -0.4321472685365301f,   -0.4321472685365301f,
            -0.508629699630796f,    -0.8586508742123365f,    0.044802370851755174f,  0.044802370851755174f,
            0.044802370851755174f, -0.8586508742123365f,   -0.508629699630796f,     0.044802370851755174f,
            0.044802370851755174f, -0.8586508742123365f,    0.044802370851755174f, -0.508629699630796f,
            -0.03381941603233842f,  -0.9982828964265062f,   -0.03381941603233842f,  -0.03381941603233842f,
            -0.37968289875261624f,  -0.37968289875261624f,  -0.753341017856078f,    -0.37968289875261624f,
            -0.4321472685365301f,   -0.4321472685365301f,   -0.7821684431180708f,    0.12128480194602098f,
            -0.4321472685365301f,    0.12128480194602098f,  -0.7821684431180708f,   -0.4321472685365301f,
            0.12128480194602098f,  -0.4321472685365301f,   -0.7821684431180708f,   -0.4321472685365301f,
            -0.508629699630796f,     0.044802370851755174f, -0.8586508742123365f,    0.044802370851755174f,
            0.044802370851755174f, -0.508629699630796f,    -0.8586508742123365f,    0.044802370851755174f,
            0.044802370851755174f,  0.044802370851755174f, -0.8586508742123365f,   -0.508629699630796f,
            -0.03381941603233842f,  -0.03381941603233842f,  -0.9982828964265062f,   -0.03381941603233842f,
            -0.37968289875261624f,  -0.37968289875261624f,  -0.37968289875261624f,  -0.753341017856078f,
            -0.4321472685365301f,   -0.4321472685365301f,    0.12128480194602098f,  -0.7821684431180708f,
            -0.4321472685365301f,    0.12128480194602098f,  -0.4321472685365301f,   -0.7821684431180708f,
            0.12128480194602098f,  -0.4321472685365301f,   -0.4321472685365301f,   -0.7821684431180708f,
            -0.508629699630796f,     0.044802370851755174f,  0.044802370851755174f, -0.8586508742123365f,
            0.044802370851755174f, -0.508629699630796f,     0.044802370851755174f, -0.8586508742123365f,
            0.044802370851755174f,  0.044802370851755174f, -0.508629699630796f,    -0.8586508742123365f,
            -0.03381941603233842f,  -0.03381941603233842f,  -0.03381941603233842f,  -0.9982828964265062f,
            -0.3239847771997537f,   -0.6740059517812944f,   -0.3239847771997537f,    0.5794684678643381f,
            -0.4004672082940195f,   -0.7504883828755602f,    0.15296486218853164f,   0.5029860367700724f,
            0.15296486218853164f,  -0.7504883828755602f,   -0.4004672082940195f,    0.5029860367700724f,
            0.08164729285680945f,  -0.8828161875373585f,    0.08164729285680945f,   0.4553054119602712f,
            -0.08164729285680945f,  -0.4553054119602712f,   -0.08164729285680945f,   0.8828161875373585f,
            -0.15296486218853164f,  -0.5029860367700724f,    0.4004672082940195f,    0.7504883828755602f,
            0.4004672082940195f,   -0.5029860367700724f,   -0.15296486218853164f,   0.7504883828755602f,
            0.3239847771997537f,   -0.5794684678643381f,    0.3239847771997537f,    0.6740059517812944f,
            -0.3239847771997537f,   -0.3239847771997537f,   -0.6740059517812944f,    0.5794684678643381f,
            -0.4004672082940195f,    0.15296486218853164f,  -0.7504883828755602f,    0.5029860367700724f,
            0.15296486218853164f,  -0.4004672082940195f,   -0.7504883828755602f,    0.5029860367700724f,
            0.08164729285680945f,   0.08164729285680945f,  -0.8828161875373585f,    0.4553054119602712f,
            -0.08164729285680945f,  -0.08164729285680945f,  -0.4553054119602712f,    0.8828161875373585f,
            -0.15296486218853164f,   0.4004672082940195f,   -0.5029860367700724f,    0.7504883828755602f,
            0.4004672082940195f,   -0.15296486218853164f,  -0.5029860367700724f,    0.7504883828755602f,
            0.3239847771997537f,    0.3239847771997537f,   -0.5794684678643381f,    0.6740059517812944f,
            -0.3239847771997537f,   -0.6740059517812944f,    0.5794684678643381f,   -0.3239847771997537f,
            -0.4004672082940195f,   -0.7504883828755602f,    0.5029860367700724f,    0.15296486218853164f,
            0.15296486218853164f,  -0.7504883828755602f,    0.5029860367700724f,   -0.4004672082940195f,
            0.08164729285680945f,  -0.8828161875373585f,    0.4553054119602712f,    0.08164729285680945f,
            -0.08164729285680945f,  -0.4553054119602712f,    0.8828161875373585f,   -0.08164729285680945f,
            -0.15296486218853164f,  -0.5029860367700724f,    0.7504883828755602f,    0.4004672082940195f,
            0.4004672082940195f,   -0.5029860367700724f,    0.7504883828755602f,   -0.15296486218853164f,
            0.3239847771997537f,   -0.5794684678643381f,    0.6740059517812944f,    0.3239847771997537f,
            -0.3239847771997537f,   -0.3239847771997537f,    0.5794684678643381f,   -0.6740059517812944f,
            -0.4004672082940195f,    0.15296486218853164f,   0.5029860367700724f,   -0.7504883828755602f,
            0.15296486218853164f,  -0.4004672082940195f,    0.5029860367700724f,   -0.7504883828755602f,
            0.08164729285680945f,   0.08164729285680945f,   0.4553054119602712f,   -0.8828161875373585f,
            -0.08164729285680945f,  -0.08164729285680945f,   0.8828161875373585f,   -0.4553054119602712f,
            -0.15296486218853164f,   0.4004672082940195f,    0.7504883828755602f,   -0.5029860367700724f,
            0.4004672082940195f,   -0.15296486218853164f,   0.7504883828755602f,   -0.5029860367700724f,
            0.3239847771997537f,    0.3239847771997537f,    0.6740059517812944f,   -0.5794684678643381f,
            -0.3239847771997537f,    0.5794684678643381f,   -0.6740059517812944f,   -0.3239847771997537f,
            -0.4004672082940195f,    0.5029860367700724f,   -0.7504883828755602f,    0.15296486218853164f,
            0.15296486218853164f,   0.5029860367700724f,   -0.7504883828755602f,   -0.4004672082940195f,
            0.08164729285680945f,   0.4553054119602712f,   -0.8828161875373585f,    0.08164729285680945f,
            -0.08164729285680945f,   0.8828161875373585f,   -0.4553054119602712f,   -0.08164729285680945f,
            -0.15296486218853164f,   0.7504883828755602f,   -0.5029860367700724f,    0.4004672082940195f,
            0.4004672082940195f,    0.7504883828755602f,   -0.5029860367700724f,   -0.15296486218853164f,
            0.3239847771997537f,    0.6740059517812944f,   -0.5794684678643381f,    0.3239847771997537f,
            -0.3239847771997537f,    0.5794684678643381f,   -0.3239847771997537f,   -0.6740059517812944f,
            -0.4004672082940195f,    0.5029860367700724f,    0.15296486218853164f,  -0.7504883828755602f,
            0.15296486218853164f,   0.5029860367700724f,   -0.4004672082940195f,   -0.7504883828755602f,
            0.08164729285680945f,   0.4553054119602712f,    0.08164729285680945f,  -0.8828161875373585f,
            -0.08164729285680945f,   0.8828161875373585f,   -0.08164729285680945f,  -0.4553054119602712f,
            -0.15296486218853164f,   0.7504883828755602f,    0.4004672082940195f,   -0.5029860367700724f,
            0.4004672082940195f,    0.7504883828755602f,   -0.15296486218853164f,  -0.5029860367700724f,
            0.3239847771997537f,    0.6740059517812944f,    0.3239847771997537f,   -0.5794684678643381f,
            0.5794684678643381f,   -0.3239847771997537f,   -0.6740059517812944f,   -0.3239847771997537f,
            0.5029860367700724f,   -0.4004672082940195f,   -0.7504883828755602f,    0.15296486218853164f,
            0.5029860367700724f,    0.15296486218853164f,  -0.7504883828755602f,   -0.4004672082940195f,
            0.4553054119602712f,    0.08164729285680945f,  -0.8828161875373585f,    0.08164729285680945f,
            0.8828161875373585f,   -0.08164729285680945f,  -0.4553054119602712f,   -0.08164729285680945f,
            0.7504883828755602f,   -0.15296486218853164f,  -0.5029860367700724f,    0.4004672082940195f,
            0.7504883828755602f,    0.4004672082940195f,   -0.5029860367700724f,   -0.15296486218853164f,
            0.6740059517812944f,    0.3239847771997537f,   -0.5794684678643381f,    0.3239847771997537f,
            0.5794684678643381f,   -0.3239847771997537f,   -0.3239847771997537f,   -0.6740059517812944f,
            0.5029860367700724f,   -0.4004672082940195f,    0.15296486218853164f,  -0.7504883828755602f,
            0.5029860367700724f,    0.15296486218853164f,  -0.4004672082940195f,   -0.7504883828755602f,
            0.4553054119602712f,    0.08164729285680945f,   0.08164729285680945f,  -0.8828161875373585f,
            0.8828161875373585f,   -0.08164729285680945f,  -0.08164729285680945f,  -0.4553054119602712f,
            0.7504883828755602f,   -0.15296486218853164f,   0.4004672082940195f,   -0.5029860367700724f,
            0.7504883828755602f,    0.4004672082940195f,   -0.15296486218853164f,  -0.5029860367700724f,
            0.6740059517812944f,    0.3239847771997537f,    0.3239847771997537f,   -0.5794684678643381f,
            0.03381941603233842f,   0.03381941603233842f,   0.03381941603233842f,   0.9982828964265062f,
            -0.044802370851755174f, -0.044802370851755174f,  0.508629699630796f,     0.8586508742123365f,
            -0.044802370851755174f,  0.508629699630796f,    -0.044802370851755174f,  0.8586508742123365f,
            -0.12128480194602098f,   0.4321472685365301f,    0.4321472685365301f,    0.7821684431180708f,
            0.508629699630796f,    -0.044802370851755174f, -0.044802370851755174f,  0.8586508742123365f,
            0.4321472685365301f,   -0.12128480194602098f,   0.4321472685365301f,    0.7821684431180708f,
            0.4321472685365301f,    0.4321472685365301f,   -0.12128480194602098f,   0.7821684431180708f,
            0.37968289875261624f,   0.37968289875261624f,   0.37968289875261624f,   0.753341017856078f,
            0.03381941603233842f,   0.03381941603233842f,   0.9982828964265062f,    0.03381941603233842f,
            -0.044802370851755174f,  0.044802370851755174f,  0.8586508742123365f,    0.508629699630796f,
            -0.044802370851755174f,  0.508629699630796f,     0.8586508742123365f,   -0.044802370851755174f,
            -0.12128480194602098f,   0.4321472685365301f,    0.7821684431180708f,    0.4321472685365301f,
            0.508629699630796f,    -0.044802370851755174f,  0.8586508742123365f,   -0.044802370851755174f,
            0.4321472685365301f,   -0.12128480194602098f,   0.7821684431180708f,    0.4321472685365301f,
            0.4321472685365301f,    0.4321472685365301f,    0.7821684431180708f,   -0.12128480194602098f,
            0.37968289875261624f,   0.37968289875261624f,   0.753341017856078f,     0.37968289875261624f,
            0.03381941603233842f,   0.9982828964265062f,    0.03381941603233842f,   0.03381941603233842f,
            -0.044802370851755174f,  0.8586508742123365f,   -0.044802370851755174f,  0.508629699630796f,
            -0.044802370851755174f,  0.8586508742123365f,    0.508629699630796f,    -0.044802370851755174f,
            -0.12128480194602098f,   0.7821684431180708f,    0.4321472685365301f,    0.4321472685365301f,
            0.508629699630796f,     0.8586508742123365f,   -0.044802370851755174f, -0.044802370851755174f,
            0.4321472685365301f,    0.7821684431180708f,   -0.12128480194602098f,   0.4321472685365301f,
            0.4321472685365301f,    0.7821684431180708f,    0.4321472685365301f,   -0.12128480194602098f,
            0.37968289875261624f,   0.753341017856078f,     0.37968289875261624f,   0.37968289875261624f,
            0.9982828964265062f,    0.03381941603233842f,   0.03381941603233842f,   0.03381941603233842f,
            0.8586508742123365f,   -0.044802370851755174f, -0.044802370851755174f,  0.508629699630796f,
            0.8586508742123365f,   -0.044802370851755174f,  0.508629699630796f,    -0.044802370851755174f,
            0.7821684431180708f,   -0.12128480194602098f,   0.4321472685365301f,    0.4321472685365301f,
            0.8586508742123365f,    0.508629699630796f,    -0.044802370851755174f, -0.044802370851755174f,
            0.7821684431180708f,    0.4321472685365301f,   -0.12128480194602098f,   0.4321472685365301f,
            0.7821684431180708f,    0.4321472685365301f,    0.4321472685365301f,   -0.12128480194602098f,
            0.753341017856078f,     0.37968289875261624f,   0.37968289875261624f,   0.37968289875261624f,
        };
        for (int i = 0; i < grad4.length; i++) {
            grad4[i] = (float)(grad4[i] / NORMALIZER_4D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_4D.length; i++, j++) {
            if (j == grad4.length) j = 0;
            GRADIENTS_4D[i] = grad4[j];
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/utils/PasswordUtils.java
================
package io.github.pokemeetup.utils;

import at.favre.lib.crypto.bcrypt.BCrypt;

public class PasswordUtils {

    public static String hashPassword(String password) {
        try {
            return BCrypt.withDefaults().hashToString(10, password.toCharArray());
        } catch (Exception e) {
            GameLogger.info("Error hashing password: " + e.getMessage());
            return null;
        }
    }

    public static boolean verifyPassword(String plainPassword, String storedHash) {
        try {
            if (storedHash == null) {
                GameLogger.info("Stored hash is null for password verification");
                return false;
            }
            return BCrypt.verifyer().verify(plainPassword.toCharArray(), storedHash).verified;
        } catch (Exception e) {
            GameLogger.info("Error verifying password: " + e.getMessage());
            return false;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/utils/PokemonLevelCalculator.java
================
package io.github.pokemeetup.utils;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;

public class PokemonLevelCalculator {
    public static final float LEVEL_VARIANCE = 2f;

    public static int calculateLevel(float pixelX, float pixelY, float tileSize) {
        float distance = Vector2.dst(pixelX, pixelY, 0, 0);
        float baseLevel = 2 + (distance / (tileSize * 50));
        float variance = MathUtils.random(-LEVEL_VARIANCE, LEVEL_VARIANCE);
        return MathUtils.round(MathUtils.clamp(baseLevel + variance, 1, 100));
    }
}

================
File: src/main/java/io/github/pokemeetup/utils/ResponsiveLayout.java
================
package io.github.pokemeetup.utils;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.math.Vector2;

public class ResponsiveLayout {
    public static final int SMALL_SCREEN_WIDTH = 800;
    public static final int MEDIUM_SCREEN_WIDTH = 1280;

    public static ScreenSize getScreenSize() {
        int width = Gdx.graphics.getWidth();
        if (width <= SMALL_SCREEN_WIDTH) return ScreenSize.SMALL;
        if (width <= MEDIUM_SCREEN_WIDTH) return ScreenSize.MEDIUM;
        return ScreenSize.LARGE;
    }

    public static float getFontScale() {
        switch (getScreenSize()) {
            case SMALL:
                return 0.5f;
            case MEDIUM:
                return 0.75f;
            default:
                return 1f;
        }
    }

    public static float getPadding() {
        switch (getScreenSize()) {
            case SMALL:
                return 10f;
            case MEDIUM:
                return 15f;
            default:
                return 20f;
        }
    }

    public static Vector2 getElementSize(float baseWidth, float baseHeight) {
        float scale = getFontScale();
        return new Vector2(baseWidth * scale, baseHeight * scale);
    }

    // Screen size categories
    public enum ScreenSize {
        SMALL, MEDIUM, LARGE
    }
}

================
File: src/main/java/io/github/pokemeetup/utils/storage/DesktopFileSystem.java
================
package io.github.pokemeetup.utils.storage;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import io.github.pokemeetup.FileSystemDelegate;
import io.github.pokemeetup.utils.GameLogger;

import java.io.*;
import java.nio.charset.StandardCharsets;

public class DesktopFileSystem implements FileSystemDelegate {

    @Override
    public boolean exists(String path) {
        return Gdx.files.local(path).exists();
    }

    @Override
    public void createDirectory(String path) {
        FileHandle dir = Gdx.files.local(path);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }
    @Override
    public void moveFile(String sourcePath, String destinationPath) throws IOException {
        File sourceFile = new File(sourcePath);
        File destFile = new File(destinationPath);

        if (!sourceFile.exists()) {
            throw new FileNotFoundException("Source file does not exist: " + sourcePath);
        }

        boolean success = sourceFile.renameTo(destFile);
        if (!success) {
            throw new IOException("Failed to move file from " + sourcePath + " to " + destinationPath);
        }
    }

    @Override
    public void writeString(String path, String content) throws IOException {
        try {
            Gdx.files.local(path).writeString(content, false);
        } catch (Exception e) {
            throw new IOException("Failed to write to file: " + path, e);
        }
    }

    @Override
    public String readString(String path) throws IOException {
        try {
            return Gdx.files.local(path).readString();
        } catch (Exception e) {
            throw new IOException("Failed to read from file: " + path, e);
        }
    }

    @Override
    public void deleteFile(String path) {
        FileHandle file = Gdx.files.local(path);
        if (file.exists()) {
            file.delete();
        }
    }

    @Override
    public void deleteDirectory(String path) {
        FileHandle dir = Gdx.files.local(path);
        if (dir.exists() && dir.isDirectory()) {
            dir.deleteDirectory();
        }
    }

    @Override
    public boolean isDirectory(String path) {
        return Gdx.files.local(path).isDirectory();
    }

    @Override
    public String[] list(String path) {
        FileHandle dir = Gdx.files.local(path);
        if (dir.exists() && dir.isDirectory()) {
            FileHandle[] files = dir.list();
            String[] names = new String[files.length];
            for (int i = 0; i < files.length; i++) {
                names[i] = files[i].name();
            }
            return names;
        }
        return new String[0];
    }

    @Override
    public void copyFile(String sourcePath, String destinationPath) throws IOException {
        try {
            FileHandle source = Gdx.files.local(sourcePath);
            FileHandle destination = Gdx.files.local(destinationPath);
            source.copyTo(destination);
        } catch (Exception e) {
            throw new IOException("Failed to copy file from " + sourcePath + " to " + destinationPath, e);
        }
    }

    @Override
    public InputStream openInputStream(String path) throws IOException {
        try {
            return Gdx.files.local(path).read();
        } catch (Exception e) {
            throw new IOException("Failed to open input stream: " + path, e);
        }
    }

    @Override
    public OutputStream openOutputStream(String path) throws IOException {
        try {
            return Gdx.files.local(path).write(false);
        } catch (Exception e) {
            throw new IOException("Failed to open output stream: " + path, e);
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/utils/storage/GameFileSystem.java
================
package io.github.pokemeetup.utils.storage;

import io.github.pokemeetup.FileSystemDelegate;
import io.github.pokemeetup.utils.GameLogger;

import java.io.*;

public class GameFileSystem {
    private static GameFileSystem instance;
    private FileSystemDelegate delegate;

    public FileSystemDelegate getDelegate() {
        checkDelegate();
        return delegate;
    }
    private GameFileSystem() {}
    public void moveFile(String sourcePath, String destinationPath) throws IOException {
        checkDelegate();
        try {
            delegate.moveFile(sourcePath, destinationPath);
        } catch (IOException e) {
            GameLogger.error("Failed to move file from " + sourcePath + " to " + destinationPath + ": " + e.getMessage());
            throw e;
        }
    }
    public static GameFileSystem getInstance() {
        if (instance == null) {
            instance = new GameFileSystem();
        }
        return instance;
    }

    public void setDelegate(FileSystemDelegate delegate) {
        this.delegate = delegate;
        GameLogger.info("File system delegate set: " + delegate.getClass().getSimpleName());
    }

    public void writeString(String path, String content) throws IOException {
        checkDelegate();
        try {
            delegate.writeString(path, content);
        } catch (IOException e) {
            GameLogger.error("Failed to write to file: " + path);
            throw e;
        }
    }

    public String readString(String path) throws IOException {
        checkDelegate();
        try {
            return delegate.readString(path);
        } catch (IOException e) {
            GameLogger.error("Failed to read from file: " + path);
            throw e;
        }
    }

    public boolean exists(String path) {
        checkDelegate();
        return delegate.exists(path);
    }

    public void createDirectory(String path) {
        checkDelegate();
        try {
            delegate.createDirectory(path);
        } catch (Exception e) {
            GameLogger.error("Failed to create directory: " + path);
            throw e;
        }
    }

    public void deleteFile(String path) {
        checkDelegate();
        try {
            delegate.deleteFile(path);
        } catch (Exception e) {
            GameLogger.error("Failed to delete file: " + path);
            throw e;
        }
    }

    public void deleteDirectory(String path) {
        checkDelegate();
        try {
            delegate.deleteDirectory(path);
        } catch (Exception e) {
            GameLogger.error("Failed to delete directory: " + path);
            throw e;
        }
    }

    public boolean isDirectory(String path) {
        checkDelegate();
        return delegate.isDirectory(path);
    }


    public String[] list(String path) {
        checkDelegate();
        return delegate.list(path);
    }


    private void checkDelegate() {
        if (delegate == null) {
            throw new IllegalStateException("FileSystemDelegate not set. Call setDelegate() first.");
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/utils/storage/InventoryConverter.java
================
package io.github.pokemeetup.utils.storage;

import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

public class InventoryConverter {



    public static ItemData itemToItemData(Item item) {
        if (item == null) {
            return null;
        }

        ItemData itemData = new ItemData();
        itemData.setItemId(item.getName());
        itemData.setCount(item.getCount());
        itemData.setUuid(item.getUuid() != null ? item.getUuid() : UUID.randomUUID());
        itemData.setDurability(item.getDurability());
        itemData.setMaxDurability(item.getMaxDurability());

        GameLogger.info("Converting Item to ItemData: " + item.getName() + " x" + item.getCount());
        return itemData;
    }

    public static Item itemDataToItem(ItemData itemData) {
        if (itemData == null) {
            return null;
        }

        // Create a new instance and DEEP copy all properties
        Item item = new Item(itemData.getItemId());

        // IMPORTANT: Deep copy all properties
        item.setCount(itemData.getCount());
        // Use original UUID to maintain item identity across operations
        item.setUuid(itemData.getUuid() != null ? itemData.getUuid() : UUID.randomUUID());
        item.setDurability(itemData.getDurability());
        item.setMaxDurability(itemData.getMaxDurability());

        GameLogger.info("Converting ItemData to Item: " + itemData.getItemId() + " x" + itemData.getCount());
        return item;
    }

        public static void extractInventoryDataFromPlayer(Player player, PlayerData playerData) {
            if (player == null || playerData == null) {
                GameLogger.error("Cannot extract inventory from null Player or PlayerData");
                return;
            }

            try {
                Inventory inventory = player.getInventory();
                if (inventory == null) {
                    GameLogger.error("Player inventory is null");
                    playerData.setInventoryItems(new ArrayList<>(Collections.nCopies(Inventory.INVENTORY_SIZE, null)));
                    return;
                }

                List<ItemData> items = new ArrayList<>(Inventory.INVENTORY_SIZE);
                for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                    ItemData item = inventory.getItemAt(i);
                    if (item != null && item.isValid()) {
                        items.add(item.copy()); // Create deep copy
                    } else {
                        items.add(null);
                    }
                }
                playerData.setInventoryItems(items);
                GameLogger.info("Extracted " + items.stream().filter(Objects::nonNull).count() +
                    " items from inventory");
            } catch (Exception e) {
                GameLogger.error("Error extracting inventory data: " + e.getMessage());
                e.printStackTrace();
            }
        }


    @Deprecated
    public static List<String> toPlayerDataFormat(List<ItemData> items) {
        List<String> itemStrings = new ArrayList<>();
        for (ItemData item : items) {
            if (item != null) {
                itemStrings.add(item.getItemId() + ":" + item.getCount());
            } else {
                itemStrings.add(null);
            }
        }
        return itemStrings;
    }
    public static boolean addItemToInventory(Inventory inventory, ItemData newItem) {
        if (inventory == null || newItem == null) {
            GameLogger.error("Inventory or newItem is null. Cannot add item.");
            return false;
        }

        synchronized (inventory) {
            boolean added = inventory.addItem(newItem.copyWithUUID());
            if (added) {
                GameLogger.info("Item added to inventory successfully: " + newItem.getItemId());
            } else {
                GameLogger.error("Failed to add item to inventory: " + newItem.getItemId());
            }
            return added;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/utils/storage/JsonConfig.java
================
package io.github.pokemeetup.utils.storage;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonValue;
import com.badlogic.gdx.utils.JsonWriter;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.system.data.*;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

public class JsonConfig {
    private static final String SINGLE_PLAYER_DIR = "worlds/singleplayer/";
    private static Json instance;

    public static WorldData loadWorldData(String worldName) {
        if (GameContext.get().getGameClient() != null &&
            GameContext.get().isMultiplayer()) {
            GameLogger.info("Skipping local world load in multiplayer mode");
            return null;
        }

        try {
            FileHandle worldDir = Gdx.files.local(SINGLE_PLAYER_DIR + worldName);
            FileHandle worldFile = worldDir.child("world.json");

            if (!worldFile.exists()) {
                GameLogger.error("World file not found: " + worldFile.path());
                return null;
            }
            String jsonContent = worldFile.readString();
            Json json = getInstance();

            return json.fromJson(WorldData.class, jsonContent);

        } catch (Exception e) {
            GameLogger.error("Error loading world data: " + e.getMessage());
            return null;
        }
    }

    public static synchronized Json getInstance() {
        if (instance == null) {
            instance = new Json();
            instance.setOutputType(JsonWriter.OutputType.json);
            instance.setTypeName(null);
            instance.setUsePrototypes(false);
            setupSerializers(instance);
        }
        return instance;
    }


    private static void setupSerializers(Json json) {


        json.setSerializer(WorldData.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, WorldData world, Class knownType) {
                json.writeObjectStart();
                synchronized (world.getTimeLock()) {
                    json.writeValue("worldTimeInMinutes", world.getWorldTimeInMinutes());
                    json.writeValue("playedTime", world.getPlayedTime());
                    json.writeValue("dayLength", world.getDayLength());
                }
                json.writeValue("name", world.getName());
                json.writeValue("lastPlayed", world.getLastPlayed());
                json.writeValue("config", world.getConfig());
                json.writeValue("players", world.getPlayers());
                json.writeValue("pokemonData", world.getPokemonData());
                json.writeValue("commands_allowed", world.commandsAllowed());
                json.writeObjectEnd();
            }


            @Override
            public WorldData read(Json json, JsonValue jsonData, Class type) {
                WorldData world = new WorldData();
                JsonValue timeValue = jsonData.get("worldTimeInMinutes");
                if (timeValue != null) {
                    world.setWorldTimeInMinutes(timeValue.asDouble());
                }

                JsonValue playedValue = jsonData.get("playedTime");
                if (playedValue != null) {
                    world.setPlayedTime(playedValue.asLong());
                }

                JsonValue dayLengthValue = jsonData.get("dayLength");
                if (dayLengthValue != null) {
                    world.setDayLength(dayLengthValue.asFloat());
                }

                world.setName(jsonData.getString("name", ""));
                world.setLastPlayed(jsonData.getLong("lastPlayed", System.currentTimeMillis()));
                WorldData.WorldConfig config = json.readValue(WorldData.WorldConfig.class, jsonData.get("config"));
                if (config == null) {
                    config = new WorldData.WorldConfig(System.currentTimeMillis());
                }
                world.setConfig(config);

                // Players
                JsonValue playersObject = jsonData.get("players");
                if (playersObject != null && playersObject.isObject()) {
                    HashMap<String, PlayerData> players = new HashMap<>();
                    for (JsonValue playerEntry = playersObject.child; playerEntry != null; playerEntry = playerEntry.next) {
                        String username = playerEntry.name;
                        PlayerData playerData = json.readValue(PlayerData.class, playerEntry);
                        if (playerData != null) {
                            players.put(username, playerData);
                        }
                    }
                    world.setPlayers(players);
                }

                PokemonData pokemonData = json.readValue(PokemonData.class, jsonData.get("pokemonData"));
                if (pokemonData == null) {
                    pokemonData = new PokemonData();
                }
                world.setPokemonData(pokemonData);

                // Commands Allowed
                world.setCommandsAllowed(jsonData.getBoolean("commands_allowed", false));

                return world;
            }
        });


        json.setSerializer(WorldData.WorldConfig.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, WorldData.WorldConfig config, Class knownType) {
                json.writeObjectStart();
                json.writeValue("seed", config.getSeed());
                json.writeValue("treeSpawnRate", config.getTreeSpawnRate());
                json.writeValue("pokemonSpawnRate", config.getPokemonSpawnRate());
                json.writeValue("spawnTileX", config.getTileSpawnX());
                json.writeValue("spawnTileY", config.getTileSpawnY());
                json.writeObjectEnd();
            }

            @Override
            public WorldData.WorldConfig read(Json json, JsonValue jsonData, Class type) {
                WorldData.WorldConfig config = new WorldData.WorldConfig();
                config.setSeed(jsonData.getLong("seed", System.currentTimeMillis()));
                config.setTreeSpawnRate(jsonData.getFloat("treeSpawnRate", 0.15f));
                config.setPokemonSpawnRate(jsonData.getFloat("pokemonSpawnRate", 0.05f));
                config.setTileSpawnX(jsonData.getInt("spawnTileX", 0));
                config.setTileSpawnY(jsonData.getInt("spawnTileY", 0));
                return config;
            }
        });

        json.setSerializer(PlayerData.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, PlayerData playerData, Class knownType) {
                json.writeObjectStart();
                json.writeValue("username", playerData.getUsername());
                json.writeValue("x", playerData.getX());
                json.writeValue("y", playerData.getY());
                json.writeValue("direction", playerData.getDirection());
                json.writeValue("isMoving", playerData.isMoving());
                json.writeValue("wantsToRun", playerData.isWantsToRun());
                json.writeValue("characterType", playerData.getCharacterType());


                // Inventory Items
                json.writeArrayStart("inventoryItems");
                if (playerData.getInventoryItems() != null) {
                    for (ItemData item : playerData.getInventoryItems()) {
                        json.writeValue(item);
                    }
                }
                json.writeArrayEnd();

                // Party Pokemon
                json.writeArrayStart("partyPokemon");
                if (playerData.getPartyPokemon() != null) {
                    for (PokemonData pokemon : playerData.getPartyPokemon()) {
                        json.writeValue(pokemon);
                    }
                }
                json.writeArrayEnd();

                json.writeObjectEnd();
            }

            @Override
            public PlayerData read(Json json, JsonValue jsonData, Class type) {
                PlayerData playerData = new PlayerData();
                playerData.setUsername(jsonData.getString("username", "Player"));
                playerData.setX(jsonData.getFloat("x", 0f));
                playerData.setY(jsonData.getFloat("y", 0f));
                playerData.setDirection(jsonData.getString("direction", "down"));
                playerData.setMoving(jsonData.getBoolean("isMoving", false));
                playerData.setWantsToRun(jsonData.getBoolean("wantsToRun", false));
                playerData.setCharacterType(jsonData.getString("characterType", "boy"));

                // Inventory Items
                JsonValue inventoryArray = jsonData.get("inventoryItems");
                List<ItemData> inventory = new ArrayList<>(Inventory.INVENTORY_SIZE);
                for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                    inventory.add(null);
                }
                if (inventoryArray != null && inventoryArray.isArray()) {
                    int index = 0;
                    for (JsonValue itemValue = inventoryArray.child; itemValue != null && index < Inventory.INVENTORY_SIZE; itemValue = itemValue.next, index++) {
                        ItemData item = json.readValue(ItemData.class, itemValue);
                        inventory.set(index, item);
                    }
                }
                playerData.setInventoryItems(inventory);

                // Party Pokemon
                JsonValue partyArray = jsonData.get("partyPokemon");
                List<PokemonData> party = new ArrayList<>(6);
                for (int i = 0; i < 6; i++) {
                    party.add(null);
                }
                if (partyArray != null && partyArray.isArray()) {
                    int index = 0;
                    for (JsonValue pokemonValue = partyArray.child; pokemonValue != null && index < 6; pokemonValue = pokemonValue.next, index++) {
                        PokemonData pokemon = json.readValue(PokemonData.class, pokemonValue);
                        party.set(index, pokemon);
                    }
                }
                playerData.setPartyPokemon(party);

                return playerData;
            }
        });
        json.setSerializer(ItemData.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, ItemData itemData, Class knownType) {
                if (itemData == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();
                json.writeValue("itemId", itemData.getItemId());
                json.writeValue("count", itemData.getCount());
                json.writeValue("uuid", itemData.getUuid() != null ? itemData.getUuid().toString() : UUID.randomUUID().toString());
                json.writeValue("durability", itemData.getDurability());
                json.writeValue("maxDurability", itemData.getMaxDurability());
                json.writeObjectEnd();
            }

            @Override
            public ItemData read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return null;
                }

                ItemData itemData = new ItemData();

                String itemId;
                try {
                    itemId = jsonData.getString("itemId");
                } catch (Exception e) {
                    GameLogger.error("ItemData deserialization error: Missing 'itemId'. Skipping item.");
                    return null; // Skip this item
                }

                itemData.setCount(jsonData.getInt("count", 1));
                try {
                    String uuidStr = jsonData.getString("uuid", null);
                    itemData.setUuid(uuidStr != null ? UUID.fromString(uuidStr) : UUID.randomUUID());
                } catch (IllegalArgumentException e) {
                    itemData.setUuid(UUID.randomUUID());
                }

                itemData.setDurability(jsonData.getInt("durability", -1));
                itemData.setMaxDurability(jsonData.getInt("maxDurability", -1));

                // Set itemId after other fields
                itemData.setItemId(itemId);

                return itemData;
            }
        });

        json.setSerializer(PokemonData.class, new Json.Serializer<PokemonData>() {
            @Override
            public void write(Json json, PokemonData pokemonData, Class knownType) {
                if (pokemonData == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();

                // Basic Info
                json.writeValue("name", pokemonData.getName());
                json.writeValue("uuid", pokemonData.getUuid() != null ? pokemonData.getUuid().toString() : UUID.randomUUID().toString());
                json.writeValue("level", pokemonData.getLevel());
                json.writeValue("nature", pokemonData.getNature());

                // Primary Type
                if (pokemonData.getPrimaryType() != null) {
                    json.writeValue("primaryType", pokemonData.getPrimaryType().name());
                } else {
                    json.writeValue("primaryType", "NORMAL"); // Default to NORMAL if null
                }

                // Secondary Type
                if (pokemonData.getSecondaryType() != null) {
                    json.writeValue("secondaryType", pokemonData.getSecondaryType().name());
                }

                // Stats
                if (pokemonData.getStats() != null) {
                    json.writeValue("stats", pokemonData.getStats());
                }

                // Base Stats
                json.writeValue("baseHp", pokemonData.getBaseHp());
                json.writeValue("baseAttack", pokemonData.getBaseAttack());
                json.writeValue("baseDefense", pokemonData.getBaseDefense());
                json.writeValue("baseSpAtk", pokemonData.getBaseSpAtk());
                json.writeValue("baseSpDef", pokemonData.getBaseSpDef());
                json.writeValue("baseSpeed", pokemonData.getBaseSpeed());

                // Experience
                json.writeValue("currentExperience", pokemonData.getCurrentExperience());
                json.writeValue("experienceToNextLevel", pokemonData.getExperienceToNextLevel());

                // Current HP
                json.writeValue("currentHp", pokemonData.getCurrentHp());

                // Moves
                json.writeArrayStart("moves");
                if (pokemonData.getMoves() != null) {
                    for (PokemonData.MoveData move : pokemonData.getMoves()) {
                        json.writeValue(move);
                    }
                }
                json.writeArrayEnd();

                json.writeObjectEnd();
            }

            @Override
            public PokemonData read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return null;
                }

                PokemonData pokemonData = new PokemonData();

                pokemonData.setName(jsonData.getString("name", "Unknown"));
                String uuidStr = jsonData.getString("uuid", null);
                pokemonData.setUuid(uuidStr != null ? UUID.fromString(uuidStr) : UUID.randomUUID());
                pokemonData.setLevel(jsonData.getInt("level", 1));
                pokemonData.setNature(jsonData.getString("nature", "Unknown"));

                // Primary Type
                String primaryTypeStr = jsonData.getString("primaryType", "NORMAL");
                try {
                    pokemonData.setPrimaryType(Pokemon.PokemonType.valueOf(primaryTypeStr));
                } catch (IllegalArgumentException e) {
                    GameLogger.error("Invalid primary type '" + primaryTypeStr + "'. Defaulting to NORMAL.");
                    pokemonData.setPrimaryType(Pokemon.PokemonType.NORMAL);
                }

                // Secondary Type
                if (jsonData.has("secondaryType")) {
                    String secondaryTypeStr = jsonData.getString("secondaryType");
                    try {
                        pokemonData.setSecondaryType(Pokemon.PokemonType.valueOf(secondaryTypeStr));
                    } catch (IllegalArgumentException e) {
                        GameLogger.error("Invalid secondary type '" + secondaryTypeStr + "'. Setting to null.");
                        pokemonData.setSecondaryType(null);
                    }
                }

                // Stats
                JsonValue statsValue = jsonData.get("stats");
                if (statsValue != null) {
                    PokemonData.Stats stats = json.readValue(PokemonData.Stats.class, statsValue);
                    pokemonData.setStats(stats);
                }

                // Base Stats
                pokemonData.setBaseHp(jsonData.getInt("baseHp", 1));
                pokemonData.setBaseAttack(jsonData.getInt("baseAttack", 1));
                pokemonData.setBaseDefense(jsonData.getInt("baseDefense", 1));
                pokemonData.setBaseSpAtk(jsonData.getInt("baseSpAtk", 1));
                pokemonData.setBaseSpDef(jsonData.getInt("baseSpDef", 1));
                pokemonData.setBaseSpeed(jsonData.getInt("baseSpeed", 1));

                // Experience
                pokemonData.setCurrentExperience(jsonData.getInt("currentExperience", 0));
                pokemonData.setExperienceToNextLevel(jsonData.getInt("experienceToNextLevel", 100));

                // Current HP
                pokemonData.setCurrentHp(jsonData.getInt("currentHp", pokemonData.getBaseHp()));

                // Moves
                JsonValue movesArray = jsonData.get("moves");
                if (movesArray != null && movesArray.isArray()) {
                    List<PokemonData.MoveData> moves = new ArrayList<>();
                    for (JsonValue moveValue = movesArray.child; moveValue != null; moveValue = moveValue.next) {
                        PokemonData.MoveData moveData = json.readValue(PokemonData.MoveData.class, moveValue);
                        moves.add(moveData);
                    }
                    pokemonData.setMoves(moves);
                }

                return pokemonData;
            }
        });
        json.setSerializer(PokemonData.Stats.class, new Json.Serializer<PokemonData.Stats>() {
            @Override
            public void write(Json json, PokemonData.Stats stats, Class knownType) {
                if (stats == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();
                json.writeValue("hp", stats.getHp());
                json.writeValue("attack", stats.getAttack());
                json.writeValue("defense", stats.getDefense());
                json.writeValue("specialAttack", stats.getSpecialAttack());
                json.writeValue("specialDefense", stats.getSpecialDefense());
                json.writeValue("speed", stats.getSpeed());

                // IVs
                json.writeArrayStart("ivs");
                for (int iv : stats.ivs) {
                    json.writeValue(iv);
                }
                json.writeArrayEnd();

                // EVs
                json.writeArrayStart("evs");
                for (int ev : stats.evs) {
                    json.writeValue(ev);
                }
                json.writeArrayEnd();

                json.writeObjectEnd();
            }

            @Override
            public PokemonData.Stats read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return new PokemonData.Stats(); // Return default stats
                }

                PokemonData.Stats stats = new PokemonData.Stats();
                stats.setHp(jsonData.getInt("hp", 1));
                stats.setAttack(jsonData.getInt("attack", 1));
                stats.setDefense(jsonData.getInt("defense", 1));
                stats.setSpecialAttack(jsonData.getInt("specialAttack", 1));
                stats.setSpecialDefense(jsonData.getInt("specialDefense", 1));
                stats.setSpeed(jsonData.getInt("speed", 1));

                // IVs
                JsonValue ivsArray = jsonData.get("ivs");
                if (ivsArray != null && ivsArray.isArray()) {
                    int[] ivs = new int[6];
                    int index = 0;
                    for (JsonValue ivValue = ivsArray.child; ivValue != null && index < 6; ivValue = ivValue.next, index++) {
                        ivs[index] = ivValue.asInt();
                    }
                    stats.ivs = ivs;
                }

                // EVs
                JsonValue evsArray = jsonData.get("evs");
                if (evsArray != null && evsArray.isArray()) {
                    int[] evs = new int[6];
                    int index = 0;
                    for (JsonValue evValue = evsArray.child; evValue != null && index < 6; evValue = evValue.next, index++) {
                        evs[index] = evValue.asInt();
                    }
                    stats.evs = evs;
                }

                return stats;
            }
        });

        json.setSerializer(PokemonData.MoveData.class, new Json.Serializer<PokemonData.MoveData>() {
            @Override
            public void write(Json json, PokemonData.MoveData moveData, Class knownType) {
                if (moveData == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();
                json.writeValue("name", moveData.getName());
                json.writeValue("type", moveData.getType() != null ? moveData.getType().name() : "NORMAL");
                json.writeValue("power", moveData.getPower());
                json.writeValue("accuracy", moveData.getAccuracy());
                json.writeValue("pp", moveData.getPp());
                json.writeValue("maxPp", moveData.getMaxPp());
                json.writeValue("isSpecial", moveData.isSpecial());
                json.writeValue("description", moveData.getDescription());
                json.writeValue("canFlinch", moveData.isCanFlinch());
                json.writeValue("effect", moveData.effect);
                json.writeObjectEnd();
            }

            @Override
            public PokemonData.MoveData read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return null;
                }

                PokemonData.MoveData moveData = new PokemonData.MoveData();
                moveData.setName(jsonData.getString("name", "Unknown"));
                String typeStr = jsonData.getString("type", "NORMAL");
                try {
                    moveData.setType(Pokemon.PokemonType.valueOf(typeStr));
                } catch (IllegalArgumentException e) {
                    GameLogger.error("Invalid move type '" + typeStr + "'. Defaulting to NORMAL.");
                    moveData.setType(Pokemon.PokemonType.NORMAL);
                }

                moveData.setPower(jsonData.getInt("power", 0));
                moveData.setAccuracy(jsonData.getInt("accuracy", 100));
                moveData.setPp(jsonData.getInt("pp", 0));
                moveData.setMaxPp(jsonData.getInt("maxPp", 0));
                moveData.setSpecial(jsonData.getBoolean("isSpecial", false));
                moveData.setDescription(jsonData.getString("description", ""));
                moveData.setCanFlinch(jsonData.getBoolean("canFlinch", false));

                // Effect
                JsonValue effectValue = jsonData.get("effect");
                if (effectValue != null && effectValue.isObject()) {
                    moveData.effect = json.readValue(PokemonData.MoveData.MoveEffectData.class, effectValue);
                }

                return moveData;
            }
        });
        json.setSerializer(PokemonData.MoveData.MoveEffectData.class, new Json.Serializer<PokemonData.MoveData.MoveEffectData>() {
            @Override
            public void write(Json json, PokemonData.MoveData.MoveEffectData effectData, Class knownType) {
                if (effectData == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();
                if (effectData.getStatusEffect() != null) {
                    json.writeValue("statusEffect", effectData.getStatusEffect().name());
                }
                if (effectData.getStatModifiers() != null && !effectData.getStatModifiers().isEmpty()) {
                    json.writeObjectStart("statModifiers");
                    for (Map.Entry<String, Integer> entry : effectData.getStatModifiers().entrySet()) {
                        json.writeValue(entry.getKey(), entry.getValue());
                    }
                    json.writeObjectEnd();
                }
                json.writeValue("effectType", effectData.getEffectType());
                json.writeValue("chance", effectData.getChance());
                json.writeValue("animation", effectData.getAnimation());
                json.writeValue("sound", effectData.getSound());
                json.writeValue("duration", effectData.getDuration());
                json.writeObjectEnd();
            }

            @Override
            public PokemonData.MoveData.MoveEffectData read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return null;
                }

                PokemonData.MoveData.MoveEffectData effectData = new PokemonData.MoveData.MoveEffectData();

                if (jsonData.has("statusEffect")) {
                    String statusStr = jsonData.getString("statusEffect");
                    try {
                        effectData.setStatusEffect(Pokemon.Status.valueOf(statusStr));
                    } catch (IllegalArgumentException e) {
                        GameLogger.error("Invalid status effect '" + statusStr + "'. Ignoring.");
                    }
                }

                JsonValue statModifiersValue = jsonData.get("statModifiers");
                if (statModifiersValue != null && statModifiersValue.isObject()) {
                    Map<String, Integer> statModifiers = new HashMap<>();
                    for (JsonValue statEntry = statModifiersValue.child; statEntry != null; statEntry = statEntry.next) {
                        statModifiers.put(statEntry.name, statEntry.asInt());
                    }
                    effectData.setStatModifiers(statModifiers);
                }

                effectData.setEffectType(jsonData.getString("effectType", ""));
                effectData.setChance(jsonData.getFloat("chance", 0f));
                effectData.setAnimation(jsonData.getString("animation", ""));
                effectData.setSound(jsonData.getString("sound", ""));
                effectData.setDuration(jsonData.getInt("duration", 0));

                return effectData;
            }
        });

        json.setSerializer(PokemonData.WildPokemonData.class, new Json.Serializer<PokemonData.WildPokemonData>() {
            @Override
            public void write(Json json, PokemonData.WildPokemonData wildPokemonData, Class knownType) {
                if (wildPokemonData == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();
                json.writeValue("name", wildPokemonData.getName());
                json.writeValue("level", wildPokemonData.getLevel());
                json.writeValue("position", wildPokemonData.getPosition());
                json.writeValue("direction", wildPokemonData.getDirection());
                json.writeValue("isMoving", wildPokemonData.isMoving());
                json.writeValue("spawnTime", wildPokemonData.getSpawnTime());

                // Primary Type
                if (wildPokemonData.getPrimaryType() != null) {
                    json.writeValue("primaryType", wildPokemonData.getPrimaryType().name());
                } else {
                    json.writeValue("primaryType", "NORMAL");
                }

                // Secondary Type
                if (wildPokemonData.getSecondaryType() != null) {
                    json.writeValue("secondaryType", wildPokemonData.getSecondaryType().name());
                }

                json.writeValue("currentHp", wildPokemonData.getCurrentHp());

                // Stats
                if (wildPokemonData.getStats() != null) {
                    json.writeValue("stats", wildPokemonData.getStats());
                }

                // Moves
                json.writeArrayStart("moves");
                if (wildPokemonData.getMoves() != null) {
                    for (PokemonData.MoveData move : wildPokemonData.getMoves()) {
                        json.writeValue(move);
                    }
                }
                json.writeArrayEnd();

                json.writeValue("uuid", wildPokemonData.getUuid() != null ? wildPokemonData.getUuid().toString() : UUID.randomUUID().toString());

                json.writeObjectEnd();
            }

            @Override
            public PokemonData.WildPokemonData read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return null;
                }

                PokemonData.WildPokemonData wildPokemonData = new PokemonData.WildPokemonData();
                wildPokemonData.setName(jsonData.getString("name", "Unknown"));
                wildPokemonData.setLevel(jsonData.getInt("level", 1));

                // Position
                JsonValue positionValue = jsonData.get("position");
                if (positionValue != null && positionValue.isObject()) {
                    float x = positionValue.getFloat("x", 0f);
                    float y = positionValue.getFloat("y", 0f);
                    wildPokemonData.setPosition(new Vector2(x, y));
                } else {
                    wildPokemonData.setPosition(new Vector2(0f, 0f));
                }

                wildPokemonData.setDirection(jsonData.getString("direction", "down"));
                wildPokemonData.setMoving(jsonData.getBoolean("isMoving", false));
                wildPokemonData.setSpawnTime(jsonData.getLong("spawnTime", System.currentTimeMillis()));

                // Primary Type
                String primaryTypeStr = jsonData.getString("primaryType", "NORMAL");
                try {
                    wildPokemonData.setPrimaryType(Pokemon.PokemonType.valueOf(primaryTypeStr));
                } catch (IllegalArgumentException e) {
                    GameLogger.error("Invalid primary type '" + primaryTypeStr + "' in WildPokemonData. Defaulting to NORMAL.");
                    wildPokemonData.setPrimaryType(Pokemon.PokemonType.NORMAL);
                }

                // Secondary Type
                if (jsonData.has("secondaryType")) {
                    String secondaryTypeStr = jsonData.getString("secondaryType");
                    try {
                        wildPokemonData.setSecondaryType(Pokemon.PokemonType.valueOf(secondaryTypeStr));
                    } catch (IllegalArgumentException e) {
                        GameLogger.error("Invalid secondary type '" + secondaryTypeStr + "' in WildPokemonData. Setting to null.");
                        wildPokemonData.setSecondaryType(null);
                    }
                }

                wildPokemonData.setCurrentHp(jsonData.getFloat("currentHp", 1f));

                // Stats
                JsonValue statsValue = jsonData.get("stats");
                if (statsValue != null) {
                    PokemonData.Stats stats = json.readValue(PokemonData.Stats.class, statsValue);
                    wildPokemonData.setStats(stats);
                }

                // Moves
                JsonValue movesValue = jsonData.get("moves");
                if (movesValue != null && movesValue.isArray()) {
                    List<PokemonData.MoveData> moves = new ArrayList<>();
                    for (JsonValue moveValue = movesValue.child; moveValue != null; moveValue = moveValue.next) {
                        PokemonData.MoveData moveData = json.readValue(PokemonData.MoveData.class, moveValue);
                        moves.add(moveData);
                    }
                    wildPokemonData.setMoves(moves);
                }

                String uuidStr = jsonData.getString("uuid", null);
                wildPokemonData.setUuid(uuidStr != null ? UUID.fromString(uuidStr) : UUID.randomUUID());

                return wildPokemonData;
            }
        });
    }

    private static void validatePlayerInventory(PlayerData playerData) {
        if (playerData.getInventoryItems() == null) {
            List<ItemData> items = new ArrayList<>(Inventory.INVENTORY_SIZE);
            for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                items.add(null);
            }
            playerData.setInventoryItems(items);
        }
    }

    private static void validatePlayerPokemon(PlayerData playerData) {
        if (playerData.getPartyPokemon() == null) {
            List<PokemonData> pokemon = new ArrayList<>(6);
            for (int i = 0; i < 6; i++) {
                pokemon.add(null);
            }
            playerData.setPartyPokemon(pokemon);
        }
    }


    private static int calculateExperienceForLevel(int level) {
        return (int) (100 * Math.pow(level, 3) / 5); // Basic Pokemon experience formula
    }


}

================
File: src/main/java/io/github/pokemeetup/utils/textures/BlockTextureManager.java
================
package io.github.pokemeetup.utils.textures;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.utils.GameLogger;

import java.util.HashMap;
import java.util.Map;

public class BlockTextureManager {
    private static final float FRAME_DURATION = 0.35f; // Adjust animation speed
    private static final Map<String, Animation<TextureRegion>> blockAnimations = new HashMap<>();
    private static final Map<String, TextureRegion[]> blockFrames = new HashMap<>();
    private final Map<String, TextureRegion> itemIcons;
    public BlockTextureManager() {
        this.itemIcons = new HashMap<>();
        initializeBlockTextures();
    }


    private static int getCustomAnimationFrame(float stateTime) {
        // Calculate which frame we should be on in the sequence: 0->1->2->1
        float totalCycleDuration = FRAME_DURATION * 4; // Time for complete cycle
        float cycleTime = stateTime % totalCycleDuration;
        int frame = (int) (cycleTime / FRAME_DURATION);

        // Map frame numbers to our desired sequence (0->1->2->1)
        switch (frame) {
            case 0: return 0; // First frame
            case 1: return 1; // Second frame
            case 2: return 2; // Third frame
            case 3: return 1; // Back to second frame
            default: return 0;
        }
    }

    public static TextureRegion getBlockFrame(PlaceableBlock block, float stateTime) {
        String blockId = block.getType().id;

        if (blockId.equals("chest")) {
            TextureRegion[] frames = blockFrames.get(blockId);
            if (frames != null) {
                boolean isOpen = block.isChestOpen();
                return frames[isOpen ? 1 : 0];
            }
            return null;
        }

        Animation<TextureRegion> animation = blockAnimations.get(blockId);
        if (animation != null) {
            if (blockId.equals("craftingtable") || blockId.equals("furnace")) {
                int frameIndex = getCustomAnimationFrame(stateTime);
                TextureRegion[] frames = blockFrames.get(blockId);
                if (frames != null && frameIndex < frames.length) {
                    return frames[frameIndex];
                }
            }
            return animation.getKeyFrame(stateTime, true);
        }
        return null;
    }



    private void initializeBlockTextures() {
        // Initialize existing blocks (chest, crafting table, furnace, wooden planks)
        initializeExistingBlocks();

        // Initialize new house-related blocks
        initializeHouseBlocks();

        // Initialize roof-related blocks
        initializeRoofBlocks();

        GameLogger.info("Initialized block textures - Blocks loaded: " + blockFrames.keySet());
    }



    private void initializeHouseBlocks() {
        // Initialize house middle section
        initializeSingleFrameBlock("house_middlesection");
        initializeSingleFrameBlock("house_middlesection_part");
        initializeSingleFrameBlock("house_midsection_part");
        initializeSingleFrameBlock("house_part");
        initializeSingleFrameBlock("house_planks");
        initializeSingleFrameBlock("wooden_door");
    }
    private void initializeExistingBlocks() {
        // Chest initialization
        TextureRegion chestRegion = TextureManager.blocks.findRegion("chest");
        if (chestRegion != null) {
            TextureRegion[] chestFrames = new TextureRegion[2];
            int frameWidth = chestRegion.getRegionWidth() / 2;

            chestFrames[0] = new TextureRegion(
                chestRegion.getTexture(),
                chestRegion.getRegionX(),
                chestRegion.getRegionY(),
                frameWidth,
                chestRegion.getRegionHeight()
            );
            chestFrames[1] = new TextureRegion(
                chestRegion.getTexture(),
                chestRegion.getRegionX() + frameWidth,
                chestRegion.getRegionY(),
                frameWidth,
                chestRegion.getRegionHeight()
            );

            blockFrames.put("chest", chestFrames);
            blockAnimations.put("chest", new Animation<>(FRAME_DURATION, chestFrames));
            itemIcons.put("chest", chestFrames[0]);
        }

        // Crafting table initialization
        TextureRegion craftingTableRegion = TextureManager.blocks.findRegion("craftingtable");
        if (craftingTableRegion != null) {
            TextureRegion[] craftingFrames = new TextureRegion[3];
            int frameWidth = craftingTableRegion.getRegionWidth() / 3;

            for (int i = 0; i < 3; i++) {
                craftingFrames[i] = new TextureRegion(
                    craftingTableRegion.getTexture(),
                    craftingTableRegion.getRegionX() + (i * frameWidth),
                    craftingTableRegion.getRegionY(),
                    frameWidth,
                    craftingTableRegion.getRegionHeight()
                );
            }
            blockFrames.put("craftingtable", craftingFrames);
            blockAnimations.put("craftingtable", new Animation<>(FRAME_DURATION, craftingFrames));
            itemIcons.put("craftingtable", craftingFrames[0]);
        }

        // Furnace initialization
        TextureRegion furnaceRegion = TextureManager.blocks.findRegion("furnace");
        if (furnaceRegion != null) {
            TextureRegion[] furnaceFrames = new TextureRegion[3];
            int frameWidth = furnaceRegion.getRegionWidth() / 3;

            for (int i = 0; i < 3; i++) {
                furnaceFrames[i] = new TextureRegion(
                    furnaceRegion.getTexture(),
                    furnaceRegion.getRegionX() + (i * frameWidth),
                    furnaceRegion.getRegionY(),
                    frameWidth,
                    furnaceRegion.getRegionHeight()
                );
            }
            blockFrames.put("furnace", furnaceFrames);
            blockAnimations.put("furnace", new Animation<>(FRAME_DURATION, furnaceFrames));
            itemIcons.put("furnace", furnaceFrames[0]);
        }

        // Wooden planks initialization
        TextureRegion woodenPlanks = TextureManager.blocks.findRegion("wooden_planks");
        if (woodenPlanks != null) {
            TextureRegion[] planksFrames = {new TextureRegion(woodenPlanks)};
            blockFrames.put("wooden_planks", planksFrames);
            blockAnimations.put("wooden_planks", new Animation<>(FRAME_DURATION, planksFrames));
            itemIcons.put("wooden_planks", planksFrames[0]);
        }
    }
    private void initializeRoofBlocks() {
        // Initialize roof pieces
        initializeSingleFrameBlock("roof_corner");
        initializeSingleFrameBlock("roof_middle");
        initializeSingleFrameBlock("roof_middle_outer");
        initializeSingleFrameBlock("roof_middle_outerside");
        initializeSingleFrameBlock("roof_middle_outside");
        initializeSingleFrameBlock("roof_middle_part");
        initializeSingleFrameBlock("roofinner");
    }

    private void initializeSingleFrameBlock(String blockId) {
        TextureRegion region = TextureManager.blocks.findRegion(blockId);
        if (region != null) {
            TextureRegion[] frames = {new TextureRegion(region)};
            blockFrames.put(blockId, frames);
            blockAnimations.put(blockId, new Animation<>(FRAME_DURATION, frames));
            itemIcons.put(blockId, frames[0]);
        }
    }
    public TextureRegion getItemIcon(String blockId) {
        return itemIcons.get(blockId);
    }

}

================
File: src/main/java/io/github/pokemeetup/utils/textures/TextureManager.java
================
package io.github.pokemeetup.utils.textures;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static io.github.pokemeetup.utils.textures.TileType.*;

public class TextureManager {
    public static final int TYPE_ICON_WIDTH = 64;
    public static final int TYPE_ICON_HEIGHT = 38;
    public static final int STATUS_ICON_WIDTH = 44;
    public static final int STATUS_ICON_HEIGHT = 16;
    public static final Map<Integer, TextureRegion> tileTextures = new HashMap<>();
    private static final Map<Pokemon.Status, TextureRegion> statusIcons = new HashMap<>();
    private static final Map<Pokemon.Status, Color> STATUS_COLORS = new HashMap<>();
    private static final int[][] RMXP_SUBTILE_MAP = {
        //  0..5
        {0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0},
        //  6..11
        {0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1},
        // 12..17
        {0, 2}, {1, 2}, {2, 2}, {3, 2}, {4, 2}, {5, 2},
        // 18..23
        {0, 3}, {1, 3}, {2, 3}, {3, 3}, {4, 3}, {5, 3},
        // 24..29
        {0, 4}, {1, 4}, {2, 4}, {3, 4}, {4, 4}, {5, 4},
        // 30..35
        {0, 5}, {1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5},
        // 36..41
        {0, 6}, {1, 6}, {2, 6}, {3, 6}, {4, 6}, {5, 6},
        // 42..47
        {0, 7}, {1, 7}, {2, 7}, {3, 7}, {4, 7}, {5, 7}
    };
    private static final Map<BiomeType, Map<Integer, TextureRegion>> biomeTileTextures = new HashMap<>();
    private static final Map<Pokemon.PokemonType, TextureRegion> typeIcons = new HashMap<>();
    private static final Map<Pokemon.PokemonType, Color> TYPE_COLORS = new HashMap<>();
    private static final int SUBTILE_SIZE = 16;        // each sub‐tile is 16×16
    private static final int SUBTILE_COLS = 6;         // 96 / 16 = 6
    private static final int SUBTILE_ROWS = 8;         // 128 / 16 = 8
    private static final int MAX_SUBTILES = SUBTILE_COLS * SUBTILE_ROWS;  // 48
    private static final Map<String, TextureRegion[]> autotileFrames = new HashMap<>();
    private static final Map<String, TextureRegion[][]> autotileSubTiles = new HashMap<>();
    // Example table:
    private static final int[] XP_AUTOTILE_TABLE = {
        // mask=0..15 => subTile in [0..47]
        // (some will be duplicates if you do the full 47 approach)
        0, 2, 8, 10,
        1, 3, 9, 11,
        24, 26, 16, 18,
        25, 27, 17, 19
    };
    /**
     * Further splits a single 96×128 frame into 6 columns × 8 rows of 16×16 = 48.
     */
// In TextureManager.java

    public static TextureAtlas ui;
    public static TextureAtlas pokemonback;
    public static TextureAtlas buildings;
    public static TextureAtlas owFx;
    public static TextureAtlas pokemonfront;
    public static TextureAtlas pokemonicon;
    public static TextureAtlas girl;
    public static TextureAtlas pokemonoverworld;
    public static TextureAtlas items;
    public static TextureAtlas steps;
    public static TextureAtlas boy;
    public static TextureAtlas tiles;
    public static TextureAtlas hairstyles;
    public static TextureAtlas battlebacks;
    public static TextureAtlas mountains;
    public static TextureAtlas effects;
    public static TextureAtlas blocks;
    public static TextureAtlas characters;
    // We know each frame is 96×128, which we can further break into
    // 16×16 sub-tiles in a 6 col × 8 row layout => 48 possible cells
    public static TextureAtlas clothing;
    public static TextureAtlas autotiles;
    public static TextureAtlas capsuleThrow;
    private static boolean usingFallbackSystem = false;
    private static Texture whitePixel;

    static {
        // Initialize status colors using the Pokémon status type.
        STATUS_COLORS.put(Pokemon.Status.NONE, Color.WHITE);
        STATUS_COLORS.put(Pokemon.Status.ASLEEP, Color.GRAY);
        STATUS_COLORS.put(Pokemon.Status.POISONED, new Color(0.627f, 0.439f, 0.627f, 1));
        STATUS_COLORS.put(Pokemon.Status.BURNED, new Color(0.940f, 0.501f, 0.376f, 1));
        STATUS_COLORS.put(Pokemon.Status.FROZEN, new Color(0.564f, 0.815f, 0.940f, 1));
        STATUS_COLORS.put(Pokemon.Status.PARALYZED, new Color(0.972f, 0.815f, 0.376f, 1));
        STATUS_COLORS.put(Pokemon.Status.BADLY_POISONED, new Color(0.5f, 0.1f, 0.5f, 1));
        STATUS_COLORS.put(Pokemon.Status.FAINTED, new Color(0.2f, 0.2f, 0.2f, 1));
    }

    static {
        // Update type color mappings
        // Initialize type colors
        TYPE_COLORS.put(Pokemon.PokemonType.NORMAL, new Color(0.658f, 0.658f, 0.658f, 1));    // A8A878
        TYPE_COLORS.put(Pokemon.PokemonType.FIGHTING, new Color(0.752f, 0.470f, 0.470f, 1));  // C03028
        TYPE_COLORS.put(Pokemon.PokemonType.FLYING, new Color(0.658f, 0.564f, 0.940f, 1));    // A890F0
        TYPE_COLORS.put(Pokemon.PokemonType.POISON, new Color(0.627f, 0.439f, 0.627f, 1));    // A040A0
        TYPE_COLORS.put(Pokemon.PokemonType.GROUND, new Color(0.878f, 0.752f, 0.470f, 1));    // E0C068
        TYPE_COLORS.put(Pokemon.PokemonType.ROCK, new Color(0.752f, 0.658f, 0.439f, 1));      // B8A038
        TYPE_COLORS.put(Pokemon.PokemonType.BUG, new Color(0.658f, 0.752f, 0.439f, 1));       // A8B820
        TYPE_COLORS.put(Pokemon.PokemonType.GHOST, new Color(0.439f, 0.439f, 0.627f, 1));     // 705898
        TYPE_COLORS.put(Pokemon.PokemonType.STEEL, new Color(0.752f, 0.752f, 0.815f, 1));     // B8B8D0
        TYPE_COLORS.put(Pokemon.PokemonType.FIRE, new Color(0.940f, 0.501f, 0.376f, 1));      // F08030
        TYPE_COLORS.put(Pokemon.PokemonType.WATER, new Color(0.376f, 0.564f, 0.940f, 1));     // 6890F0
        TYPE_COLORS.put(Pokemon.PokemonType.GRASS, new Color(0.470f, 0.815f, 0.376f, 1));     // 78C850
        TYPE_COLORS.put(Pokemon.PokemonType.ELECTRIC, new Color(0.972f, 0.815f, 0.376f, 1));  // F8D030
        TYPE_COLORS.put(Pokemon.PokemonType.PSYCHIC, new Color(0.940f, 0.376f, 0.564f, 1));   // F85888
        TYPE_COLORS.put(Pokemon.PokemonType.ICE, new Color(0.564f, 0.815f, 0.940f, 1));       // 98D8D8
        TYPE_COLORS.put(Pokemon.PokemonType.DRAGON, new Color(0.439f, 0.376f, 0.940f, 1));    // 7038F8
        TYPE_COLORS.put(Pokemon.PokemonType.DARK, new Color(0.439f, 0.376f, 0.376f, 1));      // 705848
        TYPE_COLORS.put(Pokemon.PokemonType.FAIRY, new Color(0.940f, 0.627f, 0.940f, 1));     // F0B6BC
        TYPE_COLORS.put(Pokemon.PokemonType.UNKNOWN, new Color(0.470f, 0.470f, 0.470f, 1));   // 68A090

    }

    /**
     * Loads autotile sheets.
     * For sand shores we now split the frame into 3 columns and 4 rows (32×32 each)
     * rather than slicing out 40 (or 48) 16×16 sub‐tiles.
     */
    public static void loadAutoTiles() {
        if (autotiles == null) {
            GameLogger.error("autotiles atlas not loaded!");
            return;
        }

        // Sea autotile remains split as usual into 48 sub–tiles.
        TextureRegion seaReg = autotiles.findRegion("Sea");
        if (seaReg != null) {
            TextureRegion[] seaFrames = splitIntoFrames(seaReg, 96, 128);
            TextureRegion[][] seaAllSubs = new TextureRegion[seaFrames.length][MAX_SUBTILES];
            for (int f = 0; f < seaFrames.length; f++) {
                seaAllSubs[f] = splitSubtiles(seaFrames[f]); // Splits into 6 cols × 8 rows (16×16 each)
            }
            autotileSubTiles.put("sea", seaAllSubs);
        }

        // For "SandShore", we now use a custom splitting:
        // We split each 96×128 frame into 3 columns × 4 rows of 32×32 blocks.
        TextureRegion sandReg = autotiles.findRegion("SandShore");
        if (sandReg != null) {
            TextureRegion[] frames = splitIntoFrames(sandReg, 96, 128);
            TextureRegion[][] allSubs = new TextureRegion[frames.length][];
            for (int f = 0; f < frames.length; f++) {
                // Use our custom method to split into 3x4 32×32 cells.
                allSubs[f] = splitSubtilesCustom(frames[f], 32, 3, 4);
            }
            autotileSubTiles.put("sand_shore", allSubs);
        }
    }

    /**
     * Returns the proper autotile region given a key, a 4–bit neighbor mask, and an animation frame.
     * For most autotiles we take one 16×16 sub‐tile from our 48–cell RMXP sheet and scale it up.
     * However, for "sand_shore" we use a custom mapping (see below) and do not scale (since our cells are already 32×32).
     */
    public static TextureRegion getAutoTileRegion(String key, int cornerMask, int animFrame) {
        // Clamp to 4 bits.
        cornerMask &= 0xF;
        TextureRegion[][] frames = autotileSubTiles.get(key);
        if (frames == null || frames.length == 0) return null;
        animFrame = animFrame % frames.length;
        TextureRegion[] subtiles = frames[animFrame];

        if (key.equals("sand_shore")) {
            // Original mapping table for a 3×3 grid (indices 0..8)
            int[] sandMapping = { 4, 1, 5, 2, 7, 4, 8, 5, 3, 0, 4, 1, 6, 3, 7, 4 };
            int baseIndex = sandMapping[cornerMask];
            // Convert the 0–8 base index (a 3×3 grid) to the proper index into our 3×4 array.
            // The base tiles live in rows 1–3 (indices 3..11). We do:
            //   fullIndex = ((baseIndex / 3) + 1) * 3 + (baseIndex % 3)
            int fullIndex = ((baseIndex / 3) + 1) * 3 + (baseIndex % 3);
            if (fullIndex < 0 || fullIndex >= subtiles.length) return null;
            // No scaling needed because these cells are already 32×32.
            return subtiles[fullIndex];
        } else {
            // For other autotiles (like "sea"), use the XP_AUTOTILE_TABLE mapping.
            int subTileIndex = XP_AUTOTILE_TABLE[cornerMask];
            if (subTileIndex < 0 || subTileIndex >= subtiles.length) return null;
            TextureRegion mini16 = subtiles[subTileIndex];
            if (mini16 == null) return null;
            // Scale from 16×16 to 32×32.
            TextureRegion scaled = new TextureRegion(
                mini16.getTexture(),
                mini16.getRegionX(),
                mini16.getRegionY(),
                mini16.getRegionWidth() * 2,
                mini16.getRegionHeight() * 2
            );
            return scaled;
        }
    }



    private static TextureRegion[] splitIntoFrames(TextureRegion source, int frameW, int frameH) {
        int totalCols = source.getRegionWidth() / frameW;
        int totalRows = source.getRegionHeight() / frameH;
        TextureRegion[] frames = new TextureRegion[totalCols * totalRows];
        int idx = 0;
        for (int ry = 0; ry < totalRows; ry++) {
            for (int rx = 0; rx < totalCols; rx++) {
                int x = source.getRegionX() + rx * frameW;
                int y = source.getRegionY() + ry * frameH;
                frames[idx++] = new TextureRegion(source.getTexture(), x, y, frameW, frameH);
            }
        }
        return frames;
    }
    /**
     * Splits a single 96×128 frame into 48 sub-tiles (16×16 each).
     */
    private static TextureRegion[] splitSubtiles(TextureRegion frame) {
        TextureRegion[] result = new TextureRegion[MAX_SUBTILES];
        int idx = 0;
        for (int row = 0; row < SUBTILE_ROWS; row++) {
            for (int col = 0; col < SUBTILE_COLS; col++) {
                int sx = frame.getRegionX() + col * SUBTILE_SIZE;
                int sy = frame.getRegionY() + row * SUBTILE_SIZE;
                result[idx++] = new TextureRegion(
                    frame.getTexture(), sx, sy,
                    SUBTILE_SIZE, SUBTILE_SIZE
                );
            }
        }
        return result;
    }


    /**
     * Returns one sub‐tile from the given autotile key, frame, and (col,row) within that frame.
     * For “sand_shore” we use 3 columns (otherwise we default to SUBTILE_COLS).
     */
    public static TextureRegion getSubTile(String autotileKey, int animFrame, int col, int row) {
        TextureRegion[][] frames = autotileSubTiles.get(autotileKey);
        if (frames == null || frames.length == 0) {
            return null;
        }
        animFrame = animFrame % frames.length;
        TextureRegion[] subtiles = frames[animFrame];
        if (subtiles == null) {
            return null;
        }
        int cols = autotileKey.equals("sand_shore") ? 3 : SUBTILE_COLS;
        int index = row * cols + col;
        if (index < 0 || index >= subtiles.length) {
            return null;
        }
        // For sand_shore the sub-tiles are already 32×32 so no scaling is required.
        return subtiles[index];
    }


    /**
     * Splits a single frame into sub‐tiles given custom parameters.
     * For example, for sand_shore, split into 3 columns and 4 rows of 32×32 tiles.
     */
    private static TextureRegion[] splitSubtilesCustom(TextureRegion frame, int subTileSize, int subTileCols, int subTileRows) {
        TextureRegion[] result = new TextureRegion[subTileCols * subTileRows];
        int index = 0;
        for (int row = 0; row < subTileRows; row++) {
            for (int col = 0; col < subTileCols; col++) {
                int sx = frame.getRegionX() + col * subTileSize;
                int sy = frame.getRegionY() + row * subTileSize;
                result[index++] = new TextureRegion(frame.getTexture(), sx, sy, subTileSize, subTileSize);
            }
        }
        return result;
    }

    // NEW constants for sand_shore splitting:


    /**
     * Splits an entire 768×128 region into an array of 8 frames (each 96×128).
     */


    /**
     * Splits a single frame (a 96×128 TextureRegion) into 48 sub‐tiles (16×16 each).
     * This method uses the frame’s own regionX and regionY as the starting offset.
     */


    public static TextureRegion getAutoTileSubTile(String key, int frameIndex, int col, int row) {
        TextureRegion[][] frames = autotileSubTiles.get(key);
        if (frames == null || frameIndex < 0 || frameIndex >= frames.length) return null;
        TextureRegion[] subtiles = frames[frameIndex];

        // sub‐tile index in [0..47]
        int idx = row * SUBTILE_COLS + col;
        if (idx < 0 || idx >= subtiles.length) return null;

        TextureRegion base16 = subtiles[idx];
        if (base16 == null) return null;

        // Create a "scaled" region by adjusting regionWidth/Height
        // This doesn’t actually scale the texture data, but the drawing code
        // in your sprite batch can interpret region width=32, height=32.
        TextureRegion scaled = new TextureRegion(
            base16.getTexture(),
            base16.getRegionX(),
            base16.getRegionY(),
            base16.getRegionWidth() * 2,
            base16.getRegionHeight() * 2
        );
        return scaled;
    }
    /**
     * Returns a 32×32 TextureRegion representing the ocean’s main center
     * (the fully “water‐filled” block) as defined in Pokémon Essentials’ RMXP
     * autotile layout.
     *
     * <p>
     * This method works as follows:
     * <ul>
     *   <li>It retrieves the full “Sea” region from the autotiles atlas.</li>
     *   <li>It splits that region into 96×128 frames (of which there are eight in your sheet).</li>
     *   <li>It selects the desired animation frame (wrapping the index if needed).</li>
     *   <li>It then extracts the central 32×32 block from that frame—i.e. the block starting at (32,32),
     *       which is considered the “ocean center” in Pokémon Essentials.</li>
     * </ul>
     * </p>
     *
     * @param animFrame the animation frame index to use (it will be wrapped into range)
     * @return a TextureRegion of size 32×32 for the ocean center, or null if something is missing.
     */
    /**
     * Returns a 32×32 TextureRegion representing the animated ocean center.
     * <p>
     * The method retrieves the full "Sea" region from the autotiles atlas and splits it
     * into eight 96×128 frames (one per animation step). Each frame is conceptually divided
     * into 32×32 blocks (3 columns × 4 rows). Previously the center block was taken as (1,1)
     * (starting at (32,32)). Now we choose the block one tile down—that is, block (1,2) starting
     * at (32,48)—to be the ocean center.
     * </p>
     *
     * @param animFrame the animation frame index to use (wrapped to the available frames)
     * @return a TextureRegion of size 32×32 for the ocean center, or null if unavailable.
     */
    public static TextureRegion getOceanCenterFrame(int animFrame) {
        // Retrieve the "Sea" region from the autotiles atlas.
        TextureRegion seaRegion = autotiles.findRegion("Sea");
        if (seaRegion == null) {
            GameLogger.error("Cannot find 'Sea' region in the autotiles atlas!");
            return null;
        }

        // Split the Sea region into its eight 96×128 frames.
        TextureRegion[] seaFrames = splitIntoFrames(seaRegion, 96, 128);
        if (seaFrames == null || seaFrames.length == 0) {
            GameLogger.error("No sea frames available!");
            return null;
        }

        // Wrap the animation frame index to the available frames.
        int safeFrame = animFrame % seaFrames.length;
        TextureRegion seaFrame = seaFrames[safeFrame];

        // For a 96×128 frame divided into 32×32 blocks:
        //   - Horizontally: blocks at x=0, 32, and 64.
        //   - Vertically: blocks at y=0, 32, 64, and 96.
        // Previously, the center was taken at block (1,1) (i.e. starting at (32,32)).
        // Now, to shift one tile down we take block (1,2), which starts at (32,48).
        int centerX = seaFrame.getRegionX() + 32;
        int centerY = seaFrame.getRegionY() + 48;

        // Create and return a new TextureRegion for the 32×32 ocean center.
        TextureRegion oceanCenter = new TextureRegion(seaFrame.getTexture(), centerX, centerY, 32, 32);
        return oceanCenter;
    }


    public static TextureRegion[][] getAutoTileSubTiles(String key) {
        return autotileSubTiles.get(key);
    }

    /**
     * Get the final 16×16 sub‐tile region for a given (key, cornerMask, animFrame).
     */
    /**
     * For “sand_shore,” we store each 16×16 in a 6×8 grid => 48 sub‐tiles.
     * This method takes a `maskIndex` in [0..46] (the 47 RMXP sub‐tiles)
     * and an animFrame in [0..7], then returns a 32×32 scaled region.
     */
    public static TextureAtlas getGirl() {
        return girl;
    }


    /**
     * Access the auto‐tile frames by key (e.g. "sand_shore" or "sea") and frame index.
     * Returns null if out of bounds or missing key.
     */
    public static TextureRegion getAutotileFrame(String key, int index) {
        TextureRegion[] frames = autotileFrames.get(key);
        if (frames == null) {
            GameLogger.error("No autotile frames for key: " + key);
            return null;
        }
        if (index < 0 || index >= frames.length) {
            GameLogger.error("Frame index out of range for key: " + key + " (index=" + index + ")");
            return null;
        }
        return frames[index];
    }

    private static void createFallbackIcons() {
        // For types, nothing changes.
        for (Pokemon.PokemonType type : Pokemon.PokemonType.values()) {
            Color color = TYPE_COLORS.get(type);
            TextureRegion icon = createColoredIcon(color, TYPE_ICON_WIDTH, TYPE_ICON_HEIGHT);
            typeIcons.put(type, icon);
        }
        // For status icons, use the Pokemon.Status values.
        for (Pokemon.Status status : Pokemon.Status.values()) {
            if (status != Pokemon.Status.NONE) {
                Color color = STATUS_COLORS.get(status);
                TextureRegion icon = createColoredIcon(color, STATUS_ICON_WIDTH, STATUS_ICON_HEIGHT);
                statusIcons.put(status, icon);
            }
        }
    }

    private static TextureRegion createColoredIcon(Color color, int width, int height) {
        if (color == null) {
            GameLogger.error("createColoredIcon received a null color; defaulting to white.");
            color = Color.WHITE;
        }
        Pixmap pixmap = new Pixmap(width, height, Pixmap.Format.RGBA8888);
        pixmap.setColor(color);
        pixmap.fillRectangle(0, 0, width, height);

        // Add a border in white.
        pixmap.setColor(Color.WHITE);
        pixmap.drawRectangle(0, 0, width, height);

        Texture texture = new Texture(pixmap);
        pixmap.dispose();

        return new TextureRegion(texture);
    }


    private static void loadTypeAndStatusIcons() {
        TextureRegion typesSheet = ui.findRegion("pokemon-type-icons");
        TextureRegion statusSheet = ui.findRegion("status-icons");

        if (typesSheet == null || statusSheet == null) {
            GameLogger.info("Sprite sheets not found, using fallback system");
            usingFallbackSystem = true;
            createFallbackIcons();
            return;
        }

        // Split the status sheet into frames of fixed size.
        TextureRegion[][] statusFrames = statusSheet.split(STATUS_ICON_WIDTH, STATUS_ICON_HEIGHT);
        // Here we assume that the status sheet’s rows (or columns) correspond in order to the Pokemon.Status values.
        for (Pokemon.Status status : Pokemon.Status.values()) {
            if (status != Pokemon.Status.NONE && (status.ordinal() - 1) < statusFrames.length) {
                // For example, if the status order in the sheet starts at index 0 for SLEEP, then use ordinal()-1.
                statusIcons.put(status, statusFrames[status.ordinal() - 1][0]);
            } else if (status != Pokemon.Status.NONE) {
                GameLogger.error("Missing status icon for: " + status.name());
            }
        }

        // Optionally check that all icons exist; if not, use fallback.
        boolean hasAllIcons = true;
        for (Pokemon.PokemonType type : Pokemon.PokemonType.values()) {
            if (!typeIcons.containsKey(type)) {
                hasAllIcons = false;
                break;
            }
        }
        for (Pokemon.Status status : Pokemon.Status.values()) {
            if (status != Pokemon.Status.NONE && !statusIcons.containsKey(status)) {
                hasAllIcons = false;
                break;
            }
        }
        if (!hasAllIcons) {
            GameLogger.info("Missing icons detected, using fallback system");
            usingFallbackSystem = true;
            createFallbackIcons();
        }
    }

    public static TextureRegion getStatusIcon(Pokemon.Status status) {
        return statusIcons.get(status);
    }

    // Helper method to get type color
    public static Color getTypeColor(Pokemon.PokemonType type) {
        return TYPE_COLORS.getOrDefault(type, Color.WHITE);
    }

    public static TextureRegion getOverworldSprite(String name) {
        if (name == null) {
            GameLogger.error("Attempted to get overworld sprite with null name.");
            return null;
        }

        // Normalize the name to lowercase to ensure consistency
        String normalizedName = name.toUpperCase();

        TextureRegion sprite = pokemonoverworld.findRegion(normalizedName + "_overworld");
        if (sprite == null) {
            GameLogger.error("Overworld sprite for Pokémon '" + name + "' not found.");
            return null;
        }
        return sprite;
    }


    public static TextureAtlas getUi() {
        return ui;
    }

    public static TextureAtlas getPokemonback() {
        return pokemonback;
    }

    public static TextureAtlas getPokemonfront() {
        return pokemonfront;
    }

    public static TextureAtlas getPokemonicon() {
        return pokemonicon;
    }

    public static TextureAtlas getPokemonoverworld() {
        return pokemonoverworld;
    }

    public static TextureAtlas getItems() {
        return items;
    }

    public static TextureAtlas getBoy() {
        try {
            if (boy == null) {
                GameLogger.error("Boy atlas is null");
                return null;
            }

            // Verify atlas textures
            for (Texture texture : boy.getTextures()) {
                if (texture == null) {
                    GameLogger.error("Boy atlas texture is null or disposed");
                    return null;
                }
            }

            // Verify some key regions
            String[] testRegions = {
                "boy_walk_down",
                "boy_walk_up",
                "boy_run_down",
                "boy_run_up"
            };

            for (String regionName : testRegions) {
                TextureAtlas.AtlasRegion region = boy.findRegion(regionName, 1);
                if (region == null || region.getTexture() == null) {
                    GameLogger.error("Critical region missing or invalid: " + regionName);
                    return null;
                }
            }

            return boy;
        } catch (Exception e) {
            GameLogger.error("Error accessing boy atlas: " + e.getMessage());
            return null;
        }

    }

    public static TextureAtlas getBattlebacks() {
        return battlebacks;
    }

    public static TextureAtlas getTiles() {
        return tiles;
    }

    public static Texture getWhitePixel() {
        if (whitePixel == null) {
            // Create on demand if not initialized
            Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
            pixmap.setColor(Color.WHITE);
            pixmap.fill();
            whitePixel = new Texture(pixmap);
            pixmap.dispose();
        }
        return whitePixel;
    }

    public static void initialize(TextureAtlas steps, TextureAtlas battlebacks, TextureAtlas ui,
                                  TextureAtlas pokemonback, TextureAtlas pokemonfront, TextureAtlas pokemonicon,
                                  TextureAtlas pokemonoverworld, TextureAtlas items, TextureAtlas boy,
                                  TextureAtlas tiles, TextureAtlas effects, TextureAtlas mountains
        , TextureAtlas blocks, TextureAtlas characters, TextureAtlas clothing, TextureAtlas hairstyles, TextureAtlas buildings, TextureAtlas girl, TextureAtlas autotiles, TextureAtlas capsuleThrow, TextureAtlas owFx) {
        TextureManager.steps = steps;
        TextureManager.effects = effects;
        TextureManager.battlebacks = battlebacks;
        TextureManager.ui = ui;
        TextureManager.pokemonback = pokemonback;
        TextureManager.pokemonfront = pokemonfront;
        TextureManager.pokemonicon = pokemonicon;
        TextureManager.pokemonoverworld = pokemonoverworld;
        TextureManager.items = items;
        TextureManager.boy = boy;
        TextureManager.tiles = tiles;
        TextureManager.mountains = mountains;
        TextureManager.blocks = blocks;
        TextureManager.characters = characters;
        TextureManager.clothing = clothing;
        TextureManager.hairstyles = hairstyles;
        TextureManager.buildings = buildings;
        TextureManager.capsuleThrow = capsuleThrow;
        TextureManager.autotiles = autotiles;
        TextureManager.girl = girl;
        TextureManager.owFx = owFx;
        // Create white pixel texture
        Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        pixmap.setColor(Color.WHITE);
        pixmap.fill();
        whitePixel = new Texture(pixmap);
        for (Texture texture : tiles.getTextures()) {
            texture.setFilter(Texture.TextureFilter.Nearest, Texture.TextureFilter.Nearest);
        }
        loadTypeAndStatusIcons();
        loadCentralTileTextures();
        loadAutoTiles();


    }

    private static void loadCentralTileTextures() {
        // Ensure tiles atlas is loaded
        if (tiles == null) {
            GameLogger.error("Tiles atlas is not initialized!");
            return;
        }
        //            loadAllBiomeTextures();
        GameLogger.info("=== Starting Texture Loading ===");

        // First log all available regions
        GameLogger.info("Available regions in atlas:");
        if (tiles != null) {
            for (TextureAtlas.AtlasRegion region : tiles.getRegions()) {
                GameLogger.info(" - " + region.name);
            }
        }
        assert tiles != null;
        tileTextures.put(WATER, tiles.findRegion("water"));
        tileTextures.put(GRASS, tiles.findRegion("grass"));
        tileTextures.put(SAND, tiles.findRegion("sand"));
        tileTextures.put(ROCK, tiles.findRegion("rock"));
        tileTextures.put(SNOW, tiles.findRegion("snow_base"));
        tileTextures.put(HAUNTED_GRASS, tiles.findRegion("haunted_grass"));
        tileTextures.put(SNOW_TALL_GRASS, tiles.findRegion("snow_tall_grass"));
        tileTextures.put(HAUNTED_TALL_GRASS, tiles.findRegion("haunted_tall_grass"));
        tileTextures.put(HAUNTED_SHROOM, tiles.findRegion("haunted_shroom"));
        tileTextures.put(HAUNTED_SHROOMS, tiles.findRegion("haunted_shrooms"));
        tileTextures.put(TALL_GRASS, tiles.findRegion("tall_grass"));
        tileTextures.put(FOREST_GRASS, tiles.findRegion("forest_grass"));
        tileTextures.put(FOREST_TALL_GRASS, tiles.findRegion("forest_tall_grass"));
        tileTextures.put(RAIN_FOREST_GRASS, tiles.findRegion("forest_grass"));
        tileTextures.put(RAIN_FOREST_TALL_GRASS, tiles.findRegion("rain_forest_tall_grass"));
        tileTextures.put(DESERT_SAND, tiles.findRegion("desert_sand"));
        tileTextures.put(DESERT_ROCKS, tiles.findRegion("desert_rock"));
        tileTextures.put(DESERT_GRASS, tiles.findRegion("desert_grass"));
        tileTextures.put(GRASS_2, tiles.findRegion("grass", 2));
        tileTextures.put(FLOWER, tiles.findRegion("flower", 1));
        tileTextures.put(FLOWER_1, tiles.findRegion("flower", 1));
        tileTextures.put(TALL_GRASS_2, tiles.findRegion("tall_grass_two"));
        tileTextures.put(TALL_GRASS_3, tiles.findRegion("tall_grass_three"));
        tileTextures.put(FLOWER_2, tiles.findRegion("flower", 1));
        tileTextures.put(GRASS_3, tiles.findRegion("grass", 3));
        tileTextures.put(SNOW_2, tiles.findRegion("snow_grass"));
        tileTextures.put(SNOW_3, tiles.findRegion("snow_base"));
        tileTextures.put(RUINS_GRASS_0, tiles.findRegion("ruins_grass", 0));
        tileTextures.put(RUINS_GRASS, tiles.findRegion("ruins_grass", 1));
        tileTextures.put(RUINS_TALL_GRASS, tiles.findRegion("ruins_tall_grass", 0));
        tileTextures.put(RUINS_BRICKS, tiles.findRegion("ruin_bricks", 0));
        tileTextures.put(CAVE_ENTRANCE, tiles.findRegion("cave_entrance"));
        tileTextures.put(MOUNTAIN_TILE_TOP_LEFT_ROCK_BG, tiles.findRegion("MOUNTAIN_TILE_TOP_LEFT_ROCK_BG"));
        tileTextures.put(MOUNTAIN_TILE_TOP_MID, tiles.findRegion("MOUNTAIN_TILE_TOP_MID"));
        tileTextures.put(MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG, tiles.findRegion("MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG"));
        tileTextures.put(MOUNTAIN_TILE_MID_LEFT, tiles.findRegion("MOUNTAIN_TILE_MID_LEFT"));
        tileTextures.put(MOUNTAIN_TILE_CENTER, tiles.findRegion("MOUNTAIN_TILE_CENTER"));
        tileTextures.put(MOUNTAIN_TILE_MID_RIGHT, tiles.findRegion("MOUNTAIN_TILE_MID_RIGHT"));
        tileTextures.put(MOUNTAIN_TILE_BOT_LEFT_ROCK_BG, tiles.findRegion("MOUNTAIN_TILE_BOT_LEFT_ROCK_BG"));
        tileTextures.put(MOUNTAIN_TILE_BOT_MID, tiles.findRegion("MOUNTAIN_TILE_BOT_MID"));
        tileTextures.put(MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG, tiles.findRegion("MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG"));
        tileTextures.put(MOUNTAIN_TILE_TOP_LEFT_GRASS_BG, tiles.findRegion("MOUNTAIN_TILE_TOP_LEFT_GRASS_BG"));
        tileTextures.put(MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG, tiles.findRegion("MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG"));
        tileTextures.put(MOUNTAIN_TILE_BOT_RIGHT_GRASS_BG, tiles.findRegion("MOUNTAIN_TILE_BOT_RIGHT_GRASS_BG"));
        tileTextures.put(TileType.MOUNTAIN_WALL, tiles.findRegion("mountainBASEMIDDLE"));
        tileTextures.put(TileType.MOUNTAIN_CORNER_TL, tiles.findRegion("mountainTOPLEFT")); // Top-left corner
        tileTextures.put(TileType.MOUNTAIN_CORNER_TR, tiles.findRegion("mountaintopRIGHT")); // Top-right corner
        tileTextures.put(TileType.MOUNTAIN_CORNER_BL, tiles.findRegion("mountainBASELEFT")); // Bottom-left corner
        tileTextures.put(TileType.MOUNTAIN_CORNER_BR, tiles.findRegion("mountainbaseRIGHT")); // Bottom-right corner
        tileTextures.put(TileType.MOUNTAIN_SLOPE_LEFT, tiles.findRegion("tile080"));
        tileTextures.put(TileType.MOUNTAIN_SLOPE_RIGHT, tiles.findRegion("tile046"));
        tileTextures.put(TileType.MOUNTAIN_STAIRS, tiles.findRegion("mountainstairsMiddle"));
        tileTextures.put(TileType.MOUNTAIN_PATH, tiles.findRegion("tile081"));
        tileTextures.put(TileType.MOUNTAIN_BASE_EDGE, tiles.findRegion("tile038"));
        tileTextures.put(TileType.MOUNTAIN_STAIRS_LEFT, tiles.findRegion("mountainstairsLEFT")); // Left stairs
        tileTextures.put(TileType.MOUNTAIN_STAIRS_RIGHT, tiles.findRegion("mountainstarsRIGHT")); // Right stairs
        tileTextures.put(TileType.MOUNTAIN_PEAK, tiles.findRegion("tile0118"));
        tileTextures.put(TileType.MOUNTAIN_BASE, tiles.findRegion("mountainBASEMIDDLE"));
        tileTextures.put(TileType.MOUNTAIN_EDGE_LEFT, tiles.findRegion("MOUNTAINMIDDLELEFT"));
        tileTextures.put(TileType.MOUNTAIN_EDGE_RIGHT, tiles.findRegion("mountainMIDDLERIGHT"));
        tileTextures.put(TileType.MOUNTAIN_EDGE_TOP, tiles.findRegion("tile029"));
        tileTextures.put(TileType.MOUNTAIN_EDGE_BOTTOM, tiles.findRegion("tile089"));
        tileTextures.put(TileType.MOUNTAIN_CORNER_INNER_TOPLEFT, tiles.findRegion("tile029"));
        tileTextures.put(STAIRS, tiles.findRegion("tile052"));
        tileTextures.put(MOUNTAIN_TILE_CONNECTING_CORNER_TOP_LEFT, tiles.findRegion("MOUNTAIN_TILE_CONNECTING_CORNER_TOP_LEFT"));
        tileTextures.put(MOUNTAIN_TILE_CONNECTING_CORNER_TOP_RIGHT, tiles.findRegion("MOUNTAIN_TILE_CONNECTING_CORNER_TOP_RIGHT"));
        tileTextures.put(MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_LEFT, tiles.findRegion("MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_LEFT"));
        tileTextures.put(MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_RIGHT, tiles.findRegion("MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_RIGHT"));
        tileTextures.put(FAIRY_ROCK, tiles.findRegion("fairy_rock"));
        tileTextures.put(CRYSTAL_ROCK, tiles.findRegion("crystal"));
        tileTextures.put(SNOWY_GRASS, tiles.findRegion("snowy_grass"));
        tileTextures.put(BEACH_SAND, tiles.findRegion("beach_sand"));
        tileTextures.put(BEACH_GRASS, tiles.findRegion("beach_tall_grass"));
        tileTextures.put(BEACH_GRASS_2, tiles.findRegion("beach_grass"));
        tileTextures.put(BEACH_STARFISH, tiles.findRegion("beach_starfish"));
        tileTextures.put(BEACH_SHELL, tiles.findRegion("beach_shell"));
        tileTextures.put(TALL_GRASS_OVERLAY, tiles.findRegion("tall_grass_overlay"));
        tileTextures.put(TALL_GRASS_OVERLAY_2, tiles.findRegion("tall_grass_2_overlay"));
        tileTextures.put(TALL_GRASS_OVERLAY_3, tiles.findRegion("tall_grass_3_overlay"));
        tileTextures.put(SNOW_TALL_GRASS_OVERLAY, tiles.findRegion("snow_tall_grass_overlay"));
        tileTextures.put(HAUNTED_TALL_GRASS_OVERLAY, tiles.findRegion("haunted_tall_grass_overlay"));
        tileTextures.put(RAINFOREST_TALL_GRASS_OVERLAY, tiles.findRegion("rain_forest_tall_grass_overlay"));
        tileTextures.put(RUINS_TALL_GRASS_OVERLAY, tiles.findRegion("ruins_tall_grass_overlay"));
        tileTextures.put(FOREST_TALL_GRASS_OVERLAY, tiles.findRegion("forest_tall_grass_overlay"));
        tileTextures.put(DESERT_TALL_GRASS_OVERLAY, tiles.findRegion("desert_grass_overlay"));
        tileTextures.put(BEACH_TALL_GRASS_OVERLAY, tiles.findRegion("beach_tall_grass_overlay"));
        // Add other tile types as needed
        for (TextureRegion texture : tileTextures.values()) {
            if (texture != null && texture.getTexture() != null) {
                texture.getTexture().setFilter(Texture.TextureFilter.Nearest, Texture.TextureFilter.Nearest);
            }
        }
        GameLogger.info("TileType name mappings:");
        for (Map.Entry<Integer, String> entry : TileType.getTileTypeNames().entrySet()) {
            GameLogger.info(String.format("Tile ID %d -> Name '%s'", entry.getKey(), entry.getValue()));
        }

        // Log each texture loading attempt
        for (Map.Entry<Integer, String> entry : TileType.getTileTypeNames().entrySet()) {
            int tileId = entry.getKey();
            String tileName = entry.getValue();
            TextureRegion region = tiles.findRegion(tileName);
            tileTextures.put(tileId, region);

            if (region == null) {
            } else {
                GameLogger.info(String.format("Successfully loaded texture for tile %d (name: %s)", tileId, tileName));
            }
        }
    }


    public static TextureRegion getTileTexture(int tileType) {
        return tileTextures.get(tileType);
    }

    private static void debugAtlas(String name, TextureAtlas atlas) {
        if (atlas == null) {
            GameLogger.error(name + " atlas is null!");
            return;
        }
        GameLogger.info(name + " atlas regions:");
        for (TextureAtlas.AtlasRegion region : atlas.getRegions()) {
            GameLogger.info("  - " + region.name +
                " (x=" + region.getRegionX() +
                ", y=" + region.getRegionY() +
                ", w=" + region.getRegionWidth() +
                ", h=" + region.getRegionHeight() + ")");
        }
    }


    public enum StatusCondition {
        NONE(0),
        SLEEP(1),
        POISON(2),
        BURN(3),
        FREEZE(4),
        PARALYSIS(5),
        TOXIC(6),    // Bad poison
        CONFUSION(7);

        private final int index;

        StatusCondition(int index) {
            this.index = index;
        }

        public int getIndex() {
            return index;
        }
    }
}

================
File: src/main/java/io/github/pokemeetup/utils/textures/TileType.java
================
package io.github.pokemeetup.utils.textures;

import java.util.HashMap;
import java.util.Map;

public class TileType {
    // Base terrain types
    public static final int WATER = 0;
    public static final int GRASS = 1;
    public static final int SAND = 2;
    public static final int ROCK = 3;
    public static final int SNOW = 4;

    // Special terrain types
    public static final int HAUNTED_GRASS = 5;
    public static final int SNOW_TALL_GRASS = 6;
    public static final int HAUNTED_TALL_GRASS = 7;
    public static final int HAUNTED_SHROOM = 8;
    public static final int HAUNTED_SHROOMS = 9;
    public static final int TALL_GRASS = 10;

    // Forest types
    public static final int FOREST_GRASS = 11;
    public static final int FOREST_TALL_GRASS = 12;

    // Rain forest types
    public static final int RAIN_FOREST_GRASS = 13;
    public static final int RAIN_FOREST_TALL_GRASS = 14;

    // Desert types
    public static final int DESERT_SAND = 15;
    public static final int DESERT_ROCKS = 16;
    public static final int DESERT_GRASS = 17;

    // Decorative types
    public static final int FLOWER_1 = 18;
    public static final int FLOWER_2 = 19;
    public static final int FLOWER = 20;
    public static final int TALL_GRASS_2 = 21;
    public static final int GRASS_2 = 22;
    public static final int GRASS_3 = 23;
    public static final int TALL_GRASS_3 = 24;

    public static final int MOUNTAIN_CORNER_INNER_TOPLEFT = 27;
    public static final int MOUNTAIN_CORNER_INNER_BOTTOMRIGHT = 30;

    // Mountain Features
    public static final int MOUNTAIN_STAIRS_LEFT = 31; // Left side stairs
    public static final int MOUNTAIN_STAIRS_RIGHT = 32; // Right side stairs
    public static final int STAIRS = 235;

    // Mountain Snow Variants
    public static final int MOUNTAIN_SNOW_BASE = 36;

    // Mountain Tiles
    public static final int MOUNTAIN_BASE = 25;       // Base mountain tile
    public static final int MOUNTAIN_PEAK = 26;       // Mountain peak
    public static final int MOUNTAIN_SLOPE_LEFT = 27; // Left slope
    public static final int MOUNTAIN_SLOPE_RIGHT = 28; // Right slope
    public static final int MOUNTAIN_WALL = 29;       // Mountain wall
    public static final int MOUNTAIN_STAIRS = 30;     // Standard stairs
    public static final int MOUNTAIN_CORNER_TL = 33;  // Top-left corner
    public static final int MOUNTAIN_CORNER_TR = 34;  // Top-right corner
    public static final int MOUNTAIN_CORNER_BL = 35;  // Bottom-left corner
    public static final int MOUNTAIN_CORNER_BR = 36;  // Bottom-right corner
    // Mountain Corner Types
    public static final int MOUNTAIN_CORNER_OUTER_TOPLEFT = 39;
    public static final int MOUNTAIN_CORNER_OUTER_BOTTOMRIGHT = 42;

    // Mountain Base Components
    public static final int MOUNTAIN_BASE_EDGE = 38;      // Basic mountain edge tile
    public static final int MOUNTAIN_PATH = 40;           // Walkable mountain path

    // Mountain Edges
    public static final int MOUNTAIN_EDGE_LEFT = 47;      // Left edge
    public static final int MOUNTAIN_EDGE_RIGHT = 48;     // Right edge
    public static final int MOUNTAIN_EDGE_TOP = 49;       // Top edge
    public static final int MOUNTAIN_EDGE_BOTTOM = 50;    // Bottom edge
    public static final int SNOW_2 = 51;
    public static final int SNOW_3 = 52;
    public static final int RUINS_GRASS = 53;
    public static final int RUINS_GRASS_0 = 54;
    public static final int RUINS_TALL_GRASS = 55;
    public static final int RUINS_BRICKS = 56;
    public static final int WATER_PUDDLE = 140;
    public static final int WATER_PUDDLE_TOP_LEFT = 141;
    public static final int WATER_PUDDLE_TOP_MIDDLE = 142;
    public static final int WATER_PUDDLE_TOP_RIGHT = 143;
    public static final int WATER_PUDDLE_LEFT_MIDDLE = 144;
    public static final int WATER_PUDDLE_RIGHT_MIDDLE = 145;
    public static final int WATER_PUDDLE_BOTTOM_LEFT = 146;
    public static final int WATER_PUDDLE_BOTTOM_MIDDLE = 147;
    public static final int WATER_PUDDLE_BOTTOM_RIGHT = 148;
    public static final int MOUNTAIN_TILE_TOP_LEFT_GRASS_BG = 209;
    public static final int MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG = 210;
    public static final int MOUNTAIN_TILE_BOT_RIGHT_GRASS_BG = 211;
    public static final int MOUNTAIN_TILE_BOT_LEFT_GRASS_BG = 212;
    public static final int MOUNTAIN_TILE_TOP_LEFT_ROCK_BG = 200;
    public static final int MOUNTAIN_TILE_TOP_MID = 201;
    public static final int MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG = 202;
    public static final int MOUNTAIN_TILE_MID_LEFT = 203;
    public static final int MOUNTAIN_TILE_CENTER = 204;
    public static final int MOUNTAIN_TILE_MID_RIGHT = 205;
    public static final int MOUNTAIN_TILE_BOT_LEFT_ROCK_BG = 206;
    public static final int MOUNTAIN_TILE_BOT_MID = 207;
    public static final int MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG = 208;
    public static final int MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_LEFT = 213;
    public static final int MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_RIGHT = 214;
    public static final int MOUNTAIN_TILE_CONNECTING_CORNER_TOP_LEFT = 215;
    public static final int MOUNTAIN_TILE_CONNECTING_CORNER_TOP_RIGHT = 216;
    public static final int FAIRY_ROCK = 217;
    public static final int CRYSTAL_ROCK = 218;
    public static final int SNOWY_GRASS = 219;
    public static final int BEACH_SAND = 220;
    public static final int BEACH_GRASS = 221;
    public static final int BEACH_GRASS_2 = 222;
    public static final int BEACH_STARFISH = 223;
    public static final int BEACH_SHELL = 224;
    public static final int CAVE_ENTRANCE = 149;

    public static final int TALL_GRASS_OVERLAY = 225;
    public static final int TALL_GRASS_OVERLAY_2 = 226;
    public static final int TALL_GRASS_OVERLAY_3 = 227;
    public static final int SNOW_TALL_GRASS_OVERLAY = 228;
    public static final int HAUNTED_TALL_GRASS_OVERLAY = 229;
    public static final int RAINFOREST_TALL_GRASS_OVERLAY = 230;
    public static final int RUINS_TALL_GRASS_OVERLAY = 231;
    public static final int FOREST_TALL_GRASS_OVERLAY = 232;
    public static final int DESERT_TALL_GRASS_OVERLAY = 233;
    public static final int BEACH_TALL_GRASS_OVERLAY = 234;
    private static final Map<Integer, String> tileTypeNames = new HashMap<>();
    private static final Map<Integer, String> mountainTileNames = new HashMap<>();

    static {
        tileTypeNames.put(WATER, "water");
        tileTypeNames.put(GRASS, "grass");
        tileTypeNames.put(SAND, "sand");
        tileTypeNames.put(ROCK, "rock");
        tileTypeNames.put(SNOW, "snow_base");
        tileTypeNames.put(WATER_PUDDLE, "water_puddle");
        tileTypeNames.put(WATER_PUDDLE_TOP_LEFT, "water_puddle_top_left_corner");
        tileTypeNames.put(WATER_PUDDLE_TOP_MIDDLE, "water_puddle_top_middle");
        tileTypeNames.put(WATER_PUDDLE_TOP_RIGHT, "water_puddle_top_right_corner");
        tileTypeNames.put(WATER_PUDDLE_LEFT_MIDDLE, "water_puddle_left_middle");
        tileTypeNames.put(WATER_PUDDLE_RIGHT_MIDDLE, "water_puddle_right_middle");
        tileTypeNames.put(WATER_PUDDLE_BOTTOM_LEFT, "water_puddle_bottom_left_corner");
        tileTypeNames.put(WATER_PUDDLE_BOTTOM_MIDDLE, "water_puddle_bottom_middle");
        tileTypeNames.put(WATER_PUDDLE_BOTTOM_RIGHT, "water_puddle_bottom_right_corner");

        // Initialize special terrain names
        tileTypeNames.put(HAUNTED_GRASS, "haunted_grass");
        tileTypeNames.put(HAUNTED_SHROOM, "haunted_shroom");
        tileTypeNames.put(HAUNTED_SHROOMS, "haunted_shrooms");

        // Initialize forest names
        tileTypeNames.put(FOREST_GRASS, "forest_grass");

        // Initialize rain forest names
        tileTypeNames.put(RAIN_FOREST_GRASS, "rainforest_grass");
        tileTypeNames.put(STAIRS, "tile052");

        // Initialize desert names
        tileTypeNames.put(DESERT_SAND, "desert_sand");

        // Initialize decorative names with indices where needed
        tileTypeNames.put(FLOWER, "flower");
        tileTypeNames.put(FLOWER_1, "flower");
        tileTypeNames.put(FLOWER_2, "flower");
        tileTypeNames.put(SNOW_2, "snow_grass");
        tileTypeNames.put(SNOW_3, "snow_base");
        tileTypeNames.put(GRASS_2, "grass");
        tileTypeNames.put(GRASS_3, "grass");
        tileTypeNames.put(MOUNTAIN_BASE_EDGE, "tile038");
        tileTypeNames.put(TileType.MOUNTAIN_SLOPE_RIGHT, "tile046");
        tileTypeNames.put(MOUNTAIN_WALL, "mountainBASEMIDDLE");
        tileTypeNames.put(MOUNTAIN_PEAK, "mountaintopRIGHT");
        tileTypeNames.put(MOUNTAIN_PATH, "tile081");
        tileTypeNames.put(MOUNTAIN_STAIRS, "mountainstairsMiddle");
        tileTypeNames.put(MOUNTAIN_BASE, "mountainBASEMIDDLE");
        tileTypeNames.put(MOUNTAIN_STAIRS_LEFT, "mountainstairsLEFT");  // Left stairs
        tileTypeNames.put(MOUNTAIN_STAIRS_RIGHT, "mountainstarsRIGHT"); // Right stairs
        tileTypeNames.put(MOUNTAIN_CORNER_TL, "mountainTOPLEFT"); // Top-left corner
        tileTypeNames.put(MOUNTAIN_CORNER_TR, "mountaintopRIGHT"); // Top-right corner
        tileTypeNames.put(MOUNTAIN_CORNER_BL, "mountainBASELEFT"); // Bottom-left corner
        tileTypeNames.put(MOUNTAIN_CORNER_OUTER_BOTTOMRIGHT, "mountainbaseRIGHT"); // Bottom-right corner
        tileTypeNames.put(MOUNTAIN_CORNER_BR, "mountainbaseRIGHT"); // Bottom-right corner
        tileTypeNames.put(MOUNTAIN_EDGE_LEFT, "mountainTOPLEFT");
        tileTypeNames.put(MOUNTAIN_EDGE_RIGHT, "mountaintopRIGHT");
        tileTypeNames.put(MOUNTAIN_EDGE_TOP, "tile050");
        tileTypeNames.put(MOUNTAIN_CORNER_INNER_TOPLEFT, "tile029");
        tileTypeNames.put(MOUNTAIN_EDGE_BOTTOM, "tile051");
        tileTypeNames.put(RUINS_GRASS, "ruins_grass");
        tileTypeNames.put(RUINS_GRASS_0, "ruins_grass");
        tileTypeNames.put(RUINS_BRICKS, "ruin_bricks");
        tileTypeNames.put(CAVE_ENTRANCE, "cave_entrance");
        tileTypeNames.put(MOUNTAIN_TILE_TOP_LEFT_ROCK_BG, "MOUNTAIN_TILE_TOP_LEFT_ROCK_BG");
        tileTypeNames.put(MOUNTAIN_TILE_TOP_MID, "MOUNTAIN_TILE_TOP_MID");
        tileTypeNames.put(MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG, "MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG");
        tileTypeNames.put(MOUNTAIN_TILE_MID_LEFT, "MOUNTAIN_TILE_MID_LEFT");
        tileTypeNames.put(MOUNTAIN_TILE_CENTER, "MOUNTAIN_TILE_CENTER");
        tileTypeNames.put(MOUNTAIN_TILE_MID_RIGHT, "MOUNTAIN_TILE_MID_RIGHT");
        tileTypeNames.put(MOUNTAIN_TILE_BOT_LEFT_ROCK_BG, "MOUNTAIN_TILE_BOT_LEFT_ROCK_BG");
        tileTypeNames.put(MOUNTAIN_TILE_BOT_MID, "MOUNTAIN_TILE_BOT_MID");
        tileTypeNames.put(MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG, "MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG");
        tileTypeNames.put(MOUNTAIN_TILE_TOP_LEFT_GRASS_BG, "MOUNTAIN_TILE_TOP_LEFT_GRASS_BG");
        tileTypeNames.put(MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG, "MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG");
        tileTypeNames.put(MOUNTAIN_TILE_BOT_LEFT_GRASS_BG, "MOUNTAIN_TILE_BOT_LEFT_GRASS_BG");
        tileTypeNames.put(MOUNTAIN_TILE_CONNECTING_CORNER_TOP_LEFT, "MOUNTAIN_TILE_CONNECTING_CORNER_TOP_LEFT");
        tileTypeNames.put(MOUNTAIN_TILE_CONNECTING_CORNER_TOP_RIGHT, "MOUNTAIN_TILE_CONNECTING_CORNER_TOP_RIGHT");
        tileTypeNames.put(MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_LEFT, "MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_LEFT");
        tileTypeNames.put(MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_RIGHT, "MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_RIGHT");
        tileTypeNames.put(SNOWY_GRASS, "snowy_grass");
        tileTypeNames.put(BEACH_SAND, "beach_sand");
        tileTypeNames.put(BEACH_GRASS, "beach_tall_grass");
        tileTypeNames.put(BEACH_GRASS_2, "beach_grass");
        tileTypeNames.put(BEACH_STARFISH, "beach_starfish");
        tileTypeNames.put(BEACH_SHELL, "beach_shell");
        tileTypeNames.put(TALL_GRASS_OVERLAY, "tall_grass_overlay");
        tileTypeNames.put(TALL_GRASS_OVERLAY_2, "tall_grass_2_overlay");
        tileTypeNames.put(TALL_GRASS_OVERLAY_3, "tall_grass_3_overlay");
        tileTypeNames.put(SNOW_TALL_GRASS_OVERLAY, "snow_tall_grass_overlay");
        tileTypeNames.put(HAUNTED_TALL_GRASS_OVERLAY, "haunted_tall_grass_overlay");
        tileTypeNames.put(RAINFOREST_TALL_GRASS_OVERLAY, "rain_forest_tall_grass_overlay");
        tileTypeNames.put(RUINS_TALL_GRASS_OVERLAY, "ruins_tall_grass_overlay");
        tileTypeNames.put(FOREST_TALL_GRASS_OVERLAY, "forest_tall_grass_overlay");
        tileTypeNames.put(DESERT_TALL_GRASS_OVERLAY, "desert_grass_overlay");
        tileTypeNames.put(BEACH_TALL_GRASS_OVERLAY, "beach_tall_grass_overlay");

        // Add mountain tiles to main tile names
        tileTypeNames.putAll(mountainTileNames);
    }

    public static boolean isWaterPuddle(int tileType) {
        return tileType >= WATER_PUDDLE && tileType <= WATER_PUDDLE_BOTTOM_RIGHT;
    }

    public static Map<Integer, String> getTileTypeNames() {
        return tileTypeNames;
    }

    public static Map<Integer, String> getMountainTileNames() {
        return mountainTileNames;
    }

    public static boolean isMountainTile(int tileType) {
        return tileType >= MOUNTAIN_BASE && tileType <= MOUNTAIN_CORNER_OUTER_BOTTOMRIGHT;
    }

    public static boolean isPassableMountainTile(int tileType) {
        return tileType == MOUNTAIN_STAIRS_LEFT ||
            tileType == MOUNTAIN_STAIRS_RIGHT ||
            tileType == STAIRS ||
            tileType == MOUNTAIN_SNOW_BASE;
    }

    public static boolean isPassableTile(int tileType) {
        // Basic terrain types that are passable
        if (tileType == GRASS || tileType == SAND || tileType == SNOW_TALL_GRASS || tileType == SNOW || tileType == SNOW_2 || tileType == SNOW_3 || tileType == GRASS_3 || tileType == FOREST_TALL_GRASS || tileType == HAUNTED_SHROOM || tileType == HAUNTED_SHROOMS || tileType == MOUNTAIN_STAIRS ||
            tileType == HAUNTED_GRASS || tileType == HAUNTED_TALL_GRASS || tileType == FOREST_GRASS || tileType == RAIN_FOREST_TALL_GRASS ||
            tileType == RAIN_FOREST_GRASS || tileType == DESERT_SAND || tileType == DESERT_GRASS || tileType == FLOWER_2 || tileType == GRASS_2 || tileType == TALL_GRASS || tileType == TALL_GRASS_2 || tileType == TALL_GRASS_3 || tileType == FLOWER_1 || tileType == FLOWER
            || tileType == BEACH_GRASS || tileType == RUINS_BRICKS || tileType == RUINS_TALL_GRASS || tileType == RUINS_GRASS_0 || tileType == RUINS_GRASS || tileType == BEACH_GRASS_2 || tileType == BEACH_SHELL || tileType == BEACH_STARFISH || tileType == SNOWY_GRASS || tileType == BEACH_SAND) {
            return true;
        }
        if (isWaterPuddle(tileType)) {
            return true;
        }
        // Mountain types that are passable (stairs and paths)
        return tileType == MOUNTAIN_STAIRS_LEFT || tileType == MOUNTAIN_STAIRS_RIGHT || tileType == MOUNTAIN_TILE_CENTER ||
            tileType == STAIRS;
    }

    public static boolean isMountainCorner(int tileType) {
        return (tileType >= MOUNTAIN_CORNER_INNER_TOPLEFT && tileType <= MOUNTAIN_CORNER_INNER_BOTTOMRIGHT) ||
            (tileType >= MOUNTAIN_CORNER_OUTER_TOPLEFT && tileType <= MOUNTAIN_CORNER_OUTER_BOTTOMRIGHT);
    }

}

================
File: src/main/java/io/github/pokemeetup/utils/TimeUtils.java
================
package io.github.pokemeetup.utils;

import java.text.SimpleDateFormat;
import java.util.Date;

public class TimeUtils {
    private static final SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm:ss");
    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd HH:mm");

    public static String formatTime(long timestamp) {
        if (System.currentTimeMillis() - timestamp < 24 * 60 * 60 * 1000) {
            // If less than 24 hours ago, show only time
            return timeFormat.format(new Date(timestamp));
        }
        // Otherwise show date and time
        return dateFormat.format(new Date(timestamp));
    }
}



================================================================
End of Codebase
================================================================
