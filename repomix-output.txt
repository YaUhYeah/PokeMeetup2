This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
build.gradle
src/main/java/org/discord/context/ServerGameContext.java
src/main/java/org/discord/DeploymentHelper.java
src/main/java/org/discord/files/ServerFileDelegate.java
src/main/java/org/discord/GameServer.java
src/main/java/org/discord/plugin/JarPluginLoader.java
src/main/java/org/discord/plugin/PluginConfig.java
src/main/java/org/discord/plugin/PluginLoader.java
src/main/java/org/discord/plugin/ServerPlugin.java
src/main/java/org/discord/PluginManager.java
src/main/java/org/discord/ServerBlockManager.java
src/main/java/org/discord/ServerLauncher.java
src/main/java/org/discord/ServerWorldObjectManager.java
src/main/java/org/discord/utils/ServerPokemonSpawnManager.java
src/main/java/org/discord/utils/ServerWorldManager.java

================================================================
Files
================================================================

================
File: build.gradle
================
plugins {
  id 'java'
  id 'com.github.johnrengelman.shadow' version '8.1.1'
}

java {
  sourceCompatibility = JavaVersion.VERSION_11
  targetCompatibility = JavaVersion.VERSION_11
}

repositories {
  mavenCentral()
}

dependencies {
  implementation project(':core')
  implementation "com.google.code.gson:gson:2.10.1"
  implementation "com.h2database:h2:2.1.214"
  implementation 'ch.qos.logback:logback-classic:1.4.11'
  implementation group: 'org.lz4', name: 'lz4-java', version: '1.8.0'



  implementation "com.esotericsoftware:kryonet:2.22.0-RC1"
  implementation "com.esotericsoftware.kryo:kryo:2.24.0"
  implementation "at.favre.lib:bcrypt:0.10.2"
}

shadowJar {
  archiveFileName = 'server.jar'
  destinationDirectory = file("${buildDir}/libs")
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE

  manifest {
    attributes(
      'Main-Class': 'org.discord.ServerLauncher',
      'Implementation-Title': 'Pokemon Meetup Server',
      'Implementation-Version': project.version
    )
  }

  // Use the configurations property to include runtime dependencies
  configurations = [project.configurations.runtimeClasspath]

  // Exclude unnecessary files
  exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
  exclude 'assets/**'
  exclude '**/*.png', '**/*.jpg', '**/*.jpeg', '**/*.mp3', '**/*.wav', '**/*.ogg', '**/*.ttf'
}

================
File: src/main/java/org/discord/context/ServerGameContext.java
================
package org.discord.context;

import io.github.pokemeetup.multiplayer.server.ServerStorageSystem;
import io.github.pokemeetup.multiplayer.server.events.EventManager;
import io.github.pokemeetup.system.gameplay.inventory.ItemEntityManager;
import org.discord.GameServer;
import org.discord.ServerBlockManager;
import org.discord.ServerWorldObjectManager;
import org.discord.utils.ServerWorldManager;

public final class ServerGameContext {
    private static ServerGameContext instance;
    private final ServerWorldManager worldManager;
    private final ServerStorageSystem storageSystem;
    private final ServerBlockManager serverBlockManager;
    private final ServerWorldObjectManager worldObjectManager;
    private final ItemEntityManager itemEntityManager;
    private final EventManager eventManager;
    private GameServer gameServer;

    private ServerGameContext(ServerWorldManager worldManager,
                              ServerStorageSystem storageSystem,
                              ServerWorldObjectManager worldObjectManager,
                              ItemEntityManager itemEntityManager, ServerBlockManager serverBlockManager, GameServer gameServer
    , EventManager eventManager) {
        this.worldManager = worldManager;
        this.storageSystem = storageSystem;
        this.worldObjectManager = worldObjectManager;
        this.serverBlockManager = serverBlockManager;
        this.itemEntityManager = itemEntityManager;
        this.gameServer = gameServer;
        this.eventManager = eventManager;
    }

    public static void init(ServerWorldManager worldManager,
                            ServerStorageSystem storageSystem,
                            ServerWorldObjectManager worldObjectManager,
                            ItemEntityManager itemEntityManager, ServerBlockManager serverBlockManager, GameServer gameServer, EventManager eventManager) {
        if (instance != null) {
            throw new IllegalStateException("ServerGameContext already initialized!");
        }
        instance = new ServerGameContext(worldManager, storageSystem, worldObjectManager, itemEntityManager, serverBlockManager, gameServer,eventManager);
    }

    public static ServerGameContext get() {
        if (instance == null) {
            throw new IllegalStateException("ServerGameContext not initialized yet!");
        }
        return instance;
    }

    public GameServer getGameServer() {
        return gameServer;
    }

    public EventManager getEventManager() {
        return eventManager;
    }

    public void setGameServer(GameServer gameServer) {
        this.gameServer = gameServer;
    }

    public ItemEntityManager getItemEntityManager() {
        return itemEntityManager;
    }

    public ServerBlockManager getServerBlockManager() {
        return serverBlockManager;
    }

    public ServerStorageSystem getStorageSystem() {
        return storageSystem;
    }

    public ServerWorldManager getWorldManager() {
        return worldManager;
    }

    public ServerWorldObjectManager getWorldObjectManager() {
        return worldObjectManager;
    }

    public void dispose() {
        if (worldManager != null) {
            worldManager.shutdown();
        }
        if (worldObjectManager != null) {
            worldObjectManager.cleanup();
        }
        instance = null;
    }
}

================
File: src/main/java/org/discord/DeploymentHelper.java
================
package org.discord;

import com.badlogic.gdx.utils.Json;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

public class DeploymentHelper {
    public static void createServerDeployment(Path deploymentDir) throws IOException {
        System.out.println("Creating server deployment in: " + deploymentDir.toAbsolutePath());

        // Create directory structure
        createDirectory(deploymentDir);
        createDirectory(Paths.get(deploymentDir.toString(), "config"));
        createDirectory(Paths.get(deploymentDir.toString(), "plugins"));
        createDirectory(Paths.get(deploymentDir.toString(), "worlds"));
        createDirectory(Paths.get(deploymentDir.toString(), "server/data"));
       // Check if we're running from JAR or development environment
        Path serverJar;
        if (isRunningFromJar()) {
            // When running from JAR, use the current JAR
            serverJar = getCurrentJarPath();
            System.out.println("Running from JAR: " + serverJar);
        } else {
            // In development, look for the JAR in build directory
            serverJar = Paths.get("server.jar");
            System.out.println("Running in development mode, looking for: " + serverJar);
        }

        if (Files.exists(serverJar)) {
            Files.copy(serverJar, Paths.get(deploymentDir.toString(), "server.jar"));
            System.out.println("Copied server JAR successfully");
        } else {
            System.out.println("Warning: Server JAR not found at: " + serverJar);
            // Continue anyway as we might be in development mode
        }

        // Create configurations
        createDefaultConfig(deploymentDir);

        // Create start scripts
        createStartScripts(deploymentDir);

        // Make shell script executable on Unix
        Path startSh = Paths.get(deploymentDir.toString(), "start.sh");
        if (Files.exists(startSh)) {
            startSh.toFile().setExecutable(true);
        }

        // Create README
        createReadme(deploymentDir);

        System.out.println("Server deployment completed successfully");
    }

    private static boolean isRunningFromJar() {
        String className = DeploymentHelper.class.getName().replace('.', '/');
        String classJar = DeploymentHelper.class.getResource("/" + className + ".class").toString();
        return classJar.startsWith("jar:");
    }

    private static Path getCurrentJarPath() {
        try {
            return Paths.get(DeploymentHelper.class.getProtectionDomain().getCodeSource().getLocation().toURI());
        } catch (Exception e) {
            return Paths.get("server.jar");
        }
    }

    private static void createDirectory(Path dir) throws IOException {
        if (!Files.exists(dir)) {
            Files.createDirectories(dir);
            System.out.println("Created directory: " + dir);
        }
    }




    // Helper method to create both start scripts
    private static void createStartScripts(Path deploymentDir) throws IOException {
        // Create Windows batch file
        try {
            createWindowsScript(deploymentDir);
            System.out.println("Created start.bat successfully");
        } catch (IOException e) {
            throw new IOException("Failed to create start.bat: " + e.getMessage());
        }

        // Create Unix shell script
        try {
            createUnixScript(deploymentDir);
            System.out.println("Created start.sh successfully");
        } catch (IOException e) {
            throw new IOException("Failed to create start.sh: " + e.getMessage());
        }
    }

    // Create Windows batch script
    private static void createWindowsScript(Path deploymentDir) throws IOException {
        String batScript =
            "@echo off\n" +
                "setlocal enabledelayedexpansion\n\n" +
                ":: Set Java path if needed\n" +
                "set JAVA_HOME=\n" +
                "if defined JAVA_HOME (\n" +
                "    set JAVA=\"%JAVA_HOME%/bin/java\"\n" +
                ") else (\n" +
                "    set JAVA=java\n" +
                ")\n\n" +
                ":: Set memory options\n" +
                "set MIN_MEMORY=1G\n" +
                "set MAX_MEMORY=4G\n\n" +
                ":: Start server\n" +
                "echo Starting Pokemon Meetup Server...\n" +
                "%JAVA% -Xms%MIN_MEMORY% -Xmx%MAX_MEMORY% -jar server.jar\n" +
                "pause\n";

        Path batPath = Paths.get(deploymentDir.toString(), "start.bat");
        Files.write(batPath, batScript.getBytes(StandardCharsets.UTF_8));
    }

    // Create Unix shell script
    private static void createUnixScript(Path deploymentDir) throws IOException {
        String shScript =
            "#!/bin/bash\n\n" +
                "# Set Java path if needed\n" +
                "if [ -n \"$JAVA_HOME\" ]; then\n" +
                "    JAVA=\"$JAVA_HOME/bin/java\"\n" +
                "else\n" +
                "    JAVA=\"java\"\n" +
                "fi\n\n" +
                "# Set memory options\n" +
                "MIN_MEMORY=\"1G\"\n" +
                "MAX_MEMORY=\"4G\"\n\n" +
                "# Start server\n" +
                "echo \"Starting Pokemon Meetup Server...\"\n" +
                "$JAVA -Xms$MIN_MEMORY -Xmx$MAX_MEMORY -jar server.jar\n";

        Path shPath = Paths.get(deploymentDir.toString(), "start.sh");
        Files.write(shPath, shScript.getBytes(StandardCharsets.UTF_8));

        // Make shell script executable
        try {
            shPath.toFile().setExecutable(true);
        } catch (SecurityException e) {
            System.out.println("Warning: Could not make start.sh executable: " + e.getMessage());
        }
    }

    private static void createDefaultConfig(Path deploymentDir) throws IOException {
        ServerConnectionConfig config = new ServerConnectionConfig(
            "0.0.0.0",
            54555,
            54556,
            "Pokemon Meetup Server",
            true,
            100
        );

        Json json = new Json();
        Path configFile = Paths.get(deploymentDir.toString(), "config/server.json");
        Files.write(configFile, Arrays.asList(json.prettyPrint(config).split("\n")), StandardCharsets.UTF_8);
    }

    private static void createReadme(Path deploymentDir) throws IOException {
        String readme =
            "Pokemon Meetup Server\n" +
                "====================\n\n" +
                "Quick Start:\n" +
                "1. Edit config/server.json to configure your server\n" +
                "2. On Windows: Run start.bat\n" +
                "   On Linux/Mac: Run ./start.sh\n" +
                "3. Server will create necessary directories on first run\n\n" +
                "Plugins:\n" +
                "- Place plugin .jar files in the plugins directory\n" +
                "- Server will load plugins automatically on startup\n\n" +
                "Configuration:\n" +
                "- Server settings: config/server.json\n" +
                "- Plugin configs: config/<plugin-id>.json\n\n" +
                "Logs:\n" +
                "- Server logs are stored in the logs directory\n\n" +
                "Support:\n" +
                "- Issues: https://github.com/yourusername/pokemon-meetup/issues\n" +
                "- Wiki: https://github.com/yourusername/pokemon-meetup/wiki\n";

        Path readmeFile = Paths.get(deploymentDir.toString(), "README.md");
        Files.write(readmeFile, Arrays.asList(readme.split("\n")), StandardCharsets.UTF_8);
    }

}

================
File: src/main/java/org/discord/files/ServerFileDelegate.java
================
package org.discord.files;

import io.github.pokemeetup.FileSystemDelegate;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.logging.Logger;

public class ServerFileDelegate implements FileSystemDelegate {
    private static final Logger logger = Logger.getLogger(ServerFileDelegate.class.getName());
    private final String basePath;
    @Override
    public void moveFile(String sourcePath, String destinationPath) throws IOException {
        File sourceFile = new File(sourcePath);
        File destFile = new File(destinationPath);

        if (!sourceFile.exists()) {
            throw new FileNotFoundException("Source file does not exist: " + sourcePath);
        }

        boolean success = sourceFile.renameTo(destFile);
        if (!success) {
            throw new IOException("Failed to move file from " + sourcePath + " to " + destinationPath);
        }
    }
    public ServerFileDelegate() {
        // Use working directory as base path
        this.basePath = System.getProperty("user.dir");
        logger.info("Initialized server file system with base path: " + basePath);
    }

    private Path getPath(String path) {
        return Paths.get(basePath, path);
    }

    @Override
    public boolean exists(String path) {
        return Files.exists(getPath(path));
    }

    @Override
    public void createDirectory(String path) {
        try {
            Files.createDirectories(getPath(path));
        } catch (IOException e) {
            logger.severe("Failed to create directory: " + path);
            throw new RuntimeException("Failed to create directory: " + path, e);
        }
    }

    @Override
    public void writeString(String path, String content) throws IOException {
        Path filePath = getPath(path);
        Files.createDirectories(filePath.getParent());
        Files.writeString(filePath, content, StandardCharsets.UTF_8);
    }

    @Override
    public String readString(String path) throws IOException {
        return Files.readString(getPath(path), StandardCharsets.UTF_8);
    }

    @Override
    public void deleteFile(String path) {
        try {
            Files.deleteIfExists(getPath(path));
        } catch (IOException e) {
            logger.severe("Failed to delete file: " + path);
            throw new RuntimeException("Failed to delete file: " + path, e);
        }
    }

    @Override
    public void deleteDirectory(String path) {
        try {
            Files.walk(getPath(path))
                .sorted((a, b) -> -a.compareTo(b))
                .forEach(p -> {
                    try {
                        Files.delete(p);
                    } catch (IOException e) {
                        logger.severe("Failed to delete: " + p);
                    }
                });
        } catch (IOException e) {
            logger.severe("Failed to delete directory: " + path);
            throw new RuntimeException("Failed to delete directory: " + path, e);
        }
    }

    @Override
    public boolean isDirectory(String path) {
        return Files.isDirectory(getPath(path));
    }

    @Override
    public String[] list(String path) {
        try {
            return Files.list(getPath(path))
                .map(p -> p.getFileName().toString())
                .toArray(String[]::new);
        } catch (IOException e) {
            logger.severe("Failed to list directory: " + path);
            return new String[0];
        }
    }

    @Override
    public void copyFile(String sourcePath, String destinationPath) throws IOException {
        Files.copy(getPath(sourcePath), getPath(destinationPath),
            StandardCopyOption.REPLACE_EXISTING);
    }

    @Override
    public InputStream openInputStream(String path) throws IOException {
        return Files.newInputStream(getPath(path));
    }

    @Override
    public OutputStream openOutputStream(String path) throws IOException {
        Path filePath = getPath(path);
        Files.createDirectories(filePath.getParent());
        return Files.newOutputStream(filePath);
    }
}

================
File: src/main/java/org/discord/GameServer.java
================
package org.discord;

import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Output;
import com.esotericsoftware.kryonet.FrameworkMessage;
import com.esotericsoftware.kryonet.Server;
import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.Listener;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.managers.BiomeTransitionResult;
import io.github.pokemeetup.managers.DatabaseManager;
import io.github.pokemeetup.multiplayer.PlayerManager;
import io.github.pokemeetup.multiplayer.ServerPlayer;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.multiplayer.server.events.blocks.BlockPlaceEvent;
import io.github.pokemeetup.multiplayer.server.events.player.PlayerJoinEvent;
import io.github.pokemeetup.system.data.*;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.inventory.ItemEntity;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.WeatherSystem;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.PasswordUtils;
import io.github.pokemeetup.utils.textures.TextureManager;
import net.jpountz.lz4.LZ4Compressor;
import net.jpountz.lz4.LZ4Factory;
import org.discord.context.ServerGameContext;
import org.discord.utils.ServerPokemonSpawnManager;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import java.util.zip.GZIPOutputStream;

import static io.github.pokemeetup.CreatureCaptureGame.MULTIPLAYER_WORLD_NAME;
import static io.github.pokemeetup.system.gameplay.overworld.World.CHUNK_SIZE;
import static io.github.pokemeetup.system.gameplay.overworld.World.TILE_SIZE;
import static io.github.pokemeetup.system.gameplay.overworld.WorldObject.WorldObjectManager.MAX_POKEBALLS_PER_CHUNK;
import static io.github.pokemeetup.system.gameplay.overworld.WorldObject.WorldObjectManager.POKEBALL_SPAWN_CHANCE;

public class GameServer {
    private static final int WRITE_BUFFER = 65536;
    private static final int OBJECT_BUFFER = 65536;
    private static final int SCHEDULER_POOL_SIZE = 3;
    private static final long AUTH_TIMEOUT = 15000;
    private static final long SAVE_INTERVAL = 300000;
    private static final ConcurrentHashMap<UUID, Object> chestLocks = new ConcurrentHashMap<>();
    private final Server networkServer;
    private final ServerConnectionConfig config;
    private final DatabaseManager databaseManager;
    private final ConcurrentHashMap<Integer, String> connectedPlayers;
    private final PlayerManager playerManager;
    private final ScheduledExecutorService scheduler;
    private final Map<String, Integer> activeUserConnections = new ConcurrentHashMap<>();
    private final Map<String, ServerPlayer> activePlayers = new ConcurrentHashMap<>();
    private final Map<String, ConnectionInfo> activeConnections = new ConcurrentHashMap<>();
    private final Map<String, Long> recentDisconnects = new ConcurrentHashMap<>();
    private final WorldData worldData;
    private final PluginManager pluginManager;
    private final ConcurrentHashMap<String, Integer> playerPingMap = new ConcurrentHashMap<>();
    private final Map<String, Vector2> playerChunkMap = new ConcurrentHashMap<>();
    private final ServerPokemonSpawnManager serverPokemonSpawnManager;
    private volatile boolean running;
    private final WeatherSystem weatherSystem;

    public GameServer(ServerConnectionConfig config) {
        this.scheduler = Executors.newScheduledThreadPool(SCHEDULER_POOL_SIZE, r -> {
            Thread thread = new Thread(r, "GameServer-Scheduler");
            thread.setDaemon(true);
            return thread;
        });
        ItemManager.setServerMode(true);
        ItemManager.initialize(null);
        this.config = config;
        this.networkServer = new Server(WRITE_BUFFER, OBJECT_BUFFER);
        NetworkProtocol.registerClasses(networkServer.getKryo());
        scheduler.scheduleAtFixedRate(() -> {
            try {
                ServerGameContext.get().getStorageSystem().getPlayerDataManager().flush();
            } catch (Exception e) {
                GameLogger.error("Scheduled player data flush failed: " + e.getMessage());
            }
        }, 300000, 300000, TimeUnit.MILLISECONDS);

        networkServer.getKryo().setReferences(false);


        this.databaseManager = new DatabaseManager();
        this.connectedPlayers = new ConcurrentHashMap<>();
        this.playerManager = new PlayerManager(ServerGameContext.get().getStorageSystem());


        try {
            this.worldData = initializeMultiplayerWorld(); this.weatherSystem = new WeatherSystem();
            serverPokemonSpawnManager = new ServerPokemonSpawnManager(MULTIPLAYER_WORLD_NAME);
            setupNetworkListener();
            scheduler.scheduleAtFixedRate(() -> {
                // You can use a delta of 0.1f or any suitable value here.
                // First update wild Pokémon state, then broadcast updates.
                serverPokemonSpawnManager.update(0.1f);
                serverPokemonSpawnManager.broadcastPokemonUpdates();
            }, 0, 100, TimeUnit.MILLISECONDS);// In your GameServer constructor, after worldData is initialized:
            scheduler.scheduleAtFixedRate(() -> {
                // Update the world time by 1 second (real time)
                worldData.updateTime(1.0f);
            }, 0, 1, TimeUnit.SECONDS);

            scheduler.scheduleAtFixedRate(() -> {
                try {
                    broadcastWorldState();
                } catch (Exception e) {
                    GameLogger.error("Error broadcasting world state: " + e.getMessage());
                }
            }, 1000, 1000, TimeUnit.MILLISECONDS); // every 1 second

            this.pluginManager = new PluginManager(worldData);
        } catch (Exception e) {
            GameLogger.error("Failed to initialize game world: " + e.getMessage());
            throw new RuntimeException("Failed to initialize server world", e);
        }
    }

    public Set<Vector2> getPlayerOccupiedChunks() {
        Set<Vector2> occupied = new HashSet<>();
        for (Map.Entry<String, Vector2> entry : playerChunkMap.entrySet()) {
            String user = entry.getKey();
            if (!activePlayers.containsKey(user)) {
                continue;
            }
            Vector2 pos = entry.getValue();
            occupied.add(pos);
        }
        return occupied;
    }

    private WorldData initializeMultiplayerWorld() {
        try {
            WorldData worldData = ServerGameContext.get().getWorldManager().loadWorld(MULTIPLAYER_WORLD_NAME);
            if (worldData == null) {
                // Create new WorldData
                worldData = ServerGameContext.get().getWorldManager().createWorld(
                    MULTIPLAYER_WORLD_NAME,
                    System.currentTimeMillis(),
                    0.15f,
                    0.05f
                );

                ServerGameContext.get().getWorldManager().saveWorld(worldData);
            }
            return worldData;
        } catch (Exception e) {
            GameLogger.error("Failed to initialize multiplayer world: " + e.getMessage());
            throw new RuntimeException("WorldData initialization failed", e);
        }
    }

    private void handleDisconnect(Connection connection) {
        String username = connectedPlayers.get(connection.getID());
        if (username != null) {
            GameLogger.info("Handling disconnect for user: " + username);

            synchronized (activeConnections) {
                try {
                    // Existing cleanup code…
                    recentDisconnects.put(username, System.currentTimeMillis());
                    activeConnections.remove(username);
                    cleanupPlayerSession(connection.getID(), username);

                    // **** REMOVE the player's ping entry ****
                    playerPingMap.remove(username);
                    // Immediately broadcast the updated list:
                    broadcastPlayerList();

                    // Notify all clients that this player left:
                    NetworkProtocol.PlayerLeft leftMessage = new NetworkProtocol.PlayerLeft();
                    leftMessage.username = username;
                    leftMessage.timestamp = System.currentTimeMillis();
                    networkServer.sendToAllTCP(leftMessage);
                } catch (Exception e) {
                    GameLogger.error("Error during disconnect handling: " + e.getMessage());
                }
            }
        } else {
            GameLogger.info("username null during disconnect?");
        }
    }

    public void shutdown() {
        try {
            GameLogger.info("Starting server shutdown sequence...");

            NetworkProtocol.ServerShutdown shutdownMsg = new NetworkProtocol.ServerShutdown();
            shutdownMsg.reason = "Server is shutting down";
            networkServer.sendToAllTCP(shutdownMsg);


            // Save world state if exists
            if (worldData != null) {
                try {
                    GameLogger.info("Saving world data during shutdown...");
                    worldData.setLastPlayed(System.currentTimeMillis());
                    ServerGameContext.get().getWorldManager().saveWorld(worldData);
                } catch (Exception e) {
                    GameLogger.error("Error saving world data during shutdown: " + e.getMessage());
                }
            }

            Thread.sleep(500);

            running = false;
            if (ServerGameContext.get().getWorldManager() != null) {
                ServerGameContext.get().getWorldManager().shutdown();
            }
            networkServer.stop();
            if (scheduler != null) {
                scheduler.shutdown();
                try {
                    if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                        scheduler.shutdownNow();
                    }
                } catch (InterruptedException e) {
                    scheduler.shutdownNow();
                }
            }

            GameLogger.info("Server shutdown completed successfully");
        } catch (Exception e) {
            GameLogger.error("Error during server shutdown: " + e.getMessage());
            if (networkServer != null) {
                networkServer.stop();
            }
        }
    }

    private void handleItemDrop(Connection connection, NetworkProtocol.ItemDrop drop) {
        String username = connectedPlayers.get(connection.getID());
        if (username == null || !username.equals(drop.username)) {
            GameLogger.error("Unauthorized item drop attempt");
            return;
        }

        // Validate the drop position isn't too far from player
        ServerPlayer player = activePlayers.get(username);
        if (player == null) {
            GameLogger.error("No player found for item drop");
            return;
        }

        float distance = Vector2.dst(
            player.getPosition().x, player.getPosition().y,
            drop.x, drop.y
        );

        if (distance > TILE_SIZE * 2) {
            GameLogger.error("Item drop position too far from player");
            return;
        }

        // Broadcast the drop to all other players
        networkServer.sendToAllExceptTCP(connection.getID(), drop);
    }

    private void cleanupPlayerSession(int connectionId, String username) {
        synchronized (activeUserConnections) {
            activeUserConnections.remove(username);
            connectedPlayers.remove(connectionId);

        }
    }

    private void sendSuccessfulLoginResponse(Connection connection, ServerPlayer player) {
        NetworkProtocol.LoginResponse response = new NetworkProtocol.LoginResponse();
        response.success = true;
        response.username = player.getUsername();
        response.message = "Login successful";
        response.x = (int) player.getPosition().x;
        response.y = (int) player.getPosition().y;
        response.seed = worldData.getConfig().getSeed();
        response.worldTimeInMinutes = worldData.getWorldTimeInMinutes();
        response.dayLength = worldData.getDayLength();
        response.timestamp = System.currentTimeMillis();

        response.playerData = player.getData();
        connection.sendTCP(response);
    }

    private Connection findConnection(int connectionId) {
        for (Connection conn : networkServer.getConnections()) {
            if (conn.getID() == connectionId) {
                return conn;
            }
        }
        return null;
    }

    private void sendLoginFailure(Connection connection, String message) {
        NetworkProtocol.LoginResponse response = new NetworkProtocol.LoginResponse();
        response.success = false;
        response.message = message;
        response.timestamp = System.currentTimeMillis();

        try {
            connection.sendTCP(response);
            GameLogger.info("Sent login failure: " + message);
        } catch (Exception e) {
            GameLogger.error("Error sending login failure: " + e.getMessage());
        }
    }

    private void handlePlayerUpdate(Connection connection, NetworkProtocol.PlayerUpdate update) {
        try {
            String username = connectedPlayers.get(connection.getID());
            if (username == null || !username.equals(update.username)) {
                GameLogger.error("Username mismatch in player update");
                return;
            }
            ServerPlayer serverPlayer = activePlayers.get(username);
            if (serverPlayer == null) {
                GameLogger.error("No ServerPlayer instance found for: " + username);
                return;
            }

            // 1. Update the player's position & state

            serverPlayer.setPosition(update.x, update.y);
            serverPlayer.setDirection(update.direction);
            serverPlayer.setMoving(update.isMoving);

            // Convert pixel coords => chunk coords
            int cX = (int) Math.floor(update.x / (World.CHUNK_SIZE * World.TILE_SIZE));
            int cY = (int) Math.floor(update.y / (World.CHUNK_SIZE * World.TILE_SIZE));
            Vector2 chunkPos = new Vector2(cX, cY);
            // Store that in the map
            playerChunkMap.put(username, chunkPos);
            // Then update persistent data
            PlayerData playerData = ServerGameContext.get().getStorageSystem()
                .getPlayerDataManager().loadPlayerData(UUID.nameUUIDFromBytes(update.username.getBytes()));

            if (playerData == null) {
                GameLogger.error("No player data found for active player: " + username);
                return;
            }

            // Update player data
            playerData.setX(update.x);
            playerData.setY(update.y);
            playerData.setDirection(update.direction);
            playerData.setMoving(update.isMoving);
            playerData.setWantsToRun(update.wantsToRun);

            if (update.inventoryItems != null) {
                playerData.setInventoryItems(Arrays.asList(update.inventoryItems));
            }
            if (update.partyPokemon != null) {
                playerData.setPartyPokemon(update.partyPokemon);
            }

            // Save to storage
            UUID playerUUID = UUID.nameUUIDFromBytes(username.getBytes());
            ServerGameContext.get().getStorageSystem()
                .getPlayerDataManager().savePlayerData(playerUUID, playerData);

            // Broadcast update to other players
            networkServer.sendToAllExceptTCP(connection.getID(), update);

        } catch (Exception e) {
            GameLogger.error("Error handling player update: " + e.getMessage());
        }
    }

    private void handlePokemonSpawn(Connection connection, NetworkProtocol.WildPokemonSpawn spawnRequest) {
        try {
            WorldData world = ServerGameContext.get().getWorldManager().loadWorld(MULTIPLAYER_WORLD_NAME);
            if (world == null) {
                GameLogger.error("Cannot spawn Pokemon: World is null");
                return;
            }

            if (!isValidSpawnPosition(spawnRequest.x, spawnRequest.y)) {
                GameLogger.error("Invalid spawn position: " + spawnRequest.x + "," + spawnRequest.y);
                return;
            }

            WildPokemon pokemon = createWildPokemon(spawnRequest);
            if (pokemon == null) {
                GameLogger.error("Failed to create Pokemon from spawn request");
                return;
            }
            // Create broadcast message
            NetworkProtocol.WildPokemonSpawn broadcastSpawn = createSpawnBroadcast(pokemon);

            // Broadcast to all clients
            try {
                networkServer.sendToAllTCP(broadcastSpawn);
                GameLogger.info("Broadcast Pokemon spawn: " + pokemon.getName() +
                    " (UUID: " + pokemon.getUuid() + ")");
            } catch (Exception e) {
                GameLogger.error("Failed to broadcast Pokemon spawn: " + e.getMessage());
                world.removeWildPokemon(pokemon.getUuid());
            }

        } catch (Exception e) {
            GameLogger.error("Error handling Pokemon spawn: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private boolean isValidSpawnPosition(float x, float y) {
        int tileX = (int) (x / TILE_SIZE);
        int tileY = (int) (y / TILE_SIZE);

        if (tileX < 0 || tileX >= World.WORLD_SIZE ||
            tileY < 0 || tileY >= World.WORLD_SIZE) {
            return false;
        }

        WorldData world = ServerGameContext.get().getWorldManager().loadWorld(MULTIPLAYER_WORLD_NAME);
        if (world == null) return false;

        return true;
    }

    private NetworkProtocol.WildPokemonSpawn createSpawnBroadcast(WildPokemon pokemon) {
        NetworkProtocol.WildPokemonSpawn broadcast = new NetworkProtocol.WildPokemonSpawn();
        broadcast.uuid = pokemon.getUuid();
        broadcast.x = pokemon.getX();
        broadcast.y = pokemon.getY();
        PokemonData pokemonData = new PokemonData();
        pokemonData.setName(pokemon.getName());
        pokemonData.setLevel(pokemon.getLevel());
        pokemonData.setPrimaryType(pokemon.getPrimaryType());
        pokemonData.setSecondaryType(pokemon.getSecondaryType());

        // Set stats
        if (pokemon.getStats() != null) {
            PokemonData.Stats stats = new PokemonData.Stats(pokemon.getStats());
            pokemonData.setStats(stats);
        }

        // Set moves
        List<PokemonData.MoveData> moves = pokemon.getMoves().stream()
            .map(PokemonData.MoveData::fromMove)
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
        pokemonData.setMoves(moves);

        broadcast.data = pokemonData;
        broadcast.timestamp = System.currentTimeMillis();

        return broadcast;
    }

    private WildPokemon createWildPokemon(NetworkProtocol.WildPokemonSpawn spawnRequest) {
        try {
            WildPokemon pokemon = new WildPokemon(
                spawnRequest.data.getName(),
                spawnRequest.data.getLevel(),
                (int) spawnRequest.x,
                (int) spawnRequest.y,
                TextureManager.getOverworldSprite(spawnRequest.data.getName())
            );
            pokemon.setUuid(spawnRequest.uuid != null ? spawnRequest.uuid : UUID.randomUUID());
            pokemon.setSpawnTime(System.currentTimeMillis() / 1000L);

            return pokemon;
        } catch (Exception e) {
            GameLogger.error("Error creating WildPokemon: " + e.getMessage());
            return null;
        }
    }

    private boolean authenticateUser(String username, String password) {
        String storedHash = databaseManager.getPasswordHash(username);
        if (storedHash == null) {
            GameLogger.error("Authentication failed: Username '" + username + "' does not exist.");
            return false;
        }
        return PasswordUtils.verifyPassword(password, storedHash);
    }

    private void handleLoginRequest(Connection connection, NetworkProtocol.LoginRequest request) {
        try {
            GameLogger.info("Processing login request for: " + request.username);

            // Generate consistent UUID based on username
            UUID playerUUID = UUID.nameUUIDFromBytes(request.username.getBytes());
            GameLogger.info("Generated UUID for player: " + playerUUID);

            // Try to load existing player data first
            PlayerData playerData = ServerGameContext.get().getStorageSystem()
                .getPlayerDataManager().loadPlayerData(playerUUID);

            if (playerData == null) {
                // Only create new data if none exists
                GameLogger.info("Creating new player data for: " + request.username);
                playerData = new PlayerData(request.username);
                playerData.setX(0);
                playerData.setY(0);
                playerData.setDirection("down");
                playerData.setMoving(false);
                playerData.setInventoryItems(new ArrayList<>());
                playerData.setPartyPokemon(new ArrayList<>());

                // Save immediately and verify
                ServerGameContext.get().getStorageSystem()
                    .getPlayerDataManager().savePlayerData(playerUUID, playerData);
                ServerGameContext.get().getStorageSystem()
                    .getPlayerDataManager().flush(); // Force write to disk
            }

            // Validate authentication
            if (!authenticateUser(request.username, request.password)) {
                sendLoginFailure(connection, "Invalid credentials");
                return;
            }

            synchronized (activeConnections) {
                // Handle existing connection
                handleExistingConnection(request.username);

                // Create new connection
                ConnectionInfo newConnection = new ConnectionInfo(connection.getID());
                activeConnections.put(request.username, newConnection);
                ServerPlayer player;
                if (!activeConnections.containsKey(request.username)) {
                    player = new ServerPlayer(request.username, playerData);
                } else {
                    player = new ServerPlayer(request.username, ServerGameContext.get().getStorageSystem().getPlayerDataManager().playerCache.get(UUID.nameUUIDFromBytes(request.username.getBytes())));
                }
                activePlayers.put(request.username, player);
                // Reg ister the player
                connectedPlayers.put(connection.getID(), request.username);
                newConnection.isAuthenticated = true;

                // Send successful response
                sendSuccessfulLoginResponse(connection, player);
                NetworkProtocol.PlayerJoined joinedMsg = new NetworkProtocol.PlayerJoined();
                joinedMsg.username = request.username;
                joinedMsg.x = playerData.getX();     // or however you track player’s X
                joinedMsg.y = playerData.getY();     // similarly for Y
                joinedMsg.timestamp = System.currentTimeMillis();

                ServerGameContext.get().getEventManager().fireEvent(new PlayerJoinEvent(request.username, playerData));
                // Send to everyone (including the newly joined player)
                networkServer.sendToAllTCP(joinedMsg);
                sendActivePokemonToConnection(connection);

                GameLogger.info("Login successful for: " + request.username);
            }

        } catch (Exception e) {
            GameLogger.error("Login error for " + request.username + ": " + e.getMessage());
            e.printStackTrace();
            sendLoginFailure(connection, "Server error occurred");
        }
    }

    private void handleExistingConnection(String username) throws InterruptedException {
        ConnectionInfo existingConnection = activeConnections.get(username);
        if (existingConnection != null) {
            Connection oldConnection = findConnection(existingConnection.connectionId);
            if (oldConnection != null && oldConnection.isConnected()) {
                NetworkProtocol.ForceDisconnect forceDisconnect = new NetworkProtocol.ForceDisconnect();
                forceDisconnect.reason = "Logged in from another location";
                oldConnection.sendTCP(forceDisconnect);
                Thread.sleep(100);
                oldConnection.close();

                cleanupPlayerSession(existingConnection.connectionId, username);
                Thread.sleep(500);
            }
        }
    }
    // Modify handleChunkRequest in GameServer.java
    public void handleChunkRequest(Connection connection, NetworkProtocol.ChunkRequest request) {
        Vector2 chunkPos = new Vector2(request.chunkX, request.chunkY);
        try {
            WorldData worldData = ServerGameContext.get().getWorldManager().loadWorld(MULTIPLAYER_WORLD_NAME);
            if (worldData == null) {
                GameLogger.error("Failed to load world data for chunk request at " + chunkPos);
                return;
            }

            // CRITICAL FIX: Generate a deterministic chunk seed based on world seed and position
            // This ensures the same chunk is generated every time for the same coordinates
            long chunkSeed = worldData.getConfig().getSeed() +
                (((long)request.chunkX << 32) | ((long)request.chunkY & 0xFFFFFFFFL));

            // Load or generate chunk with proper error handling
            Chunk chunk = ServerGameContext.get().getWorldManager().loadChunk(MULTIPLAYER_WORLD_NAME, request.chunkX, request.chunkY);
            if (chunk == null) {
                GameLogger.error("Failed to load/generate chunk at " + chunkPos);
                return;
            }

            // Calculate precise biome transition at chunk center for consistency
            float centerPixelX = (request.chunkX * Chunk.CHUNK_SIZE + Chunk.CHUNK_SIZE * 0.5f) * World.TILE_SIZE;
            float centerPixelY = (request.chunkY * Chunk.CHUNK_SIZE + Chunk.CHUNK_SIZE * 0.5f) * World.TILE_SIZE;
            BiomeTransitionResult transition = ServerGameContext.get().getWorldManager().getBiomeTransitionAt(
                centerPixelX, centerPixelY
            );

            // FIX: Save biome info to the chunk to ensure it's consistently stored
            if (transition != null && transition.getPrimaryBiome() != null) {
                chunk.setBiome(transition.getPrimaryBiome());
            }

            // Ensure world objects are consistently generated
            List<WorldObject> objects = ServerGameContext.get().getWorldObjectManager()
                .getObjectsForChunk(MULTIPLAYER_WORLD_NAME, chunkPos);
            if (objects == null || objects.isEmpty()) {
                objects = ServerGameContext.get().getWorldObjectManager()
                    .generateObjectsForChunk(MULTIPLAYER_WORLD_NAME, chunkPos, chunk);
                GameLogger.info("Generated " + objects.size() + " objects for chunk " + chunkPos);
            }

            // Build comprehensive chunk data with all necessary information
            NetworkProtocol.ChunkData chunkData = new NetworkProtocol.ChunkData();
            chunkData.chunkX = request.chunkX;
            chunkData.chunkY = request.chunkY;

            // CRITICAL FIX: Always provide biome information from the chunk
            chunkData.primaryBiomeType = chunk.getBiome().getType();

            // Include complete biome transition data for visual consistency
            if (transition != null && transition.getSecondaryBiome() != null) {
                chunkData.secondaryBiomeType = transition.getSecondaryBiome().getType();
                chunkData.biomeTransitionFactor = transition.getTransitionFactor();
            } else {
                chunkData.secondaryBiomeType = null;
                chunkData.biomeTransitionFactor = 1.0f;
            }

            chunkData.tileData = chunk.getTileData().clone(); // Send a clone to prevent modifications
            chunkData.blockData = chunk.getBlockDataForSave();

            // IMPORTANT: Save the deterministic seed with the chunk data
            chunkData.generationSeed = chunkSeed;
            chunkData.timestamp = System.currentTimeMillis();

            // Include all world objects with complete data
            chunkData.worldObjects = new ArrayList<>();
            if (objects != null) {
                for (WorldObject obj : objects) {
                    if (obj != null) {
                        Map<String, Object> objData = obj.getSerializableData();
                        if (objData != null) {
                            chunkData.worldObjects.add(new HashMap<>(objData));
                        }
                    }
                }
            }

            // Compress and send
            NetworkProtocol.CompressedChunkData compressed = compressChunkData(chunkData);
            if (compressed == null) {
                GameLogger.error("Failed to compress chunk data for " + chunkPos);
                return;
            }

            // Send to client and log success with detailed information
            connection.sendTCP(compressed);
            GameLogger.info("Sent chunk " + chunkPos + " to client with " +
                (objects != null ? objects.size() : 0) + " objects and biome: " +
                chunkData.primaryBiomeType + (chunkData.secondaryBiomeType != null ?
                " blended with " + chunkData.secondaryBiomeType + " at " +
                    chunkData.biomeTransitionFactor : ""));

        } catch (Exception e) {
            GameLogger.error("Error processing chunk request at " + chunkPos + ": " + e.getMessage());
            e.printStackTrace();
        }
    }
    private void broadcastWorldState() {
        // For each active player, compute personalized weather based on their position.
        for (Map.Entry<String, ServerPlayer> entry : activePlayers.entrySet()) {
            String username = entry.getKey();
            ServerPlayer player = entry.getValue();
            Vector2 pos = player.getPosition(); // player's position in pixels

            // Retrieve the biome transition using the new method in ServerWorldManager.
            BiomeTransitionResult biomeTransition =
                ServerGameContext.get().getWorldManager().getBiomeTransitionAt(pos.x, pos.y);

            // Use global world time for time-of–day.
            double worldTime = worldData.getWorldTimeInMinutes();
            // Compute a temperature based on the primary biome.
            float temperature = computeTemperatureForBiome(biomeTransition.getPrimaryBiome().getType());

            // Decide weather based on the primary biome type.
            WeatherSystem.WeatherType weatherType;
            float intensity;
            float rand = MathUtils.random();
            switch (biomeTransition.getPrimaryBiome().getType()) {
                case RAIN_FOREST:
                    if (rand < 0.75f) {
                        weatherType = WeatherSystem.WeatherType.HEAVY_RAIN;
                        intensity = 0.8f;
                    } else {
                        weatherType = WeatherSystem.WeatherType.RAIN;
                        intensity = 0.6f;
                    }
                    break;
                case HAUNTED:
                    if (worldTime >= 18 || worldTime < 6) {
                        if (rand < 0.7f) {
                            weatherType = WeatherSystem.WeatherType.FOG;
                            intensity = 0.8f;
                        } else {
                            weatherType = WeatherSystem.WeatherType.THUNDERSTORM;
                            intensity = 0.9f;
                        }
                    } else {
                        if (rand < 0.5f) {
                            weatherType = WeatherSystem.WeatherType.FOG;
                            intensity = 0.6f;
                        } else {
                            weatherType = WeatherSystem.WeatherType.THUNDERSTORM;
                            intensity = 0.7f;
                        }
                    }
                    break;
                case SNOW:
                    if (temperature < 0) {
                        weatherType = WeatherSystem.WeatherType.BLIZZARD;
                        intensity = 0.7f;
                    } else {
                        weatherType = WeatherSystem.WeatherType.SNOW;
                        intensity = 0.5f;
                    }
                    break;
                case DESERT:
                    if (temperature > 35 && rand < 0.4f) {
                        weatherType = WeatherSystem.WeatherType.SANDSTORM;
                        intensity = 0.7f;
                    } else {
                        // Clear (sunny) conditions for desert when not stormy.
                        weatherType = WeatherSystem.WeatherType.CLEAR;
                        intensity = 0f;
                    }
                    break;
                case PLAINS:
                case BEACH:
                    // For these biomes, use clear (sunny) weather.
                    weatherType = WeatherSystem.WeatherType.CLEAR;
                    intensity = 0f;
                    break;
                case FOREST:
                    if (rand < 0.4f) {
                        weatherType = WeatherSystem.WeatherType.RAIN;
                        intensity = 0.4f;
                    } else {
                        weatherType = WeatherSystem.WeatherType.CLEAR;
                        intensity = 0f;
                    }
                    break;
                default:
                    weatherType = WeatherSystem.WeatherType.CLEAR;
                    intensity = 0f;
                    break;
            }

            // Compute accumulation (for clear weather, accumulation is 0).
            float accumulation;
            if (weatherType == WeatherSystem.WeatherType.SNOW || weatherType == WeatherSystem.WeatherType.BLIZZARD) {
                accumulation = 0.1f * intensity;
            } else if (weatherType == WeatherSystem.WeatherType.RAIN) {
                accumulation = 0.05f * intensity;
            } else if (weatherType == WeatherSystem.WeatherType.HEAVY_RAIN || weatherType == WeatherSystem.WeatherType.THUNDERSTORM) {
                accumulation = 0.15f * intensity;
            } else {
                accumulation = 0f;
            }

            // Build the personalized world state update message.
            NetworkProtocol.WorldStateUpdate update = new NetworkProtocol.WorldStateUpdate();
            update.seed = worldData.getConfig().getSeed();
            update.worldTimeInMinutes = worldData.getWorldTimeInMinutes();
            update.dayLength = worldData.getDayLength();
            update.currentWeather = weatherType;
            update.intensity = intensity;
            update.accumulation = accumulation;
            update.timestamp = System.currentTimeMillis();

            // Send the update only to the connection associated with this player.
            for (Connection conn : networkServer.getConnections()) {
                if (username.equals(connectedPlayers.get(conn.getID()))) {
                    conn.sendTCP(update);
                    break;
                }
            }
        }
    }

    /**
     * Example helper that computes a temperature (in °C) based on a given biome type.
     */
    private float computeTemperatureForBiome(BiomeType type) {
        switch (type) {
            case SNOW:
                return 0f;
            case DESERT:
                return 40f;
            case HAUNTED:
                return 15f;
            case RAIN_FOREST:
                return 28f;
            case FOREST:
                return 22f;
            case PLAINS:
                return 25f;
            case BEACH:
                return 30f;
            default:
                return 20f;
        }
    }

    private NetworkProtocol.CompressedChunkData compressChunkData(NetworkProtocol.ChunkData chunkData) {
        try {
            // Serialize ChunkData to an uncompressed byte array using Kryo.
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int initialBufferSize = 16 * 1024;   // 16 KB
            int maxBufferSize = 256 * 1024;        // 256 KB
            Output output = new Output(initialBufferSize, maxBufferSize);
            output.setOutputStream(baos);

            Kryo kryo = new Kryo();
            // Register all classes exactly as on the client!
            NetworkProtocol.registerClasses(kryo);
            kryo.setReferences(false);
            kryo.writeObject(output, chunkData);
            output.close();
            byte[] uncompressedData = baos.toByteArray();

            // Compress the uncompressed data using LZ4.
            LZ4Factory factory = LZ4Factory.fastestInstance();
            LZ4Compressor compressor = factory.fastCompressor();
            int maxCompressedLength = compressor.maxCompressedLength(uncompressedData.length);
            byte[] compressedBuffer = new byte[maxCompressedLength];
            int compressedLength = compressor.compress(uncompressedData, 0, uncompressedData.length,
                compressedBuffer, 0, maxCompressedLength);
            byte[] finalCompressedData = Arrays.copyOf(compressedBuffer, compressedLength);

            // Build the compressed chunk message.
            NetworkProtocol.CompressedChunkData compressed = new NetworkProtocol.CompressedChunkData();
            compressed.chunkX = chunkData.chunkX;
            compressed.chunkY = chunkData.chunkY;
            compressed.primaryBiomeType = chunkData.primaryBiomeType;
            compressed.secondaryBiomeType = chunkData.secondaryBiomeType; // may be null
            compressed.biomeTransitionFactor = chunkData.biomeTransitionFactor; // may be 0
            compressed.generationSeed = worldData.getConfig().getSeed();
            // Save the original (uncompressed) length.
            compressed.originalLength = uncompressedData.length;
            compressed.data = finalCompressedData;
            return compressed;
        } catch (Exception e) {
            GameLogger.error("Chunk compression failed: " + e.getMessage());
            return null;
        }
    }


    private void setupNetworkListener() {
        networkServer.addListener(new Listener() {
            @Override
            public void connected(Connection connection) {
                try {
                    GameLogger.info("New connection attempt from: " + connection.getRemoteAddressTCP());
                    // Check max players
                    if (playerManager.getOnlinePlayers().size() >= config.getMaxPlayers()) {
                        GameLogger.info("Connection rejected: Max players reached");
                        sendConnectionResponse(connection, false, "Server is full");
                        scheduler.schedule(() -> connection.close(), 100, TimeUnit.MILLISECONDS);
                        return;
                    }

                    // Send success response
                    NetworkProtocol.ConnectionResponse response = new NetworkProtocol.ConnectionResponse();
                    response.success = true;
                    response.message = "Connection established";
                    connection.sendTCP(response);

                    GameLogger.info("Connection " + connection.getID() + " established - awaiting authentication");

                    // Set authentication timeout
                    scheduler.schedule(() -> {
                        if (!connectedPlayers.containsKey(connection.getID())) {
                            GameLogger.info("Authentication timeout for connection: " + connection.getID());
                            connection.close();
                        }
                    }, AUTH_TIMEOUT, TimeUnit.MILLISECONDS);

                } catch (Exception e) {
                    GameLogger.error("Error handling connection: " + e.getMessage());
                    connection.close();
                }
            }

            @Override
            public void received(Connection connection, Object object) {
                try {
                    if (object instanceof FrameworkMessage) {
                        // Ignore KryoNet's internal messages
                        return;
                    }

                    if (object instanceof NetworkProtocol.WorldObjectUpdate) {
                        handleWorldObjectUpdate(connection, (NetworkProtocol.WorldObjectUpdate) object);
                        return;
                    }


                    if (object instanceof NetworkProtocol.LoginRequest) {
                        handleLoginRequest(connection, (NetworkProtocol.LoginRequest) object);
                        return;
                    }

                    if (object instanceof NetworkProtocol.RegisterRequest) {
                        handleRegisterRequest(connection, (NetworkProtocol.RegisterRequest) object);
                        return;
                    }

                    if (object instanceof NetworkProtocol.ChunkRequest) {
                        handleChunkRequest(connection, (NetworkProtocol.ChunkRequest) object);
                        return;
                    }
                    if (object instanceof NetworkProtocol.BlockPlacement) {
                        handleBlockPlacement(connection, (NetworkProtocol.BlockPlacement) object);
                    }
                    if (object instanceof NetworkProtocol.ItemDrop) {
                        handleItemDrop(connection, (NetworkProtocol.ItemDrop) object);
                        return;
                    }
                    if (object instanceof NetworkProtocol.BuildingPlacement) {
                        handleBuildingPlacement(connection, (NetworkProtocol.BuildingPlacement) object);
                    }
                    if (object instanceof NetworkProtocol.ChestUpdate) {
                        handleChestUpdate(connection, (NetworkProtocol.ChestUpdate) object);
                        return;
                    }
                    if (object instanceof NetworkProtocol.ItemPickup) {
                        handleItemPickup(connection, (NetworkProtocol.ItemPickup) object);
                        return;
                    }
                    if (object instanceof NetworkProtocol.PlayerInfoUpdate) {
                        NetworkProtocol.PlayerInfoUpdate update = (NetworkProtocol.PlayerInfoUpdate) object;
                        playerPingMap.put(update.username, update.ping);
                        broadcastPlayerList();
                    }

                    if (object instanceof NetworkProtocol.PingRequest) {
                        NetworkProtocol.PingRequest pingRequest = (NetworkProtocol.PingRequest) object;
                        NetworkProtocol.PingResponse pingResponse = new NetworkProtocol.PingResponse();
                        pingResponse.timestamp = pingRequest.timestamp; // echo back the timestamp
                        connection.sendTCP(pingResponse);
                        return;
                    }

                    if (object instanceof NetworkProtocol.SavePlayerDataRequest) {
                        NetworkProtocol.SavePlayerDataRequest saveRequest =
                            (NetworkProtocol.SavePlayerDataRequest) object;

                        try {
                            ServerGameContext.get().getStorageSystem()
                                .savePlayerData(saveRequest.playerData.getUsername(), saveRequest.playerData);

                            ServerGameContext.get().getStorageSystem().getPlayerDataManager().flush();


                        } catch (Exception e) {
                            GameLogger.error("Failed to save player data: " + e.getMessage());
                        }
                    }

                    String username = connectedPlayers.get(connection.getID());
                    if (username == null) {
                        GameLogger.error("Received unauthorized message from Connection " + connection.getID());
                        return;
                    }

                    processAuthenticatedMessage(connection, object);
                } catch (Exception e) {
                    GameLogger.error("Error handling message: " + e.getMessage());
                }
            }

            @Override
            public void disconnected(Connection connection) {
                handleDisconnect(connection);
            }
        });
    }

    private void broadcastPlayerList() {
        NetworkProtocol.PlayerList list = new NetworkProtocol.PlayerList();
        List<NetworkProtocol.PlayerInfo> infos = new ArrayList<>();
        for (Map.Entry<String, Integer> entry : playerPingMap.entrySet()) {
            NetworkProtocol.PlayerInfo info = new NetworkProtocol.PlayerInfo();
            info.username = entry.getKey();
            info.ping = entry.getValue();
            infos.add(info);
        }
        list.players = infos;
        networkServer.sendToAllTCP(list);
    }

    private void handleItemPickup(Connection connection, NetworkProtocol.ItemPickup pickup) {
        // Validate the message
        if (pickup == null || pickup.entityId == null) {
            GameLogger.error("Received invalid ItemPickup message.");
            return;
        }

        // Validate that the sender’s username matches the connection.
        String sender = connectedPlayers.get(connection.getID());
        if (sender == null || !sender.equals(pickup.username)) {
            GameLogger.error("Item pickup username mismatch: expected " + sender + " but got " + pickup.username);
            return;
        }

        // Retrieve the item entity from the server’s item entity manager.
        // (Assuming ServerGameContext.get().getItemEntityManager() exists.)
        ItemEntity itemEntity = ServerGameContext.get().getItemEntityManager().getItemEntity(pickup.entityId);
        if (itemEntity == null) {
            GameLogger.error("Item entity not found for pickup: " + pickup.entityId);
            return;
        }

        // Remove the item from the server state.
        ServerGameContext.get().getItemEntityManager().removeItemEntity(pickup.entityId);
        GameLogger.info("Item " + pickup.entityId + " picked up by " + pickup.username);

        // Optionally: update the player's inventory on the server side here.
        // For example, retrieve the ServerPlayer for pickup.username and add itemEntity.getItemData() to their inventory.
        // (This depends on how you want to handle authoritative inventory data on the server.)

        // Broadcast the pickup to all other clients so they remove the item.
        networkServer.sendToAllExceptTCP(connection.getID(), pickup);
    }

    private void handleChestUpdate(Connection connection, NetworkProtocol.ChestUpdate update) {
        // (1) Verify that the sender is authorized.
        String username = connectedPlayers.get(connection.getID());
        if (username == null || !username.equals(update.username)) {
            GameLogger.error("Unauthorized chest update from " + update.username);
            return;
        }

        // (2) Find the chest position using a helper (for example, scanning placed blocks)
        Vector2 chestPos = findChestPositionInPlacedBlocks(update.chestId);
        if (chestPos == null) {
            GameLogger.error("Could not find chest position for chestId = " + update.chestId);
            return;
        }

        // (3) Determine the chunk coordinates and force–load that chunk.
        int chunkX = chestPos.x >= 0 ? (int) (chestPos.x / World.CHUNK_SIZE)
            : Math.floorDiv((int) chestPos.x, World.CHUNK_SIZE);
        int chunkY = chestPos.y >= 0 ? (int) (chestPos.y / World.CHUNK_SIZE)
            : Math.floorDiv((int) chestPos.y, World.CHUNK_SIZE);
        Chunk chunk = ServerGameContext.get().getWorldManager().loadChunk("multiplayer_world", chunkX, chunkY);

        // (4) Get the chest block from the server’s block manager.
        PlaceableBlock chestBlock = ServerGameContext.get().getServerBlockManager().getChestBlock(update.chestId);
        if (chestBlock == null) {
            GameLogger.error("Chest block with id " + update.chestId + " not found even after loading chunk");
            return;
        }

        // (5) Synchronize updates on a per–chest lock so that concurrent updates won’t conflict.
        Object lock = chestLocks.computeIfAbsent(update.chestId, id -> new Object());
        synchronized (lock) {
            // Retrieve the current chest data; if none exists, create one.
            ChestData currentChest = chestBlock.getChestData();
            if (currentChest == null) {
                currentChest = new ChestData((int) chestPos.x, (int) chestPos.y);
                chestBlock.setChestData(currentChest);
            }

            // **** FIX: Update the chest data in place (do not create a separate copy)
            currentChest.setItems(new ArrayList<>(update.items));


            // Optionally, if you have other state (like “isOpen”) you might update that too.

            // (6) Mark the chunk as dirty and force–save it so that the updated chest data is persisted.
            chunk.setDirty(true);
            ServerGameContext.get().getWorldManager().saveChunk(MULTIPLAYER_WORLD_NAME, chunk);

            // (7) Broadcast the chest update to all connected clients.
            networkServer.sendToAllTCP(update);
            GameLogger.info("Processed chest update for chestId " + update.chestId + " from " + update.username);
        }
    }

    private Vector2 findChestPositionInPlacedBlocks(UUID chestId) {
        for (Map.Entry<Vector2, PlaceableBlock> entry :
            ServerGameContext.get().getServerBlockManager().getPlacedBlocks().entrySet()) {
            PlaceableBlock block = entry.getValue();
            if (block.getType() == PlaceableBlock.BlockType.CHEST) {
                ChestData cd = block.getChestData();
                if (cd != null && cd.chestId.equals(chestId)) {
                    return entry.getKey();
                }
            }
        }
        return null;
    }

    private void handleBuildingPlacement(Connection connection, NetworkProtocol.BuildingPlacement bp) {
        // Validate that the sender’s username matches the connection
        String username = connectedPlayers.get(connection.getID());
        if (username == null || !username.equals(bp.username)) {
            GameLogger.error("Unauthorized building placement attempt by " + bp.username);
            return;
        }

        // Loop over the layout and place each block.
        for (int x = 0; x < bp.width; x++) {
            for (int y = 0; y < bp.height; y++) {
                String typeId = bp.blockTypeIds[x][y];
                boolean isFlipped = bp.flippedFlags[x][y];
                if (typeId == null || typeId.isEmpty()) continue;
                PlaceableBlock.BlockType type = PlaceableBlock.BlockType.fromItemId(typeId);
                int tileX = bp.startX + x;
                int tileY = bp.startY + y;
                boolean placed = ServerGameContext.get().getServerBlockManager().placeBlock(type, tileX, tileY, isFlipped);
                if (!placed) {
                    GameLogger.error("Failed to place block at (" + tileX + "," + tileY + ") of type " + type);
                    return;
                }
            }
        }

        // (Optionally mark affected chunks as dirty, etc.)

        // Broadcast the building placement to all other clients
        networkServer.sendToAllExceptTCP(connection.getID(), bp);
        GameLogger.info("Building placement by " + bp.username + " placed at (" + bp.startX + "," + bp.startY + ")");
    }

    private void initializePeriodicTasks() {
        scheduler.scheduleAtFixedRate(() -> {
            try {
                if (worldData != null) {
                    ServerGameContext.get().getWorldManager().saveWorld(worldData);
                    GameLogger.info("World data saved periodically.");
                }
            } catch (Exception e) {
                GameLogger.error("Error during periodic world save: " + e.getMessage());
            }
        }, SAVE_INTERVAL, SAVE_INTERVAL, TimeUnit.MILLISECONDS);
    }

    private void sendConnectionResponse(Connection connection, boolean success, String message) {
        NetworkProtocol.ConnectionResponse response = new NetworkProtocol.ConnectionResponse();
        response.success = success;
        response.message = message;

        try {
            connection.sendTCP(response);
        } catch (Exception e) {
            GameLogger.error("Error sending connection response: " + e.getMessage());
        }
    }

    private void handleChatMessage(Connection connection, NetworkProtocol.ChatMessage message) {
        if (message == null || message.content == null) return;
        if (message.timestamp == 0) {
            message.timestamp = System.currentTimeMillis();
        }
        GameLogger.info("Server broadcasting chat message from " + message.sender + ": " + message.content);
        networkServer.sendToAllTCP(message);
    }

    private void sendRegistrationResponse(Connection connection, boolean success, String message) {
        NetworkProtocol.RegisterResponse response = new NetworkProtocol.RegisterResponse();
        response.success = success;
        response.message = message;
        networkServer.sendToTCP(connection.getID(), response);
    }

    private boolean isValidUsername(String username) {
        return username != null &&
            username.length() >= 3 &&
            username.length() <= 20 &&
            username.matches("^[a-zA-Z0-9_]+$");
    }

    private void handleRegisterRequest(Connection connection, NetworkProtocol.RegisterRequest request) {
        try {
            GameLogger.info("Processing registration request for username: " + request.username);

            // Basic validation
            if (request.username == null || request.username.isEmpty() ||
                request.password == null || request.password.isEmpty()) {
                sendRegistrationResponse(connection, false, "Username and password are required.");
                return;
            }
            if (!isValidUsername(request.username)) {
                sendRegistrationResponse(connection, false,
                    "Username must be 3-20 characters long and contain only letters, numbers, and underscores.");
                return;
            }

            // Check if username already exists
            if (databaseManager.checkUsernameExists(request.username)) {
                sendRegistrationResponse(connection, false, "Username already exists.");
                return;
            }

            // Attempt to register the player in database
            boolean success = databaseManager.registerPlayer(request.username, request.password);

            if (success) {
                GameLogger.info("Successfully registered new player: " + request.username);
                sendRegistrationResponse(connection, true, "Registration successful!");
            } else {
                GameLogger.error("Failed to register player: " + request.username);
                sendRegistrationResponse(connection, false, "Registration failed. Please try again.");
            }

        } catch (Exception e) {
            GameLogger.error("Error during registration: " + e.getMessage());
            sendRegistrationResponse(connection, false, "An error occurred during registration.");
        }
    }

    public void start() {
        try {
            GameLogger.info("Starting server...");

            if (!isPortAvailable(config.getTcpPort())) {
                throw new IOException("TCP port " + config.getTcpPort() + " is already in use.");
            }

            if (!isPortAvailable(config.getUdpPort())) {
                throw new IOException("UDP port " + config.getUdpPort() + " is already in use.");
            }

            GameLogger.info("Storage system initialized");

            GameLogger.info("World manager initialized");
            initializePeriodicTasks();
            // Load plugins
            pluginManager.loadPlugins();
            pluginManager.enablePlugins();
            GameLogger.info("Plugins loaded");

            NetworkProtocol.registerClasses(networkServer.getKryo());
            GameLogger.info("Network classes registered");

            networkServer.start();

            networkServer.bind(config.getTcpPort(), config.getUdpPort());
            running = true;

            GameLogger.info("Server started successfully on TCP port " + config.getTcpPort() +
                " and UDP port " + config.getUdpPort());
            GameLogger.info("Maximum players: " + config.getMaxPlayers());

        } catch (Exception e) {
            GameLogger.info("Failed to start server: " + e.getMessage());
            e.printStackTrace();
            throw new RuntimeException("Server failed to start", e);
        }
    }

    private boolean isPortAvailable(int port) {
        try (ServerSocket ss = new ServerSocket(port)) {
            ss.setReuseAddress(true);
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    private void processAuthenticatedMessage(Connection connection, Object message) {
        String username = connectedPlayers.get(connection.getID());
        if (username == null) {
            GameLogger.error("Received message from non-authenticated connection: " + connection.getID());
            return;
        }

        ServerPlayer player = activePlayers.get(username);
        if (player == null) {
            GameLogger.error("No player instance found for authenticated user: " + username);
            // Attempt to recover
            PlayerData savedData = ServerGameContext.get().getStorageSystem().getPlayerDataManager().loadPlayerData(UUID.nameUUIDFromBytes(username.getBytes()));
            if (savedData != null) {
                player = new ServerPlayer(username, savedData);
                activePlayers.put(username, player);
                GameLogger.info("Recovered player instance for: " + username);
            } else {
                connection.close(); // Force disconnect if unrecoverable
                return;
            }
        }

        try {
            if (message instanceof NetworkProtocol.PlayerUpdate) {
                handlePlayerUpdate(connection, (NetworkProtocol.PlayerUpdate) message);
            } else if (message instanceof NetworkProtocol.ChatMessage) {
                handleChatMessage(connection, (NetworkProtocol.ChatMessage) message);
            } else if (message instanceof NetworkProtocol.PlayerAction) {
                handlePlayerAction(connection, (NetworkProtocol.PlayerAction) message);
            }
        } catch (Exception e) {
            GameLogger.error("Error processing message for " + username + ": " + e.getMessage());
        }

    }

    public void sendActivePokemonToConnection(Connection connection) {
        List<NetworkProtocol.PokemonUpdate> updates = new ArrayList<>();
        for (WildPokemon pokemon : serverPokemonSpawnManager.getActivePokemon()) {
            NetworkProtocol.PokemonUpdate update = new NetworkProtocol.PokemonUpdate();
            update.uuid = pokemon.getUuid();
            update.x = pokemon.getX();
            update.y = pokemon.getY();
            update.direction = pokemon.getDirection();
            update.isMoving = pokemon.isMoving();
            update.level = pokemon.getLevel();
            update.timestamp = System.currentTimeMillis();
            updates.add(update);
        }
        if (!updates.isEmpty()) {
            NetworkProtocol.PokemonBatchUpdate batchUpdate = new NetworkProtocol.PokemonBatchUpdate();
            batchUpdate.updates = updates;
            connection.sendTCP(batchUpdate);
        }
    }

    private void handlePlayerAction(Connection connection, NetworkProtocol.PlayerAction action) {
        if (action == null || action.playerId == null) {
            GameLogger.error("Invalid player action received");
            return;
        }

        ServerPlayer player = activePlayers.get(action.playerId);
        if (player == null) {
            GameLogger.error("No player found for action: " + action.playerId);
            return;
        }

        switch (action.actionType) {
            case CHOP_START:
            case PUNCH_START:
                // Find a choppable world object (e.g. a tree) near the player.
                WorldObject targetObject = findServerChoppableObject(player, action.direction);
                if (targetObject != null) {
                    // Save the target object in the player’s state
                    player.setChoppingObject(targetObject);
                    GameLogger.info("Player " + action.playerId + " started chopping/punching object: " +
                        targetObject.getId() + " at (" + targetObject.getTileX() + "," +
                        targetObject.getTileY() + ")");
                } else {
                    GameLogger.error("No choppable object found near player " + action.playerId);
                }
                // Broadcast the start action to all clients (including the sender)
                networkServer.sendToAllTCP(action);
                break;

            case CHOP_STOP:
            case PUNCH_STOP:
                WorldObject choppedObject = player.getChoppingObject();
                if (choppedObject != null) {
                    Vector2 chunkPos = new Vector2(
                        (int) Math.floor(choppedObject.getPixelX() / (World.CHUNK_SIZE * World.TILE_SIZE)),
                        (int) Math.floor(choppedObject.getPixelY() / (World.CHUNK_SIZE * World.TILE_SIZE))
                    );
                    // Remove the object from the server’s world–object manager.
                    ServerGameContext.get().getWorldObjectManager().removeObject(MULTIPLAYER_WORLD_NAME, chunkPos, choppedObject.getId());
                    NetworkProtocol.WorldObjectUpdate removalUpdate = new NetworkProtocol.WorldObjectUpdate();
                    removalUpdate.objectId = choppedObject.getId();
                    removalUpdate.type = NetworkProtocol.NetworkObjectUpdateType.REMOVE;
                    removalUpdate.data = choppedObject.getSerializableData();
                    // Reinsert the raw tile coordinates so the client computes the correct chunk:
                    removalUpdate.data.put("tileX", choppedObject.getTileX());
                    removalUpdate.data.put("tileY", choppedObject.getTileY());
                    networkServer.sendToAllTCP(removalUpdate);
                    player.setChoppingObject(null);
                }
                // Broadcast the stop action to all clients so that remote players can stop the animation.
                networkServer.sendToAllTCP(action);
                break;

            default:
                GameLogger.error("Unhandled player action type: " + action.actionType);
                break;
        }
    }

    private void handleWorldObjectUpdate(Connection connection, NetworkProtocol.WorldObjectUpdate update) {
        // Ensure that only authenticated users can send updates.
        String username = connectedPlayers.get(connection.getID());
        if (username == null) {
            GameLogger.error("WorldObjectUpdate received from unauthenticated connection.");
            return;
        }

        switch (update.type) {
            case REMOVE:
                // Instead of checking for "x" and "y", check for "tileX" and "tileY".
                if (update.data == null || !update.data.containsKey("tileX") || !update.data.containsKey("tileY")) {
                    GameLogger.error("WorldObjectUpdate REMOVE missing tile position data.");
                    return;
                }

                float tileX, tileY;
                try {
                    tileX = Float.parseFloat(update.data.get("tileX").toString());
                    tileY = Float.parseFloat(update.data.get("tileY").toString());
                } catch (Exception e) {
                    GameLogger.error("Error parsing world object tile position: " + e.getMessage());
                    return;
                }
                // Convert tile coordinates to pixel coordinates.
                float x = tileX * World.TILE_SIZE;
                float y = tileY * World.TILE_SIZE;

                // Compute which chunk this object belongs to.
                int chunkX = (int) Math.floor(x / (World.TILE_SIZE * Chunk.CHUNK_SIZE));
                int chunkY = (int) Math.floor(y / (World.TILE_SIZE * Chunk.CHUNK_SIZE));
                Vector2 chunkPos = new Vector2(chunkX, chunkY);

                // Remove the object from the server’s world–object manager.
                ServerGameContext.get().getWorldObjectManager().removeObject(MULTIPLAYER_WORLD_NAME, chunkPos, update.objectId);
                GameLogger.info("Removed world object " + update.objectId + " from chunk " + chunkPos);

                // Mark the corresponding chunk as dirty and save it so that the change is persisted.
                Chunk chunk = ServerGameContext.get().getWorldManager().loadChunk(MULTIPLAYER_WORLD_NAME, chunkX, chunkY);
                if (chunk != null) {
                    chunk.setDirty(true);
                    ServerGameContext.get().getWorldManager().saveChunk(MULTIPLAYER_WORLD_NAME, chunk);
                }

                // Broadcast the removal update to all connected clients.
                networkServer.sendToAllTCP(update);
                break;

            case ADD:
                // (Handle object addition if needed.)
                break;

            case UPDATE:
                // (Handle object update if needed.)
                break;

            default:
                GameLogger.error("Unknown world object update type: " + update.type);
                break;
        }
    }

    public Server getNetworkServer() {
        return networkServer;
    }

    /**
     * Returns the first WorldObject that is choppable and whose bounding box
     * overlaps a search rectangle in front of the player.
     * <p>
     * This version uses the player's current pixel position and computes a target
     * point based on the chop direction. It then constructs a search rectangle (2×tile size)
     * centered at that target and searches current and adjacent chunks for a matching object.
     *
     * @param player    The ServerPlayer performing the chop action.
     * @param direction The chop direction (e.g. "up", "down", "left", or "right")
     * @return A choppable WorldObject if found; otherwise null.
     */
    private WorldObject findServerChoppableObject(ServerPlayer player, String direction) {
        // Use the player's current position in pixels.
        Vector2 playerPos = player.getPosition();

        // Calculate target point by offsetting the player's position.
        float searchDistance = TILE_SIZE * 1.5f;
        float targetX = playerPos.x;
        float targetY = playerPos.y;

        switch (direction.toLowerCase()) {
            case "up":
                targetY += searchDistance;
                break;
            case "down":
                targetY -= searchDistance;
                break;
            case "left":
                targetX -= searchDistance;
                break;
            case "right":
                targetX += searchDistance;
                break;
            default:
                GameLogger.error("Unknown chopping direction: " + direction);
                return null;
        }

        // Create a search rectangle centered at the target position.
        // Here the rectangle is 2 tiles wide and 2 tiles high.
        Rectangle searchArea = new Rectangle(targetX - TILE_SIZE, targetY - TILE_SIZE, TILE_SIZE * 2, TILE_SIZE * 2);
        GameLogger.info("Chop search area: x=" + searchArea.x + " y=" + searchArea.y +
            " width=" + searchArea.width + " height=" + searchArea.height);

        // Determine chunk coordinates based on the target position.
        int chunkX = (int) Math.floor(targetX / (TILE_SIZE * CHUNK_SIZE));
        int chunkY = (int) Math.floor(targetY / (TILE_SIZE * CHUNK_SIZE));

        // Search the current chunk and adjacent chunks.
        for (int dx = -1; dx <= 1; dx++) {
            for (int dy = -1; dy <= 1; dy++) {
                Vector2 searchChunkPos = new Vector2(chunkX + dx, chunkY + dy);
                List<WorldObject> objects = ServerGameContext.get()
                    .getWorldObjectManager()
                    .getObjectsForChunk(MULTIPLAYER_WORLD_NAME, searchChunkPos);
                if (objects == null || objects.isEmpty()) {
                    GameLogger.error("No objects found in chunk " + searchChunkPos);
                    continue;
                }
                for (WorldObject obj : objects) {
                    if (isChoppable(obj.getType())) {
                        // Use the object's bounding box (which is already defined for collision)
                        Rectangle objBounds = obj.getBoundingBox();
                        if (objBounds.overlaps(searchArea)) {
                            GameLogger.info("Found choppable object: " + obj.getType() +
                                " (ID: " + obj.getId() + ") in chunk " + searchChunkPos);
                            return obj;
                        }
                    }
                }
            }
        }

        GameLogger.info("No choppable objects found in search area: " + searchArea);
        return null;
    }


    private void handlePokeballSpawning(Vector2 chunkPos, Chunk chunk) {
        try {
            List<WorldObject> chunkObjects = worldData.getChunkObjects().computeIfAbsent(chunkPos, k -> new ArrayList<>());

            // Count existing pokeballs
            long pokeballCount = chunkObjects.stream()
                .filter(obj -> obj.getType() == WorldObject.ObjectType.POKEBALL)
                .count();
            Random random = new Random();
            // Check if we can spawn a new pokeball
            if (pokeballCount < MAX_POKEBALLS_PER_CHUNK && random.nextFloat() < POKEBALL_SPAWN_CHANCE) {
                // Find valid spawn location
                int attempts = 10;
                while (attempts > 0) {
                    int localX = random.nextInt(Chunk.CHUNK_SIZE);
                    int localY = random.nextInt(Chunk.CHUNK_SIZE);

                    int worldTileX = (int) (chunkPos.x * Chunk.CHUNK_SIZE + localX);
                    int worldTileY = (int) (chunkPos.y * Chunk.CHUNK_SIZE + localY);

                    // Check if location is valid (e.g., on grass or walkable terrain)
                    if (chunk.isPassable(localX, localY)) {
                        // Create new pokeball object
                        WorldObject pokeball = new WorldObject(
                            worldTileX,
                            worldTileY,
                            null, // Server doesn't need texture
                            WorldObject.ObjectType.POKEBALL
                        );

                        // Add to chunk objects
                        chunkObjects.add(pokeball);

                        // Create spawn update
                        NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
                        update.objectId = pokeball.getId();
                        update.type = NetworkProtocol.NetworkObjectUpdateType.ADD;
                        update.data = pokeball.getSerializableData();

                        // Broadcast to all players
                        networkServer.sendToAllTCP(update);

                        GameLogger.info("Spawned pokeball at " + worldTileX + "," + worldTileY);
                        break;
                    }
                    attempts--;
                }
            }
        } catch (Exception e) {
            GameLogger.error("Error handling pokeball spawn: " + e.getMessage());
        }
    }

    private boolean isChoppable(WorldObject.ObjectType type) {
        return type == WorldObject.ObjectType.TREE_0 ||
            type == WorldObject.ObjectType.TREE_1 ||
            type == WorldObject.ObjectType.SNOW_TREE ||
            type == WorldObject.ObjectType.HAUNTED_TREE ||
            type == WorldObject.ObjectType.RAIN_TREE ||
            type == WorldObject.ObjectType.APRICORN_TREE ||
            type == WorldObject.ObjectType.RUINS_TREE ||
            type == WorldObject.ObjectType.CHERRY_TREE;
    }

    private void handleBlockPlacement(Connection connection, NetworkProtocol.BlockPlacement placement) {
        String username = connectedPlayers.get(connection.getID());
        if (username == null || !username.equals(placement.username)) {
            GameLogger.error("Unauthorized block placement attempt by " + placement.username);
            return;
        }

        switch (placement.action) {
            case PLACE:
                // Place the block using our block manager.
                PlaceableBlock.BlockType type = PlaceableBlock.BlockType.fromItemId(placement.blockTypeId);
                boolean placed = ServerGameContext.get().getServerBlockManager().placeBlock(type, placement.tileX, placement.tileY, false);
                if (placed) {
                    // *** NEW CODE: Update the corresponding chunk ***
                    int chunkX = Math.floorDiv(placement.tileX, World.CHUNK_SIZE);
                    int chunkY = Math.floorDiv(placement.tileY, World.CHUNK_SIZE);
                    Chunk chunk = ServerGameContext.get().getWorldManager().loadChunk("multiplayer_world", chunkX, chunkY);
                    if (chunk != null) {
                        // (Assume that blockManager.placeBlock() internally creates and returns the new block.)
                        // If not, then get the block from your block manager’s internal map:
                        Vector2 blockPos = new Vector2(placement.tileX, placement.tileY);
                        PlaceableBlock block = ServerGameContext.get().getServerBlockManager().getBlockAt(blockPos);
                        if (block != null) {
                            chunk.getBlocks().put(blockPos, block);
                            chunk.setDirty(true);
                            ServerGameContext.get().getWorldManager().saveChunk("multiplayer_world", chunk);
                        }
                    }
                    ServerGameContext.get().getEventManager().fireEvent(
                        new BlockPlaceEvent(placement.username, placement.tileX, placement.tileY, placement.blockTypeId)
                    );
                    networkServer.sendToAllExceptTCP(connection.getID(), placement);
                } else {
                    GameLogger.error("Failed to place block at (" + placement.tileX + ", " + placement.tileY + ")");
                }
                break;
            case REMOVE:
                // Remove the block from our world.
                ServerGameContext.get().getServerBlockManager().removeBlock(placement.tileX, placement.tileY);
                // Also update the chunk data.
                int chunkX = Math.floorDiv(placement.tileX, World.CHUNK_SIZE);
                int chunkY = Math.floorDiv(placement.tileY, World.CHUNK_SIZE);
                Chunk chunk = ServerGameContext.get().getWorldManager().loadChunk("multiplayer_world", chunkX, chunkY);
                if (chunk != null) {
                    chunk.getBlocks().remove(new Vector2(placement.tileX, placement.tileY));
                    chunk.setDirty(true);
                    ServerGameContext.get().getWorldManager().saveChunk("multiplayer_world", chunk);
                }
                // Broadcast to other clients.
                networkServer.sendToAllExceptTCP(connection.getID(), placement);
                break;
        }
    }

    private static class ConnectionInfo {
        final int connectionId;
        final long connectionTime;
        volatile boolean isAuthenticated;

        ConnectionInfo(int connectionId) {
            this.connectionId = connectionId;
            this.connectionTime = System.currentTimeMillis();
            this.isAuthenticated = false;
        }
    }

}

================
File: src/main/java/org/discord/plugin/JarPluginLoader.java
================
package org.discord.plugin;

import java.io.File;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.net.URLClassLoader;
import java.net.URL;


public class JarPluginLoader implements PluginLoader {
    @Override
    public boolean canLoad(File file) {
        return file.getName().endsWith(".jar");
    }

    @Override
    public ServerPlugin loadPlugin(File file) throws Exception {
        try (JarFile jarFile = new JarFile(file)) {
            // Get plugin.yml entry
            JarEntry configEntry = jarFile.getJarEntry("plugin.yml");
            if (configEntry == null) {
                throw new Exception("Missing plugin.yml in " + file.getName());
            }

            // Load plugin config
            PluginConfig config = PluginConfig.load(jarFile.getInputStream(configEntry));

            // Create class loader
            URL[] urls = { file.toURI().toURL() };
            try (URLClassLoader classLoader = new URLClassLoader(urls, getClass().getClassLoader())) {
                // Load main class
                Class<?> mainClass = Class.forName(config.getMainClass(), true, classLoader);
                Class<? extends ServerPlugin> pluginClass = mainClass.asSubclass(ServerPlugin.class);

                // Create plugin instance
                ServerPlugin plugin = pluginClass.getDeclaredConstructor().newInstance();
                return plugin;
            }
        }
    }
}

================
File: src/main/java/org/discord/plugin/PluginConfig.java
================
package org.discord.plugin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class PluginConfig {
    private String name;
    private String version;
    private String mainClass;
    private List<String> dependencies;


    public static PluginConfig load(InputStream input) {
        try {
            // Read the content as JSON
            StringBuilder content = new StringBuilder();
            try (Scanner scanner = new Scanner(input)) {
                while (scanner.hasNextLine()) {
                    content.append(scanner.nextLine()).append("\n");
                }
            }

            // Parse JSON to PluginConfig
            Gson gson = new GsonBuilder()
                .setPrettyPrinting()
                .create();

            PluginConfig config = gson.fromJson(content.toString(), PluginConfig.class);

            // Validate required fields
            if (config.name == null || config.name.isEmpty()) {
                throw new IllegalArgumentException("Plugin name is required");
            }
            if (config.mainClass == null || config.mainClass.isEmpty()) {
                throw new IllegalArgumentException("Main class is required");
            }
            if (config.version == null || config.version.isEmpty()) {
                config.version = "1.0.0";
            }
            if (config.dependencies == null) {
                config.dependencies = new ArrayList<>();
            }

            return config;
        } catch (Exception e) {
            throw new RuntimeException("Failed to load plugin config: " + e.getMessage(), e);
        }
    }


    // Getters
    public String getName() { return name; }
    public String getVersion() { return version; }
    public String getMainClass() { return mainClass; }
    public List<String> getDependencies() { return dependencies; }
}

================
File: src/main/java/org/discord/plugin/PluginLoader.java
================
package org.discord.plugin;

import java.io.File;

public interface PluginLoader {
    boolean canLoad(File file);
    ServerPlugin loadPlugin(File file) throws Exception;
}

================
File: src/main/java/org/discord/plugin/ServerPlugin.java
================
package org.discord.plugin;


import io.github.pokemeetup.system.servers.PluginContext;

public interface ServerPlugin {
    String getId();

    void onLoad(PluginContext manager);

    void onEnable();

    void onDisable();
}

================
File: src/main/java/org/discord/PluginManager.java
================
package org.discord;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import org.discord.plugin.PluginConfig;
import org.discord.plugin.ServerPlugin;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.servers.PluginContext;

import java.io.*;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.logging.Logger;

public class PluginManager {
    private static final Logger logger = Logger.getLogger(PluginManager.class.getName());
    private final Map<String, ServerPlugin> loadedPlugins = new ConcurrentHashMap<>();
    private final Map<String, PluginConfig> pluginConfigs = new ConcurrentHashMap<>();
    private final Path pluginsDir;
    private final WorldData gameWorld;

    public PluginManager(WorldData gameWorld) {
        this.gameWorld = gameWorld;
        this.pluginsDir = Paths.get("plugins");
        createPluginDirectory();
    }

    private void createPluginDirectory() {
        try {
            Files.createDirectories(pluginsDir);
        } catch (IOException e) {
            logger.severe("Failed to create plugins directory: " + e.getMessage());
            throw new RuntimeException("Failed to create plugins directory", e);
        }
    }

    public void loadPlugins() {
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(pluginsDir, "*.jar")) {
            for (Path jarPath : stream) {
                loadPlugin(jarPath);
            }
        } catch (IOException e) {
            logger.severe("Error loading plugins: " + e.getMessage());
        }
    }

    private void loadPlugin(Path jarPath) {
        try (JarFile jarFile = new JarFile(jarPath.toFile())) {
            // Load plugin.yml
            JarEntry configEntry = jarFile.getJarEntry("plugin.yml");
            if (configEntry == null) {
                throw new IllegalStateException("Missing plugin.yml in " + jarPath.getFileName());
            }

            // Load and parse config
            PluginConfig config = loadPluginConfig(jarFile.getInputStream(configEntry));

            // Validate dependencies
            validateDependencies(config);

            // Create isolated classloader for plugin
            URLClassLoader classLoader = new URLClassLoader(
                new URL[]{jarPath.toUri().toURL()},
                getClass().getClassLoader()
            );

            // Load main plugin class
            Class<?> mainClass = Class.forName(config.getMainClass(), true, classLoader);
            if (!ServerPlugin.class.isAssignableFrom(mainClass)) {
                throw new IllegalStateException("Plugin main class must implement ServerPlugin interface");
            }

            ServerPlugin plugin = (ServerPlugin) mainClass.getDeclaredConstructor().newInstance();

            // Create plugin context and initialize
            Map<String, Object> pluginConfig = loadPluginConfig(plugin.getId());
            PluginContext context = new PluginContext(gameWorld, pluginConfig);
            plugin.onLoad(context);

            // Store loaded plugin
            loadedPlugins.put(plugin.getId(), plugin);
            pluginConfigs.put(plugin.getId(), config);

            logger.info("Successfully loaded plugin: " + config.getName() + " v" + config.getVersion());

        } catch (Exception e) {
            logger.severe("Failed to load plugin " + jarPath.getFileName() + ": " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void validateDependencies(PluginConfig config) {
        for (String dependency : config.getDependencies()) {
            if (!loadedPlugins.containsKey(dependency)) {
                throw new IllegalStateException("Missing required dependency: " + dependency);
            }
        }
    }

    private PluginConfig loadPluginConfig(InputStream input) {
        try {
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            try (Reader reader = new InputStreamReader(input)) {
                return gson.fromJson(reader, PluginConfig.class);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to load plugin config", e);
        }
    }

    public void enablePlugins() {
        List<String> enableOrder = calculateEnableOrder();
        for (String pluginId : enableOrder) {
            ServerPlugin plugin = loadedPlugins.get(pluginId);
            try {
                plugin.onEnable();
                logger.info("Enabled plugin: " + pluginId);
            } catch (Exception e) {
                logger.severe("Failed to enable plugin " + pluginId + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    private List<String> calculateEnableOrder() {
        // Simple topological sort for dependencies
        Map<String, Set<String>> graph = new HashMap<>();
        for (Map.Entry<String, PluginConfig> entry : pluginConfigs.entrySet()) {
            graph.put(entry.getKey(), new HashSet<>(entry.getValue().getDependencies()));
        }

        List<String> result = new ArrayList<>();
        Set<String> visited = new HashSet<>();

        for (String plugin : graph.keySet()) {
            if (!visited.contains(plugin)) {
                visitPlugin(plugin, graph, visited, new HashSet<>(), result);
            }
        }

        return result;
    }

    private void visitPlugin(String plugin, Map<String, Set<String>> graph,
                             Set<String> visited, Set<String> visiting, List<String> result) {
        visiting.add(plugin);

        Set<String> dependencies = graph.get(plugin) != null ? graph.get(plugin) : new HashSet<>();
        for (String dep : dependencies) {
            if (visiting.contains(dep)) {
                throw new IllegalStateException("Circular dependency detected: " + plugin + " -> " + dep);
            }
            if (!visited.contains(dep)) {
                visitPlugin(dep, graph, visited, visiting, result);
            }
        }

        visiting.remove(plugin);
        visited.add(plugin);
        result.add(plugin);
    }

    public void disablePlugins() {
        List<String> disableOrder = new ArrayList<>(loadedPlugins.keySet());
        Collections.reverse(disableOrder);  // Disable in reverse order

        for (String pluginId : disableOrder) {
            try {
                ServerPlugin plugin = loadedPlugins.get(pluginId);
                plugin.onDisable();
                logger.info("Disabled plugin: " + pluginId);
            } catch (Exception e) {
                logger.severe("Error disabling plugin " + pluginId + ": " + e.getMessage());
            }
        }
        loadedPlugins.clear();
        pluginConfigs.clear();
    }

    // Public API
    public ServerPlugin getPlugin(String id) {
        return loadedPlugins.get(id);
    }

    public Collection<ServerPlugin> getPlugins() {
        return Collections.unmodifiableCollection(loadedPlugins.values());
    }

    public void savePluginConfig(String pluginId, Map<String, Object> config) {
        Path configPath = pluginsDir.resolve(pluginId + ".json");
        try {
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            String json = gson.toJson(config);
            Files.write(configPath, json.getBytes(StandardCharsets.UTF_8));
        } catch (IOException e) {
            logger.severe("Failed to save config for plugin " + pluginId + ": " + e.getMessage());
        }
    }

    public Map<String, Object> loadPluginConfig(String pluginId) {
        Path configPath = pluginsDir.resolve(pluginId + ".json");
        if (!Files.exists(configPath)) {
            ServerPlugin plugin = loadedPlugins.get(pluginId);
            return plugin != null ? new HashMap<>() : new HashMap<>();
        }

        try {
            Gson gson = new GsonBuilder().create();
            byte[] bytes = Files.readAllBytes(configPath);
            String json = new String(bytes, StandardCharsets.UTF_8);
            @SuppressWarnings("unchecked")
            Map<String, Object> config = gson.fromJson(json, Map.class);
            return config != null ? config : new HashMap<>();
        } catch (IOException e) {
            logger.severe("Failed to load config for plugin " + pluginId + ": " + e.getMessage());
            return new HashMap<>();
        }
    }
}

================
File: src/main/java/org/discord/ServerBlockManager.java
================
package org.discord;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import org.discord.context.ServerGameContext;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class ServerBlockManager {
    // Map storing block placements keyed by world tile position.
    private final Map<Vector2, PlaceableBlock> placedBlocks = new ConcurrentHashMap<>();

    /**
     * Places a block at the given tile coordinates.
     * In addition to storing the block in our internal map, we also determine the chunk
     * that covers the tile, add the block to that chunk, and mark the chunk as dirty.
     *
     * @param type      The type of block to place.
     * @param tileX     The world X tile coordinate.
     * @param tileY     The world Y tile coordinate.
     * @param isFlipped Whether the block should be rendered flipped.
     * @return true if placement succeeded; false otherwise.
     */
    public boolean placeBlock(PlaceableBlock.BlockType type, int tileX, int tileY, boolean isFlipped) {
        Vector2 pos = new Vector2(tileX, tileY);
        // Prevent placement if a block already exists at this tile.
        if (placedBlocks.containsKey(pos)) {
            return false;
        }
        // Create the block.
        PlaceableBlock block = new PlaceableBlock(type, pos);
        if (isFlipped) {
            block.toggleFlip();
        }

        // If the block is a chest, initialize its chest data.
        if (type == PlaceableBlock.BlockType.CHEST) {
            // Create a new ChestData for this chest block.
            ChestData chestData = new ChestData(tileX, tileY);
            block.setChestData(chestData);
        }

        placedBlocks.put(pos, block);

        // Now update the chunk data.
        int chunkX = Math.floorDiv(tileX, World.CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, World.CHUNK_SIZE);

        // Here we assume the world name is "multiplayer_world" (adjust as needed).
        Chunk chunk = ServerGameContext.get().getWorldManager().loadChunk("multiplayer_world", chunkX, chunkY);
        if (chunk != null) {
            chunk.addBlock(block);
            chunk.setDirty(true);
        }
        return true;
    }


    /**
     * Returns the block at the given world tile position.
     *
     * @param pos the tile position as a Vector2.
     * @return the PlaceableBlock at that position, or null if none exists.
     */
    public PlaceableBlock getBlockAt(Vector2 pos) {
        return placedBlocks.get(pos);
    }

    /**
     * Returns the block at the given world tile coordinates.
     *
     * @param tileX the world X tile coordinate.
     * @param tileY the world Y tile coordinate.
     * @return the PlaceableBlock at that position, or null if none exists.
     */
    public PlaceableBlock getBlockAt(int tileX, int tileY) {
        return getBlockAt(new Vector2(tileX, tileY));
    }

    public PlaceableBlock getChestBlock(UUID chestId) {
        for (PlaceableBlock block : placedBlocks.values()) {
            if (block.getType() == PlaceableBlock.BlockType.CHEST && block.getChestData() != null) {
                if (block.getChestData().chestId.equals(chestId)) {
                    return block;
                }
            }
        }
        return null;
    }

    /**
     * Removes a block at the specified tile coordinates.
     * Also removes the block from the corresponding chunk and marks the chunk dirty.
     *
     * @param tileX The world X tile coordinate.
     * @param tileY The world Y tile coordinate.
     */
    public void removeBlock(int tileX, int tileY) {
        Vector2 pos = new Vector2(tileX, tileY);
        // If there is no block at the specified position, do nothing.
        if (!placedBlocks.containsKey(pos)) {
            return;
        }
        placedBlocks.remove(pos);

        // Update the corresponding chunk.
        int chunkX = Math.floorDiv(tileX, World.CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, World.CHUNK_SIZE);
        Chunk chunk = ServerGameContext.get().getWorldManager().loadChunk("multiplayer_world", chunkX, chunkY);
        if (chunk != null) {
            chunk.removeBlock(pos);
            chunk.setDirty(true);
        }
    }

    public Map<Vector2, PlaceableBlock> getPlacedBlocks() {
        return placedBlocks;
    }
}

================
File: src/main/java/org/discord/ServerLauncher.java
================
package org.discord;

import com.badlogic.gdx.math.Vector2;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import io.github.pokemeetup.multiplayer.server.ServerStorageSystem;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.multiplayer.server.events.EventManager;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.gameplay.inventory.ItemEntityManager;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.utils.storage.GameFileSystem;
import org.discord.context.ServerGameContext;
import org.discord.files.ServerFileDelegate;
import org.discord.utils.ServerWorldManager;
import org.h2.tools.Server;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.logging.Logger;

import static io.github.pokemeetup.CreatureCaptureGame.MULTIPLAYER_WORLD_NAME;

public class ServerLauncher {
    private static final String DEFAULT_ICON = "server-icon.png";
    private static final String DEFAULT_MOTD = "Basic and default server description fr!";
    private static final Logger logger = Logger.getLogger(ServerLauncher.class.getName());
    private static final Path SERVER_ROOT = Paths.get(".");
    public static ServerStorageSystem storage;

    public static void main(String[] args) {
        Server h2Server = null;
        try {
            // Initialize server deployment
            logger.info("Initializing server deployment...");
            DeploymentHelper.createServerDeployment(SERVER_ROOT);
            logger.info("Server deployment initialized");

            // Initialize file system
            GameFileSystem.getInstance().setDelegate(new ServerFileDelegate());
            logger.info("Server file system initialized");

            // Start H2 Database Server
            h2Server = startH2Server();

            // Load server configuration
            ServerConnectionConfig config = loadServerConfig();
            logger.info("Server configuration loaded");

            // Initialize storage
            storage = new ServerStorageSystem();
            logger.info("Storage system initialized");

            // Initialize world management
            ServerWorldManager serverWorldManager = ServerWorldManager.getInstance(storage);
            logger.info("World manager initialized");

            // Initialize ServerGameContext first!
            ServerWorldObjectManager worldObjectManager = new ServerWorldObjectManager();
            worldObjectManager.initializeWorld(MULTIPLAYER_WORLD_NAME);
            ServerGameContext.init(serverWorldManager, storage, worldObjectManager, new ItemEntityManager(), new ServerBlockManager(), null, new EventManager());
            logger.info("Server game context initialized");

            // In your ServerLauncher (or similar startup routine):
            WorldData worldData = serverWorldManager.loadWorld("multiplayer_world");
            if (worldData == null) {
                logger.info("No existing world; creating new multiplayer world...");
                long seed = System.currentTimeMillis();
                worldData = serverWorldManager.createWorld("multiplayer_world", seed, 0.15f, 0.05f);
            }
            logger.info("World loaded – warming up spawn area chunks");
            generateInitialChunks(serverWorldManager, worldData);



            // Start game server
            GameServer server = new GameServer(config);
            server.start();
            ServerGameContext.get().setGameServer(server);
            logger.info("Game server started successfully");

            // Add shutdown hook
            addShutdownHook(server, h2Server);

        } catch (Exception e) {
            logger.severe("Failed to start server: " + e.getMessage());
            e.printStackTrace();
            if (h2Server != null) {
                h2Server.stop();
            }
            System.exit(1);
        }
    }



    private static void generateInitialChunks(ServerWorldManager serverWorldManager, WorldData worldData) {
        logger.info("Generating initial spawn chunks...");

        // Generate a larger initial area to ensure good transitions
        int radius = 2;  // This gives us a 5x5 area

        // First pass: Generate all chunks
        for (int x = -radius; x <= radius; x++) {
            for (int y = -radius; y <= radius; y++) {
                try {
                    // Load/generate the chunk
                    Chunk chunk = serverWorldManager.loadChunk("multiplayer_world", x, y);
                    if (chunk != null) {
                        // Save immediately to ensure proper object placement
                        serverWorldManager.saveChunk("multiplayer_world", chunk);
                        logger.info(String.format("Generated chunk at (%d, %d)", x, y));
                    }
                } catch (Exception e) {
                    logger.warning(String.format("Failed to generate chunk at (%d, %d): %s", x, y, e.getMessage()));
                }
            }
        }

        // Second pass: Verify all chunks and objects
        for (int x = -radius; x <= radius; x++) {
            for (int y = -radius; y <= radius; y++) {
                Vector2 chunkPos = new Vector2(x, y);
                List<WorldObject> objects = worldData.getChunkObjects().get(chunkPos);
                if (objects != null) {
                    logger.info(String.format("Chunk (%d, %d) contains %d objects", x, y, objects.size()));

                    // Log object positions for debugging
                    for (WorldObject obj : objects) {
                        if (obj != null) {
                            logger.fine(String.format("- %s at (%d,%d)",
                                obj.getType(), obj.getTileX(), obj.getTileY()));
                        }
                    }
                }
            }
        }

        logger.info("Initial spawn chunks generated");

        // Final world save
        serverWorldManager.saveWorld(worldData);
    }

    private static Server startH2Server() throws Exception {
        Server h2Server = Server.createTcpServer(
            "-tcpPort", "9101",
            "-tcpAllowOthers",
            "-ifNotExists",
            "-baseDir", "./data"
        ).start();

        if (h2Server.isRunning(true)) {
            logger.info("H2 Database Server started on port 9101");
        }
        return h2Server;
    }

    private static ServerConnectionConfig loadServerConfig() throws IOException {
        Path configDir = SERVER_ROOT.resolve("config");
        Path configFile = configDir.resolve("server.json");

        try {
            if (!configFile.toFile().exists()) {
                logger.info("Configuration not found, loading defaults");
                return new ServerConnectionConfig(
                    "0.0.0.0",
                    54555,
                    54556,
                    "Pokemon Meetup Server",
                    true,
                    100
                );
            }

            Gson gson = new GsonBuilder()
                .setPrettyPrinting()
                .serializeNulls()
                .create();

            String jsonContent = Files.readString(configFile);
            ServerConnectionConfig config = gson.fromJson(jsonContent, ServerConnectionConfig.class);
            config.setServerIP("0.0.0.0");

            return config;
        } catch (Exception e) {
            Path iconPath = SERVER_ROOT.resolve(DEFAULT_ICON);
            if (!Files.exists(iconPath)) {
                // Copy default icon from resources
                try (InputStream is = ServerLauncher.class.getResourceAsStream("/assets/default-server-icon.png")) {
                    if (is != null) {
                        Files.copy(is, iconPath);
                    }
                }
            }
            logger.warning("Error loading config: " + e.getMessage() + ". Using defaults.");
            ServerConnectionConfig config = new ServerConnectionConfig(
                "0.0.0.0",
                54555,
                54556,
                "Pokemon Meetup Server",
                true,
                100
            );
            config.setMotd(DEFAULT_MOTD);
            config.setIconPath(DEFAULT_ICON);
            return config;
        }
    }
    private static void addShutdownHook(GameServer server, Server h2Server) {
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            logger.info("Shutting down server...");
            try {
                server.shutdown();
                logger.info("Game server stopped");

                storage.shutdown();

                if (h2Server != null) {
                    h2Server.stop();
                    logger.info("Database server stopped");
                }

            } catch (Exception e) {
                logger.severe("Error during shutdown: " + e.getMessage());
            }
        }));
    }
}

================
File: src/main/java/org/discord/ServerWorldObjectManager.java
================
package org.discord;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class ServerWorldObjectManager {

    private final Map<String, Map<Vector2, List<WorldObject>>> worldObjectsByWorld = new ConcurrentHashMap<>();
    private final Map<Vector2, Long> lastChunkAccess = new ConcurrentHashMap<>();

    public void initializeWorld(String worldName) {
        worldObjectsByWorld.putIfAbsent(worldName, new ConcurrentHashMap<>());
    }

    public List<WorldObject> getObjectsForChunk(String worldName, Vector2 chunkPos) {
        Map<Vector2, List<WorldObject>> worldObjects = worldObjectsByWorld.get(worldName);
        if (worldObjects == null) return new ArrayList<>();
        List<WorldObject> objects = worldObjects.get(chunkPos);
        lastChunkAccess.put(chunkPos, System.currentTimeMillis());
        return objects != null ? objects : new ArrayList<>();
    }

    public void removeObject(String worldName, Vector2 chunkPos, String objectId) {
        Map<Vector2, List<WorldObject>> worldObjects = worldObjectsByWorld.get(worldName);
        if (worldObjects == null) return;
        List<WorldObject> objects = worldObjects.get(chunkPos);
        if (objects != null) {
            objects.removeIf(obj -> obj.getId().equals(objectId));
            if (objects.isEmpty()) {
                worldObjects.remove(chunkPos);
            }
            GameLogger.info("Removed object " + objectId + " from chunk " + chunkPos);
        }
    }

    /**
     * Instead of running our own per–tile object placement algorithm,
     * we simply retrieve the world objects that were already generated by UnifiedWorldGenerator.
     */
    public List<WorldObject> generateObjectsForChunk(String worldName, Vector2 chunkPos, Chunk chunk) {
        if (chunk == null) return Collections.emptyList();
        List<WorldObject> objects = chunk.getWorldObjects();
        if (objects == null) {
            objects = new ArrayList<>();
        }
        // Ensure that each object has an ID and its texture is loaded.
        for (WorldObject obj : objects) {
            if (obj != null) {
                if (obj.getId() == null) {
                    obj.setId(UUID.randomUUID().toString());
                }
                obj.ensureTexture();
            }
        }
        // Populate the cache.
        setObjectsForChunk(worldName, chunkPos, objects);
        return objects;
    }

    public void setObjectsForChunk(String worldName, Vector2 chunkPos, List<WorldObject> objects) {
        try {
            if (objects == null) {
                worldObjectsByWorld.computeIfAbsent(worldName, k -> new ConcurrentHashMap<>())
                    .remove(chunkPos);
                return;
            }
            List<WorldObject> safeObjects = new CopyOnWriteArrayList<>();
            for (WorldObject obj : objects) {
                if (obj != null) {
                    if (obj.getId() == null) {
                        obj.setId(UUID.randomUUID().toString());
                    }
                    obj.ensureTexture();
                    safeObjects.add(obj);
                }
            }
            worldObjectsByWorld.computeIfAbsent(worldName, k -> new ConcurrentHashMap<>())
                .put(chunkPos, safeObjects);
        } catch (Exception e) {
            GameLogger.error("Error setting chunk objects: " + e.getMessage());
        }
    }

    public void cleanup() {
        worldObjectsByWorld.clear();
        lastChunkAccess.clear();
    }
}

================
File: src/main/java/org/discord/utils/ServerPokemonSpawnManager.java
================
package org.discord.utils;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.data.PokemonData;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.DayNightCycle;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.PokemonSpawnManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.PokemonLevelCalculator;
import org.discord.context.ServerGameContext;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import static io.github.pokemeetup.CreatureCaptureGame.MULTIPLAYER_WORLD_NAME;

/**
 * This class is responsible for generating and updating wild Pokémon spawns on the server.
 * Instead of using textures (which are client–side), it creates WildPokemon instances with a null sprite.
 * It obtains the loaded chunks from ServerWorldManager.getLoadedChunks(worldName) and then,
 * if a chunk has fewer than MAX_POKEMON_PER_CHUNK, it attempts to spawn a new Pokémon.
 *
 * When a spawn occurs a serializable PokemonData object is built and a WildPokemonSpawn network message
 * is broadcast so that clients update their local world.
 */
public class ServerPokemonSpawnManager {
    private static final float MOVEMENT_UPDATE_INTERVAL = 0.1f; // Send updates 10 times per second maximum
    private static final float MOVEMENT_THRESHOLD = 1.0f;
    private final Map<UUID, Vector2> lastSentPositions = new ConcurrentHashMap<>();

    // Movement update accumulator
    private float movementUpdateTimer = 0f;
    // Check for new spawns every 5 seconds.
    private static final float SPAWN_INTERVAL = 5f;
    // Maximum wild Pokémon per chunk.
    private static final int MAX_POKEMON_PER_CHUNK = 5;
    // These constants must match those used in your World class.
    private static final int TILE_SIZE = 32;
    // Assume Chunk.CHUNK_SIZE is defined in the Chunk class.

    private final String worldName;
    private float spawnTimer = 0f;
    // Map of active wild Pokémon keyed by their UUID.
    private final Map<UUID, WildPokemon> activePokemon = new HashMap<>();
    private final Random random = new Random();

    /**
     * Constructs a server spawn manager for the given world.
     *
     * @param worldName The name (ID) of the world (e.g. "multiplayer_world").
     */
    public ServerPokemonSpawnManager(String worldName) {
        this.worldName = worldName;
        initializePokemonSpawns();
    }

    /**
     * Called periodically by the server update loop.
     *
     * @param delta Elapsed time in seconds.
     */
    public void update(float delta) {
        spawnTimer += delta;
        if (spawnTimer >= SPAWN_INTERVAL) {
            spawnTimer = 0f;
            trySpawnPokemon();
            removeExpiredPokemon();
        }
        movementUpdateTimer += delta;

        // If it's time to check for movement updates
        if (movementUpdateTimer >= MOVEMENT_UPDATE_INTERVAL) {
            movementUpdateTimer = 0f;
            checkForMovementUpdates();
        }
    }

    private void checkForMovementUpdates() {
        List<NetworkProtocol.PokemonUpdate> updates = new ArrayList<>();

        for (WildPokemon pokemon : activePokemon.values()) {
            Vector2 lastPos = lastSentPositions.getOrDefault(pokemon.getUuid(), new Vector2(Float.MAX_VALUE, Float.MAX_VALUE));

            // Check if the Pokemon has moved enough to warrant an update
            float distance = Vector2.dst(lastPos.x, lastPos.y, pokemon.getX(), pokemon.getY());
            boolean directionChanged = !pokemon.getDirection().equals(syncedPokemonData
                .getOrDefault(pokemon.getUuid(), new PokemonSpawnManager.NetworkSyncData()).direction);
            boolean movingChanged = pokemon.isMoving() != syncedPokemonData
                .getOrDefault(pokemon.getUuid(), new PokemonSpawnManager.NetworkSyncData()).isMoving;

            // Send update if position changed significantly or direction/moving state changed
            if (distance > MOVEMENT_THRESHOLD || directionChanged || movingChanged) {
                NetworkProtocol.PokemonUpdate update = createPokemonUpdate(pokemon);
                updates.add(update);

                // Update the last sent position and state
                lastSentPositions.put(pokemon.getUuid(), new Vector2(pokemon.getX(), pokemon.getY()));

                // Update the synced data
                PokemonSpawnManager.NetworkSyncData syncData = syncedPokemonData.computeIfAbsent(pokemon.getUuid(), k -> new PokemonSpawnManager.NetworkSyncData());
                syncData.direction = pokemon.getDirection();
                syncData.isMoving = pokemon.isMoving();
            }
        }

        // If there are updates to send, send them as a batch
        if (!updates.isEmpty()) {
            broadcastPokemonUpdates(updates);
        }
    }  private NetworkProtocol.PokemonUpdate createPokemonUpdate(WildPokemon pokemon) {
        NetworkProtocol.PokemonUpdate update = new NetworkProtocol.PokemonUpdate();
        update.uuid = pokemon.getUuid();
        update.x = pokemon.getX();
        update.y = pokemon.getY();
        update.direction = pokemon.getDirection();
        update.isMoving = pokemon.isMoving();
        update.level = pokemon.getLevel();
        update.timestamp = System.currentTimeMillis();
        return update;
    }// Add this inner class at the bottom of ServerPokemonSpawnManager
    private static class NetworkSyncData {
        Vector2 targetPosition;
        String direction;
        boolean isMoving;
        long lastUpdateTime;

        NetworkSyncData() {
            this.lastUpdateTime = System.currentTimeMillis();
            this.direction = "down";
            this.isMoving = false;
        }
    }
    private final Map<UUID, PokemonSpawnManager.NetworkSyncData> syncedPokemonData = new ConcurrentHashMap<>();
    /**
     * Broadcast a batch of Pokemon updates to all clients
     */
    private void broadcastPokemonUpdates(List<NetworkProtocol.PokemonUpdate> updates) {
        if (updates.isEmpty()) return;

        // Use batch update to reduce network overhead
        NetworkProtocol.PokemonBatchUpdate batchUpdate = new NetworkProtocol.PokemonBatchUpdate();
        batchUpdate.updates = updates;

        // Broadcast to all connected clients
        ServerGameContext.get().getGameServer().getNetworkServer().sendToAllTCP(batchUpdate);
    }
    /**
     * Iterates over all active wild Pokémon and builds a batch update message,
     * then broadcasts it to all clients.
     */
    public void broadcastPokemonUpdates() {
        List<NetworkProtocol.PokemonUpdate> updates = new ArrayList<>();
        for (WildPokemon pokemon : activePokemon.values()) {
            NetworkProtocol.PokemonUpdate update = new NetworkProtocol.PokemonUpdate();
            update.uuid = pokemon.getUuid();
            update.x = pokemon.getX();
            update.y = pokemon.getY();
            update.direction = pokemon.getDirection();
            update.isMoving = pokemon.isMoving();
            update.level = pokemon.getLevel();
            update.timestamp = System.currentTimeMillis();
            updates.add(update);
        }
        if (!updates.isEmpty()) {
            NetworkProtocol.PokemonBatchUpdate batchUpdate = new NetworkProtocol.PokemonBatchUpdate();
            batchUpdate.updates = updates;
            // Broadcast to all connected clients.
            ServerGameContext.get().getGameServer().getNetworkServer().sendToAllTCP(batchUpdate);
        }
    }


    private void trySpawnPokemon() {
        // (A) Grab the loaded chunks from the world manager
        Map<Vector2, Chunk> loadedChunks =
            ServerGameContext.get().getWorldManager().getLoadedChunks(worldName);

        if (loadedChunks == null || loadedChunks.isEmpty()) {
            GameLogger.error("No loaded chunks for world " + worldName + "; cannot spawn Pokémon.");
            return;
        }

        // (B) Find which chunks are actually occupied by players
        Set<Vector2> playerChunks =
            ServerGameContext.get().getGameServer().getPlayerOccupiedChunks();

        if (playerChunks.isEmpty()) {
            return;
        }

        // (C) Try to spawn in each chunk that has a player
        for (Vector2 chunkPos : playerChunks) {
            Chunk chunk = loadedChunks.get(chunkPos);
            if (chunk == null) {
                // might not be loaded yet
                continue;
            }

            int count = getPokemonCountInChunk(chunkPos);

            float chance = random.nextFloat();

            if (count < MAX_POKEMON_PER_CHUNK && chance < 0.4f) {
                spawnPokemonInChunk(chunkPos, chunk);
            }
        }
    }

    private int getPokemonCountInChunk(Vector2 chunkPos) {
        int count = 0;
        for (WildPokemon pokemon : activePokemon.values()) {
            Vector2 pos = new Vector2(pokemon.getX(), pokemon.getY());
            Vector2 computedChunk = getChunkPosition(pos);
            if (computedChunk.equals(chunkPos)) {
                count++;
            }
        }
        return count;
    }

    /**
     * Converts a pixel position into chunk coordinates.
     *
     * @param pixelPos The position in pixels.
     * @return The chunk coordinates.
     */
    private Vector2 getChunkPosition(Vector2 pixelPos) {
        int chunkX = (int)Math.floor(pixelPos.x / (TILE_SIZE * Chunk.CHUNK_SIZE));
        int chunkY = (int)Math.floor(pixelPos.y / (TILE_SIZE * Chunk.CHUNK_SIZE));
        return new Vector2(chunkX, chunkY);
    }
    private void spawnPokemonInChunk(Vector2 chunkPos, Chunk chunk) {
        // pick random local tile
        int localX = random.nextInt(Chunk.CHUNK_SIZE);
        int localY = random.nextInt(Chunk.CHUNK_SIZE);

        boolean passable = chunk.isPassable(localX, localY);

        // If the tile isn't passable, we skip
        if (!passable) {
            GameLogger.info("Spawn location not passable in chunk " + chunkPos);
            return;
        }

        try {
            // convert local tile coords to pixel coords
            int worldTileX = (int)(chunkPos.x * Chunk.CHUNK_SIZE + localX);
            int worldTileY = (int)(chunkPos.y * Chunk.CHUNK_SIZE + localY);
            float pixelX = worldTileX * TILE_SIZE;
            float pixelY = worldTileY * TILE_SIZE;

            // ensure we have a non‐null biome
            Biome biome = chunk.getBiome();
            if (biome == null) {
                // fallback:
                GameLogger.error("Null biome at chunk " + chunkPos + ", defaulting to PLAINS biome.");
            }

            // pick a random Pokémon for this biome
            String pokemonName = selectRandomPokemonForBiome(biome);
            int level = calculatePokemonLevel(pixelX, pixelY);
            WildPokemon pokemon = new WildPokemon(
                pokemonName,
                level,
                (int) pixelX,
                (int) pixelY,
                true // noTexture mode on the server
            );


            // store in active map
            activePokemon.put(pokemon.getUuid(), pokemon);

            // build a spawn message
            NetworkProtocol.WildPokemonSpawn spawnMsg = new NetworkProtocol.WildPokemonSpawn();
            spawnMsg.uuid = pokemon.getUuid();
            spawnMsg.x = pokemon.getX();
            spawnMsg.y = pokemon.getY();
            spawnMsg.timestamp = System.currentTimeMillis();
            spawnMsg.data = createPokemonData(pokemon); // might throw if dictionary is missing?

            // broadcast to all clients
            ServerGameContext.get()
                .getGameServer()
                .getNetworkServer()
                .sendToAllTCP(spawnMsg);


        } catch (Exception ex) {
            // Catch anything that might silently prevent the spawn
            GameLogger.error("spawnPokemonInChunk: Unexpected error => " + ex.getMessage());
            ex.printStackTrace();
        }
    }



    private static void initializePokemonSpawns() {
        // PLAINS biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> plainsSpawns = new HashMap<>();
        plainsSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Rattata", "Pidgey", "Sentret", "Hoppip", "Sunkern",
            "Caterpie", "Weedle", "Oddish", "Bellsprout", "Zigzagoon", "Spinarak"
        });
        plainsSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Zubat", "Hoothoot", "Rattata", "Caterpie", "Weedle",
            "Hoppip", "Sunkern", "Spinarak", "Skitty"
        });
        POKEMON_SPAWNS.put(BiomeType.PLAINS, plainsSpawns);

        // FOREST biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> forestSpawns = new HashMap<>();
        forestSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Caterpie", "Weedle", "Oddish", "Bellsprout", "Treecko",
            "Shroomish", "Seedot", "Lotad", "Nincada", "Poochyena",
            "Hoppip", "Sunkern"
        });
        forestSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Hoothoot", "Caterpie", "Weedle", "Oddish", "Bellsprout",
            "Treecko", "Shroomish", "Seedot", "Lotad", "Poochyena",
            "Hoppip", "Nincada"
        });
        POKEMON_SPAWNS.put(BiomeType.FOREST, forestSpawns);

        // SNOW biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> snowSpawns = new HashMap<>();
        snowSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Swinub", "Snorunt", "Snover", "Spheal", "Cubchoo",
            "Sneasel", "Vanillite", "Snom"
        });
        snowSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Swinub", "Snorunt", "Snover", "Spheal", "Cubchoo",
            "Sneasel", "Vanillite", "Snom"
        });
        POKEMON_SPAWNS.put(BiomeType.SNOW, snowSpawns);

        // DESERT biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> desertSpawns = new HashMap<>();
        desertSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Sandshrew", "Trapinch", "Cacnea", "Sandile", "Diglett",
            "Vulpix", "Ekans", "Spinarak", "Poochyena"
        });
        desertSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Sandshrew", "Trapinch", "Cacnea", "Sandile", "Diglett",
            "Vulpix", "Ekans", "Zubat", "Spinarak"
        });
        POKEMON_SPAWNS.put(BiomeType.DESERT, desertSpawns);

        // HAUNTED biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> hauntedSpawns = new HashMap<>();
        hauntedSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Gastly", "Misdreavus", "Shuppet", "Duskull", "Sableye",
            "Litwick", "Murkrow", "Yamask"
        });
        hauntedSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Gastly", "Misdreavus", "Shuppet", "Duskull", "Sableye",
            "Litwick", "Murkrow", "Yamask"
        });
        POKEMON_SPAWNS.put(BiomeType.HAUNTED, hauntedSpawns);

        // RAIN FOREST biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> rainforestSpawns = new HashMap<>();
        rainforestSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Treecko", "Mudkip", "Torchic", "Lotad", "Seedot",
            "Shroomish", "Sunkern", "Hoppip", "Caterpie", "Weedle",
            "Nincada", "Poochyena"
        });
        rainforestSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Treecko", "Mudkip", "Torchic", "Lotad", "Seedot",
            "Shroomish", "Sunkern", "Hoppip", "Caterpie", "Weedle",
            "Nincada", "Poochyena"
        });
        POKEMON_SPAWNS.put(BiomeType.RAIN_FOREST, rainforestSpawns);

        // BIG MOUNTAINS biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> mountainSpawns = new HashMap<>();
        mountainSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Geodude", "Machop", "Onix", "Rhyhorn", "Nosepass",
            "Larvitar", "Meditite", "Riolu", "Rockruff", "Swinub"
        });
        mountainSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Geodude", "Machop", "Onix", "Rhyhorn", "Nosepass",
            "Larvitar", "Meditite", "Riolu", "Rockruff", "Swinub"
        });
        POKEMON_SPAWNS.put(BiomeType.BIG_MOUNTAINS, mountainSpawns);

        // RUINS biome
        Map<PokemonSpawnManager.TimeOfDay, String[]> ruinsSpawns = new HashMap<>();
        ruinsSpawns.put(PokemonSpawnManager.TimeOfDay.DAY, new String[]{
            "Zubat", "Geodude", "Kabuto", "Omanyte", "Aerodactyl",
            "Rattata", "Gastly", "Onix", "Abra", "Cubone"
        });
        ruinsSpawns.put(PokemonSpawnManager.TimeOfDay.NIGHT, new String[]{
            "Zubat", "Geodude", "Kabuto", "Omanyte", "Aerodactyl",
            "Rattata", "Gastly", "Onix", "Abra", "Cubone"
        });
        POKEMON_SPAWNS.put(BiomeType.RUINS, ruinsSpawns);
    }
    private String selectRandomPokemonForBiome(Biome biome) {
        if (biome == null) {
            return "Rattata";
        }
        BiomeType biomeType = biome.getType();
        // extra check
        Map<PokemonSpawnManager.TimeOfDay, String[]> spawnOptions = POKEMON_SPAWNS.get(biomeType);
        if (spawnOptions == null) {
            GameLogger.error("selectRandomPokemonForBiome: No spawn table for biome " + biomeType
                + ", defaulting to Rattata");
            return "Rattata";
        }

        double worldTimeInMinutes = ServerGameContext.get()
            .getWorldManager()
            .loadWorld(MULTIPLAYER_WORLD_NAME)
            .getWorldTimeInMinutes();
        float hourOfDay = DayNightCycle.getHourOfDay(worldTimeInMinutes);
        PokemonSpawnManager.TimeOfDay timeOfDay = (hourOfDay >= 6 && hourOfDay < 18)
            ? PokemonSpawnManager.TimeOfDay.DAY
            : PokemonSpawnManager.TimeOfDay.NIGHT;

        String[] options = spawnOptions.get(timeOfDay);
        if (options == null || options.length == 0) {
            return "Rattata";
        }
        int index = random.nextInt(options.length);
        return options[index];
    }


    private static final Map<BiomeType, Map<PokemonSpawnManager.TimeOfDay, String[]>> POKEMON_SPAWNS = new HashMap<>();

    private int calculatePokemonLevel(float pixelX, float pixelY) {
        return PokemonLevelCalculator.calculateLevel(pixelX, pixelY, TILE_SIZE);
    }
    private void removeExpiredPokemon() {
        activePokemon.entrySet().removeIf(entry -> {
            WildPokemon pokemon = entry.getValue();
            if (pokemon.isExpired()) {
                NetworkProtocol.WildPokemonDespawn despawnMsg = new NetworkProtocol.WildPokemonDespawn();
                despawnMsg.uuid = pokemon.getUuid();
                despawnMsg.timestamp = System.currentTimeMillis();
                ServerGameContext.get().getGameServer().getNetworkServer().sendToAllTCP(despawnMsg);
                GameLogger.info("Server despawned Pokémon with UUID: " + pokemon.getUuid());
                return true;
            }
            return false;
        });
    }

    /**
     * Creates a serializable PokemonData object from the given WildPokemon.
     * This replaces any client–only method that would otherwise return a sprite-based summary.
     *
     * @param pokemon The wild Pokémon.
     * @return A new PokemonData object with its properties.
     */
    private PokemonData createPokemonData(WildPokemon pokemon) {
        PokemonData data = new PokemonData();
        data.setName(pokemon.getName());
        data.setLevel(pokemon.getLevel());
        data.setPrimaryType(pokemon.getPrimaryType());
        data.setSecondaryType(pokemon.getSecondaryType());
        if (pokemon.getStats() != null) {
            PokemonData.Stats stats = new PokemonData.Stats(pokemon.getStats());
            data.setStats(stats);
        }
        // Copy moves if available.
        // (Assume WildPokemon.getMoves() returns a list of move objects.)
        // If not available on the server, leave the move list empty.
        return data;
    }

    /**
     * Returns a collection of all currently active wild Pokémon.
     *
     * @return The active wild Pokémon.
     */
    public Collection<WildPokemon> getActivePokemon() {
        return activePokemon.values();
    }
}

================
File: src/main/java/org/discord/utils/ServerWorldManager.java
================
package org.discord.utils;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonWriter;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.managers.BiomeTransitionResult;
import io.github.pokemeetup.system.data.BlockSaveData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.UnifiedWorldGenerator;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.multiplayer.server.ServerStorageSystem;
import io.github.pokemeetup.utils.storage.JsonConfig;
import org.discord.context.ServerGameContext;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.*;


/**
 * Manages loading & saving of worlds and chunks on the server side,
 * including chunk-specific WorldObjects, tile data, and block data.
 */
public class ServerWorldManager {

    private static final long AUTO_SAVE_INTERVAL_MS = 300_000;   // e.g. 5 minutes
    private static final long CHUNK_EVICT_TIMEOUT_MS = 600_000;  // e.g. 10 minutes
    private static ServerWorldManager instance;
    private final ServerStorageSystem storageSystem;// In ServerWorldManager, add:
    // Worlds & Chunks in memory
    private final Map<String, WorldData> activeWorlds = new ConcurrentHashMap<>();
    private final Map<String, Map<Vector2, TimedChunk>> chunkCache = new ConcurrentHashMap<>();
    // Schedulers
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
    private final ExecutorService loadExecutor = Executors.newFixedThreadPool(4);
    private final BiomeManager biomeManager;

    // Update constructor:
    private ServerWorldManager(ServerStorageSystem storageSystem) {
        this.storageSystem = storageSystem;
        this.biomeManager = new BiomeManager(System.currentTimeMillis());
        initScheduledTasks();
    }

    public static synchronized ServerWorldManager getInstance(ServerStorageSystem storageSystem) {
        if (instance == null) {
            instance = new ServerWorldManager(storageSystem);
        }
        return instance;
    }

    public BiomeTransitionResult getBiomeTransitionAt(float worldX, float worldY) {
        return biomeManager.getBiomeAt(worldX, worldY);
    }

    private void initScheduledTasks() {
        // Periodically auto-save worlds & evict idle chunks
        scheduler.scheduleAtFixedRate(() -> {
            try {
                // Save any dirty worlds
                for (WorldData wd : activeWorlds.values()) {
                    if (wd.isDirty()) {
                        saveWorld(wd);
                    }
                }
                // Evict idle chunks
                evictIdleChunks();
            } catch (Exception e) {
                GameLogger.error("Error in scheduled task: " + e.getMessage());
            }
        }, AUTO_SAVE_INTERVAL_MS, AUTO_SAVE_INTERVAL_MS, TimeUnit.MILLISECONDS);
    }

    /**
     * Loads the specified world from disk if not already in memory,
     * and caches it in activeWorlds.
     */
    public synchronized WorldData loadWorld(String worldName) {
        if (activeWorlds.containsKey(worldName)) {
            return activeWorlds.get(worldName);
        }
        WorldData wd = storageSystem.loadWorld(worldName);
        if (wd == null) {
            GameLogger.error("World not found in server storage: " + worldName);
            return null;
        }
        activeWorlds.put(worldName, wd);
        // Create a chunk cache for that world
        chunkCache.put(worldName, new ConcurrentHashMap<>());

        GameLogger.info("Loaded world '" + worldName + "' from server storage.");
        return wd;
    }

    /**
     * Saves high-level WorldData only (not chunk data) to server storage.
     */
    public synchronized void saveWorld(WorldData worldData) {
        if (worldData == null) return;
        try {
            storageSystem.saveWorld(worldData);
            worldData.setDirty(false);
            GameLogger.info("Saved world: " + worldData.getName());
        } catch (Exception e) {
            GameLogger.error("Failed to save world: " + e.getMessage());
        }
    }

    /**
     * Creates a brand-new world, stored under server/data/worlds/<name>/world.json,
     * then caches it in memory.
     */
    public synchronized WorldData createWorld(String worldName, long seed, float treeRate, float pokeRate) {
        if (activeWorlds.containsKey(worldName) || storageSystem.worldExists(worldName)) {
            GameLogger.error("World '" + worldName + "' already exists.");
            return null;
        }
        WorldData wd = new WorldData(worldName);
        WorldData.WorldConfig config = new WorldData.WorldConfig(seed);
        config.setTreeSpawnRate(treeRate);
        config.setPokemonSpawnRate(pokeRate);
        wd.setConfig(config);

        // Save to disk
        saveWorld(wd);

        // Cache in memory
        activeWorlds.put(worldName, wd);
        chunkCache.put(worldName, new ConcurrentHashMap<>());
        return wd;
    }

    // ------------------------------------------------------------------------------------
    // CHUNK LOADING & GENERATION
    // ------------------------------------------------------------------------------------


    // The new load–or–generate method for the server.
    // Modify loadChunk in ServerWorldManager.java
    public Chunk loadChunk(String worldName, int chunkX, int chunkY) {
        WorldData wd = loadWorld(worldName);
        if (wd == null) {
            GameLogger.error("WorldData is null for: " + worldName);
            return null;
        }

        Map<Vector2, TimedChunk> worldChunkMap =
            chunkCache.computeIfAbsent(worldName, k -> new ConcurrentHashMap<>());
        Vector2 pos = new Vector2(chunkX, chunkY);
        TimedChunk timed = worldChunkMap.get(pos);

        if (timed == null || timed.chunk == null) {
            // a) Load from disk or generate
            Chunk loaded = loadChunkFromDisk(worldName, chunkX, chunkY);
            if (loaded == null) {
                // CRITICAL FIX: Generate new chunk with deterministic seed
                // This ensures consistent generation across server restarts
                long determinSeed = wd.getConfig().getSeed() +
                    (((long)chunkX << 32) | ((long)chunkY & 0xFFFFFFFFL));

                loaded = generateNewChunk(chunkX, chunkY, determinSeed);

                // Save immediately to ensure persistence
                saveChunk(worldName, loaded);
            }

            // b) Store in cache
            timed = new TimedChunk(loaded);
            worldChunkMap.put(pos, timed);

            // If we changed the chunk's boundary tiles, mark dirty & save now
            if (loaded.isDirty()) {
                saveChunk(worldName, loaded);
            }
        }

        // c) If chunk is dirty, we can also consider saving
        if (timed.chunk.isDirty()) {
            saveChunk(worldName, timed.chunk);
            timed.chunk.setDirty(false);
        }

        timed.lastAccess = System.currentTimeMillis();
        return timed.chunk;
    }

    private Chunk generateNewChunk(int chunkX, int chunkY, long seed) {
        int worldTileX = chunkX * Chunk.CHUNK_SIZE;
        int worldTileY = chunkY * Chunk.CHUNK_SIZE;

        // Calculate chunk center for consistent biome determination
        float centerPixelX = (chunkX * Chunk.CHUNK_SIZE + Chunk.CHUNK_SIZE * 0.5f) * World.TILE_SIZE;
        float centerPixelY = (chunkY * Chunk.CHUNK_SIZE + Chunk.CHUNK_SIZE * 0.5f) * World.TILE_SIZE;

        BiomeTransitionResult btr = biomeManager.getBiomeAt(centerPixelX, centerPixelY);

        // Ensure we always have a valid biome
        if (btr == null || btr.getPrimaryBiome() == null) {
            btr = new BiomeTransitionResult(
                biomeManager.getBiome(BiomeType.PLAINS),
                null,
                1.0f
            );
        }

        // Pass the deterministic seed to the world generator
        Chunk chunk = UnifiedWorldGenerator.generateChunkForServer(
            chunkX, chunkY, seed, biomeManager);

        // IMPORTANT: Force the biome to match what we calculated
        // This ensures consistent biome assignment
        chunk.setBiome(btr.getPrimaryBiome());

        return chunk;
    }

    private Chunk loadChunkFromDisk(String worldName, int chunkX, int chunkY) {
        Path path = getChunkFilePath(worldName, chunkX, chunkY);
        try {
            if (!storageSystem.getFileSystem().exists(path.toString())) {
                return null;
            }
            String jsonContent = storageSystem.getFileSystem().readString(path.toString());
            if (jsonContent == null || jsonContent.isEmpty()) {
                return null;
            }
            Json json = JsonConfig.getInstance();
            ChunkData cd = json.fromJson(ChunkData.class, jsonContent);
            // Use the saved biome type if available; however, you may choose to override it.
            Biome biome = biomeManager.getBiome(cd.biomeType);
            if (biome == null) {
                biome = biomeManager.getBiome(BiomeType.PLAINS);
            }
            Chunk chunk = new Chunk(chunkX, chunkY, biome, cd.generationSeed);
            chunk.setTileData(cd.tileData);
            // Process blocks.
            if (cd.blockData != null) {
                for (BlockSaveData.BlockData bd : cd.blockData) {
                    processBlockData(chunk, bd);
                }
            }
            // Process world objects.
            Vector2 chunkPos = new Vector2(chunkX, chunkY);
            List<WorldObject> objectList = new ArrayList<>();
            if (cd.worldObjects != null) {
                for (Map<String, Object> objData : cd.worldObjects) {
                    try {
                        WorldObject obj = new WorldObject();
                        obj.updateFromData(objData);
                        obj.ensureTexture();
                        objectList.add(obj);
                    } catch (Exception e) {
                        GameLogger.error("Failed to load object: " + e.getMessage());
                    }
                }
            }
            // Register the objects in the ServerWorldObjectManager.
            ServerGameContext.get().getWorldObjectManager().setObjectsForChunk(worldName, chunkPos, objectList);
            return chunk;
        } catch (Exception e) {
            GameLogger.error("Error reading chunk from disk: " + e.getMessage());
            return null;
        }
    }


    /**
     * Generates a new chunk if it doesn’t exist on disk. Basic flow:
     * 1) Determine biome
     * 2) Generate tile data
     * 3) Place default objects
     */
    private void processBlockData(Chunk chunk, BlockSaveData.BlockData blockData) {
        try {
            PlaceableBlock.BlockType blockType = PlaceableBlock.BlockType.fromId(blockData.type);
            if (blockType == null) {
                GameLogger.error("Unknown block type: " + blockData.type);
                return;
            }

            Vector2 pos = new Vector2(blockData.x, blockData.y);
            PlaceableBlock block = new PlaceableBlock(blockType, pos, null, blockData.isFlipped);

            // Handle chest-specific data
            if (blockType == PlaceableBlock.BlockType.CHEST) {
                block.setChestOpen(blockData.isChestOpen);
                if (blockData.chestData != null) {
                    block.setChestData(blockData.chestData);
                    GameLogger.info("Loaded chest at " + pos + " with " +
                        blockData.chestData.items.stream().filter(Objects::nonNull).count() + " items");
                }
            }

            chunk.addBlock(block);
            ServerGameContext.get().getServerBlockManager().getPlacedBlocks().put(pos, block);

        } catch (Exception e) {
            GameLogger.error("Failed to process block data: " + e.getMessage());
        }
    }

    /**
     * Returns a map of all currently loaded chunks (as Chunk objects)
     * for the given world name. This is used by the server to determine
     * which chunks are active so that wild Pokémon can be spawned in them.
     *
     * @param worldName The name (ID) of the world.
     * @return A Map keyed by chunk position (Vector2) to the loaded Chunk.
     */
    public Map<Vector2, Chunk> getLoadedChunks(String worldName) {
        Map<Vector2, TimedChunk> cache = chunkCache.get(worldName);
        Map<Vector2, Chunk> loadedChunks = new HashMap<>();
        if (cache != null) {
            for (Map.Entry<Vector2, TimedChunk> entry : cache.entrySet()) {
                if (entry.getValue().chunk != null) {
                    // Update last access time
                    entry.getValue().lastAccess = System.currentTimeMillis();
                    loadedChunks.put(entry.getKey(), entry.getValue().chunk);
                }
            }
        }
        return loadedChunks;
    }


    // ------------------------------------------------------------------------------------
    // CHUNK HELPER METHODS
    // ------------------------------------------------------------------------------------

    private Path getChunkFilePath(String worldName, int chunkX, int chunkY) {
        return Paths.get("server", "data", "worlds", worldName, "chunks",
            "chunk_" + chunkX + "_" + chunkY + ".json");
    }


    public void saveChunk(String worldName, Chunk chunk) {
        if (chunk == null) return;
        try {
            // Determine the file path for the chunk data.
            Path chunkPath = getChunkFilePath(worldName, chunk.getChunkX(), chunk.getChunkY());
            Path chunksDir = chunkPath.getParent();
            if (chunksDir != null) {
                storageSystem.getFileSystem().createDirectory(chunksDir.toString());
            }

            // Prepare the ChunkData object.
            ChunkData cd = new ChunkData();
            cd.chunkX = chunk.getChunkX();
            cd.chunkY = chunk.getChunkY();
            cd.biomeType = chunk.getBiome().getType();
            cd.tileData = chunk.getTileData().clone();
            cd.blockData = new ArrayList<>(chunk.getBlockDataForSave());

            // Get the current world objects from the object manager.
            List<WorldObject> objects = ServerGameContext.get().getWorldObjectManager()
                .getObjectsForChunk(worldName, new Vector2(chunk.getChunkX(), chunk.getChunkY()));
            if (objects != null) {
                cd.worldObjects = new ArrayList<>();
                for (WorldObject obj : objects) {
                    if (obj != null) {
                        Map<String, Object> objData = obj.getSerializableData();
                        if (objData != null) {
                            cd.worldObjects.add(new HashMap<>(objData));
                        }
                    }
                }
            }

            // Serialize and write the chunk data to disk.
            Json json = JsonConfig.getInstance();
            json.setOutputType(JsonWriter.OutputType.json);
            String jsonData = json.prettyPrint(cd);
            storageSystem.getFileSystem().writeString(chunkPath.toString(), jsonData);

            // Mark the chunk as clean.
            chunk.setDirty(false);

            // --- NEW CODE: Update the persistent WorldData ---
            // Retrieve the current WorldData for this world.
            WorldData wd = loadWorld(worldName);
            if (wd != null) {
                Vector2 chunkKey = new Vector2(chunk.getChunkX(), chunk.getChunkY());
                // Update the chunk in the world data.
                wd.getChunks().put(chunkKey, chunk);
                // Update the world objects for that chunk.
                wd.addChunkObjects(chunkKey, objects);
                wd.setDirty(true);
                // Save the updated world data.
                saveWorld(wd);
            } else {
                GameLogger.error("Could not load WorldData for " + worldName + " to update chunk " + chunk.getChunkX() + "," + chunk.getChunkY());
            }

            GameLogger.info("Chunk saved successfully for chunk " + new Vector2(chunk.getChunkX(), chunk.getChunkY()));
        } catch (Exception e) {
            GameLogger.error("Failed to save chunk: " + e.getMessage());
        }
    }

    // ------------------------------------------------------------------------------------
    // CHUNK EVICTION
    // ------------------------------------------------------------------------------------

    private void evictIdleChunks() {
        long now = System.currentTimeMillis();
        for (Map.Entry<String, Map<Vector2, TimedChunk>> entry : chunkCache.entrySet()) {
            String worldName = entry.getKey();
            Map<Vector2, TimedChunk> chunkMap = entry.getValue();

            Iterator<Map.Entry<Vector2, TimedChunk>> it = chunkMap.entrySet().iterator();
            while (it.hasNext()) {
                Map.Entry<Vector2, TimedChunk> e = it.next();
                TimedChunk container = e.getValue();
                // If chunk is idle for too long, evict it
                if ((now - container.lastAccess) >= CHUNK_EVICT_TIMEOUT_MS) {
                    // Save if dirty
                    if (container.chunk.isDirty()) {
                        saveChunk(worldName, container.chunk);
                    }
                    it.remove();
                    GameLogger.info("Evicted chunk (" + e.getKey().x + "," + e.getKey().y +
                        ") from world '" + worldName + "'");
                }
            }
        }
    }

    // ------------------------------------------------------------------------------------
    // SHUTDOWN
    // ------------------------------------------------------------------------------------

    public void shutdown() {
        GameLogger.info("Shutting down ServerWorldManager...");

        // Save chunks
        for (Map.Entry<String, Map<Vector2, TimedChunk>> entry : chunkCache.entrySet()) {
            String worldName = entry.getKey();
            for (TimedChunk tchunk : entry.getValue().values()) {
                if (tchunk.chunk.isDirty()) {
                    saveChunk(worldName, tchunk.chunk);
                }
            }
        }

        // Save worlds
        for (WorldData wd : activeWorlds.values()) {
            if (wd.isDirty()) {
                saveWorld(wd);
            }
        }

        // Clean up executors
        loadExecutor.shutdown();
        scheduler.shutdown();

        GameLogger.info("ServerWorldManager shutdown complete.");
    }
    // ------------------------------------------------------------------------------------
    // INNER CLASSES
    // ------------------------------------------------------------------------------------

    /**
     * For storing chunk + lastAccess time so we can evict if idle.
     */
    static class TimedChunk {
        final Chunk chunk;
        long lastAccess;

        TimedChunk(Chunk chunk) {
            this.chunk = chunk;
            this.lastAccess = System.currentTimeMillis();
        }
    }

    /**
     * Represents chunk data in chunk_<x>_<y>.json, including tileData,
     * block data, and a list of serialized world objects.
     */

    public static class ChunkData {
        public int chunkX;
        public int chunkY;
        public BiomeType biomeType;
        public int[][] tileData;
        public List<BlockSaveData.BlockData> blockData = new ArrayList<>();
        public long generationSeed;
        public List<HashMap<String, Object>> worldObjects = new ArrayList<>();


    }
}



================================================================
End of Codebase
================================================================
