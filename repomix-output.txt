This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-22T10:52:49.697Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
main/java/io/github/pokemeetup/audio/AudioManager.java
main/java/io/github/pokemeetup/blocks/BlockManager.java
main/java/io/github/pokemeetup/blocks/BuildingData.java
main/java/io/github/pokemeetup/blocks/BuildingTemplate.java
main/java/io/github/pokemeetup/blocks/ConnectionPattern.java
main/java/io/github/pokemeetup/blocks/PlaceableBlock.java
main/java/io/github/pokemeetup/blocks/SmartBlockConfig.java
main/java/io/github/pokemeetup/blocks/SmartBuildingManager.java
main/java/io/github/pokemeetup/chat/ChatSystem.java
main/java/io/github/pokemeetup/chat/Command.java
main/java/io/github/pokemeetup/chat/CommandManager.java
main/java/io/github/pokemeetup/chat/commands/GiveCommand.java
main/java/io/github/pokemeetup/chat/commands/SetWorldSpawnCommand.java
main/java/io/github/pokemeetup/chat/commands/SpawnCommand.java
main/java/io/github/pokemeetup/chat/commands/TeleportManager.java
main/java/io/github/pokemeetup/chat/commands/TeleportPositionCommand.java
main/java/io/github/pokemeetup/context/GameContext.java
main/java/io/github/pokemeetup/CreatureCaptureGame.java
main/java/io/github/pokemeetup/FileSystemDelegate.java
main/java/io/github/pokemeetup/managers/BiomeManager.java
main/java/io/github/pokemeetup/managers/BiomeRenderer.java
main/java/io/github/pokemeetup/managers/BiomeTransitionResult.java
main/java/io/github/pokemeetup/managers/DatabaseManager.java
main/java/io/github/pokemeetup/managers/DisconnectionManager.java
main/java/io/github/pokemeetup/managers/WaterEffectManager.java
main/java/io/github/pokemeetup/managers/WaterEffectsRenderer.java
main/java/io/github/pokemeetup/multiplayer/client/GameClient.java
main/java/io/github/pokemeetup/multiplayer/client/GameClientSingleton.java
main/java/io/github/pokemeetup/multiplayer/client/PlayerDataResponseHandler.java
main/java/io/github/pokemeetup/multiplayer/network/NetworkedPokeball.java
main/java/io/github/pokemeetup/multiplayer/network/NetworkedTree.java
main/java/io/github/pokemeetup/multiplayer/network/NetworkedWorldObject.java
main/java/io/github/pokemeetup/multiplayer/network/NetworkProtocol.java
main/java/io/github/pokemeetup/multiplayer/OtherPlayer.java
main/java/io/github/pokemeetup/multiplayer/PlayerManager.java
main/java/io/github/pokemeetup/multiplayer/server/config/ServerConfigManager.java
main/java/io/github/pokemeetup/multiplayer/server/config/ServerConnectionConfig.java
main/java/io/github/pokemeetup/multiplayer/server/DialogListener.java
main/java/io/github/pokemeetup/multiplayer/server/entity/AIController.java
main/java/io/github/pokemeetup/multiplayer/server/entity/CreatureEntity.java
main/java/io/github/pokemeetup/multiplayer/server/entity/Entity.java
main/java/io/github/pokemeetup/multiplayer/server/entity/EntityEvents.java
main/java/io/github/pokemeetup/multiplayer/server/entity/EntityFactory.java
main/java/io/github/pokemeetup/multiplayer/server/entity/EntityManager.java
main/java/io/github/pokemeetup/multiplayer/server/entity/EntityType.java
main/java/io/github/pokemeetup/multiplayer/server/entity/PokeballEntity.java
main/java/io/github/pokemeetup/multiplayer/server/entity/SimpleAIController.java
main/java/io/github/pokemeetup/multiplayer/server/events/BaseServerEvent.java
main/java/io/github/pokemeetup/multiplayer/server/events/EventListener.java
main/java/io/github/pokemeetup/multiplayer/server/events/EventManager.java
main/java/io/github/pokemeetup/multiplayer/server/events/ServerEvent.java
main/java/io/github/pokemeetup/multiplayer/server/GameStateHandler.java
main/java/io/github/pokemeetup/multiplayer/server/PlayerDataManager.java
main/java/io/github/pokemeetup/multiplayer/server/PlayerEvents.java
main/java/io/github/pokemeetup/multiplayer/server/plugin/JarPluginLoader.java
main/java/io/github/pokemeetup/multiplayer/server/plugin/PluginConfig.java
main/java/io/github/pokemeetup/multiplayer/server/plugin/PluginLoader.java
main/java/io/github/pokemeetup/multiplayer/server/plugin/ServerPlugin.java
main/java/io/github/pokemeetup/multiplayer/server/ServerStorageSystem.java
main/java/io/github/pokemeetup/multiplayer/server/storage/FileStorage.java
main/java/io/github/pokemeetup/multiplayer/server/storage/StorageSystem.java
main/java/io/github/pokemeetup/multiplayer/ServerPlayer.java
main/java/io/github/pokemeetup/oldsystems/PlayerDataV1.java
main/java/io/github/pokemeetup/pokemon/attacks/LearnableMove.java
main/java/io/github/pokemeetup/pokemon/attacks/Move.java
main/java/io/github/pokemeetup/pokemon/attacks/MoveLoader.java
main/java/io/github/pokemeetup/pokemon/data/PokemonDatabase.java
main/java/io/github/pokemeetup/pokemon/Pokemon.java
main/java/io/github/pokemeetup/pokemon/PokemonDespawnAnimation.java
main/java/io/github/pokemeetup/pokemon/PokemonParty.java
main/java/io/github/pokemeetup/pokemon/WildPokemon.java
main/java/io/github/pokemeetup/screens/ChestScreen.java
main/java/io/github/pokemeetup/screens/CraftingTableScreen.java
main/java/io/github/pokemeetup/screens/DisconnectionScreen.java
main/java/io/github/pokemeetup/screens/GameScreen.java
main/java/io/github/pokemeetup/screens/InventoryScreen.java
main/java/io/github/pokemeetup/screens/InventoryScreenInterface.java
main/java/io/github/pokemeetup/screens/LoadingScreen.java
main/java/io/github/pokemeetup/screens/LoginScreen.java
main/java/io/github/pokemeetup/screens/ModeSelectionScreen.java
main/java/io/github/pokemeetup/screens/otherui/BattleTable.java
main/java/io/github/pokemeetup/screens/otherui/BuildingHotbar.java
main/java/io/github/pokemeetup/screens/otherui/BuildModeUI.java
main/java/io/github/pokemeetup/screens/otherui/GameMenu.java
main/java/io/github/pokemeetup/screens/otherui/HotbarUI.java
main/java/io/github/pokemeetup/screens/otherui/InventorySlotUI.java
main/java/io/github/pokemeetup/screens/otherui/PokemonPartyUI.java
main/java/io/github/pokemeetup/screens/otherui/ServerListEntry.java
main/java/io/github/pokemeetup/screens/otherui/StarterSelectionTable.java
main/java/io/github/pokemeetup/screens/WorldSelectionScreen.java
main/java/io/github/pokemeetup/system/AndroidMovementController.java
main/java/io/github/pokemeetup/system/battle/BattleCompletionHandler.java
main/java/io/github/pokemeetup/system/battle/BattleInitiationHandler.java
main/java/io/github/pokemeetup/system/battle/BattleResult.java
main/java/io/github/pokemeetup/system/battle/BattleSystemHandler.java
main/java/io/github/pokemeetup/system/data/BlockSaveData.java
main/java/io/github/pokemeetup/system/data/ChestData.java
main/java/io/github/pokemeetup/system/data/ItemData.java
main/java/io/github/pokemeetup/system/data/PlayerData.java
main/java/io/github/pokemeetup/system/data/PokemonData.java
main/java/io/github/pokemeetup/system/data/WorldData.java
main/java/io/github/pokemeetup/system/gameplay/CharacterAnimations.java
main/java/io/github/pokemeetup/system/gameplay/CharacterCustomization.java
main/java/io/github/pokemeetup/system/gameplay/inventory/ChestInteractionHandler.java
main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/CraftingGrid.java
main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/CraftingResult.java
main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/CraftingSystem.java
main/java/io/github/pokemeetup/system/gameplay/inventory/Inventory.java
main/java/io/github/pokemeetup/system/gameplay/inventory/Item.java
main/java/io/github/pokemeetup/system/gameplay/inventory/ItemManager.java
main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventoryLock.java
main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventoryObserver.java
main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventorySlotData.java
main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventorySlotDataObserver.java
main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/ItemContainer.java
main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/ItemDataObserver.java
main/java/io/github/pokemeetup/system/gameplay/inventory/Slot.java
main/java/io/github/pokemeetup/system/gameplay/overworld/AddOperation.java
main/java/io/github/pokemeetup/system/gameplay/overworld/biomes/Biome.java
main/java/io/github/pokemeetup/system/gameplay/overworld/biomes/BiomeType.java
main/java/io/github/pokemeetup/system/gameplay/overworld/Chunk.java
main/java/io/github/pokemeetup/system/gameplay/overworld/ChunkManager.java
main/java/io/github/pokemeetup/system/gameplay/overworld/DayNightCycle.java
main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/PokemonAI.java
main/java/io/github/pokemeetup/system/gameplay/overworld/mechanics/AutoTileSystem.java
main/java/io/github/pokemeetup/system/gameplay/overworld/mechanics/MountainGenerator.java
main/java/io/github/pokemeetup/system/gameplay/overworld/mechanics/MountainTileManager.java
main/java/io/github/pokemeetup/system/gameplay/overworld/multiworld/WorldManager.java
main/java/io/github/pokemeetup/system/gameplay/overworld/PersistOperation.java
main/java/io/github/pokemeetup/system/gameplay/overworld/PokemonSpawnManager.java
main/java/io/github/pokemeetup/system/gameplay/overworld/RemoveOperation.java
main/java/io/github/pokemeetup/system/gameplay/overworld/UpdateOperation.java
main/java/io/github/pokemeetup/system/gameplay/overworld/WeatherAudioSystem.java
main/java/io/github/pokemeetup/system/gameplay/overworld/WeatherSystem.java
main/java/io/github/pokemeetup/system/gameplay/overworld/World.java
main/java/io/github/pokemeetup/system/gameplay/overworld/WorldObject.java
main/java/io/github/pokemeetup/system/gameplay/overworld/WorldObjectOperation.java
main/java/io/github/pokemeetup/system/gameplay/PlayerAnimations.java
main/java/io/github/pokemeetup/system/gameplay/PokemonAnimations.java
main/java/io/github/pokemeetup/system/gameplay/SpawnPointValidator.java
main/java/io/github/pokemeetup/system/GlobalInputProcessor.java
main/java/io/github/pokemeetup/system/InputHandler.java
main/java/io/github/pokemeetup/system/InputManager.java
main/java/io/github/pokemeetup/system/PickupActionHandler.java
main/java/io/github/pokemeetup/system/Player.java
main/java/io/github/pokemeetup/system/servers/PluginContext.java
main/java/io/github/pokemeetup/system/UITransitionManager.java
main/java/io/github/pokemeetup/utils/ChunkPos.java
main/java/io/github/pokemeetup/utils/DialogStyles.java
main/java/io/github/pokemeetup/utils/GameInitializer.java
main/java/io/github/pokemeetup/utils/GameLogger.java
main/java/io/github/pokemeetup/utils/OpenSimplex2.java
main/java/io/github/pokemeetup/utils/PasswordUtils.java
main/java/io/github/pokemeetup/utils/PerlinNoise.java
main/java/io/github/pokemeetup/utils/ResponsiveLayout.java
main/java/io/github/pokemeetup/utils/storage/DesktopFileSystem.java
main/java/io/github/pokemeetup/utils/storage/GameFileSystem.java
main/java/io/github/pokemeetup/utils/storage/InventoryConverter.java
main/java/io/github/pokemeetup/utils/storage/JsonConfig.java
main/java/io/github/pokemeetup/utils/textures/AssetManagerSingleton.java
main/java/io/github/pokemeetup/utils/textures/BattleAssets.java
main/java/io/github/pokemeetup/utils/textures/BlockTextureManager.java
main/java/io/github/pokemeetup/utils/textures/TextureManager.java
main/java/io/github/pokemeetup/utils/textures/TexturePackerConfig.java
main/java/io/github/pokemeetup/utils/textures/TextureUtils.java
main/java/io/github/pokemeetup/utils/textures/TileNameParser.java
main/java/io/github/pokemeetup/utils/textures/TileNameValidator.java
main/java/io/github/pokemeetup/utils/textures/TilesetSplitter.java
main/java/io/github/pokemeetup/utils/textures/TileType.java
main/java/io/github/pokemeetup/utils/textures/TileTypeMapping.java
main/java/io/github/pokemeetup/utils/TimeUtils.java
main/java/io/github/pokemeetup/utils/UUIDSerializer.java

================================================================
Files
================================================================

================
File: main/java/io/github/pokemeetup/audio/AudioManager.java
================
package io.github.pokemeetup.audio;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.math.MathUtils;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class AudioManager {
    private static AudioManager instance;
    private final Map<WeatherSoundEffect, Sound> weatherSounds = new EnumMap<>(WeatherSoundEffect.class);
    private final Map<WeatherSoundEffect, Long> loopingSoundIds = new EnumMap<>(WeatherSoundEffect.class);
    private final Map<SoundEffect, Sound> sounds;
    private final Map<BiomeType, List<Music>> biomeMusic;

    private final Map<String, Sound> customSounds;
    private final float MUSIC_FADE_DURATION = 2.0f;
    private final Map<AmbientSoundType, Sound> ambientSounds;
    private final Map<AmbientSoundType, Long> activeAmbientLoops;
    private final Map<WeatherSoundEffect, Long> loopingStartTimes = new EnumMap<>(WeatherSoundEffect.class);
    private final Map<WeatherSoundEffect, Float> loopingDurations = new EnumMap<>(WeatherSoundEffect.class);
    private List<Music> menuMusicList;

    private Music currentMusic;
    private BiomeType currentBiome;
    private final float masterVolume = 1.0f;
    private float musicVolume = 0.7f;
    private float soundVolume = 1.0f;
    private boolean musicEnabled = true;
    private boolean soundEnabled = true;
    private BiomeType pendingBiome;
    private boolean isFadingOutMusic = false;
    private float fadeOutMusicTimer = 0f;
    private boolean isFadingInMusic = false;
    private float fadeInMusicTimer = 0f;

    private AudioManager() {
        sounds = new EnumMap<>(SoundEffect.class);
        biomeMusic = new EnumMap<>(BiomeType.class);
        customSounds = new ConcurrentHashMap<>();
        this.ambientSounds = new EnumMap<>(AmbientSoundType.class);
        this.activeAmbientLoops = new EnumMap<>(AmbientSoundType.class);
        initializeAmbientSounds();
        initializeWeatherSounds();
        initializeAudio();
    }

    public static AudioManager getInstance() {
        if (instance == null) {
            instance = new AudioManager();
        }
        return instance;
    }

    public static void setInstance(AudioManager instance) {
        AudioManager.instance = instance;
    }

    private void updateVolumes() {
        if (currentMusic != null) {
            currentMusic.setVolume(Math.max(0, musicVolume * masterVolume));
        }
        for (List<Music> musicList : biomeMusic.values()) {
            for (Music music : musicList) {
                music.setVolume(musicVolume * masterVolume);
            }
        }
    }

    private void updateSoundVolumes() {
        for (Map.Entry<WeatherSoundEffect, Long> entry : loopingSoundIds.entrySet()) {
            Sound sound = weatherSounds.get(entry.getKey());
            Long soundId = entry.getValue();
            if (sound != null && soundId != null) {
                sound.setVolume(soundId, soundVolume * masterVolume);
            }
        }
    }

    private void initializeWeatherSounds() {
        for (WeatherSoundEffect effect : WeatherSoundEffect.values()) {
            try {
                Sound sound = Gdx.audio.newSound(Gdx.files.internal(effect.getPath()));
                weatherSounds.put(effect, sound);
            } catch (Exception e) {
                GameLogger.error("Failed to load weather sound: " + effect.getPath());
            }
        }
    }

    private void initializeAmbientSounds() {
        for (AmbientSoundType type : AmbientSoundType.values()) {
            try {
                Sound sound = Gdx.audio.newSound(Gdx.files.internal(type.getPath()));
                ambientSounds.put(type, sound);
                GameLogger.info("Loaded ambient sound: " + type.name());
            } catch (Exception e) {
                GameLogger.error("Failed to load ambient sound: " + type.name() + " - " + e.getMessage());
            }
        }
    }

    public void stopAllAmbientSounds() {
        for (Map.Entry<AmbientSoundType, Long> entry : activeAmbientLoops.entrySet()) {
            Sound sound = ambientSounds.get(entry.getKey());
            if (sound != null) {
                sound.stop(entry.getValue());
            }
        }
        activeAmbientLoops.clear();
    }

    public void playWeatherSound(WeatherSoundEffect effect, float volume, float pitch) {
        if (!soundEnabled) return;

        Sound sound = weatherSounds.get(effect);
        if (sound != null) {
            sound.play(volume * soundVolume * masterVolume, pitch, 0);
        }
    }

    public void updateWeatherLoop(WeatherSoundEffect effect, float volume) {
        if (!soundEnabled) {
            stopWeatherLoop(effect);
            return;
        }

        Sound sound = weatherSounds.get(effect);
        if (sound != null) {
            Long currentId = loopingSoundIds.get(effect);

            if (currentId == null || !isPlaying(effect)) {
                // Start new loop
                long id = sound.loop(volume * soundVolume * masterVolume);
                loopingSoundIds.put(effect, id);
                loopingStartTimes.put(effect, System.currentTimeMillis());

                // Store duration based on effect type
                float duration = getEffectDuration(effect);
                loopingDurations.put(effect, duration);
            } else {
                // Update existing loop volume
                sound.setVolume(currentId, volume * soundVolume * masterVolume);
            }
        }
    }

    private float getEffectDuration(WeatherSoundEffect effect) {
        // Define durations for each effect (in seconds)
        switch (effect) {
            case LIGHT_RAIN:
            case WIND:
            case SAND_WIND:
                return 10.0f; // 10-second loop for ambient sounds
            case THUNDER:
                return 3.0f; // 3-second duration for thunder
            default:
                return 5.0f; // Default duration
        }
    }

    public void stopWeatherLoop(WeatherSoundEffect effect) {
        Sound sound = weatherSounds.get(effect);
        Long id = loopingSoundIds.get(effect);
        if (sound != null && id != null) {
            sound.stop(id);
            loopingSoundIds.remove(effect);
            loopingStartTimes.remove(effect);
            loopingDurations.remove(effect);
        }
    }

    public void stopAllWeatherLoops() {
        for (WeatherSoundEffect effect : WeatherSoundEffect.values()) {
            stopWeatherLoop(effect);
        }
    }

    private boolean isPlaying(WeatherSoundEffect effect) {
        Long startTime = loopingStartTimes.get(effect);
        Float duration = loopingDurations.get(effect);
        Long soundId = loopingSoundIds.get(effect);

        if (startTime == null || duration == null || soundId == null) {
            return false;
        }
        long currentTime = System.currentTimeMillis();
        long elapsedTime = currentTime - startTime;

        if (elapsedTime > duration * 1000) { // Convert duration to milliseconds
            loopingSoundIds.remove(effect);
            loopingStartTimes.remove(effect);
            return false;
        }

        return true;
    }

    public void playSound(AudioManager.SoundEffect effect) {
        if (!soundEnabled) return;

        Sound sound = sounds.get(effect);
        if (sound != null) {
            sound.play(soundVolume * masterVolume);
        }
    }

    private void initializeAudio() {
        // Load sound effects
        for (SoundEffect effect : SoundEffect.values()) {
            try {
                Sound sound = Gdx.audio.newSound(Gdx.files.internal(effect.getPath()));
                sounds.put(effect, sound);
            } catch (Exception e) {
                Gdx.app.error("AudioManager", "Failed to load sound: " + effect.getPath());
            }
        }
        menuMusicList = new ArrayList<>();
        loadMenuMusic(Arrays.asList(
            "music/Menu-Music-1.mp3",
            "music/Menu-Music-2.mp3",
            "music/Menu-Music-0.mp3",
            "music/Menu-Music-3.mp3",
            "music/Menu-Music-4.mp3"
        ));
        loadBiomeMusic(BiomeType.RUINS, (Arrays.asList("music/Ruins-Biome-0.mp3", "music/Ruins-Biome-1.mp3")));
        loadBiomeMusic(BiomeType.FOREST, (Arrays.asList("music/Forest-Biome-0.mp3", "music/Forest-Biome-1.mp3", "music/Forest-Biome-2.mp3", "music/Forest-Biome-3.mp3")));
        loadBiomeMusic(BiomeType.SNOW, (Arrays.asList("music/Snow-Biome-0.mp3", "music/Snow-Biome-1.mp3", "music/Snow-Biome-2.mp3")));
        loadBiomeMusic(BiomeType.HAUNTED, (Arrays.asList("music/Haunted-Biome-0.mp3", "music/Haunted-Biome-1.mp3")));
        loadBiomeMusic(BiomeType.PLAINS, (Arrays.asList("music/Plains-Biome-0.mp3", "music/Plains-Biome-1.mp3", "music/Plains-Biome-2.mp3", "music/Plains-Biome-3.mp3", "music/Plains-Biome-4.mp3")));
        loadBiomeMusic(BiomeType.BIG_MOUNTAINS, (Arrays.asList("music/Mountain-Biome-1.mp3", "music/Mountain-Biome-0.mp3")));
        loadBiomeMusic(BiomeType.RAIN_FOREST, (Arrays.asList("music/RainForest-Biome-0.mp3", "music/RainForest-Biome-1.mp3", "music/RainForest-Biome-2.mp3", "music/RainForest-Biome-3.mp3")));
        loadBiomeMusic(BiomeType.DESERT, (Arrays.asList("music/Desert-Biome-0.mp3", "music/Desert-Biome-1.mp3", "music/Desert-Biome-2.mp3", "music/Desert-Biome-3.mp3", "music/Desert-Biome-4.mp3")));

    }

    private void loadMenuMusic(List<String> paths) {
        for (String path : paths) {
            try {
                Music music = Gdx.audio.newMusic(Gdx.files.internal(path));
                music.setVolume(musicVolume * masterVolume);
                menuMusicList.add(music);
            } catch (Exception e) {
                Gdx.app.error("AudioManager", "Failed to load menu music: " + path + ", error: " + e.getMessage(), e);
            }
        }
    }

    private void loadBiomeMusic(BiomeType biome, List<String> paths) {
        List<Music> musicList = new ArrayList<>();
        for (String path : paths) {
            try {
                Music music = Gdx.audio.newMusic(Gdx.files.internal(path));
                music.setVolume(musicVolume * masterVolume);
                musicList.add(music);
            } catch (Exception e) {
                Gdx.app.error("AudioManager", "Failed to load music: " + path + ", error: " + e.getMessage(), e);
            }
        }
        biomeMusic.put(biome, musicList);
    }


    public void playMenuMusic() {
        if (musicEnabled && (currentMusic == null || !currentMusic.isPlaying())) {
            stopCurrentMusic();
            int index = MathUtils.random(menuMusicList.size() - 1);
            currentMusic = menuMusicList.get(index);
            currentBiome = null;
            currentMusic.setVolume(0f);
            currentMusic.setLooping(false);
            currentMusic.play();
            isFadingInMusic = true;
            fadeInMusicTimer = MUSIC_FADE_DURATION;
            setMusicCompletionListenerForMenu();
        }
    }

    private void setMusicCompletionListenerForMenu() {
        if (currentMusic != null) {
            currentMusic.setOnCompletionListener(music -> {
                // Play next menu music track
                playMenuMusic();
            });
        }
    }

    public void stopMenuMusic() {
        if (currentMusic != null && menuMusicList.contains(currentMusic)) {
            isFadingOutMusic = true;
            fadeOutMusicTimer = MUSIC_FADE_DURATION;
        }
    }

    public float getMusicVolume() {
        return musicVolume;
    }

    public void setMusicVolume(float musicVolume) {
        this.musicVolume = musicVolume;
        updateVolumes();
    }

    public float getSoundVolume() {
        return soundVolume;
    }

    public void setSoundVolume(float soundVolume) {
        this.soundVolume = soundVolume;
        // Optionally update volumes of looping sounds
        updateSoundVolumes();
    }

    public boolean isMusicEnabled() {
        return musicEnabled;
    }

    public void setMusicEnabled(boolean musicEnabled) {
        this.musicEnabled = musicEnabled;
        if (currentMusic != null) {
            if (musicEnabled) {
                if (!currentMusic.isPlaying()) {
                    currentMusic.play();
                }
                currentMusic.setVolume(musicVolume * masterVolume);
            } else {
                currentMusic.pause();
            }
        }
    }

    public boolean isSoundEnabled() {
        return soundEnabled;
    }

    public void setSoundEnabled(boolean soundEnabled) {
        this.soundEnabled = soundEnabled;
        if (!soundEnabled) {
            // Stop all playing sounds if necessary
            stopAllWeatherLoops();
            stopAllAmbientSounds();
        }
    }

    public void fadeOutMenuMusic() {
    }

    public void updateBiomeMusic(BiomeType newBiome) {
        if (!musicEnabled || (pendingBiome != null && newBiome == pendingBiome)) return;

        if (currentBiome != newBiome) {
            pendingBiome = newBiome;
            GameLogger.info("Pending biome set to: " + pendingBiome);

            if (currentMusic != null && menuMusicList.contains(currentMusic)) {
                isFadingOutMusic = true;
                fadeOutMusicTimer = MUSIC_FADE_DURATION;
            } else if (currentMusic == null || !currentMusic.isPlaying()) {
                startMusicForPendingBiome();
            }
        }
    }

    private void startMusicForPendingBiome() {
        if (pendingBiome != null) {
            List<Music> musicList = biomeMusic.get(pendingBiome);
            if (musicList != null && !musicList.isEmpty()) {
                int index = MathUtils.random(musicList.size() - 1);
                currentMusic = musicList.get(index);
                currentBiome = pendingBiome;
                pendingBiome = null;
                currentMusic.setVolume(0f); // Start from 0 volume for fade-in
                currentMusic.setLooping(false); // Don't loop so it can end naturally
                currentMusic.play();
                GameLogger.info("Started playing music for biome: " + currentBiome);
                setMusicCompletionListener();
                isFadingInMusic = true; // Flag to start fade-in
                fadeInMusicTimer = MUSIC_FADE_DURATION;
            } else {
                GameLogger.error("No music found for biome: " + pendingBiome);
                currentMusic = null;
                currentBiome = null;
                pendingBiome = null;
            }
        } else {
            currentMusic = null;
            currentBiome = null;
        }
    }


    public void update(float delta) {

        if (isFadingInMusic && currentMusic != null) {
            fadeInMusicTimer -= delta;
            float progress = 1 - Math.max(0, fadeInMusicTimer / MUSIC_FADE_DURATION);
            float volume = progress * musicVolume * masterVolume;
            currentMusic.setVolume(volume);

            if (fadeInMusicTimer <= 0) {
                isFadingInMusic = false;
                currentMusic.setVolume(musicVolume * masterVolume);
            }
        }
        if (isFadingOutMusic && currentMusic != null) {
            fadeOutMusicTimer -= delta;
            float volume = Math.max(0, (fadeOutMusicTimer / MUSIC_FADE_DURATION) * musicVolume * masterVolume);
            currentMusic.setVolume(volume);

            if (fadeOutMusicTimer <= 0) {
                currentMusic.stop();
                isFadingOutMusic = false;
                currentMusic = null;
                if (pendingBiome != null) {
                    startMusicForPendingBiome();
                } else if (menuMusicList.contains(null)) {
                    playMenuMusic();
                }
            }
        }
    }

    private void stopCurrentMusic() {
        if (currentMusic != null) {
            isFadingOutMusic = true;
            fadeOutMusicTimer = MUSIC_FADE_DURATION;
        }
    }


    private void setMusicCompletionListener() {
        if (currentMusic != null) {
            currentMusic.setOnCompletionListener(music -> {
                if (pendingBiome != null && pendingBiome != currentBiome) {
                    // Biome has changed, start music for new biome
                    startMusicForPendingBiome();
                } else {
                    // Biome hasn't changed, pick another random song from currentBiome
                    pendingBiome = currentBiome; // Ensure pendingBiome is set
                    startMusicForPendingBiome();
                }
            });
        }
    }

    public void dispose() {
        for (Sound sound : sounds.values()) {
            sound.dispose();
        }
        loopingStartTimes.clear();
        loopingDurations.clear();

        for (List<Music> musicList : biomeMusic.values()) {
            for (Music music : musicList) {
                music.dispose();
            }
        }
        biomeMusic.clear();
        for (Sound sound : customSounds.values()) {
            sound.dispose();
        }
        sounds.clear();
        biomeMusic.clear();
        customSounds.clear();
        for (Sound sound : weatherSounds.values()) {
            sound.dispose();
        }
        stopAllAmbientSounds();
        for (Sound sound : ambientSounds.values()) {
            sound.dispose();
        }
        ambientSounds.clear();
        weatherSounds.clear();
        loopingSoundIds.clear();
    }

    public enum AmbientSoundType {
        ;

        private final String path;

        AmbientSoundType(String path) {
            this.path = path;
        }

        public String getPath() {
            return path;
        }
    }


    public enum WeatherSoundEffect {
        LIGHT_RAIN("sounds/weather/rain.ogg"),
        THUNDER("sounds/weather/thunder.ogg"),
        WIND("sounds/weather/wind.ogg"),
        SAND_WIND("sounds/weather/sandwind.ogg");

        private final String path;

        WeatherSoundEffect(String path) {
            this.path = path;
        }

        public String getPath() {
            return path;
        }
    }

    public enum SoundEffect {
        ITEM_PICKUP("sounds/pickup.ogg"),
        MENU_SELECT("sounds/select.ogg"),
        MENU_BACK("sounds/back.ogg"),
        BATTLE_WIN("sounds/battle_win.ogg"),
        CRITICAL_HIT("sounds/critical_hit.ogg"),
        CURSOR_MOVE("sounds/cursor_move.ogg"),
        DAMAGE("sounds/damage.ogg"),
        COLLIDE("sounds/player-bump.ogg"),
        MOVE_SELECT("sounds/move_select.ogg"),
        NOT_EFFECTIVE("sounds/not_effective.ogg"),
        SUPER_EFFECTIVE("sounds/super_effective.ogg"),
        CRAFT("sounds/crafting.ogg"),
        BLOCK_PLACE_0("sounds/block_place_0.ogg"),
        BLOCK_PLACE_1("sounds/block_place_1.ogg"),
        BLOCK_PLACE_2("sounds/block_place_2.ogg"),
        BLOCK_BREAK_WOOD("sounds/break_wood.ogg"),
        TOOL_BREAK("sounds/tool_break.ogg"),
        BLOCK_BREAK_WOOD_HAND("sounds/break_wood_hand.ogg"),
        PUDDLE("sounds/puddle.ogg"),
        CHEST_OPEN("sounds/chest-open.ogg"),
        CHEST_CLOSE("sounds/chest-close.ogg"),
        HOUSE_BUILD("sounds/house_build.ogg");

        private final String path;

        SoundEffect(String path) {
            this.path = path;
        }

        public String getPath() {
            return path;
        }
    }
}

================
File: main/java/io/github/pokemeetup/blocks/BlockManager.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.BlockTextureManager;

public class BlockManager {
    private final World world;
    private boolean initialized = false;


    public BlockManager(World world) {
        this.world = world;
        GameLogger.info("Initialized BlockManager");
    }

    public boolean placeBlockFromPlayer(PlaceableBlock.BlockType type, Player player, World world) {
        if (type == null || player == null || world == null) {
            GameLogger.error("Invalid parameters for player block placement");
            return false;
        }

        Vector2 targetPos = calculateTargetPosition(player);
        int targetX = (int) targetPos.x;
        int targetY = (int) targetPos.y;

        GameLogger.info("Checking placement - Player(" + player.getTileX() + "," + player.getTileY() +
            ") Target(" + targetX + "," + targetY + ") Dir:" + player.getDirection());

        if (!isValidPlacement(targetX, targetY, world)) {
            return false;
        }

        if (world.getGameClient() != null && !world.getGameClient().isSinglePlayer()) {
            NetworkProtocol.BlockPlacement placement = new NetworkProtocol.BlockPlacement();
            placement.username = player.getUsername();
            placement.blockTypeId = type.id;
            placement.tileX = targetX;
            placement.tileY = targetY;
            placement.action = NetworkProtocol.BlockAction.PLACE;
            world.getGameClient().sendBlockPlacement(placement);
        }
        return placeBlock(type, targetX, targetY);
    }

    private Vector2 calculateTargetPosition(Player player) {
        int targetX = player.getTileX();
        int targetY = player.getTileY();

        switch (player.getDirection()) {
            case "up":
                targetY++;
                break;
            case "down":
                targetY--;
                break;
            case "left":
                targetX--;
                break;
            case "right":
                targetX++;
                break;
        }

        return new Vector2(targetX, targetY);
    }


    public PlaceableBlock getBlockAt(int worldX, int worldY) {
        Chunk chunk = world.getChunkAtPosition(worldX, worldY);
        if (chunk == null) return null;
        Vector2 blockPos = new Vector2(worldX, worldY);
        return chunk.getBlock(blockPos);
    }

    private boolean isValidPlacement(int tileX, int tileY, World world) {
        if (!world.isPassable(tileX, tileY)) {
            GameLogger.info("Cannot place at non-passable location");
            return false;
        }

        return true;
    }



    public boolean placeBlock(PlaceableBlock.BlockType type, int tileX, int tileY) {
        // Calculate the chunk position
        int chunkX = Math.floorDiv(tileX, Chunk.CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, Chunk.CHUNK_SIZE);
        Vector2 chunkPos = new Vector2(chunkX, chunkY);

        // Get or load the chunk
        Chunk chunk = world.getChunkAtPosition(tileX, tileY);
        if (chunk == null) {
            chunk = world.loadOrGenerateChunk(chunkPos);
            world.getChunks().put(chunkPos, chunk);
        }

        // Check if there's already a block at this position
        Vector2 blockPos = new Vector2(tileX, tileY);
        if (chunk.getBlock(blockPos) != null) {
            GameLogger.info("Block already exists at position: " + blockPos);
            return false; // Can't place block on top of another block
        }

        // Create the block
        PlaceableBlock block = new PlaceableBlock(type, blockPos, null, false);

        // Set the texture
        block.setTexture(BlockTextureManager.getBlockFrame(block, 0));

        // Add the block to the chunk
        chunk.addBlock(block);
        chunk.setDirty(true); // Mark chunk as dirty for saving
        GameLogger.info("Placed block of type " + type + " at " + blockPos);

        return true;
    }


    public void removeBlock(int tileX, int tileY) {
        // Calculate the chunk position
        int chunkX = Math.floorDiv(tileX, Chunk.CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, Chunk.CHUNK_SIZE);
        Vector2 chunkPos = new Vector2(chunkX, chunkY);

        // Get the chunk
        Chunk chunk = world.getChunkAtPosition(tileX, tileY);
        if (chunk == null) {
            GameLogger.info("Chunk not loaded at position: " + chunkPos);
            return;
        }

        // Check if there's a block at this position
        Vector2 blockPos = new Vector2(tileX, tileY);
        PlaceableBlock block = chunk.getBlock(blockPos);
        if (block == null) {
            GameLogger.info("No block exists at position: " + blockPos);
            return; // Can't remove a block that doesn't exist
        }

        // Remove the block from the chunk
        chunk.removeBlock(blockPos);
        chunk.setDirty(true); // Mark chunk as dirty for saving
        GameLogger.info("Removed block at " + blockPos);

    }

    public boolean isInitialized() {
        return initialized;
    }


    public boolean hasCollisionAt(int tileX, int tileY) {
        PlaceableBlock block = getBlockAt(tileX, tileY);
        return block != null && block.getType().hasCollision;
    }
    public void render(SpriteBatch batch, double worldTimeInMinutes) {
        for (Chunk chunk : world.getChunks().values()) {
            for (PlaceableBlock block : chunk.getBlocks().values()) {
                TextureRegion currentFrame = BlockTextureManager.getBlockFrame(
                    block, (float) worldTimeInMinutes
                );

                if (currentFrame != null) {
                    float tileX = block.getPosition().x * World.TILE_SIZE;
                    float tileY = block.getPosition().y * World.TILE_SIZE;
                    float blockWidth = currentFrame.getRegionWidth();
                    float blockHeight = currentFrame.getRegionHeight();
                    float offsetX = (World.TILE_SIZE - blockWidth) / 2;
                    float offsetY = 0;

                    Color originalColor = batch.getColor().cpy();

                    // Get light level for this block's position
                    Vector2 tilePos = block.getPosition();
                    Float lightLevel = world.getLightLevelAtTile(tilePos);

                    // Apply light level if it exists
                    if (lightLevel != null && lightLevel > 0) {
                        Color lightColor = new Color(1f, 0.8f, 0.6f, 1f);
                        Color baseColor = world.getCurrentWorldColor().cpy();
                        baseColor.lerp(lightColor, lightLevel * 0.7f);
                        batch.setColor(baseColor);
                    } else {
                        batch.setColor(world.getCurrentWorldColor());
                    }

                    // Handle flipped rendering
                    if (block.isFlipped()) {
                        batch.draw(currentFrame,
                            tileX + offsetX + blockWidth, // X position (offset + width for flip)
                            tileY + offsetY,              // Y position
                            -blockWidth,                  // Negative width for horizontal flip
                            blockHeight                   // Normal height
                        );
                    } else {
                        batch.draw(currentFrame,
                            tileX + offsetX,
                            tileY + offsetY,
                            blockWidth,
                            blockHeight
                        );
                    }

                    // Restore original color
                    batch.setColor(originalColor);
                }
            }
        }
    }

    public String getChunkKey(int tileX, int tileY) {
        int chunkX = tileX / World.CHUNK_SIZE;
        int chunkY = tileY / World.CHUNK_SIZE;
        return chunkX + "," + chunkY;
    }


}

================
File: main/java/io/github/pokemeetup/blocks/BuildingData.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.graphics.g2d.TextureRegion;

import java.util.HashMap;
import java.util.Map;

public class BuildingData {
    private final String id;
    private final String name;
    private final Map<String, Integer> requirements;
    private final BuildingTemplate template;
    private TextureRegion previewTexture;

    public void setPreviewTexture(TextureRegion texture) {
        this.previewTexture = texture;
    }

    public TextureRegion getPreviewTexture() {
        return previewTexture;
    }
    public BuildingData(String id, String name, BuildingTemplate template) {
        this.id = id;
        this.name = name;
        this.template = template;
        this.requirements = new HashMap<>();
    }

    public void addRequirement(String itemId, int amount) {
        requirements.put(itemId, amount);
    }

    public String getId() { return id; }
    public String getName() { return name; }
    public Map<String, Integer> getRequirements() { return requirements; }
    public BuildingTemplate getTemplate() { return template; }

    public static class BuildingSlot {
        public BuildingData buildingData;
        public boolean isLocked;

        public BuildingSlot(BuildingData data, boolean locked) {
            this.buildingData = data;
            this.isLocked = locked;
        }
    }
}

================
File: main/java/io/github/pokemeetup/blocks/BuildingTemplate.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class BuildingTemplate {
    private final int width;
    private final int height;
    private final BlockData[][] layout;

    public BuildingTemplate(int width, int height) {
        this.width = width;
        this.height = height;
        this.layout = new BlockData[width][height];
    }

    public static BuildingTemplate createWoodenHouse() {
        BuildingTemplate template = new BuildingTemplate(5, 4);

        template.setBlock(2, 0, new BlockData(PlaceableBlock.BlockType.WOODEN_DOOR, false));
        template.setBlock(0, 0, new BlockData(PlaceableBlock.BlockType.HOUSE_PART, false));
        template.setBlock(1, 0, new BlockData(PlaceableBlock.BlockType.HOUSE_PLANKS, false));
        template.setBlock(3, 0, new BlockData(PlaceableBlock.BlockType.HOUSE_PLANKS, true));
        template.setBlock(4, 0, new BlockData(PlaceableBlock.BlockType.HOUSE_PART, true));

        template.setBlock(0, 1, new BlockData(PlaceableBlock.BlockType.HOUSE_MIDDLE_PART, false));
        template.setBlock(1, 1, new BlockData(PlaceableBlock.BlockType.HOUSE_MIDDLE_PART_1, false));
        template.setBlock(2, 1, new BlockData(PlaceableBlock.BlockType.HOUSE_MIDDLE_PART_0, false));
        template.setBlock(3, 1, new BlockData(PlaceableBlock.BlockType.HOUSE_MIDDLE_PART_1, true));
        template.setBlock(4, 1, new BlockData(PlaceableBlock.BlockType.HOUSE_MIDDLE_PART, true));


        template.setBlock(0, 2, new BlockData(PlaceableBlock.BlockType.ROOFINNER, false));
        template.setBlock(1, 2, new BlockData(PlaceableBlock.BlockType.ROOF_MIDDLE_OUTSIDE, false));
        template.setBlock(2, 2, new BlockData(PlaceableBlock.BlockType.ROOF_MIDDLE_OUTER, false));
        template.setBlock(3, 2, new BlockData(PlaceableBlock.BlockType.ROOF_MIDDLE_OUTSIDE, true));
        template.setBlock(4, 2, new BlockData(PlaceableBlock.BlockType.ROOFINNER, true));


        template.setBlock(0, 3, new BlockData(PlaceableBlock.BlockType.ROOF_CORNER, false));
        template.setBlock(1, 3, new BlockData(PlaceableBlock.BlockType.ROOF_CORNER_1, false));
        template.setBlock(2, 3, new BlockData(PlaceableBlock.BlockType.ROOF_MIDDLE, false));
        template.setBlock(3, 3, new BlockData(PlaceableBlock.BlockType.ROOF_CORNER_1, true));
        template.setBlock(4, 3, new BlockData(PlaceableBlock.BlockType.ROOF_CORNER, true));

        return template;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    public BlockData[][] getLayout() {
        return layout;
    }

    public BlockData getBlockAt(int x, int y) {
        if (x < 0 || x >= width || y < 0 || y >= height) {
            return null;
        }
        return layout[x][y];
    }

    public void setBlock(int x, int y, BlockData blockData) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
            layout[x][y] = blockData;
        }
    }

    public boolean placeBuilding(World world, int startX, int startY) {
        // Check if area is clear
        if (!canPlaceAt(world, startX, startY)) {
            GameLogger.info("Cannot place building - area not clear");
            return false;
        }

        try {
            // Place all blocks
            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    BlockData blockData = layout[x][y];
                    if (blockData != null) {
                        // Create position for the block
                        Vector2 pos = new Vector2(startX + x, startY + y);
                        boolean placed = world.getBlockManager().placeBlock(blockData.type, startX + x, startY + y);
                        if (!placed) {
                            GameLogger.error("Failed to place block at " + pos + " of type " + blockData.type);
                            return false;
                        }

                        PlaceableBlock placedBlock = world.getBlockManager().getBlockAt(startX + x, startY + y);
                        if (placedBlock != null && blockData.isFlipped) {
                            placedBlock.toggleFlip();
                            // Mark the chunk as dirty so flipping is saved
                            int chunkX = Math.floorDiv((int)placedBlock.getPosition().x, World.CHUNK_SIZE);
                            int chunkY = Math.floorDiv((int)placedBlock.getPosition().y, World.CHUNK_SIZE);
                            Chunk chunk = world.getChunks().get(new Vector2(chunkX, chunkY));
                            if (chunk != null) {
                                chunk.setDirty(true);
                            }
                        }

                        GameLogger.info("Placed block: " + blockData.type + " at " + pos +
                            " flipped: " + blockData.isFlipped);
                    }
                }
            }
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.HOUSE_BUILD);
            return true;

        } catch (Exception e) {
            GameLogger.error("Error placing building: " + e.getMessage());
            return false;
        }
    }

    private boolean canPlaceAt(World world, int startX, int startY) {
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                if (!world.isPassable(startX + x, startY + y) ||
                    world.getBlockManager().getBlockAt(startX + x, startY + y) != null) {
                    return false;
                }
            }
        }
        return true;
    }

    public static class BlockData {
        public PlaceableBlock.BlockType type;
        public boolean isFlipped;

        public BlockData(PlaceableBlock.BlockType type, boolean isFlipped) {
            this.type = type;
            this.isFlipped = isFlipped;
        }
    }
}

================
File: main/java/io/github/pokemeetup/blocks/ConnectionPattern.java
================
package io.github.pokemeetup.blocks;

public class ConnectionPattern {
    public static final ConnectionPattern NONE = new ConnectionPattern(false, false, false, false);

    private final boolean north;
    private final boolean south;
    private final boolean east;
    private final boolean west;

    public ConnectionPattern(boolean north, boolean south, boolean east, boolean west) {
        this.north = north;
        this.south = south;
        this.east = east;
        this.west = west;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ConnectionPattern)) return false;
        ConnectionPattern that = (ConnectionPattern) o;
        return north == that.north &&
            south == that.south &&
            east == that.east &&
            west == that.west;
    }

    @Override
    public int hashCode() {
        int result = (north ? 1 : 0);
        result = 31 * result + (south ? 1 : 0);
        result = 31 * result + (east ? 1 : 0);
        result = 31 * result + (west ? 1 : 0);
        return result;
    }
}

================
File: main/java/io/github/pokemeetup/blocks/PlaceableBlock.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

public class PlaceableBlock {
    private static final float CHEST_ANIMATION_DURATION = 0.3f;
    private final String id;
    private final Vector2 position;
    private final BlockType type;
    private transient TextureRegion texture;
    private boolean isChestOpen = false;
    private float animationTime = 0;
    private ChestData chestData;
    private boolean isFlipped = false;

    public PlaceableBlock(BlockType type, Vector2 position, TextureRegion texture, boolean isFlipped) {
        this.type = type;
        this.id = type.id;
        this.isFlipped = isFlipped;
        this.position = position;
        this.texture = texture;
        if (type == BlockType.CHEST) {
            this.chestData = new ChestData((int) position.x, (int) position.y);
        }
    }

    public PlaceableBlock(BlockType type, Vector2 position) {
        this.type = type;
        this.position = position;
        this.texture = null;
        this.id = type.id;
    }

    public boolean isChestOpen() {
        return isChestOpen;
    }

    public void setChestOpen(boolean isOpen) {
        this.isChestOpen = isOpen;
    }

    public boolean isFlipped() {
        return isFlipped;
    }

    public void toggleFlip() {
        if (type.isFlippable) {
            isFlipped = !isFlipped;
        }
    }


    public void render(SpriteBatch batch, float x, float y) {
        if (type == BlockType.CHEST) {
            TextureRegion chestTexture = isChestOpen ?
                TextureManager.blocks.findRegion("chest", 1) :
                TextureManager.blocks.findRegion("chest", 0);
            float width = chestTexture.getRegionWidth();
            float height = chestTexture.getRegionHeight();

            if (isFlipped) {
                batch.draw(chestTexture,
                    x + width, y,        // Position (x + width for flip)
                    -width, height);     // Negative width for horizontal flip
            } else {
                batch.draw(chestTexture, x, y);
            }
        } else if (texture != null) {
            float width = texture.getRegionWidth();
            float height = texture.getRegionHeight();

            if (isFlipped) {
                batch.draw(texture,
                    x + width, y,        // Position (x + width for flip)
                    -width, height);     // Negative width for horizontal flip
            } else {
                batch.draw(texture, x, y);
            }
        }
    }

    public ChestData getChestData() {
        return chestData;
    }

    public void setChestData(ChestData chestData) {
        this.chestData = chestData;
    }

    public void update(float delta) {
        if (type == BlockType.CHEST) {
            if (isChestOpen) {
                animationTime = Math.min(animationTime + delta, CHEST_ANIMATION_DURATION);
            } else {
                animationTime = Math.max(animationTime - delta, 0);
            }
        }
    }

    public BlockType getType() {
        return type;
    }

    public Vector2 getPosition() {
        return position;
    }

    public TextureRegion getTexture() {
        return texture;
    }

    public void setTexture(TextureRegion texture) {
        this.texture = texture;
    }

    public String getId() {
        return id;
    }


    public enum BlockType {
        CRAFTINGTABLE("craftingtable", true, true, 4.0f, ItemManager.ItemIDs.CRAFTING_TABLE, false),
        WOODEN_PLANKS("wooden_planks", true, true, 3.0f, ItemManager.ItemIDs.WOODEN_PLANKS, true),
        HOUSE_PLANKS("house_planks", true, true, 3.0f, ItemManager.ItemIDs.HOUSE_PLANKS, true),
        WOODEN_DOOR("wooden_door", true, true, 3.0f, ItemManager.ItemIDs.WOODEN_DOOR, true),
        CHEST("chest", true, true, 4.0f, ItemManager.ItemIDs.CHEST, false),
        FURNACE("furnace", true, true, 8.0f, ItemManager.ItemIDs.FURNACE, false),
        ROOF_MIDDLE("roof_middle", true, true, 6.0f, ItemManager.ItemIDs.ROOF_MIDDLE, true),
        ROOF_CORNER("roof_corner", true, true, 3.0f, ItemManager.ItemIDs.ROOF_CORNER, true),
        HOUSE_PART("house_part", true, true, 3.0f, ItemManager.ItemIDs.HOUSE_PART, true),
        ROOF_INSIDE("roof_inside", true, true, 3.0f, ItemManager.ItemIDs.ROOF_INSIDE, true),
        HOUSE_MIDDLE_PART("house_midsection_part", true, true, 4.0f, ItemManager.ItemIDs.HOUSE_MIDDLE_PART, true),
        HOUSE_MIDDLE_PART_0("house_middlesection", true, true, 4.0f, ItemManager.ItemIDs.HOUSE_MIDDLE_PART_0, true),
        HOUSE_MIDDLE_PART_1("house_middlesection_part", true, true, 4.0f, ItemManager.ItemIDs.HOUSE_MIDDLE_PART_1, true),
        ROOF_CORNER_1("roof_middle_part", true, true, 4.0f, ItemManager.ItemIDs.ROOF_CORNER_1, true),
        ROOF_MIDDLE_OUTSIDE("roof_middle_outside", true, true, 4.0f, ItemManager.ItemIDs.ROOF_CORNER_1, true),
        ROOFINNER("roofinner", true, true, 3.0f, ItemManager.ItemIDs.ROOFINNER, true),
        ROOF_MIDDLE_OUTERSIDE("roof_middle_outerside", true, true, 4.0f, ItemManager.ItemIDs.ROOF_CORNER_1, true),
        ROOF_MIDDLE_OUTER("roof_middle_outer", true, true, 4.0f, ItemManager.ItemIDs.ROOF_CORNER_1, true);

        public final String id;
        public final boolean interactive;
        public final boolean isFlippable;
        public final boolean hasCollision;
        public final float breakTime;
        public final String itemId;

        BlockType(String id, boolean interactive, boolean hasCollision, float breakTime, String itemId, boolean isFlippable) {
            this.id = id;
            this.isFlippable = isFlippable;
            this.interactive = interactive;
            this.hasCollision = hasCollision;
            this.breakTime = breakTime;
            this.itemId = itemId;

        }

        public static BlockType fromId(String id) {
            for (BlockType type : values()) {
                if (type.id.equalsIgnoreCase(id)) {
                    return type;
                }
            }
            return null;
        }


        public static BlockType fromItemId(String itemId) {
            try {
                return valueOf(itemId.toUpperCase());
            } catch (IllegalArgumentException e) {
                for (BlockType type : values()) {
                    if (type.itemId.equalsIgnoreCase(itemId) ||
                        type.id.equalsIgnoreCase(itemId.replace("_item", ""))) {
                        return type;
                    }
                }
                GameLogger.error("No matching block type for item: " + itemId);
                return null;
            }
        }

        public float getBreakTime(boolean hasAxe) {
            return hasAxe ? breakTime * 0.5f : breakTime * 1.5f;
        }

        public String getId() {
            return id;
        }
    }

}

================
File: main/java/io/github/pokemeetup/blocks/SmartBlockConfig.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.utils.GameLogger;
import java.util.*;

public class SmartBlockConfig {
    private final Map<ConnectionPattern, PlaceableBlock.BlockType> variants = new HashMap<>();
    private final String groupId;

    public SmartBlockConfig(String groupId) {
        this.groupId = groupId;
    }

    public void addVariant(ConnectionPattern pattern, PlaceableBlock.BlockType blockType) {
        variants.put(pattern, blockType);
        GameLogger.info("Added variant for " + groupId + ": " + blockType.getId());
    }

    public PlaceableBlock.BlockType getVariantForPattern(ConnectionPattern pattern) {
        return variants.getOrDefault(pattern, getDefaultVariant());
    }

    public boolean containsBlockType(PlaceableBlock.BlockType blockType) {
        return variants.containsValue(blockType);
    }

    private PlaceableBlock.BlockType getDefaultVariant() {
        return variants.values().iterator().next();
    }

}

================
File: main/java/io/github/pokemeetup/blocks/SmartBuildingManager.java
================
package io.github.pokemeetup.blocks;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

public class SmartBuildingManager {
    private final World world;
    private final Map<String, SmartBlockConfig> smartBlocks = new HashMap<>();
    private final Map<String, BuildingTemplate> buildingTemplates = new HashMap<>();

    public SmartBuildingManager(World world) {
        this.world = world;
        initializeSmartBlocks();
        initializeBuildingTemplates();
    }

    private void initializeBuildingTemplates() {
        buildingTemplates.put("wooden_house", BuildingTemplate.createWoodenHouse());
    }

    public boolean placeBuilding(String templateId, int startX, int startY) {
        BuildingTemplate template = buildingTemplates.get(templateId);
        if (template == null) {
            GameLogger.error("No template found for: " + templateId);
            return false;
        }

        return template.placeBuilding(world, startX, startY);
    }

    private void initializeSmartBlocks() {
        // Initialize roof configuration
        SmartBlockConfig roofConfig = new SmartBlockConfig("roof");
        roofConfig.addVariant(new ConnectionPattern(false, true, true, true),
            PlaceableBlock.BlockType.ROOF_CORNER);
        roofConfig.addVariant(new ConnectionPattern(true, true, true, true),
            PlaceableBlock.BlockType.ROOF_MIDDLE);
        roofConfig.addVariant(new ConnectionPattern(true, false, true, true),
            PlaceableBlock.BlockType.ROOF_INSIDE);
        smartBlocks.put("roof", roofConfig);

        // Initialize wall configuration
        SmartBlockConfig wallConfig = new SmartBlockConfig("wall");
        wallConfig.addVariant(new ConnectionPattern(true, true, false, false),
            PlaceableBlock.BlockType.WOODEN_PLANKS);
        wallConfig.addVariant(new ConnectionPattern(false, true, true, true),
            PlaceableBlock.BlockType.HOUSE_MIDDLE_PART);
        smartBlocks.put("wall", wallConfig);

        GameLogger.info("Initialized smart block configurations");
    }

    public PlaceableBlock.BlockType getSmartBlockType(String groupId, int x, int y) {
        SmartBlockConfig config = smartBlocks.get(groupId);
        if (config == null) return null;

        ConnectionPattern pattern = calculateConnectionPattern(groupId, x, y);
        return config.getVariantForPattern(pattern);
    }

    private ConnectionPattern calculateConnectionPattern(String groupId, int x, int y) {
        boolean north = hasConnection(groupId, x, y + 1);
        boolean south = hasConnection(groupId, x, y - 1);
        boolean east = hasConnection(groupId, x + 1, y);
        boolean west = hasConnection(groupId, x - 1, y);

        return new ConnectionPattern(north, south, east, west);
    }

    private boolean hasConnection(String groupId, int x, int y) {
        PlaceableBlock block = world.getBlockManager().getBlockAt(x, y);
        if (block == null) return false;

        SmartBlockConfig config = smartBlocks.get(groupId);
        return config != null && config.containsBlockType(block.getType());
    }

    public void updateSurroundingBlocks(int x, int y, String groupId) {
        updateBlockIfNeeded(x + 1, y, groupId);
        updateBlockIfNeeded(x - 1, y, groupId);
        updateBlockIfNeeded(x, y + 1, groupId);
        updateBlockIfNeeded(x, y - 1, groupId);
    }

    private void updateBlockIfNeeded(int x, int y, String groupId) {
        PlaceableBlock existingBlock = world.getBlockManager().getBlockAt(x, y);
        if (existingBlock == null) return;

        SmartBlockConfig config = smartBlocks.get(groupId);
        if (config != null && config.containsBlockType(existingBlock.getType())) {
            PlaceableBlock.BlockType newType = getSmartBlockType(groupId, x, y);
            if (newType != null && newType != existingBlock.getType()) {
                world.getBlockManager().placeBlock(newType, x, y);
            }
        }
    }

    public String getGroupIdForBlockType(PlaceableBlock.BlockType blockType) {
        for (Map.Entry<String, SmartBlockConfig> entry : smartBlocks.entrySet()) {
            if (entry.getValue().containsBlockType(blockType)) {
                return entry.getKey();
            }
        }
        return null;
    }
}

================
File: main/java/io/github/pokemeetup/chat/ChatSystem.java
================
package io.github.pokemeetup.chat;

import com.badlogic.gdx.Application;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.TimeUtils;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class ChatSystem extends Table {
    public static final float CHAT_PADDING = 10f;
    public static final float MIN_CHAT_WIDTH = 300f;
    public static final float MIN_CHAT_HEIGHT = 200f;
    private static final int MAX_MESSAGES = 50;
    private static final float MESSAGE_FADE_TIME = 10f;
    private static final Color WINDOW_BACKGROUND = new Color(0, 0, 0, 0.8f);
    private static final Color[] CHAT_COLORS = {
        new Color(0.8f, 0.3f, 0.3f, 1), // Red
        new Color(0.3f, 0.8f, 0.3f, 1), // Green
        new Color(0.3f, 0.3f, 0.8f, 1), // Blue
        new Color(0.8f, 0.8f, 0.3f, 1), // Yellow
        new Color(0.8f, 0.3f, 0.8f, 1), // Purple
        new Color(0.3f, 0.8f, 0.8f, 1), // Cyan
        new Color(0.8f, 0.5f, 0.3f, 1), // Orange
        new Color(0.5f, 0.8f, 0.3f, 1)  // Lime
    };
    private final List<String> messageHistory = new ArrayList<>();
    private final Stage stage;
    private final Skin skin;
    private final GameClient gameClient;
    private final String username;
    private final Queue<ChatMessage> messages;
    private final boolean battleMode = false;
    private final CommandManager commandManager;
    boolean commandsEnabled;
    private int messageHistoryIndex = -1; // Initialize to -1 to indicate no history selected
    private Table chatWindow;
    private String currentInputBeforeHistory = "";
    private ScrollPane messageScroll;
    private Table messageTable;
    private boolean isActive;
    private float inactiveTimer;
    private boolean isInitialized = false;
    private TextField inputField;

    public ChatSystem(Stage stage, Skin skin, GameClient gameClient, String username, CommandManager commandManager, boolean commandsEnabled) {
        this.stage = stage;
        this.skin = skin;
        this.gameClient = gameClient;
        this.username = username;
        this.messages = new LinkedList<>();
        this.commandsEnabled = commandsEnabled;
        this.commandManager = commandManager;

        createChatUI();
        setupChatHandler();
        setupInputHandling();
    }

    @Override
    public void act(float delta) {
        super.act(delta);
        update(delta);
    }

    public void setSize(float width, float height) {

        if (chatWindow != null) {
            chatWindow.setSize(width, height);

            // Update message scroll size
            if (messageScroll != null) {
                messageScroll.setSize(width, height - 40); // Leave room for input
            }

            // Force layout update
            chatWindow.invalidateHierarchy();
        }
    }

    public void setPosition(float x, float y) {
        if (chatWindow != null) {
            chatWindow.setPosition(x, y);
        }
    }

    public void resize(int width, int height) {
        float chatWidth = Math.max(MIN_CHAT_WIDTH, width * 0.25f);
        float chatHeight = Math.max(MIN_CHAT_HEIGHT, height * 0.3f);

        chatWindow.setSize(chatWidth, chatHeight);
        chatWindow.setPosition(
            CHAT_PADDING,
            height - chatHeight - CHAT_PADDING
        );
    }

    public boolean isActive() {
        return isActive;
    }

    private void setupChatHandler() {
        gameClient.setChatMessageHandler(this::handleIncomingMessage);
    }


    public void sendMessage(String content) {
        GameLogger.info("sendMessage called with content: " + content);
        if (content.isEmpty()) return;
        if (messageHistory.isEmpty() || !content.equals(messageHistory.get(messageHistory.size() - 1))) {
            messageHistory.add(content);
            messageHistoryIndex = messageHistory.size();
            GameLogger.info("Added message to history. Size: " + messageHistory.size() + ", Index: " + messageHistoryIndex);
        }
        if (content.startsWith("/")) {
            GameLogger.info("Command detected. Commands enabled: " + commandsEnabled);
            if (commandsEnabled || !gameClient.isSinglePlayer()) {
                String command = content.substring(1);
                String[] parts = command.split(" ", 2);
                String commandName = parts[0].toLowerCase();
                String args = parts.length > 1 ? parts[1] : "";

                GameLogger.info("Processing command: " + commandName + " with args: " + args);




                if (commandManager != null) {
                    Command cmd = commandManager.getCommand(commandName);
                    if (cmd != null) {
                        try {
                            GameLogger.info("Executing command: " + commandName);
                            cmd.execute(args, gameClient, this);
                            return;
                        } catch (Exception e) {
                            GameLogger.error("Command execution failed: " + e.getMessage());
                            addSystemMessage("Error executing command: " + e.getMessage());
                            return;
                        }
                    } else {
                        GameLogger.info("Unknown command: " + commandName);
                        addSystemMessage("Unknown command: " + commandName);
                        return;
                    }
                } else {
                    GameLogger.error("CommandManager is null!");
                    addSystemMessage("Command system not initialized!");
                    return;
                }
            } else {
                GameLogger.info("Commands are disabled!");
                addSystemMessage("Commands are currently disabled.");
                return;
            }
        }

        NetworkProtocol.ChatMessage chatMessage = new NetworkProtocol.ChatMessage();
        chatMessage.sender = username;
        chatMessage.content = content;
        chatMessage.timestamp = System.currentTimeMillis();
        chatMessage.type = NetworkProtocol.ChatType.NORMAL;

        if (gameClient.isSinglePlayer()) {
            handleIncomingMessage(chatMessage);
        } else {
            handleIncomingMessage(chatMessage);
            gameClient.sendMessage(chatMessage);
        }
    }


    public void addSystemMessage(String message) {
        NetworkProtocol.ChatMessage chatMessage = new NetworkProtocol.ChatMessage();
        chatMessage.sender = "System";
        chatMessage.content = message;
        chatMessage.timestamp = System.currentTimeMillis();
        chatMessage.type = NetworkProtocol.ChatType.SYSTEM;
        handleIncomingMessage(chatMessage);
    }


    public void handleIncomingMessage(NetworkProtocol.ChatMessage message) {
        Gdx.app.postRunnable(() -> addMessageToChat(message));
    }



    public void activateChat() {
        isActive = true;
        inputField.setVisible(true);
        inputField.setText("");
        messageHistoryIndex = messageHistory.size(); // Start at end of history
        inactiveTimer = 0;
        chatWindow.getColor().a = 1f;

        Gdx.app.postRunnable(() -> {
            stage.setKeyboardFocus(inputField);
            GameLogger.info("Chat activated: Keyboard focus set to inputField");
        });
    }


    public void deactivateChat() {
        isActive = false;
        inputField.setVisible(false);
        stage.setKeyboardFocus(null);
        if (Gdx.app.getType() == Application.ApplicationType.Android) {
            Gdx.input.setOnscreenKeyboardVisible(false);
        }
        GameLogger.info("Chat deactivated");
    }

    private void update(float delta) {
        if (!isActive) {
            inactiveTimer += delta;
            if (inactiveTimer > MESSAGE_FADE_TIME) {
                chatWindow.getColor().a = Math.max(0.3f, 1 - (inactiveTimer - MESSAGE_FADE_TIME) / 2f);
            }
        }

        while (messages.size() > MAX_MESSAGES) {
            ((LinkedList<ChatMessage>) messages).removeFirst();
            messageTable.getChildren().first().remove();
        }
    }

    private void createChatUI() {
        if (isInitialized) {
            return;
        }

        chatWindow = new Table();

        // Create background
        Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        pixmap.setColor(WINDOW_BACKGROUND);
        pixmap.fill();
        TextureRegion bgTexture = new TextureRegion(new Texture(pixmap));
        pixmap.dispose();

        chatWindow.setBackground(new TextureRegionDrawable(bgTexture));

        // Create content table with padding
        Table contentTable = new Table();
        contentTable.pad(10);

        // Create message area
        messageTable = new Table();
        messageScroll = new ScrollPane(messageTable, skin);
        messageScroll.setFadeScrollBars(false);
        messageScroll.setScrollingDisabled(true, false);
        contentTable.add(messageScroll).expand().fill().padBottom(5).row();

        // Create input field
        TextField.TextFieldStyle textFieldStyle = new TextField.TextFieldStyle(skin.get(TextField.TextFieldStyle.class));
        textFieldStyle.background = skin.newDrawable("white", new Color(0.2f, 0.2f, 0.2f, 0.8f));
        textFieldStyle.fontColor = Color.WHITE;
        textFieldStyle.cursor = skin.newDrawable("white", Color.WHITE);

        inputField = new TextField("", textFieldStyle);
        inputField.setMessageText("Press T to chat...");
        inputField.setTouchable(Touchable.enabled);

        // Remove all other input listeners and add a single, focused one
        inputField.addCaptureListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (!isActive) return false;

                GameLogger.info("Chat input keyDown captured: " + Input.Keys.toString(keycode));

                switch (keycode) {
                    case Input.Keys.UP:
                        if (!messageHistory.isEmpty()) {
                            if (messageHistoryIndex > 0) {
                                messageHistoryIndex--;
                                String message = messageHistory.get(messageHistoryIndex);
                                inputField.setText(message);
                                inputField.setCursorPosition(message.length());
                                GameLogger.info("Up pressed - Showing message: " + message + " (index: " + messageHistoryIndex + ")");
                            }
                        }
                        event.stop();
                        return true;

                    case Input.Keys.DOWN:
                        if (!messageHistory.isEmpty()) {
                            if (messageHistoryIndex < messageHistory.size() - 1) {
                                messageHistoryIndex++;
                                String message = messageHistory.get(messageHistoryIndex);
                                inputField.setText(message);
                                inputField.setCursorPosition(message.length());
                                GameLogger.info("Down pressed - Showing message: " + message + " (index: " + messageHistoryIndex + ")");
                            } else {
                                // At the end of history, clear the field
                                messageHistoryIndex = messageHistory.size();
                                inputField.setText("");
                                GameLogger.info("Down pressed - End of history, clearing input");
                            }
                        }
                        event.stop();
                        return true;

                    case Input.Keys.ENTER:
                        String content = inputField.getText().trim();
                        if (!content.isEmpty()) {
                            sendMessage(content);
                            inputField.setText("");
                        }
                        deactivateChat();
                        event.stop();
                        return true;

                    case Input.Keys.ESCAPE:
                        deactivateChat();
                        event.stop();
                        return true;
                }
                return false;
            }

            @Override
            public boolean keyTyped(InputEvent event, char character) {
                if (character != '\0' && character != '\r' && character != '\n') {
                    messageHistoryIndex = messageHistory.size();
                }
                return false;
            }
        });

        // Remove all other input handlers except for the simple click listener for mobile
        chatWindow.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (Gdx.app.getType() == Application.ApplicationType.Android) {
                    if (!isActive) {
                        activateChat();
                        Gdx.input.setOnscreenKeyboardVisible(true);
                    }
                }
            }
        });

        contentTable.add(inputField).expandX().fillX().height(30);
        chatWindow.add(contentTable).expand().fill();
        stage.addActor(chatWindow);

        inputField.setVisible(false);
        isInitialized = true;
    }

    private Color getSenderColor(String sender) {
        int colorIndex = Math.abs(sender.hashCode()) % CHAT_COLORS.length;
        return CHAT_COLORS[colorIndex];
    }

    private void addMessageToChat(NetworkProtocol.ChatMessage message) {
        Table messageEntry = new Table();
        messageEntry.pad(5);

        Label.LabelStyle timeStyle = new Label.LabelStyle(skin.get(Label.LabelStyle.class));
        timeStyle.fontColor = Color.GRAY;

        Label.LabelStyle nameStyle = new Label.LabelStyle(skin.get(Label.LabelStyle.class));
        nameStyle.fontColor = getSenderColor(message.sender);

        Label.LabelStyle contentStyle = new Label.LabelStyle(skin.get(Label.LabelStyle.class));
        contentStyle.fontColor = Color.WHITE;

        Label timeLabel = new Label(TimeUtils.formatTime(message.timestamp), timeStyle);
        Label nameLabel = new Label(message.sender + ": ", nameStyle);
        Label contentLabel = new Label(message.content, contentStyle);
        contentLabel.setWrap(true);

        messageEntry.add(timeLabel).padRight(5);
        messageEntry.add(nameLabel).padRight(5);
        messageEntry.add(contentLabel).expandX().fillX();

        messages.add(new ChatMessage(message));
        messageTable.add(messageEntry).expandX().fillX().padBottom(2).row();

        messageScroll.scrollTo(0, 0, 0, 0);
        chatWindow.getColor().a = 1f;
        inactiveTimer = 0;
    }


    private void setupInputHandling() {
        stage.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (battleMode) {
                    return false;
                }

                if (isActive) {
                    // Handle message history navigation
                    if (keycode == Input.Keys.UP) {
                        navigateMessageHistory(-1);
                        return true;
                    } else if (keycode == Input.Keys.DOWN) {
                        navigateMessageHistory(1);
                        return true;
                    }
                }

                // Activate chat on T or / when not active
                if (!isActive && (keycode == Input.Keys.T || keycode == Input.Keys.SLASH)) {
                    activateChat();
                    if (keycode == Input.Keys.SLASH) {
                        inputField.setText("/");
                    }
                    event.cancel();
                    GameLogger.info("Chat activation key pressed: " + Input.Keys.toString(keycode));
                    return true;
                }

                // Handle escape to close chat
                if (isActive && keycode == Input.Keys.ESCAPE) {
                    deactivateChat();
                    event.cancel();
                    GameLogger.info("Chat deactivation key pressed: ESCAPE");
                    return true;
                }

                return false;
            }
        });

        inputField.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (keycode == Input.Keys.UP) {
                    navigateMessageHistory(-1);
                    return true;
                } else if (keycode == Input.Keys.DOWN) {
                    navigateMessageHistory(1);
                    return true;
                }
                return false;
            }

            @Override
            public boolean keyTyped(InputEvent event, char character) {
                // Reset history index when typing new text
                if (character != '\0' && character != '\r' && character != '\n') {
                    messageHistoryIndex = messageHistory.size();
                }
                return false;
            }
        });
        chatWindow.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (Gdx.app.getType() == Application.ApplicationType.Android) {
                    if (!isActive) {
                        activateChat();
                        Gdx.input.setOnscreenKeyboardVisible(true);
                    }
                }
            }
        });

    }


    private void navigateMessageHistory(int direction) {
        if (messageHistory.isEmpty()) {
            return;
        }

        // Store current input if we're at the end of history
        if (messageHistoryIndex == messageHistory.size() && direction < 0) {
            String currentInput = inputField.getText();
            if (!currentInput.isEmpty()) {
                messageHistory.add(currentInput);
            }
        }

        // Calculate new index
        messageHistoryIndex += direction;

        // Clamp index to valid range
        if (messageHistoryIndex < 0) {
            messageHistoryIndex = 0;
        } else if (messageHistoryIndex >= messageHistory.size()) {
            messageHistoryIndex = messageHistory.size();
            inputField.setText("");
            return;
        }

        // Set text and cursor position
        String historicalMessage = messageHistory.get(messageHistoryIndex);
        inputField.setText(historicalMessage);
        inputField.setCursorPosition(historicalMessage.length());

        GameLogger.info("Navigating message history: index=" + messageHistoryIndex +
            ", total messages=" + messageHistory.size());
    }

    private static class ChatMessage {
        public final String sender;
        public final String content;
        public final long timestamp;

        public ChatMessage(NetworkProtocol.ChatMessage message) {
            this.sender = message.sender;
            this.content = message.content;
            this.timestamp = message.timestamp;
        }
    }

}

================
File: main/java/io/github/pokemeetup/chat/Command.java
================
package io.github.pokemeetup.chat;

import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.system.Player;

public interface Command {
    String getName();
    String[] getAliases();
    String getDescription();
    String getUsage();
    boolean isMultiplayerOnly();
    void execute(String args, GameClient player, ChatSystem chatSystem);
}

================
File: main/java/io/github/pokemeetup/chat/CommandManager.java
================
package io.github.pokemeetup.chat;

import io.github.pokemeetup.utils.GameLogger;

import java.util.HashMap;
import java.util.Map;

public class CommandManager {
    private final Map<String, Command> commands = new HashMap<>();


    public Command getCommand(String name) {
        if (name == null) {
            GameLogger.error("Attempted to get null command name");
            return null;
        }
        Command cmd = commands.get(name.toLowerCase());
        if (cmd == null) {
            GameLogger.info("Command not found: " + name);
        }
        return cmd;
    }

    public int getRegisteredCommandCount() {
        return commands.size();
    }

    public boolean hasCommand(String name) {
        return commands.containsKey(name.toLowerCase());
    }
    public void registerCommand(Command command) {
        if (command == null) {
            GameLogger.error("Attempted to register null command");
            return;
        }
        commands.put(command.getName().toLowerCase(), command);
        for (String alias : command.getAliases()) {
            commands.put(alias.toLowerCase(), command);
        }
        GameLogger.info("Registered command: " + command.getName() +
            " with " + command.getAliases().length + " aliases");
    }
}

================
File: main/java/io/github/pokemeetup/chat/commands/GiveCommand.java
================
package io.github.pokemeetup.chat.commands;

import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.Command;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.utils.storage.InventoryConverter;

public class GiveCommand implements Command {

    @Override
    public String getName() {
        return "give";
    }

    @Override
    public String[] getAliases() {
        return new String[0];
    }

    @Override
    public String getDescription() {
        return "gives item to player";
    }

    @Override
    public String getUsage() {
        return "/give <item> <amount> || Optional: <player>";
    }

    @Override
    public boolean isMultiplayerOnly() {
        return false;
    }

    @Override
    public void execute(String args, GameClient gameClient, ChatSystem chatSystem) {
        String[] argsArray = args.split(" ");

        if (argsArray.length != 2) {
            chatSystem.addSystemMessage("Usage: /give <item> <amount>");
            return;
        }

        String itemId = argsArray[0];
        try {
            int count = Integer.parseInt(argsArray[1]);
            ItemData item = InventoryConverter.itemToItemData(ItemManager.getItem(itemId));

            if (item == null) {
                chatSystem.addSystemMessage("Item " + itemId + " not found");
                return;
            }

            if (count <= 0 || count > 64) {
                chatSystem.addSystemMessage("Invalid count; must be between 1 and 64");
                return;
            }

            item.setCount(count);
            boolean added = GameContext.get().getPlayer().getInventory().addItem(item);

            if (added) {
                chatSystem.addSystemMessage("You got " + count + "x " + itemId);
            } else {
                chatSystem.addSystemMessage("Inventory full! Could not add item.");
            }

        } catch (NumberFormatException e) {
            chatSystem.addSystemMessage("Invalid number format: " + argsArray[1]);
        } catch (Exception e) {
            chatSystem.addSystemMessage("Error executing command: " + e.getMessage());
        }
    }
}

================
File: main/java/io/github/pokemeetup/chat/commands/SetWorldSpawnCommand.java
================
package io.github.pokemeetup.chat.commands;

import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.Command;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class SetWorldSpawnCommand implements Command {

    @Override
    public String getName() {
        return "setSpawn";
    }

    @Override
    public String[] getAliases() {
        return new String[0];
    }

    @Override
    public String getDescription() {
        return "sets the world spawn to the player";
    }

    @Override
    public String getUsage() {
        return "/setSpawn";
    }

    @Override
    public boolean isMultiplayerOnly() {
        return false;
    }

    @Override
    public void execute(String args, GameClient gameClient, ChatSystem chatSystem) {
        String[] argsArray = args.split(" ");

        try {
            GameLogger.info("Executing setSpawn command...");

            Player player = GameContext.get().getPlayer();
            if (player == null) {
                chatSystem.addSystemMessage("Error: Player not found");
                return;
            }

            World currentWorld = GameContext.get().getWorld();
            if (currentWorld == null) {
                chatSystem.addSystemMessage("Error: World not found");
                return;
            }

            if (currentWorld.getWorldData() == null || currentWorld.getWorldData().getConfig() == null) {
                chatSystem.addSystemMessage("Error: World configuration not available");
                return;
            }

            if (argsArray.length > 2) {
                chatSystem.addSystemMessage("Invalid arguments: " + getUsage());
                return;
            }

            int tileX = player.getTileX();
            int tileY = player.getTileY();

            if (argsArray.length == 2) {
                tileX = Integer.parseInt(argsArray[0]);
                tileY = Integer.parseInt(argsArray[1]);
            }

            currentWorld.getWorldData().getConfig().setTileSpawnX(tileX);
            currentWorld.getWorldData().getConfig().setTileSpawnY(tileY);

            chatSystem.addSystemMessage("You set the world's spawn coords to " + tileX + " " + tileY);
        } catch (Exception e) {
            GameLogger.error("Error executing spawn command: " + e.getMessage());
        }
    }
}

================
File: main/java/io/github/pokemeetup/chat/commands/SpawnCommand.java
================
package io.github.pokemeetup.chat.commands;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.Command;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class SpawnCommand implements Command {

    @Override
    public String getName() { return "spawn"; }

    @Override
    public String[] getAliases() { return new String[0]; }

    @Override
    public String getDescription() { return "teleports player to spawn"; }

    @Override
    public String getUsage() { return "/spawn"; }

    @Override
    public boolean isMultiplayerOnly() { return false; }

    @Override
    public void execute(String args, GameClient gameClient, ChatSystem chatSystem) {
        try {
            GameLogger.info("Executing spawn command...");

            Player player = GameContext.get().getPlayer();
            if (player == null) {
                chatSystem.addSystemMessage("Error: Player not found");
                return;
            }

            World currentWorld = GameContext.get().getWorld();

            if (currentWorld == null) {
                chatSystem.addSystemMessage("Error: World not found");
                return;
            }

            if (currentWorld.getWorldData() == null || currentWorld.getWorldData().getConfig() == null) {
                chatSystem.addSystemMessage("Error: World configuration not available");
                return;
            }

            int tileX = currentWorld.getWorldData().getConfig().getTileSpawnX();
            int tileY = currentWorld.getWorldData().getConfig().getTileSpawnY();

            float pixelX = tileX * World.TILE_SIZE;
            float pixelY = tileY * World.TILE_SIZE;

            player.getPosition().set(pixelX, pixelY);

            player.setMoving(false);

            player.setTileX(tileX);
            player.setTileY(tileY);
            player.setX(pixelX);
            player.setY(pixelY);

            player.setDirection(player.getDirection());
            player.setRenderPosition(new Vector2(pixelX, pixelY));
            player.setMoving(false);

            player.validateResources();
            currentWorld.setPlayer(player);

            if (!gameClient.isSinglePlayer()) {
                gameClient.sendPlayerUpdate();
                gameClient.savePlayerState(player.getPlayerData());
            }
            chatSystem.addSystemMessage("Teleported to spawn point! (" + tileX + ", " + tileY + ")");
            GameLogger.info("Player successfully teleported to spawn: " + pixelX + "," + pixelY);

        } catch (Exception e) {
            GameLogger.error("Spawn command failed: " + e.getMessage());
            chatSystem.addSystemMessage("Error executing spawn command: " + e.getMessage());
        }
    }
}

================
File: main/java/io/github/pokemeetup/chat/commands/TeleportManager.java
================
package io.github.pokemeetup.chat.commands;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class TeleportManager {
    private final Map<String, TeleportRequest> pendingRequests = new ConcurrentHashMap<>();
    private static final long REQUEST_TIMEOUT = 60000; // 60 seconds

    public static class TeleportRequest {
        public final String from;
        public final String to;
        public final long timestamp;

        public TeleportRequest(String from, String to) {
            this.from = from;
            this.to = to;
            this.timestamp = System.currentTimeMillis();
        }

        public boolean isExpired() {
            return System.currentTimeMillis() - timestamp > REQUEST_TIMEOUT;
        }
    }

    public void addRequest(String from, String to) {
        cleanExpiredRequests();
        pendingRequests.put(from, new TeleportRequest(from, to));
    }

    public TeleportRequest getRequest(String from) {
        return pendingRequests.get(from);
    }

    public void removeRequest(String from) {
        pendingRequests.remove(from);
    }

    private void cleanExpiredRequests() {
        pendingRequests.entrySet().removeIf(entry -> entry.getValue().isExpired());
    }
}

================
File: main/java/io/github/pokemeetup/chat/commands/TeleportPositionCommand.java
================
package io.github.pokemeetup.chat.commands;

import com.badlogic.gdx.math.Vector2;

import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.Command;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class TeleportPositionCommand implements Command {
    @Override
    public String getName() {
        return "tp";
    }

    @Override
    public String[] getAliases() {
        return new String[0];
    }

    @Override
    public String getDescription() {
        return "teleports user to specified location";
    }

    @Override
    public String getUsage() {
        return "tp <x> <y>";
    }

    @Override
    public boolean isMultiplayerOnly() {
        return false;
    }

    @Override
    public void execute(String args, GameClient gameClient, ChatSystem chatSystem) {
        String[] argsArray = args.split(" ");

        try {
            GameLogger.info("Executing tp command...");

            Player player = GameContext.get().getPlayer();
            if (player == null) {
                chatSystem.addSystemMessage("Error: Player not found");
                return;
            }

            World currentWorld = GameContext.get().getWorld();

            if (currentWorld == null) {
                chatSystem.addSystemMessage("Error: World not found");
                return;
            }

            if (currentWorld.getWorldData() == null || currentWorld.getWorldData().getConfig() == null) {
                chatSystem.addSystemMessage("Error: World configuration not available");
                return;
            }

            if (argsArray.length != 2) {
                chatSystem.addSystemMessage("Invalid arguments. Use: " + getUsage());
                return;
            }

            int tileX = Integer.parseInt(argsArray[0]);
            int tileY = Integer.parseInt(argsArray[1]);

            float pixelX = tileX * World.TILE_SIZE;
            float pixelY = tileY * World.TILE_SIZE;

            player.getPosition().set(pixelX, pixelY);

            player.setMoving(false);

            player.setTileX(tileX);
            player.setTileY(tileY);
            player.setX(pixelX);
            player.setY(pixelY);

            player.setDirection(player.getDirection());
            player.setRenderPosition(new Vector2(pixelX, pixelY));
            player.setMoving(false);

            player.validateResources();
            currentWorld.setPlayer(player);

        } catch (Exception e) {
            GameLogger.error("Error executing tp command: " + e.getMessage());
        }
    }
}

================
File: main/java/io/github/pokemeetup/context/GameContext.java
================
package io.github.pokemeetup.context;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.scenes.scene2d.Stage;

import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.screens.ChestScreen;
import io.github.pokemeetup.screens.CraftingTableScreen;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.screens.InventoryScreen;
import io.github.pokemeetup.screens.otherui.BuildModeUI;
import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.screens.otherui.GameMenu;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.battle.BattleSystemHandler;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;

public final class GameContext {

    private static GameContext instance;

    private final CreatureCaptureGame game;
    private final ChatSystem chatSystem;
    private final BattleSystemHandler battleSystem;
    private GameClient gameClient;
    private World world;
    private Player player;
    private SpriteBatch batch;
    private SpriteBatch uiBatch;
    private Stage uiStage;
    private Stage battleStage;
    private InventoryScreen inventoryScreen;
    private BuildModeUI buildModeUI;
    private ChestScreen chestScreen;
    private CraftingTableScreen craftingScreen;
    private GameMenu gameMenu;
    private WorldManager worldManager;
    private GameScreen gameScreen;

    /**
     * Private constructor to enforce singleton usage.
     */
    private GameContext(
        CreatureCaptureGame game,
        GameClient gameClient,
        World world,
        Player player,
        SpriteBatch batch,
        SpriteBatch uiBatch,
        Stage uiStage,
        Stage battleStage,
        ChatSystem chatSystem,
        BattleSystemHandler battleSystem,
        InventoryScreen inventoryScreen,
        BuildModeUI buildModeUI,
        CraftingTableScreen craftingScreen,
        GameMenu gameMenu,
        ChestScreen chestScreen, WorldManager worldManager,
        GameScreen gameScreen
    ) {
        this.game = game;
        this.gameClient = gameClient;
        this.world = world;
        this.player = player;
        this.batch = batch;
        this.uiBatch = uiBatch;
        this.uiStage = uiStage;
        this.battleStage = battleStage;
        this.chatSystem = chatSystem;
        this.battleSystem = battleSystem;
        this.inventoryScreen = inventoryScreen;
        this.buildModeUI = buildModeUI;
        this.craftingScreen = craftingScreen;
        this.gameMenu = gameMenu;
        this.chestScreen = chestScreen;
        this.worldManager = worldManager;
        this.gameScreen = gameScreen;
    }

    public static void init(
        CreatureCaptureGame game,
        GameClient gameClient,
        World world,
        Player player,
        SpriteBatch batch,
        SpriteBatch uiBatch,
        Stage uiStage,
        Stage battleStage,
        ChatSystem chatSystem,
        BattleSystemHandler battleSystem,
        InventoryScreen inventoryScreen,
        BuildModeUI buildModeUI,
        CraftingTableScreen craftingScreen,
        GameMenu gameMenu,
        ChestScreen chestScreen,WorldManager worldManager,
        GameScreen gameScreen
    ) {
        if (instance != null) {
            throw new IllegalStateException("GameContext already initialized!");
        }
        instance = new GameContext(
            game,
            gameClient,
            world,
            player,
            batch,
            uiBatch,
            uiStage,
            battleStage,
            chatSystem,
            battleSystem,
            inventoryScreen,
            buildModeUI,
            craftingScreen,
            gameMenu,
            chestScreen,worldManager,gameScreen
        );
    }

    /**
     * Returns the singleton instance of the GameContext. Make sure {@link #(...)}
     * has been called first.
     */
    public static GameContext get() {
        if (instance == null) {
            throw new IllegalStateException("GameContext not initialized yet!");
        }
        return instance;
    }

    public CraftingTableScreen getCraftingScreen() {
        return craftingScreen;
    }

    public void setCraftingScreen(CraftingTableScreen craftingScreen) {
        this.craftingScreen = craftingScreen;
    }

    public GameScreen getGameScreen() {
        return gameScreen;
    }

    public void setGameScreen(GameScreen gameScreen) {
        this.gameScreen = gameScreen;
    }

    public GameMenu getGameMenu() {
        return gameMenu;
    }

    public WorldManager getWorldManager() {
        return worldManager;
    }

    public void setWorldManager(WorldManager worldManager) {
        this.worldManager = worldManager;
    }

    public void setGameMenu(GameMenu gameMenu) {
        this.gameMenu = gameMenu;
    }

    public CreatureCaptureGame getGame() {
        return game;
    }

    public GameClient getGameClient() {
        return gameClient;
    }

    public void setGameClient(GameClient gameClient) {
        this.gameClient = gameClient;
    }

    public World getWorld() {
        return world;
    }

    public void setWorld(World world) {
        this.world = world;
    }

    public Player getPlayer() {
        return player;
    }

    public void setPlayer(Player player) {
        this.player = player;
    }

    public SpriteBatch getBatch() {
        return batch;
    }

    public void setBatch(SpriteBatch batch) {
        this.batch = batch;
    }

    public SpriteBatch getUiBatch() {
        return uiBatch;
    }

    public void setUiBatch(SpriteBatch uiBatch) {
        this.uiBatch = uiBatch;
    }

    public Stage getUiStage() {
        return uiStage;
    }

    public void setUiStage(Stage uiStage) {
        this.uiStage = uiStage;
    }

    public Stage getBattleStage() {
        return battleStage;
    }

    public void setBattleStage(Stage battleStage) {
        this.battleStage = battleStage;
    }

    public ChatSystem getChatSystem() {
        return chatSystem;
    }

    public BattleSystemHandler getBattleSystem() {
        return battleSystem;
    }

    public InventoryScreen getInventoryScreen() {
        return inventoryScreen;
    }

    public void setInventoryScreen(InventoryScreen inventoryScreen) {
        this.inventoryScreen = inventoryScreen;
    }

    public BuildModeUI getBuildModeUI() {
        return buildModeUI;
    }

    public void setBuildModeUI(BuildModeUI buildModeUI) {
        this.buildModeUI = buildModeUI;
    }

    public ChestScreen getChestScreen() {
        return chestScreen;
    }

    public void setChestScreen(ChestScreen chestScreen) {
        this.chestScreen = chestScreen;
    }

    public void dispose() {
        // Dispose of SpriteBatches
        if (batch != null) {
            batch.dispose();
        }
        if (uiBatch != null) {
            uiBatch.dispose();
        }
        // Dispose of Stages
        if (uiStage != null) {
            uiStage.dispose();
        }
        if (battleStage != null) {
            battleStage.dispose();
        }
        if (battleSystem != null) {
            battleSystem.endBattle(); // or other cleanup
        }

        instance = null;
    }
}

================
File: main/java/io/github/pokemeetup/CreatureCaptureGame.java
================
package io.github.pokemeetup;

import com.badlogic.gdx.Application;
import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.assets.AssetManager;
import com.badlogic.gdx.assets.loaders.TextureAtlasLoader;
import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Stage;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.client.GameClientSingleton;
import io.github.pokemeetup.multiplayer.server.GameStateHandler;
import io.github.pokemeetup.multiplayer.server.config.ServerConfigManager;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.pokemon.data.PokemonDatabase;
import io.github.pokemeetup.screens.*;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.storage.DesktopFileSystem;
import io.github.pokemeetup.utils.storage.GameFileSystem;

import java.io.IOException;
import java.util.Map;

public class CreatureCaptureGame extends Game implements GameStateHandler {
    public static final String MULTIPLAYER_WORLD_NAME = "multiplayer_world";
    private GameClient gameClient;
    private BiomeManager biomeManager;
    private Player player;
    private World currentWorld;
    private AssetManager assetManager;

    public CreatureCaptureGame(boolean isAndroid) {
        if (
            !isAndroid) {
            GameFileSystem system = GameFileSystem.getInstance();
            DesktopFileSystem delegate = new DesktopFileSystem();
            system.setDelegate(delegate);
        }
    }

    public CreatureCaptureGame() {
    }

    public boolean isMultiplayerMode() {
        return false;
    }

    @Override
    public void create() {


        assetManager = new AssetManager();
        queueAssets();
        GameLogger.info("Loading assets...");
        assetManager.finishLoading();
        initializeManagers();


        setScreen(new ModeSelectionScreen(this));

        GameLogger.info("Game initialization complete");
    }


    public void saveAndDispose() {
        try {
            GameLogger.info("Starting game state save...");
            if (!GameContext.get().getGameClient().isSinglePlayer()){
                return;
            }
            if (GameContext.get().getWorld() != null) {
                // Ensure all chunks are saved first
                for (Map.Entry<Vector2, Chunk> entry : GameContext.get().getWorld().getChunks().entrySet()) {
                    try {
                        Vector2 chunkPos = entry.getKey();
                        Chunk chunk = entry.getValue();
                        GameContext.get().getWorld().saveChunkData(chunkPos, chunk);
                    } catch (Exception e) {
                        GameLogger.error("Failed to save chunk: " + e.getMessage());
                    }
                }

                // Save world data after all chunks are saved
                World world = GameContext.get().getWorld();
                WorldData worldData = world.getWorldData();

                // Update player data if needed
                if (GameContext.get().getPlayer() != null) {
                    PlayerData currentState = new PlayerData(GameContext.get().getPlayer().getUsername());
                    currentState.updateFromPlayer(GameContext.get().getPlayer());
                    worldData.savePlayerData(GameContext.get().getPlayer().getUsername(), currentState, false);
                }

                // Force one final save
                GameContext.get().getWorldManager().saveWorld(worldData);

                // Verify the save
                FileHandle worldFile = Gdx.files.local("worlds/singleplayer/" + world.getName() + "/world.json");
                if (!worldFile.exists()) {
                    GameLogger.error("World file not created after final save!");
                } else {
                    GameLogger.info("Final world save successful");
                }
                GameContext.get().getWorld().dispose();
                GameLogger.info("World disposed successfully");
            }

            cleanupCurrentWorld();

        } catch (Exception e) {
            GameLogger.error("Error during game state save: " + e.getMessage());
        }
    }


    public void reinitializeGame() {
        try {
         GameContext.get().setWorldManager(WorldManager.getInstance());
            this.biomeManager = new BiomeManager(System.currentTimeMillis());
            GameContext.get().getWorldManager().init();

            GameLogger.info("Game state reinitialized");
        } catch (Exception e) {
            GameLogger.error("Failed to reinitialize game: " + e.getMessage());
        }
    }

    public void shutdown() {
        try {
            saveAndDispose();

            Gdx.app.postRunnable(() -> {
                try {
                    if (assetManager != null) {
                        assetManager.dispose();
                        assetManager = null;
                    }

                    AudioManager audioManager = AudioManager.getInstance();
                    if (audioManager != null) {
                        audioManager.dispose();
                    }

                    Gdx.app.exit();
                } catch (Exception e) {
                    GameLogger.error("Error during final shutdown: " + e.getMessage());
                }
            });
        } catch (Exception e) {
            GameLogger.error("Error during shutdown: " + e.getMessage());
        }
    }

    public void cleanupCurrentWorld() {
        try {
            GameLogger.info("Cleaning up current world state...");

            // Save current world if exists
            if (GameContext.get().getWorld() != null) {
                // Validate world data before saving
                if (GameContext.get().getWorld().getWorldData() == null) {
                    GameLogger.error("World data is null - creating new");
                    WorldData newData = new WorldData(GameContext.get().getWorld().getName());
                    GameContext.get().getWorld().setWorldData(newData);
                }

                // Ensure player data is saved to world
                if (GameContext.get().getPlayer() != null) {
                    PlayerData currentState = GameContext.get().getPlayer().getPlayerData();
                    GameContext.get().getWorld().getWorldData().savePlayerData(GameContext.get().getPlayer().getUsername(), currentState, false);
                    GameLogger.info("Saved player data for: " + GameContext.get().getPlayer().getUsername());
                }

                // Force a final save
                GameContext.get().getWorld().save();

                // Validate save was successful
                FileHandle worldFile = Gdx.files.local("worlds/singleplayer/" +
                    GameContext.get().getWorld().getName() + "/world.json");
                if (!worldFile.exists()) {
                    GameLogger.error("World file not created after save");
                }

                // Clean up world resources
                GameContext.get().getWorld().dispose();
                GameContext.get().setWorld(null);
            }

            // Clean up player
            if (GameContext.get().getPlayer() != null) {
                GameContext.get().getPlayer().dispose();
                GameContext.get().setPlayer(null);
            }


            GameLogger.info("World state cleaned up successfully");

        } catch (Exception e) {
            GameLogger.error("Error cleaning up world state: " + e.getMessage());
        }
    }


    @Override
    public void dispose() {
        try {
            GameLogger.info("Starting game disposal...");

            // Queue on main thread if we're not already there
            if (!Gdx.app.getType().equals(Application.ApplicationType.Desktop) ||
                !Thread.currentThread().getName().equals("LWJGL Application")) {

                Gdx.app.postRunnable(() -> {
                    try {
                        saveAndDispose();
                        if (assetManager != null) {
                            assetManager.dispose();
                        }
                    } catch (Exception e) {
                        GameLogger.error("Error during final disposal: " + e.getMessage());
                    }
                });
            } else {
                saveAndDispose();
                if (assetManager != null) {
                    assetManager.dispose();
                }
            }
        } catch (Exception e) {
            GameLogger.error("Error during disposal: " + e.getMessage());
        }
    }

    public void initializeWorld(String worldName, boolean isMultiplayer) throws IOException {
        GameLogger.info("Starting world initialization: " + worldName);

        try {
            if (GameContext.get().getGameClient() == null) {
                if (isMultiplayer) {
                    ServerConnectionConfig config = ServerConfigManager.getDefaultServerConfig();
                    GameContext.get().setGameClient(GameClientSingleton.getInstance(config));
                } else {
                    GameContext.get().setGameClient(GameClientSingleton.getSinglePlayerInstance());
                }

                if (GameContext.get().getGameClient() == null) {
                    throw new IllegalStateException("Failed to initialize GameClient");
                }
            }
            WorldData worldData = GameContext.get().getWorldManager().loadAndValidateWorld(worldName);
            if (worldData == null) {
                GameLogger.error("Failed to load world data for: " + worldName);
                throw new IOException("Failed to load world data");
            }
            String username = isMultiplayer ? GameContext.get().getGameClient().getLocalUsername() : "Player";
            PlayerData savedPlayerData = worldData.getPlayerData(username, false);

            if (savedPlayerData != null) {
                GameLogger.info("Found saved player data for: " + username +
                    " Items: " + savedPlayerData.getInventoryItems().size() +
                    " Pokemon: " + savedPlayerData.getPartyPokemon().size());

            }

            // Initialize world
            GameContext.get().setWorld(new World(worldName,
                worldData.getConfig().getSeed(), biomeManager));
            GameContext.get().getWorld().setWorldData(worldData);

            // Initialize player
            if (savedPlayerData != null) {
                GameContext.get().setPlayer(new Player((int) savedPlayerData.getX(),
                    (int) savedPlayerData.getY(), currentWorld, username));
                GameContext.get().getPlayer().initializeResources();
                savedPlayerData.applyToPlayer(GameContext.get().getPlayer());
                GameLogger.info("Restored player state - Items: " +
                    GameContext.get().getPlayer().getInventory().getAllItems().size() +
                    " Pokemon: " + GameContext.get().getPlayer().getPokemonParty().getSize());
            } else {
                GameLogger.info("Creating new player at default position");
                GameContext.get().setPlayer(new Player(World.DEFAULT_X_POSITION,
                    World.DEFAULT_Y_POSITION, currentWorld, username));
                GameContext.get().getPlayer().initializeResources();
            }

            GameContext.get().getWorld().setPlayer(GameContext.get().getPlayer());
            GameLogger.info("World initialization complete: " + worldName);

        } catch (Exception e) {
            GameLogger.error("Failed to initialize world: " + e.getMessage());
            throw new IOException("World initialization failed", e);
        }
    }

    private void queueAssets() {
        String[] atlasFiles = {
            "atlas/ui-gfx-atlas.atlas",
            "atlas/back-gfx-atlas",
            "atlas/front-gfx-atlas",
            "atlas/boy-gfx-atlas",
            "atlas/tiles-gfx-atlas",
            "atlas/icon_gfx_atlas",
            "atlas/items-gfx-atlas",
            "atlas/overworld-gfx-atlas.atlas",
            "atlas/battlebacks-gfx-atlas",
            "atlas/move-effects-gfx",
            "atlas/haunted_biome.atlas",
            "atlas/mountain-atlas.atlas",
            "atlas/move_effects_gfx.atlas",
            "atlas/blocks.atlas",
            "atlas/characters.atlas",
            "atlas/clothing.atlas",
            "atlas/hairstyles.atlas",
            "atlas/buildings.atlas",
        };

        for (String path : atlasFiles) {
            verifyAssetExists(path);
            assetManager.load(path, TextureAtlas.class);
        }

        // Verify required data files exist
        String[] dataFiles = {
            "Data/pokemon.json",
            "Data/biomes.json",
            "Data/moves.json"
        };
        for (String dataFile : dataFiles) {
            verifyDataFileExists(dataFile);
        }

        assetManager.setLoader(TextureAtlas.class, new TextureAtlasLoader(new InternalFileHandleResolver()));

        GameLogger.info("Asset loading queued");
    }

    private void verifyDataFileExists(String path) {
        try {
            String content = GameFileSystem.getInstance().getDelegate().readString(path);
            if (content == null || content.isEmpty()) {
                throw new RuntimeException("Empty data file: " + path);
            }
            GameLogger.info("Successfully verified data file: " + path);
        } catch (Exception e) {
            GameLogger.error("Failed to verify data file: " + path);
            throw new RuntimeException("Required data file missing: " + path, e);
        }
    }

    @Override
    public void returnToLogin(String message) {
        try {
            if (screen != null) {
                screen.dispose();
            }
            setScreen(new LoginScreen(this));
        } catch (Exception e) {
            GameLogger.error("Error returning to login: " + e.getMessage());
        }
    }

    private void verifyAssetExists(String path) {
        try {
            if (!Gdx.files.internal(path).exists()) {
                String[] alternatives = {
                    path.toLowerCase(),
                    "assets/" + path,
                    path.replace("Data/", "data/")
                };

                boolean found = false;
                for (String alt : alternatives) {
                    if (Gdx.files.internal(alt).exists()) {
                        GameLogger.info("Found asset at alternate path: " + alt);
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    throw new RuntimeException("Required asset not found: " + path +
                        " (tried multiple path variants)");
                }
            }
        } catch (Exception e) {
            GameLogger.error("Error verifying asset: " + path + " - " + e.getMessage());
            throw new RuntimeException("Asset verification failed", e);
        }
    }

    private void initializeManagers() {
        try {

            GameLogger.info("Initializing managers with loaded assets...");
            TextureAtlas battleAtlas = assetManager.get("atlas/battlebacks-gfx-atlas", TextureAtlas.class);
            TextureAtlas uiAtlas = assetManager.get("atlas/ui-gfx-atlas.atlas", TextureAtlas.class);
            TextureAtlas backAtlas = assetManager.get("atlas/back-gfx-atlas", TextureAtlas.class);
            TextureAtlas frontAtlas = assetManager.get("atlas/front-gfx-atlas", TextureAtlas.class);
            TextureAtlas iconAtlas = assetManager.get("atlas/icon_gfx_atlas", TextureAtlas.class);
            TextureAtlas overworldAtlas = assetManager.get("atlas/overworld-gfx-atlas.atlas", TextureAtlas.class);
            TextureAtlas itemsAtlas = assetManager.get("atlas/items-gfx-atlas", TextureAtlas.class);
            TextureAtlas boyAtlas = assetManager.get("atlas/boy-gfx-atlas", TextureAtlas.class);
            TextureAtlas effects = assetManager.get("atlas/move_effects_gfx.atlas", TextureAtlas.class);
            TextureAtlas mountains = assetManager.get("atlas/mountain-atlas.atlas", TextureAtlas.class);
            TextureAtlas tilesAtlas = assetManager.get("atlas/tiles-gfx-atlas", TextureAtlas.class);
            TextureAtlas blocks = assetManager.get("atlas/blocks.atlas", TextureAtlas.class);
            TextureAtlas clothing = assetManager.get("atlas/clothing.atlas", TextureAtlas.class);
            TextureAtlas buildings = assetManager.get("atlas/buildings.atlas", TextureAtlas.class);

            TextureAtlas characters = assetManager.get("atlas/characters.atlas", TextureAtlas.class);

            TextureAtlas hairstyles = assetManager.get("atlas/hairstyles.atlas", TextureAtlas.class);

            TextureManager.debugAtlasState("Boy", boyAtlas);

            if (!verifyAtlas(boyAtlas)) {
                throw new RuntimeException("Boy atlas verification failed");
            }

            TextureManager.initialize(
                battleAtlas,
                uiAtlas,
                backAtlas,
                frontAtlas,
                iconAtlas,
                overworldAtlas,
                itemsAtlas,
                boyAtlas,
                tilesAtlas,
                effects,
                mountains, blocks, characters, clothing, hairstyles, buildings

            );

            PokemonDatabase.initialize();

            ItemManager.initialize(TextureManager.items);
            AudioManager.getInstance();

            SpriteBatch mainBatch = new SpriteBatch();
            SpriteBatch uiBatch = new SpriteBatch();
            Stage uiStage = new Stage();
            Stage battleStage = new Stage();
            GameContext.init(this, this.gameClient, this.currentWorld, this.player, mainBatch, uiBatch, uiStage, battleStage, null, null, null, null, null, null, null,WorldManager.getInstance(), null);

            this.biomeManager = new BiomeManager(System.currentTimeMillis());
            GameContext.get().getWorldManager().init();

            GameLogger.info("Managers initialized successfully");

        } catch (Exception e) {
            GameLogger.error("Failed to initialize managers: " + e.getMessage());
            throw new RuntimeException("Failed to initialize game managers", e);
        }
    }

    private boolean verifyAtlas(TextureAtlas atlas) {
        if (atlas == null) {
            GameLogger.error("Boy" + " atlas is null");
            return false;
        }

        try {
            for (Texture texture : atlas.getTextures()) {
                if (texture == null) {
                    GameLogger.error("Boy" + " atlas has invalid textures");
                    return false;
                }
            }
            if (atlas.getRegions().isEmpty()) {
                GameLogger.error("Boy" + " atlas has no regions");
                return false;
            }

            return true;
        } catch (Exception e) {
            GameLogger.error("Error verifying " + "Boy" + " atlas: " + e.getMessage());
            return false;
        }
    }

    public Player getPlayer() {
        return GameContext.get().getPlayer();
    }


    public WorldManager getWorldManager() {
        return GameContext.get().getWorldManager();
    }
}

================
File: main/java/io/github/pokemeetup/FileSystemDelegate.java
================
package io.github.pokemeetup;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public interface FileSystemDelegate {
    boolean exists(String path);
    void createDirectory(String path);
    void writeString(String path, String content) throws IOException;
    String readString(String path) throws IOException;
    void deleteFile(String path);
    void deleteDirectory(String path);
    boolean isDirectory(String path); void moveFile(String sourcePath, String destinationPath) throws IOException;
    String[] list(String path);
    void copyFile(String sourcePath, String destinationPath) throws IOException;
    InputStream openInputStream(String path) throws IOException;
    OutputStream openOutputStream(String path) throws IOException;
}

================
File: main/java/io/github/pokemeetup/managers/BiomeManager.java
================
package io.github.pokemeetup.managers;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.google.gson.*;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.system.gameplay.overworld.mechanics.MountainTileManager;
import io.github.pokemeetup.utils.GameLogger;

import io.github.pokemeetup.utils.OpenSimplex2;
import io.github.pokemeetup.utils.storage.GameFileSystem;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.textures.TileType;

import java.io.IOException;
import java.io.Serializable;
import java.util.*;

public class BiomeManager {
    private static final double RUINS_THRESHOLD = 0.65; // Lowered from 0.85
    private static final double COLD_THRESHOLD = 0.35; // Adjusted for better distribution
    private static final double HOT_THRESHOLD = 0.65;
    private static final double DRY_THRESHOLD = 0.35;
    private static final double WET_THRESHOLD = 0.65;

    private static final float TEMPERATURE_SCALE = 0.00005f;
    private static final float MOISTURE_SCALE = 0.00005f;
    private static final float WARP_SCALE = 0.00001f;
    private static final float WARP_STRENGTH = 30f;
    private static final float MOUNTAIN_BASE_SCALE = 0.001f;
    private static final int BASE_TILE_MASK = 0x0000FFFF;
    private static final int OVERLAY_SHIFT = 16;
    private static final float MOUNTAIN_DETAIL_SCALE = 0.002f;
    private static final float MOUNTAIN_RIDGE_SCALE = 0.0015f;
    private static final float MOUNTAIN_THRESHOLD = 0.65f;
    private static final double HEIGHT_EPSILON = 0.05;
    private final long temperatureSeed;
    private final long moistureSeed;
    private final long warpSeed;
    private final long baseSeed;
    private final long mountainSeed;
    private final long detailSeed;
    private final Map<BiomeType, Biome> biomes;

    public BiomeManager(long baseSeed) {
        this.baseSeed = baseSeed;
        this.biomes = new HashMap<>();
        this.temperatureSeed = baseSeed + 1000;
        this.moistureSeed = baseSeed + 2000;
        this.mountainSeed = baseSeed + 3000;
        this.warpSeed = baseSeed + 4000;
        this.detailSeed = baseSeed + 5000;
        loadBiomesFromJson();
    }

    private float[] domainWarp(float x, float y) {
        float[] warped = new float[]{x, y};
        float amplitude = WARP_STRENGTH;
        float frequency = WARP_SCALE;

        for (int i = 0; i < 3; i++) {
            float warpX = (float) OpenSimplex2.noise2(warpSeed + i,
                warped[0] * frequency,
                warped[1] * frequency) * amplitude;

            float warpY = (float) OpenSimplex2.noise2(warpSeed + i + 1000,
                warped[0] * frequency,
                warped[1] * frequency) * amplitude;

            warped[0] += warpX;
            warped[1] += warpY;

            amplitude *= 0.5f;
            frequency *= 1.8f;
        }
        return warped;
    }


    private BiomeType determineBiomeType(double temperature, double moisture) {
        double regionalVariation = OpenSimplex2.noise2(detailSeed + 3000, temperature * 2, moisture * 2) * 0.05;

        double adjustedTemp = temperature + regionalVariation;
        double adjustedMoist = moisture + regionalVariation;

        if (shouldGenerateRuins(adjustedTemp, adjustedMoist)) {
            return BiomeType.RUINS;
        }

        BiomeType chosenBiome;
        if (adjustedTemp < COLD_THRESHOLD) {
            chosenBiome = determineColderBiomes(adjustedMoist);
        } else if (adjustedTemp > HOT_THRESHOLD) {
            chosenBiome = determineHotterBiomes(adjustedMoist);
        } else {
            chosenBiome = determineTemperateBiomes(adjustedTemp, adjustedMoist);
        }

        double mountainNoise = OpenSimplex2.noise2(mountainSeed, adjustedTemp * 5, adjustedMoist * 5);
        if (shouldGenerateMountains(adjustedTemp, adjustedMoist, mountainNoise)) {
            chosenBiome = BiomeType.BIG_MOUNTAINS;
        }

        return chosenBiome;
    }

    private boolean shouldGenerateMountains(double temp, double moisture, double mountainNoise) {
        double mountainProbability = (mountainNoise + 1.0) / 2.0;

        if (temp < COLD_THRESHOLD) {
            mountainProbability *= 1.3;
        }
        if (moisture > WET_THRESHOLD) {
            mountainProbability *= 1.2;
        }

        double ridgeNoise = Math.abs(OpenSimplex2.noise2(mountainSeed + 1000,
            temp * MOUNTAIN_RIDGE_SCALE,
            moisture * MOUNTAIN_RIDGE_SCALE));

        double detailNoise = OpenSimplex2.noise2(mountainSeed + 2000,
            temp * MOUNTAIN_DETAIL_SCALE,
            moisture * MOUNTAIN_DETAIL_SCALE);

        double combinedProbability = mountainProbability * 0.5 +
            ridgeNoise * 0.3 +
            Math.abs(detailNoise) * 0.2;

        return combinedProbability > MOUNTAIN_THRESHOLD;
    }

    private void addMountainOverlay(Chunk chunk, int x, int y, double height,
                                    MountainTileManager tileManager, Random random) {
        int[][] tileData = chunk.getTileData();
        BiomeType biomeType = chunk.getBiome().getType();

        // Determine overlay type based on height and biome
        if (height > 0.8 && (biomeType == BiomeType.SNOW || biomeType == BiomeType.BIG_MOUNTAINS)) {
            // Heavy snow overlay for high altitudes
            TextureRegion snowOverlay = tileManager.getTile(
                random.nextBoolean() ?
                    MountainTileManager.MountainTileType.SNOW_OVERLAY_1 :
                    MountainTileManager.MountainTileType.SNOW_OVERLAY_2
            );
            applyOverlay(chunk, x, y, snowOverlay);
        } else if (height > 0.6 && random.nextFloat() < 0.3) {
            // Occasional grass patches on lower slopes
            TextureRegion grassOverlay = tileManager.getTile(
                MountainTileManager.MountainTileType.GRASS_OVERLAY
            );
            applyOverlay(chunk, x, y, grassOverlay);
        }

        // Add random rocks with decreasing probability as height increases
        if (random.nextFloat() < (1.0 - height) * 0.2) {
            TextureRegion rockOverlay = tileManager.getRandomRock(random);
            applyOverlay(chunk, x, y, rockOverlay);
        }
    }


    private boolean shouldGenerateRuins(double temp, double moisture) {
        // Expanded temperature and moisture ranges for ruins
        boolean moderateClimate = temp > 0.3 && temp < 0.7 &&
            moisture > 0.3 && moisture < 0.7;

        if (!moderateClimate) return false;

        // Multiple noise layers for natural ruins placement with adjusted weights
        double ruinsNoise = OpenSimplex2.noise2(detailSeed + 2000,
            temp * 2, moisture * 2);
        double structureNoise = OpenSimplex2.noise2(detailSeed + 2500,
            temp * 4, moisture * 4);
        double historyNoise = OpenSimplex2.noise2(detailSeed + 3000,
            temp * 1.5, moisture * 1.5);

        // Adjusted weights to increase ruins frequency
        double combinedNoise = ruinsNoise * 0.4 +
            structureNoise * 0.4 +
            historyNoise * 0.2;

        return combinedNoise > RUINS_THRESHOLD;
    }

    private int convertTextureToTileId(MountainTileManager.MountainTileType tileType) {
        // Convert mountain tile types to game tile IDs
        switch (tileType) {
            case BASE_SNOW:
                return TileType.MOUNTAIN_SNOW_BASE;
            case SLOPE_LEFT:
                return TileType.MOUNTAIN_SLOPE_LEFT;
            case SLOPE_RIGHT:
                return TileType.MOUNTAIN_SLOPE_RIGHT;
            default:
                return TileType.MOUNTAIN_BASE;
        }
    }

    private void applyOverlay(Chunk chunk, int x, int y, TextureRegion overlay) {
        try {
            int[][] tileData = chunk.getTileData();
            if (tileData == null) return;

            // Get current tile value
            int currentTile = tileData[x][y];

            // Get overlay tile ID
            int overlayId = getOverlayTileId(overlay);
            if (overlayId == -1) return;

            // Clear any existing overlay
            currentTile &= BASE_TILE_MASK;

            // Apply new overlay
            currentTile |= (overlayId << OVERLAY_SHIFT);

            // Update tile data
            tileData[x][y] = currentTile;
            chunk.setDirty(true);

        } catch (Exception e) {
            GameLogger.error("Failed to apply overlay: " + e.getMessage());
        }
    }

    private int getOverlayTileId(TextureRegion overlay) {
        // Match MountainTileManager's tile types to game tile IDs
        if (overlay == null) return 1;


        GameLogger.error("Unknown overlay texture - no matching tile ID found");
        return 1;
    }

    private BiomeType determineTemperateBiomes(double temperature, double moisture) {
        // Calculate local variation for more interesting distribution
        double varietyNoise = OpenSimplex2.noise2(detailSeed + 1000,
            temperature * 3, moisture * 3) * 0.5 + 0.5;

        if (moisture > WET_THRESHOLD) {
            // Wet temperate regions favor forests
            return varietyNoise > 0.5 ? BiomeType.RAIN_FOREST : BiomeType.FOREST;
        } else if (moisture < DRY_THRESHOLD) {
            // Dry temperate regions favor plains
            return BiomeType.PLAINS;
        }

        // Moderate moisture creates varied landscape
        if (varietyNoise > 0.6) {
            return BiomeType.FOREST;
        } else if (varietyNoise > 0.3) {
            return BiomeType.PLAINS;
        } else {
            return BiomeType.HAUNTED; // Haunted biome is now rarer
        }
    }


    private BiomeType determineColderBiomes(double moisture) {
        // Adjusted variety noise calculation
        double varietyNoise = OpenSimplex2.noise2(detailSeed + 3000,
            moisture * 4, moisture * 4) * 0.5 + 0.5;

        if (moisture > WET_THRESHOLD) {
            // Cold and wet regions are snowy
            return BiomeType.SNOW;
        } else if (moisture < DRY_THRESHOLD) {
            // Cold and dry regions tend to be plains
            return BiomeType.PLAINS;
        }

        // Moderate moisture in cold regions
        return varietyNoise > 0.2 ? BiomeType.SNOW : BiomeType.HAUNTED; // Haunted biome is less likely
    }

    private BiomeType determineHotterBiomes(double moisture) {
        if (moisture < DRY_THRESHOLD) {
            return BiomeType.DESERT; // Hot and dry
        } else if (moisture > WET_THRESHOLD) {
            return BiomeType.RAIN_FOREST; // Hot and wet
        }

        // Moderate moisture in hot regions
        double varietyNoise = OpenSimplex2.noise2(detailSeed + 2000,
            moisture * 4, moisture * 4) * 0.5 + 0.5;

        return varietyNoise > 0.5 ? BiomeType.PLAINS : BiomeType.DESERT;
    }

    private MountainTileManager.MountainTileType determineSlopeTileType(int x, int y, Chunk chunk) {
        int[][] heightMap = chunk.getTileData();

        // Check surrounding tiles to determine slope direction
        boolean higherLeft = isHigherTile(x - 1, y, heightMap);
        boolean higherRight = isHigherTile(x + 1, y, heightMap);
        boolean higherTop = isHigherTile(x, y + 1, heightMap);
        boolean higherBottom = isHigherTile(x, y - 1, heightMap);

        // Determine corners first
        if (higherTop && higherLeft) {
            return MountainTileManager.MountainTileType.CORNER_TOP_LEFT;
        } else if (higherTop && higherRight) {
            return MountainTileManager.MountainTileType.CORNER_TOP_RIGHT;
        } else if (higherBottom && higherLeft) {
            return MountainTileManager.MountainTileType.CORNER_BOTTOM_LEFT;
        } else if (higherBottom && higherRight) {
            return MountainTileManager.MountainTileType.CORNER_BOTTOM_RIGHT;
        }

        // Determine slopes
        if (higherLeft) {
            return MountainTileManager.MountainTileType.SLOPE_LEFT;
        } else if (higherRight) {
            return MountainTileManager.MountainTileType.SLOPE_RIGHT;
        }

        // Default to cliff face if no specific direction is determined
        return MountainTileManager.MountainTileType.CLIFF_FACE;
    }

    private boolean isHigherTile(int x, int y, int[][] heightMap) {
        // Validate coordinates
        if (x < 0 || x >= Chunk.CHUNK_SIZE || y < 0 || y >= Chunk.CHUNK_SIZE) {
            return false;
        }

        int currentHeight = heightMap[x][y];
        if (currentHeight == -1) return false;  // Not a mountain tile

        // Check all adjacent tiles (including diagonals)
        for (int dx = -1; dx <= 1; dx++) {
            for (int dy = -1; dy <= 1; dy++) {
                if (dx == 0 && dy == 0) continue;  // Skip self

                int nx = x + dx;
                int ny = y + dy;

                // Skip out of bounds neighbors
                if (nx < 0 || nx >= Chunk.CHUNK_SIZE ||
                    ny < 0 || ny >= Chunk.CHUNK_SIZE) {
                    continue;
                }

                // Get neighbor's height
                int neighborHeight = heightMap[nx][ny];
                if (neighborHeight == -1) {
                    // Consider non-mountain tiles as lower
                    return true;
                }

                // Check if current tile is significantly higher
                if (neighborHeight - currentHeight > HEIGHT_EPSILON) {
                    return false;
                }
            }
        }

        // Additional checks for mountain peaks
        boolean isPeak = true;
        int higherNeighbors = 0;
        int totalValidNeighbors = 0;

        for (int dx = -1; dx <= 1; dx++) {
            for (int dy = -1; dy <= 1; dy++) {
                if (dx == 0 && dy == 0) continue;

                int nx = x + dx;
                int ny = y + dy;

                if (nx < 0 || nx >= Chunk.CHUNK_SIZE ||
                    ny < 0 || ny >= Chunk.CHUNK_SIZE) {
                    continue;
                }

                int neighborHeight = heightMap[nx][ny];
                if (neighborHeight != -1) {
                    totalValidNeighbors++;
                    if (neighborHeight >= currentHeight) {
                        higherNeighbors++;
                    }
                }
            }
        }

        // Consider special cases for peaks and ridges
        if (totalValidNeighbors > 0) {
            // Peak condition - significantly higher than most neighbors
            if (higherNeighbors == 0) {
                return true;
            }

            // Ridge condition - higher than neighbors in at least one direction
            return higherNeighbors <= totalValidNeighbors / 2;
        }

        // Default case - not higher
        return false;
    }


    public void applyMountainFeatures(Chunk chunk, MountainTileManager tileManager) {
        int[][] tileData = chunk.getTileData();
        Random random = new Random(baseSeed + chunk.getChunkX() * 31L + chunk.getChunkY() * 17L);

        for (int x = 0; x < Chunk.CHUNK_SIZE; x++) {
            for (int y = 0; y < Chunk.CHUNK_SIZE; y++) {
                float worldX = (chunk.getChunkX() * Chunk.CHUNK_SIZE + x) * World.TILE_SIZE;
                float worldY = (chunk.getChunkY() * Chunk.CHUNK_SIZE + y) * World.TILE_SIZE;

                double height = getMountainHeight(worldX, worldY);
                if (height > 0.6) {
                    // Determine appropriate mountain tile type
                    MountainTileManager.MountainTileType tileType =
                        determineMountainTileType(height, x, y, chunk);

                    // Apply tile
                    TextureRegion tileTexture = tileManager.getTile(tileType);
                    if (tileTexture != null) {
                        tileData[x][y] = convertTextureToTileId(tileType);
                    }

                    // Add overlays where appropriate
                    if (tileManager.shouldHaveSnowOverlay((int) height, random)) {
                        addMountainOverlay(chunk, x, y, height, tileManager, random);
                    }
                }
            }
        }
    }

    private MountainTileManager.MountainTileType determineMountainTileType(
        double height, int x, int y, Chunk chunk) {
        BiomeType biomeType = chunk.getBiome().getType();

        if (height > 0.85) {
            return biomeType == BiomeType.SNOW ?
                MountainTileManager.MountainTileType.PEAK_SNOW :
                MountainTileManager.MountainTileType.PEAK_ROCK;
        } else if (height > 0.75) {
            return determineSlopeTileType(x, y, chunk);
        } else {
            return biomeType == BiomeType.SNOW ?
                MountainTileManager.MountainTileType.BASE_SNOW :
                MountainTileManager.MountainTileType.BASE_BROWN;
        }
    }



    public double getMountainHeight(float worldX, float worldY) {
        // Base mountain height
        double baseHeight = (OpenSimplex2.noise2(mountainSeed,
            worldX * MOUNTAIN_BASE_SCALE,
            worldY * MOUNTAIN_BASE_SCALE) + 1.0) / 2.0;

        // Ridge formation
        double ridgeNoise = Math.abs(OpenSimplex2.noise2(mountainSeed + 1000,
            worldX * MOUNTAIN_RIDGE_SCALE,
            worldY * MOUNTAIN_RIDGE_SCALE));
        ridgeNoise = Math.pow(ridgeNoise, 2.0); // Sharper ridges

        // Detail noise
        double detailNoise = (OpenSimplex2.noise2(detailSeed,
            worldX * MOUNTAIN_DETAIL_SCALE,
            worldY * MOUNTAIN_DETAIL_SCALE) + 1.0) / 2.0;

        // Get current biome and its influence
        BiomeTransitionResult biomeTransition = getBiomeAt(worldX, worldY);
        double biomeInfluence = getBiomeHeightInfluence(biomeTransition.getPrimaryBiome().getType());

        // Combine factors with different weights
        double height = baseHeight * 0.5 +
            ridgeNoise * 0.3 +
            detailNoise * 0.2;

        // Apply biome influence and peak sharpening
        height *= biomeInfluence;
        height = Math.pow(height, 1.5);

        return clamp(height);
    }


    public BiomeTransitionResult getBiomeAt(float worldX, float worldY) {
        // Apply domain warping for more natural transitions
        float[] warped = domainWarp(worldX, worldY);

        // Get base temperature and moisture values
        double temperature = getNoiseValue(warped[0], warped[1], temperatureSeed, TEMPERATURE_SCALE);
        double moisture = getNoiseValue(warped[0], warped[1], moistureSeed, MOISTURE_SCALE);

        // Calculate edge noise for transition variation
        double edge = getNoiseValue(worldX, worldY, warpSeed, TEMPERATURE_SCALE * 2);
        double transitionThreshold = 0.15 + edge * 0.05;

        // Determine primary biome
        BiomeType primaryType = determineBiomeType(temperature, moisture);

        // Check for transition zones
        if (Math.abs(temperature - 0.5) < transitionThreshold ||
            Math.abs(moisture - 0.5) < transitionThreshold) {

            // Get offset coordinates for second biome check
            float[] offset = domainWarp(worldX + 64, worldY + 64);
            double temp2 = getNoiseValue(offset[0], offset[1], temperatureSeed, TEMPERATURE_SCALE);
            double moist2 = getNoiseValue(offset[0], offset[1], moistureSeed, MOISTURE_SCALE);
            BiomeType secondaryType = determineBiomeType(temp2, moist2);

            // Only create transition if biomes are compatible
            if (primaryType != secondaryType && areCompatibleBiomes(primaryType, secondaryType)) {
                float transitionFactor = (float) (Math.abs(temperature - 0.5) / transitionThreshold);
                return new BiomeTransitionResult(getBiome(primaryType), getBiome(secondaryType), transitionFactor);
            }
        }

        return new BiomeTransitionResult(getBiome(primaryType), null, 1.0f);
    }

    private double clamp(double value) {
        return Math.max(0.0, Math.min(1.0, value));
    }


    public void saveChunkBiomeData(Vector2 chunkPos, Chunk chunk, String worldName, boolean isMultiplayer) {
        if (isMultiplayer) {
            return;
        }

        try {
            String baseDir = "worlds/singleplayer/" + worldName + "/biomes/";

            FileHandle saveDir = Gdx.files.local(baseDir);
            if (!saveDir.exists()) {
                saveDir.mkdirs();
            }

            BiomeData biomeData = new BiomeData();
            biomeData.chunkX = (int) chunkPos.x;
            biomeData.chunkY = (int) chunkPos.y;
            biomeData.primaryBiomeType = chunk.getBiome().getType();
            biomeData.lastModified = System.currentTimeMillis();

            // Create new mutable collections
            HashMap<Integer, Integer> distribution = new HashMap<>(chunk.getBiome().getTileDistribution());
            biomeData.setTileDistribution(distribution);

            ArrayList<Integer> allowedTypes = new ArrayList<>(chunk.getBiome().getAllowedTileTypes());
            biomeData.setAllowedTileTypes(allowedTypes);

            String filename = String.format("biome_%d_%d.json", (int) chunkPos.x, (int) chunkPos.y);
            FileHandle biomeFile = saveDir.child(filename);

            // Use Gson for serialization
            Gson gson = new GsonBuilder()
                .registerTypeAdapter(BiomeData.class, new BiomeDataTypeAdapter())
                .setPrettyPrinting()
                .create();

            String jsonContent = gson.toJson(biomeData);
            biomeFile.writeString(jsonContent, false);

            GameLogger.info("Saved biome data for chunk at: " + chunkPos);

        } catch (Exception e) {
            GameLogger.error("Failed to save biome data: " + e.getMessage());
        }
    }

    public BiomeType loadChunkBiomeData(Vector2 chunkPos, String worldName, boolean isMultiplayer) {
        if (isMultiplayer) {
            return null;
        }
        try {
            String baseDir = isMultiplayer ?
                "worlds/" + worldName + "/biomes/" :
                "worlds/singleplayer/" + worldName + "/biomes/";

            String filename = String.format("biome_%d_%d.json", (int) chunkPos.x, (int) chunkPos.y);
            FileHandle biomeFile = Gdx.files.local(baseDir + filename);

            if (!biomeFile.exists()) {
                return null;
            }

            Gson gson = new GsonBuilder()
                .registerTypeAdapter(BiomeData.class, new BiomeDataTypeAdapter())
                .create();

            BiomeData biomeData = gson.fromJson(biomeFile.readString(), BiomeData.class);

            if (biomeData != null && biomeData.primaryBiomeType != null) {
                return biomeData.primaryBiomeType;
            }

        } catch (Exception e) {
            GameLogger.error("Failed to load biome data: " + e.getMessage());
        }
        return null;
    }


    public boolean areCompatibleBiomes(BiomeType a, BiomeType b) {
        if (a == b) return true;

        // First check if either biome is RUINS, as it has special transition rules
        if (a == BiomeType.RUINS || b == BiomeType.RUINS) {
            BiomeType other = (a == BiomeType.RUINS) ? b : a;
            return isCompatibleWithRuins(other);
        }

        switch (a) {
            case PLAINS:
                return b == BiomeType.FOREST || b == BiomeType.DESERT ||
                    b == BiomeType.HAUNTED;

            case FOREST:
                return b == BiomeType.PLAINS || b == BiomeType.RAIN_FOREST ||
                    b == BiomeType.SNOW || b == BiomeType.HAUNTED;

            case DESERT:
                return b == BiomeType.PLAINS;

            case SNOW:
                return b == BiomeType.FOREST || b == BiomeType.HAUNTED;

            case RAIN_FOREST:
                return b == BiomeType.FOREST;

            case HAUNTED:
                return b == BiomeType.FOREST || b == BiomeType.PLAINS ||
                    b == BiomeType.SNOW;

            case BIG_MOUNTAINS:
                return b == BiomeType.SNOW || b == BiomeType.FOREST;

            default:
                return false;
        }
    }

    private boolean isCompatibleWithRuins(BiomeType other) {
        // Ruins can transition to most moderate biomes
        return other == BiomeType.PLAINS ||
            other == BiomeType.FOREST ||
            other == BiomeType.HAUNTED;
    }

    public double getBiomeHeightInfluence(BiomeType biomeType) {
        switch (biomeType) {
            case BIG_MOUNTAINS:
                return 1.5;     // Highest elevation

            case SNOW:
                return 1.2;     // Tall snowy peaks

            case RUINS:
                return 0.9;     // Slightly elevated with occasional ruins

            case HAUNTED:
                return 1.1;     // Moderately high for atmosphere

            case DESERT:
                return 0.7;     // Generally flat with dunes

            case FOREST:
            case RAIN_FOREST:
                return 0.8;     // Rolling hills

            case PLAINS:
                return 0.6;     // Flattest terrain

            default:
                return 1.0;     // Default height
        }
    }

    // Helper method to get noise value with octaves
    private double getNoiseValue(float x, float y, long seed, float scale) {
        double value = 0;
        double amplitude = 1.0;
        double frequency = 1.0;
        double maxAmplitude = 0;

        for (int i = 0; i < 3; i++) {
            value += amplitude * OpenSimplex2.noise2(seed + i,
                x * scale * frequency,
                y * scale * frequency);

            // Add subtle detail layer
            value += amplitude * 0.2 * OpenSimplex2.noise2(seed + i + 500,
                x * scale * frequency * 2,
                y * scale * frequency * 2);

            maxAmplitude += amplitude * 1.2;
            amplitude *= 0.5;    // Steeper falloff for smoother transitions
            frequency *= 2.0;    // Slower frequency scaling
        }

        // Normalize and adjust range
        value = value / maxAmplitude;
        value = (value + 1) / 2;
        value = Math.pow(value, 1.1); // Slightly sharpen transitions

        return clamp(value);
    }

    public void debugBiomeDistribution(int samples) {
        Map<BiomeType, Integer> distribution = new HashMap<>();
        Random random = new Random(baseSeed); // Use world seed for consistent debugging

        for (int i = 0; i < samples; i++) {
            float x = random.nextFloat() * 1000;
            float y = random.nextFloat() * 1000;

            BiomeTransitionResult result = getBiomeAt(x, y);
            BiomeType type = result.getPrimaryBiome().getType();

            distribution.merge(type, 1, Integer::sum);
        }

        GameLogger.info("=== Biome Distribution Analysis ===");
        GameLogger.info("Samples: " + samples);
        GameLogger.info("World Seed: " + baseSeed);
        for (Map.Entry<BiomeType, Integer> entry : distribution.entrySet()) {
            double percentage = (entry.getValue() * 100.0) / samples;
            GameLogger.info(String.format("%s: %d occurrences (%.2f%%)",
                entry.getKey(), entry.getValue(), percentage));
        }
        GameLogger.info("===============================");
    }


    public void debugNoiseDistribution(int samples) {
        GameLogger.info("=== Noise Distribution Analysis ===");

        double minTemp = 1.0, maxTemp = 0.0, avgTemp = 0.0;
        double minMoist = 1.0, maxMoist = 0.0, avgMoist = 0.0;

        Random random = new Random(baseSeed);

        for (int i = 0; i < samples; i++) {
            float x = random.nextFloat() * 1000;
            float y = random.nextFloat() * 1000;

            double tempNoise = OpenSimplex2.noise2(temperatureSeed, x * TEMPERATURE_SCALE, y * TEMPERATURE_SCALE);
            double moistNoise = OpenSimplex2.noise2(moistureSeed, x * MOISTURE_SCALE, y * MOISTURE_SCALE);

            // Convert to 0-1 range
            double temp = (tempNoise + 1.0) / 2.0;
            double moist = (moistNoise + 1.0) / 2.0;

            minTemp = Math.min(minTemp, temp);
            maxTemp = Math.max(maxTemp, temp);
            avgTemp += temp;

            minMoist = Math.min(minMoist, moist);
            maxMoist = Math.max(maxMoist, moist);
            avgMoist += moist;
        }

        avgTemp /= samples;
        avgMoist /= samples;

        GameLogger.info(String.format("Temperature - Min: %.3f, Max: %.3f, Avg: %.3f",
            minTemp, maxTemp, avgTemp));
        GameLogger.info(String.format("Moisture - Min: %.3f, Max: %.3f, Avg: %.3f",
            minMoist, maxMoist, avgMoist));
        GameLogger.info("===============================");
    }

    public Biome getBiome(BiomeType type) {
        Biome biome = biomes.get(type);
        if (biome == null) {
            GameLogger.error("Missing biome type: " + type + ", falling back to PLAINS");
            return biomes.get(BiomeType.PLAINS);
        }
        return biome;
    }

    private void loadBiomesFromJson() {
        try {
            String jsonContent = GameFileSystem.getInstance().getDelegate().readString("Data/biomes.json");
            if (jsonContent == null) {
                initializeDefaultBiomes();
                return;
            }

            JsonParser parser = new JsonParser();
            JsonArray biomesArray = parser.parse(jsonContent).getAsJsonArray();

            for (JsonElement element : biomesArray) {
                JsonObject biomeObject = element.getAsJsonObject();
                BiomeData data = parseBiomeData(biomeObject);

                if (validateBiomeData(data)) {
                    Biome biome = createBiomeFromData(data);
                    biomes.put(biome.getType(), biome);

                } else {
                    GameLogger.error("Invalid biome data for: " + data.getName());
                }
            }

        } catch (Exception e) {
            GameLogger.error("Failed to load biomes: " + e.getMessage());
            initializeDefaultBiomes();
        }
    }

    private BiomeData parseBiomeData(JsonObject json) {
        BiomeData data = new BiomeData();
        data.setName(json.get("name").getAsString());
        data.setType(json.get("type").getAsString());

        JsonArray allowedTypes = json.getAsJsonArray("allowedTileTypes");
        List<Integer> tileTypes = new ArrayList<>();
        for (JsonElement type : allowedTypes) {
            tileTypes.add(type.getAsInt());
        }
        data.setAllowedTileTypes(tileTypes);

        JsonObject distObject = json.getAsJsonObject("tileDistribution");
        Map<Integer, Integer> distribution = new HashMap<>();
        double total = 0;
        for (Map.Entry<String, JsonElement> entry : distObject.entrySet()) {
            int tileType = Integer.parseInt(entry.getKey());
            double weight = entry.getValue().getAsDouble();
            distribution.put(tileType, (int) Math.round(weight));
            total += weight;
        }


        // Parse spawnable objects
        if (json.has("spawnableObjects")) {
            List<String> spawnableObjects = new ArrayList<>();
            JsonArray objectsArray = json.getAsJsonArray("spawnableObjects");
            for (JsonElement element : objectsArray) {
                spawnableObjects.add(element.getAsString());
            }
            data.setSpawnableObjects(spawnableObjects);
        }

        // Parse spawn chances
        if (json.has("spawnChances")) {
            Map<String, Double> chances = new HashMap<>();
            JsonObject chancesObj = json.getAsJsonObject("spawnChances");
            for (Map.Entry<String, JsonElement> entry : chancesObj.entrySet()) {
                chances.put(entry.getKey(), entry.getValue().getAsDouble());
            }
            data.setSpawnChances(chances);
        }
        if (Math.abs(total - 100.0) > 0.01) {
            GameLogger.error("Tile distribution does not sum to 100% for biome: " + data.getName());
            distribution = getDefaultDistribution(BiomeType.valueOf(data.getType()));
        }

        data.setTileDistribution(distribution);
        return data;
    }

    private boolean validateBiomeData(BiomeData data) {
        if (data.getName() == null || data.getType() == null) return false;
        if (data.getAllowedTileTypes() == null || data.getAllowedTileTypes().isEmpty()) return false;

        Map<Integer, Integer> dist = data.getTileDistribution();
        if (dist == null || dist.isEmpty()) return false;

        double total = dist.values().stream()
            .mapToDouble(Integer::intValue)
            .sum();

        return Math.abs(total - 100.0) < 0.01;
    }


    private Biome createBiomeFromData(BiomeData data) {
        Biome biome = new Biome(data.getName(), BiomeType.valueOf(data.getType()));
        biome.setAllowedTileTypes(data.getAllowedTileTypes());
        biome.setTileDistribution(data.getTileDistribution());

        // Load spawnable objects and chances
        if (data.getSpawnableObjects() != null) {
            biome.loadSpawnableObjects(data.getSpawnableObjects());
        }
        if (data.getSpawnChances() != null) {
            biome.loadSpawnChances(data.getSpawnChances());
        }

        return biome;
    }

    private Map<Integer, Integer> getDefaultDistribution(BiomeType type) {
        Map<Integer, Integer> dist = new HashMap<>();
        switch (type) {
            case DESERT:
                dist.put(16, 70); // sand
                dist.put(2, 20);  // dirt
                dist.put(1, 10);  // grass
                break;
            case SNOW:
                dist.put(4, 70);  // snow
                dist.put(1, 20);  // grass
                dist.put(3, 10);  // stone
                break;
            case HAUNTED:
                dist.put(8, 70);  // dark grass
                dist.put(2, 20);  // dirt
                dist.put(3, 10);  // stone
                break;
            default:
                dist.put(1, 70);  // grass
                dist.put(2, 20);  // dirt
                dist.put(3, 10);  // stone
        }
        return dist;
    }

    private void initializeDefaultBiomes() {
        // Ensure we have basic biomes even if loading fails
        if (!biomes.containsKey(BiomeType.PLAINS)) {
            Biome plains = new Biome("Plains", BiomeType.PLAINS);
            plains.setAllowedTileTypes(Arrays.asList(1, 2, 3));
            plains.getTileDistribution().put(1, 70);
            plains.getTileDistribution().put(2, 20);
            plains.getTileDistribution().put(3, 10);
            biomes.put(BiomeType.PLAINS, plains);
        }

        if (!biomes.containsKey(BiomeType.FOREST)) {
            Biome forest = new Biome("Forest", BiomeType.FOREST);
            forest.setAllowedTileTypes(Arrays.asList(1, 2, 3));
            forest.getTileDistribution().put(1, 60);
            forest.getTileDistribution().put(2, 30);
            forest.getTileDistribution().put(3, 10);
            biomes.put(BiomeType.FOREST, forest);
        }

        // Add other default biomes
        BiomeType[] requiredTypes = {BiomeType.SNOW, BiomeType.DESERT, BiomeType.HAUNTED};
        for (BiomeType type : requiredTypes) {
            if (!biomes.containsKey(type)) {
                Biome biome = new Biome(type.name(), type);
                biome.setAllowedTileTypes(Arrays.asList(1, 2, 3));
                biome.getTileDistribution().put(1, 80);
                biome.getTileDistribution().put(2, 15);
                biome.getTileDistribution().put(3, 5);
                biomes.put(type, biome);
            }
        }

        GameLogger.info("Default biomes initialized");
    }


    public static class BiomeData implements Serializable {
        private String name;
        private String type;
        private ArrayList<Integer> allowedTileTypes;
        private HashMap<Integer, Integer> tileDistribution;
        private int chunkX;
        private List<String> spawnableObjects;
        private Map<String, Double> spawnChances;
        private int chunkY;
        private BiomeType primaryBiomeType;
        private long lastModified;

        public BiomeData() {
            this.tileDistribution = new HashMap<>();
            this.allowedTileTypes = new ArrayList<>();
            this.spawnableObjects = new ArrayList<>();
            this.spawnChances = new HashMap<>();
        }

        public int getChunkX() {
            return chunkX;
        }

        public List<String> getSpawnableObjects() {
            return spawnableObjects;
        }

        public void setSpawnableObjects(List<String> objects) {
            this.spawnableObjects = objects;
        }

        public Map<String, Double> getSpawnChances() {
            return spawnChances;
        }

        public void setSpawnChances(Map<String, Double> chances) {
            this.spawnChances = chances;
        }

        public int getChunkY() {
            return chunkY;
        }

        public long getLastModified() {
            return lastModified;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getType() {
            return type;
        }

        public void setType(String type) {
            this.type = type;
        }

        public ArrayList<Integer> getAllowedTileTypes() {
            return allowedTileTypes;
        }

        public void setAllowedTileTypes(List<Integer> types) {
            if (types != null) {
                this.allowedTileTypes.clear();
                this.allowedTileTypes.addAll(types);
            }
        }

        public HashMap<Integer, Integer> getTileDistribution() {
            return tileDistribution;
        }

        public void setTileDistribution(Map<Integer, Integer> distribution) {
            if (distribution != null) {
                this.tileDistribution.clear();
                this.tileDistribution.putAll(distribution);
            }
        }

        public double getSpawnChanceForObject(WorldObject.ObjectType objectType) {
            return spawnChances != null ? spawnChances.getOrDefault(objectType, 0.0) : 0.0;
        }

        public BiomeType getPrimaryBiomeType() {
            return primaryBiomeType;
        }

        public void setPrimaryBiomeType(BiomeType type) {
            this.primaryBiomeType = type;
        }

        public void validate() {
            if (tileDistribution == null) tileDistribution = new HashMap<>();
            if (allowedTileTypes == null) allowedTileTypes = new ArrayList<>();
            if (spawnableObjects == null) spawnableObjects = new ArrayList<>();
            if (spawnChances == null) spawnChances = new HashMap<>();
        }
    }

    // Custom TypeAdapter for BiomeData
    private static class BiomeDataTypeAdapter extends TypeAdapter<BiomeData> {
        @Override
        public void write(JsonWriter out, BiomeData value) throws IOException {
            out.beginObject();

            // Write basic properties
            if (value.getName() != null) out.name("name").value(value.getName());
            if (value.getType() != null) out.name("type").value(value.getType());

            // Write allowed types
            if (value.getAllowedTileTypes() != null && !value.getAllowedTileTypes().isEmpty()) {
                out.name("allowedTileTypes");
                out.beginArray();
                for (Integer type : value.getAllowedTileTypes()) {
                    if (type != null) out.value(type);
                }
                out.endArray();
            }

            // Write distribution
            if (value.getTileDistribution() != null && !value.getTileDistribution().isEmpty()) {
                out.name("tileDistribution");
                out.beginObject();
                for (Map.Entry<Integer, Integer> entry : value.getTileDistribution().entrySet()) {
                    if (entry.getKey() != null && entry.getValue() != null) {
                        out.name(entry.getKey().toString()).value(entry.getValue());
                    }
                }
                out.endObject();
            }

            // Write optional properties
            if (value.getPrimaryBiomeType() != null) {
                out.name("primaryBiomeType").value(value.getPrimaryBiomeType().name());
            }

            out.endObject();
        }

        @Override
        public BiomeData read(JsonReader in) throws IOException {
            BiomeData data = new BiomeData();
            in.beginObject();

            while (in.hasNext()) {
                String fieldName = in.nextName();
                try {
                    switch (fieldName) {
                        case "name":
                            data.setName(in.nextString());
                            break;
                        case "type":
                            data.setType(in.nextString());
                            break;
                        case "allowedTileTypes":
                            in.beginArray();
                            while (in.hasNext()) {
                                try {
                                    data.getAllowedTileTypes().add(in.nextInt());
                                } catch (Exception e) {
                                    in.skipValue();
                                    GameLogger.error("Skipped invalid allowed tile type");
                                }
                            }
                            in.endArray();
                            break;
                        case "tileDistribution":
                            in.beginObject();
                            while (in.hasNext()) {
                                try {
                                    String key = in.nextName();
                                    int value = in.nextInt();
                                    data.getTileDistribution().put(Integer.parseInt(key), value);
                                } catch (Exception e) {
                                    in.skipValue();
                                    GameLogger.error("Skipped invalid tile distribution entry");
                                }
                            }
                            in.endObject();
                            break;
                        case "primaryBiomeType":
                            try {
                                data.setPrimaryBiomeType(BiomeType.valueOf(in.nextString()));
                            } catch (Exception e) {
                                in.skipValue();
                            }
                            break;
                        default:
                            in.skipValue();
                            break;
                    }
                } catch (Exception e) {
                    GameLogger.error("Error parsing field " + fieldName + ": " + e.getMessage());
                    in.skipValue();
                }
            }

            in.endObject();
            data.validate();
            return data;
        }
    }
}

================
File: main/java/io/github/pokemeetup/managers/BiomeRenderer.java
================
package io.github.pokemeetup.managers;


import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.textures.TextureManager;


public class BiomeRenderer {
    private static final float TEXTURE_BLEED_FIX = 0.001f;
    public void renderChunk(SpriteBatch batch, Chunk chunk, World world) {
        int chunkX = chunk.getChunkX();
        int chunkY = chunk.getChunkY();
        Color originalColor = batch.getColor().cpy();

        for (int x = 0; x < Chunk.CHUNK_SIZE; x++) {
            for (int y = 0; y < Chunk.CHUNK_SIZE; y++) {
                float worldX = (chunkX * Chunk.CHUNK_SIZE + x) * World.TILE_SIZE;
                float worldY = (chunkY * Chunk.CHUNK_SIZE + y) * World.TILE_SIZE;

                Vector2 tilePos = new Vector2(chunkX * Chunk.CHUNK_SIZE + x,
                    chunkY * Chunk.CHUNK_SIZE + y);
                Color tileColor = world.getCurrentWorldColor().cpy();

                Float lightLevel = world.getLightLevelAtTile(tilePos);
                if (lightLevel != null && lightLevel > 0) {
                    Color lightColor = new Color(1f, 0.8f, 0.6f, 1f);
                    tileColor.lerp(lightColor, lightLevel * 0.7f);
                }

                batch.setColor(tileColor);

                int tileType = chunk.getTileType(x, y);
                TextureRegion tileTexture = TextureManager.getTileTexture(tileType);
                if (tileTexture != null) {
                    // Get the original UV coordinates
                    float u = tileTexture.getU();
                    float v = tileTexture.getV();
                    float u2 = tileTexture.getU2();
                    float v2 = tileTexture.getV2();

                    // Apply bleed fix and flip V coordinates
                    float uFixed = u + TEXTURE_BLEED_FIX;
                    float vFixed = v2 - TEXTURE_BLEED_FIX;  // Use v2 for bottom
                    float u2Fixed = u2 - TEXTURE_BLEED_FIX;
                    float v2Fixed = v + TEXTURE_BLEED_FIX;  // Use v for top

                    batch.draw(tileTexture.getTexture(),
                        worldX, worldY,                // Position
                        World.TILE_SIZE, World.TILE_SIZE,  // Size
                        uFixed, vFixed,                // UV start (bottom-left)
                        u2Fixed, v2Fixed);            // UV end (top-right)
                }
            }
        }

        batch.setColor(originalColor);
    }


    public enum Direction {
        NORTH, SOUTH, EAST, WEST
    }
}

================
File: main/java/io/github/pokemeetup/managers/BiomeTransitionResult.java
================
package io.github.pokemeetup.managers;

import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;

public class BiomeTransitionResult {
    public final Biome primaryBiome;
    public final Biome secondaryBiome;
    public final float transitionFactor;

    public BiomeTransitionResult(Biome primaryBiome, Biome secondaryBiome, float transitionFactor) {
        this.primaryBiome = primaryBiome;
        this.secondaryBiome = secondaryBiome;
        this.transitionFactor = transitionFactor;
    }

    public Biome getPrimaryBiome() {
        return primaryBiome;
    }

    public Biome getSecondaryBiome() {
        return secondaryBiome;
    }

    public float getTransitionFactor() {
        return transitionFactor;
    }
}

================
File: main/java/io/github/pokemeetup/managers/DatabaseManager.java
================
package io.github.pokemeetup.managers;

import at.favre.lib.crypto.bcrypt.BCrypt;
import io.github.pokemeetup.utils.GameLogger;

import java.nio.charset.StandardCharsets;
import java.sql.*;

import static io.github.pokemeetup.utils.PasswordUtils.hashPassword;

public class DatabaseManager {
    private static final String DB_PATH = "real";
    public static final String DB_USER = "sa";
    public static final String DB_PASS = "";
    private static final int BASE_PORT = 9101;
    private Connection connection;


    public DatabaseManager() {
        try {
            connectToDatabase();
            initializeDatabase();
        } catch (SQLException e) {
            GameLogger.info("Database initialization error: " + e.getMessage());
            throw new RuntimeException("Failed to initialize database", e);
        }
    }

    public boolean checkUsernameExists(String username) {
        String sql = "SELECT COUNT(*) FROM PLAYERS WHERE USERNAME = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                return rs.getInt(1) > 0;
            }
            return false;
        } catch (SQLException e) {
            GameLogger.error("Database error checking username: " + e.getMessage());
            throw new RuntimeException("Database error checking username", e);
        }
    }

    private void connectToDatabase() throws SQLException {
        @SuppressWarnings("DefaultLocale")
        String url = String.format("jdbc:h2:tcp://localhost:%d/%s", BASE_PORT, DB_PATH);
        connection = DriverManager.getConnection(url, DB_USER, DB_PASS);
        GameLogger.info("Connected to database on port " + BASE_PORT);
    }


    public void dispose() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
                GameLogger.info("Database connection closed");
            }
        } catch (SQLException e) {
            GameLogger.error("Error closing database connection: " + e.getMessage());
        }
    }

    private Connection getConnection() throws SQLException {
        if (connection == null || connection.isClosed()) {
            connectToDatabase();
        }
        return connection;
    }

    private void ensureConnection() {
        try {
            if (connection == null || connection.isClosed()) {
                GameLogger.info("Reconnecting to database...");
                connectToDatabase();
            }
        } catch (SQLException e) {
            GameLogger.info("Error checking connection: " + e.getMessage());
        }
    }
    public boolean registerPlayer(String username, String password) {
        if (doesUsernameExist(username)) {
            GameLogger.info("Username already exists: " + username);
            return false;
        }
        String sql = "INSERT INTO PLAYERS (username, password_hash, x_pos, y_pos) VALUES (?, ?, 0, 0)";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            String hashedPassword = hashPassword(password);
            stmt.setString(1, username);
            stmt.setString(2, hashedPassword);

            int result = stmt.executeUpdate();
            GameLogger.info("Player registration " + (result > 0 ? "successful" : "failed") +
                " for username: " + username);
            return result > 0;
        } catch (SQLException e) {
            GameLogger.error("Database error registering player: " + e.getMessage());
            throw new RuntimeException("Database error registering player", e);
        }
    }
    private void initializeDatabase() {
        String createPlayersTable =
            "CREATE TABLE IF NOT EXISTS PLAYERS (" +
                "id BIGINT AUTO_INCREMENT PRIMARY KEY, " +
                "username VARCHAR(255) NOT NULL UNIQUE, " +
                "password_hash VARCHAR(255) NOT NULL, " +
                "created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP(), " +
                "last_login TIMESTAMP, " +
                "status VARCHAR(20) DEFAULT 'OFFLINE', " +
                "x_pos INT DEFAULT 0, " +
                "y_pos INT DEFAULT 0" +
                ")";

        try (Statement stmt = connection.createStatement()) {
            stmt.execute(createPlayersTable);
            GameLogger.info("Database tables initialized successfully");
        } catch (SQLException e) {
            GameLogger.error("Error initializing database: " + e.getMessage());
            throw new RuntimeException("Failed to initialize database", e);
        }
    }

    public void updatePlayerCoordinates(String username, int x, int y) {
        ensureConnection();
        String updateSQL = "UPDATE PLAYERS SET x_pos = ?, y_pos = ? WHERE username = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(updateSQL)) {
            pstmt.setInt(1, x);
            pstmt.setInt(2, y);
            pstmt.setString(3, username);
            GameLogger.info("Updated coordinates for " + username + ": (" + x + ", " + y + ")");
        } catch (SQLException e) {
            GameLogger.error("Error updating coordinates: " + e.getMessage());
            throw new RuntimeException("Failed to update player coordinates", e);
        }
    }

    private boolean doesUsernameExist(String username) {
        String sql = "SELECT 1 FROM PLAYERS WHERE username = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();
            boolean exists = rs.next();
            GameLogger.info("Username check: '" + username + "' exists: " + exists);
            return exists;
        } catch (SQLException e) {
            GameLogger.error("Error checking if username exists: " + e.getMessage());
            throw new RuntimeException("Database error checking username", e);
        }
    }

    public void closeConnection() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
                GameLogger.info("Database connection closed.");
            }
        } catch (SQLException e) {
            GameLogger.info("Error closing database connection: " + e.getMessage());
        }
    }

    public boolean authenticatePlayer(String username, String password) {
        // Updated to use password_hash column name
        String query = "SELECT password_hash FROM PLAYERS WHERE username = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(query)) {

            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                String storedHash = rs.getString("password_hash");
                boolean verified = BCrypt.verifyer().verify(
                    password.getBytes(StandardCharsets.UTF_8),
                    storedHash.getBytes(StandardCharsets.UTF_8)
                ).verified;

                if (verified) {
                    updateLastLogin(username);
                    GameLogger.info("Authentication successful for username: " + username);
                } else {
                    GameLogger.info("Authentication failed - invalid password for username: " + username);
                }

                return verified;
            }
            GameLogger.info("Authentication failed - username not found: " + username);
            return false;
        } catch (SQLException e) {
            GameLogger.error("Database error during authentication: " + e.getMessage());
            return false;
        }
    }  public String getPasswordHash(String username) {
        String query = "SELECT password_hash FROM PLAYERS WHERE username = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(query)) {

            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                String storedHash = rs.getString("password_hash");
                GameLogger.info("Retrieved password hash for username: " + username);
                return storedHash;
            } else {
                GameLogger.info("No password hash found for username: " + username);
                return null;
            }
        } catch (SQLException e) {
            GameLogger.error("Database error retrieving password hash: " + e.getMessage());
            return null;
        }
    }
    private void updateLastLogin(String username) {
        String sql = "UPDATE PLAYERS SET LAST_LOGIN = CURRENT_TIMESTAMP(), STATUS = 'ONLINE' WHERE USERNAME = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, username);
            stmt.executeUpdate();
        } catch (SQLException e) {
            GameLogger.error("Error updating last login time: " + e.getMessage());
        }
    }


    public int[] getPlayerCoordinates(String username) {
        String sql = "SELECT x_pos, y_pos FROM PLAYERS WHERE username = ?";
        try (Connection conn = getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return new int[]{rs.getInt("x_pos"), rs.getInt("y_pos")};
            }
            return new int[]{0, 0};
        } catch (SQLException e) {
            GameLogger.error("Error retrieving coordinates: " + e.getMessage());
            return new int[]{0, 0};
        }
    }
}

================
File: main/java/io/github/pokemeetup/managers/DisconnectionManager.java
================
package io.github.pokemeetup.managers;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.screens.DisconnectionScreen;
import io.github.pokemeetup.screens.LoginScreen;
import io.github.pokemeetup.utils.GameLogger;

import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

public class DisconnectionManager {
    private static final int MAX_RECONNECT_ATTEMPTS = 3;
    private static final long RECONNECT_DELAY = 5000; // 5 seconds
    private static final long SAVE_INTERVAL = 30000; // 30 seconds

    private final AtomicBoolean isHandlingDisconnect = new AtomicBoolean(false);
    private final AtomicInteger reconnectAttempts = new AtomicInteger(0);
    private final CreatureCaptureGame game;
    private Screen previousScreen;
    private DisconnectionScreen disconnectionScreen;
    private String disconnectReason;
    private boolean showingDisconnectScreen = false;
    private ScheduledFuture<?> autoSaveTask;
    private ScheduledExecutorService scheduler;

    public DisconnectionManager(CreatureCaptureGame game) {
        this.game = game;
    }

    public void handleDisconnect(String reason) {
        if (isHandlingDisconnect.getAndSet(true)) {
            return; // Already handling disconnect
        }

        GameLogger.info("Handling disconnect: " + reason);
        disconnectReason = reason;
        reconnectAttempts.set(0);
        previousScreen = game.getScreen();

        // Save player state if possible
        savePlayerState();

        // Schedule periodic saves while disconnected
        scheduleAutoSave();

        // Show disconnect screen on main thread
        Gdx.app.postRunnable(() -> {
            if (!showingDisconnectScreen) {
                showDisconnectScreen();
            }
        });
    }

    private void scheduleAutoSave() {
        if (scheduler != null && !scheduler.isShutdown()) {
            autoSaveTask = scheduler.scheduleWithFixedDelay(
                this::savePlayerState,
                SAVE_INTERVAL,
                SAVE_INTERVAL,
                TimeUnit.MILLISECONDS
            );
        }
    }

    private void savePlayerState() {
        try {
            if (GameContext.get().getPlayer() != null && GameContext.get().getWorld() != null) {
                GameContext.get().getWorld().save();
                GameLogger.info("Saved player state during disconnect");
            }
        } catch (Exception e) {
            GameLogger.error("Failed to save player state: " + e.getMessage());
        }
    }

    public void attemptReconnect() {
        if (reconnectAttempts.get() >= MAX_RECONNECT_ATTEMPTS) {
            exitToLogin("Maximum reconnection attempts reached");
            return;
        }

        reconnectAttempts.incrementAndGet();
        GameLogger.info("Attempting reconnect: " + reconnectAttempts.get() + "/" + MAX_RECONNECT_ATTEMPTS);

        GameClient client = GameContext.get().getGameClient();
        if (client != null) {
            client.dispose();
            GameContext.get().setGameClient(null);
            try {
                Thread.sleep(RECONNECT_DELAY);
                client.connect();
            } catch (Exception e) {
                GameLogger.error("Reconnection attempt failed: " + e.getMessage());
                handleReconnectFailure();
            }
        } else {
            exitToLogin("Game client is null");
        }
    }

    private void handleReconnectFailure() {
        if (reconnectAttempts.get() < MAX_RECONNECT_ATTEMPTS) {
            // Schedule another attempt
            Gdx.app.postRunnable(this::attemptReconnect);
        } else {
            exitToLogin("Unable to reconnect to server");
        }
    }

    private void showDisconnectScreen() {
        showingDisconnectScreen = true;
        disconnectionScreen = new DisconnectionScreen(game, disconnectReason, this);
        Gdx.app.postRunnable(() -> {
            game.setScreen(disconnectionScreen);
        });
    }

    public void onReconnectionSuccess() {
        Gdx.app.postRunnable(() -> {
            isHandlingDisconnect.set(false);
            showingDisconnectScreen = false;
            cancelAutoSave();

            if (previousScreen != null) {
                game.setScreen(previousScreen);
                GameLogger.info("Returned to previous screen after reconnection");
            }
        });
    }

    private void cancelAutoSave() {
        if (autoSaveTask != null && !autoSaveTask.isDone()) {
            autoSaveTask.cancel(false);
        }
    }

    private void exitToLogin(String reason) {
        Gdx.app.postRunnable(() -> {
            cleanup();
            game.setScreen(new LoginScreen(game));
            GameLogger.info("Exited to login: " + reason);
        });
    }

    public void cleanup() {
        isHandlingDisconnect.set(false);
        showingDisconnectScreen = false;
        cancelAutoSave();

        if (GameContext.get().getGameClient() != null) {
            GameContext.get().getGameClient().dispose();
            GameContext.get().setGameClient(null);
        }

        if (GameContext.get().getWorld() != null) {
            GameContext.get().getWorld().save();
            GameContext.get().getWorld().dispose();
            GameContext.get().setWorld(null);
        }

        if (previousScreen != null) {
            previousScreen.dispose();
            previousScreen = null;
        }

        if (disconnectionScreen != null) {
            disconnectionScreen.dispose();
            disconnectionScreen = null;
        }

        System.gc();
    }

    public boolean isHandlingDisconnect() {
        return isHandlingDisconnect.get();
    }

    public void setScheduler(ScheduledExecutorService scheduler) {
        this.scheduler = scheduler;
    }
}

================
File: main/java/io/github/pokemeetup/managers/WaterEffectManager.java
================
package io.github.pokemeetup.managers;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Pool;
import io.github.pokemeetup.utils.textures.TextureManager;

public class WaterEffectManager {
    private static final float RIPPLE_DURATION = 0.5f;
    private static final float RIPPLE_MAX_SCALE = 1.5f;

    private final Pool<Ripple> ripplePool;
    private final Array<Ripple> activeRipples;
    private final TextureRegion rippleTexture;

    public WaterEffectManager() {
        rippleTexture = TextureManager.tiles.findRegion("water_puddle");
        activeRipples = new Array<>();

        ripplePool = new Pool<Ripple>() {
            @Override
            protected Ripple newObject() {
                return new Ripple();
            }
        };
    }

    public void createRipple(float x, float y) {
        Ripple ripple = ripplePool.obtain();
        ripple.init(x, y);
        activeRipples.add(ripple);
    }

    public void update(float delta) {
        for (int i = activeRipples.size - 1; i >= 0; i--) {
            Ripple ripple = activeRipples.get(i);
            ripple.update(delta);

            if (ripple.isComplete()) {
                activeRipples.removeIndex(i);
                ripplePool.free(ripple);
            }
        }
    }

    public void render(SpriteBatch batch) {
        Color originalColor = batch.getColor().cpy();

        for (Ripple ripple : activeRipples) {
            float alpha = 1f - (ripple.stateTime / RIPPLE_DURATION);
            batch.setColor(1, 1, 1, alpha * 0.5f);

            float scale = 1f + ((RIPPLE_MAX_SCALE - 1f) * (ripple.stateTime / RIPPLE_DURATION));
            float width = rippleTexture.getRegionWidth() * scale;
            float height = rippleTexture.getRegionHeight() * scale;

            batch.draw(rippleTexture,
                ripple.x - width/2,
                ripple.y - height/2,
                width, height);
        }

        batch.setColor(originalColor);
    }

    private static class Ripple {
        float x, y;
        float stateTime;

        void init(float x, float y) {
            this.x = x;
            this.y = y;
            this.stateTime = 0;
        }

        void update(float delta) {
            stateTime += delta;
        }

        boolean isComplete() {
            return stateTime >= RIPPLE_DURATION;
        }
    }
}

================
File: main/java/io/github/pokemeetup/managers/WaterEffectsRenderer.java
================
package io.github.pokemeetup.managers;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.textures.TileType;

public class WaterEffectsRenderer {
    private static final float FRAME_DURATION = 0.15f;
    private static final float SCALE_FACTOR = 1.5f;
    private static final float SOUND_INTERVAL = 0.4f; // Time between splash sounds

    private Animation<TextureRegion> movingAnimation;
    private TextureRegion standingTexture;
    private float stateTime = 0;
    private boolean initialized = false;
    private float soundTimer = 0;
    private boolean wasOnWater = false;

    public WaterEffectsRenderer() {
        initializeAnimations();
    }

    private void initializeAnimations() {
        try {
            if (TextureManager.effects == null) {
                GameLogger.error("Effects atlas is null");
                return;
            }

            TextureRegion movingRegion = TextureManager.effects.findRegion("water_player_moving");
            standingTexture = TextureManager.effects.findRegion("water_player_standing");

            if (movingRegion == null || standingTexture == null) {
                GameLogger.error("Failed to load water effect textures");
                return;
            }

            int frameWidth = movingRegion.getRegionWidth() / 3;
            int frameHeight = movingRegion.getRegionHeight();

            TextureRegion[] movingFrames = new TextureRegion[3];
            for (int i = 0; i < 3; i++) {
                movingFrames[i] = new TextureRegion(movingRegion,
                    i * frameWidth, 0, frameWidth, frameHeight);
            }

            movingAnimation = new Animation<>(FRAME_DURATION, movingFrames);
            initialized = true;
            GameLogger.info("Water effects animations initialized successfully");

        } catch (Exception e) {
            GameLogger.error("Error initializing water effects: " + e.getMessage());
            initialized = false;
        }
    }

    public void update(float deltaTime) {
        if (!initialized) {
            initializeAnimations();
            return;
        }
        stateTime += deltaTime;
        if (soundTimer > 0) {
            soundTimer -= deltaTime;
        }
    }

    public void render(SpriteBatch batch, Player player) {
        if (!initialized || batch == null || player == null) {
            return;
        }

        try {
            boolean onWater = isPlayerOnWater(player);

            // Handle water splash sounds
            if (onWater) {
                if (!wasOnWater) {
                    // Just stepped into water
                    playWaterSound();
                } else if (player.isMoving() && soundTimer <= 0) {
                    // Continue playing splash sounds while moving in water
                    playWaterSound();
                    soundTimer = SOUND_INTERVAL;
                }
            }
            wasOnWater = onWater;

            if (!onWater) {
                return;
            }

            float playerX = player.getX();
            float playerY = player.getY();
            float effectX = playerX - (World.TILE_SIZE * 0.25f);
            float effectY = playerY - (World.TILE_SIZE * 0.25f);
            float effectWidth = World.TILE_SIZE * SCALE_FACTOR;
            float effectHeight = World.TILE_SIZE * 0.75f;

            TextureRegion currentFrame = player.isMoving() ?
                movingAnimation.getKeyFrame(stateTime, true) :
                standingTexture;

            if (currentFrame != null) {
                batch.draw(currentFrame, effectX, effectY, effectWidth, effectHeight);
            }

        } catch (Exception e) {
            GameLogger.error("Error rendering water effects: " + e.getMessage());
        }
    }

    private void playWaterSound() {
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.PUDDLE);
    }

    private boolean isPlayerOnWater(Player player) {
        if (player == null || player.getWorld() == null) {
            return false;
        }

        World world = player.getWorld();
        int tileX = player.getTileX();
        int tileY = player.getTileY();

        // Get chunk coordinates
        int chunkX = Math.floorDiv(tileX, World.CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, World.CHUNK_SIZE);
        Vector2 chunkPos = new Vector2(chunkX, chunkY);

        // Check if chunk exists
        if (!world.getChunks().containsKey(chunkPos)) {
            return false;
        }

        // Get local coordinates within chunk
        int localX = Math.floorMod(tileX, World.CHUNK_SIZE);
        int localY = Math.floorMod(tileY, World.CHUNK_SIZE);

        Chunk chunk = world.getChunks().get(chunkPos);
        if (chunk == null) {
            return false;
        }

        int tileType = chunk.getTileType(localX, localY);
        return isWaterTile(tileType);
    }

    private boolean isWaterTile(int tileType) {
        return tileType == TileType.WATER_PUDDLE ||
            tileType == TileType.WATER_PUDDLE_TOP_LEFT ||
            tileType == TileType.WATER_PUDDLE_TOP_RIGHT ||
            tileType == TileType.WATER_PUDDLE_BOTTOM_LEFT ||
            tileType == TileType.WATER_PUDDLE_BOTTOM_RIGHT ||
            tileType == TileType.WATER_PUDDLE_TOP_MIDDLE ||
            tileType == TileType.WATER_PUDDLE_BOTTOM_MIDDLE ||
            tileType == TileType.WATER_PUDDLE_LEFT_MIDDLE ||
            tileType == TileType.WATER_PUDDLE_RIGHT_MIDDLE;
    }

    public boolean isInitialized() {
        return initialized;
    }

    public void dispose() {
        movingAnimation = null;
        standingTexture = null;
        initialized = false;
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/client/GameClient.java
================
package io.github.pokemeetup.multiplayer.client;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Preferences;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryonet.Client;
import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.Listener;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.managers.DisconnectionManager;
import io.github.pokemeetup.multiplayer.OtherPlayer;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;


public class GameClient {
    private static final long CONNECTION_TIMEOUT = 45000;
    private static final long RECONNECT_DELAY = 3000;
    private static final int MAX_RECONNECT_ATTEMPTS = 5;
    private static final int MAX_CONCURRENT_CHUNK_REQUESTS = 4;
    private static final long CHUNK_REQUEST_INTERVAL = 50;
    private static final float SYNC_INTERVAL = 1 / 60f;
    private static final float INTERPOLATION_SPEED = 10f;
    private static final float UPDATE_INTERVAL = 1 / 20f;
    private static final int BUFFER_SIZE = 8192;
    private static final int INCREASED_BUFFER = 16384;
    private final DisconnectionManager disconnectHandler;
    private final PlayerDataResponseHandler playerDataHandler = new PlayerDataResponseHandler();
    private final Queue<Vector2> chunkRequestQueue = new ConcurrentLinkedQueue<>();
    private final Map<Vector2, ChunkFragmentAssembler> fragmentAssemblers = new ConcurrentHashMap<>();
    private final Set<Vector2> pendingChunks = new ConcurrentHashMap<Vector2, Boolean>().keySet(true);
    private final AtomicBoolean isAuthenticated = new AtomicBoolean(false);
    private final AtomicBoolean isDisposing = new AtomicBoolean(false);
    private final ReentrantLock connectionLock = new ReentrantLock();
    private final ConcurrentHashMap<String, OtherPlayer> otherPlayers = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<UUID, WildPokemon> trackedWildPokemon = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<UUID, NetworkSyncData> syncedPokemonData = new ConcurrentHashMap<>();
    private final BlockingQueue<NetworkProtocol.ChatMessage> chatMessageQueue = new LinkedBlockingQueue<>();
    private final ConcurrentHashMap<String, NetworkProtocol.PlayerUpdate> playerUpdates = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler;
    private final Queue<Object> pendingMessages = new ConcurrentLinkedQueue<>();
    private final Preferences credentials;
    private final AtomicBoolean isConnected = new AtomicBoolean(false);
    private final AtomicBoolean isConnecting = new AtomicBoolean(false);
    private final Map<Vector2, Chunk> chunks = new ConcurrentHashMap<>();
    private final Map<Vector2, Future<Chunk>> loadingChunks = new ConcurrentHashMap<>();
    private final AtomicBoolean isShuttingDown = new AtomicBoolean(false);
    private final Set<String> recentJoinEvents = Collections.synchronizedSet(new HashSet<>());
    public AtomicBoolean shouldReconnect = new AtomicBoolean(true);
    private boolean isSinglePlayer;
    private int reconnectAttempts = 0;
    private volatile boolean isInitializing = false;
    private long lastRequestTime = 0;
    private float syncTimer = 0;
    private PlayerData lastKnownState;
    private Consumer<NetworkProtocol.ChatMessage> chatMessageHandler;
    private LoginResponseListener loginResponseListener;
    private RegistrationResponseListener registrationResponseListener;
    private PokemonUpdateHandler pokemonUpdateHandler;
    private WorldData worldData;
    private float updateAccumulator = 0;
    private volatile boolean isInitialized = false;
    private volatile boolean fullyInitialized = false;
    private InitializationListener initializationListener;
    private String pendingUsername;
    private String pendingPassword;
    private String currentPassword;
    private volatile boolean loginRequestSent = false;
    private String pendingRegistrationUsername;
    private String pendingRegistrationPassword;
    private volatile boolean processingMessages = false;
    private volatile ConnectionState connectionState = ConnectionState.DISCONNECTED;
    private volatile Client client;
    private ServerConnectionConfig serverConfig;
    private String localUsername;
    private long worldSeed;
    private ReconnectionListener reconnectionListener;
    public GameClient(ServerConnectionConfig config, boolean isSinglePlayer) {

        this.disconnectHandler = null;
        this.serverConfig = config;
        this.isSinglePlayer = isSinglePlayer;
        this.lastKnownState = new PlayerData();
        new BiomeManager(System.currentTimeMillis());

        this.credentials = Gdx.app.getPreferences("game-credentials");
        this.serverConfig = config;
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
        this.lastKnownState = new PlayerData();

        if (!isSinglePlayer) {
            setupReconnectionHandler();
            loadSavedCredentials();
            if (serverConfig != null) {
                setServerConfig(serverConfig);
            } else {
                GameLogger.info("Failed to load server config, multiplayer disabled.");
            }

            this.client = new Client(INCREASED_BUFFER, INCREASED_BUFFER);
            NetworkProtocol.registerClasses(client.getKryo());
            client.getKryo().setReferences(false);
        }
    }

    public void setShouldReconnect(AtomicBoolean shouldReconnect) {
        this.shouldReconnect = shouldReconnect;
    }

    public void setReconnectionListener(ReconnectionListener listener) {
        this.reconnectionListener = listener;
    }

    public void savePlayerData(UUID uuid, PlayerData data) {
        if (isSinglePlayer || !isConnected() || !isAuthenticated()) {
            GameLogger.error("Cannot save player data - not in multiplayer mode or not connected");
            return;
        }

        try {
            NetworkProtocol.SavePlayerDataRequest request = new NetworkProtocol.SavePlayerDataRequest();
            request.uuid = uuid;
            request.playerData = data;
            request.timestamp = System.currentTimeMillis();
            client.sendTCP(request);
            GameLogger.info("Sent player data save request for UUID: " + uuid);
        } catch (Exception e) {
            GameLogger.error("Failed to save player data: " + e.getMessage());
        }
    }

    public void update(float deltaTime) {
        if (!isAuthenticated.get() || connectionState != ConnectionState.CONNECTED) {
            return;
        }
        syncTimer += deltaTime;
        if (syncTimer >= SYNC_INTERVAL) {
            syncTimer = 0;
            processChatMessages();
            updatePokemonStates(deltaTime);
        }

        updateOtherPlayers(deltaTime);
        updateAccumulator += deltaTime;

        if (updateAccumulator >= UPDATE_INTERVAL) {
            updateAccumulator = 0;
            if (!isSinglePlayer && GameContext.get().getPlayer() != null && isAuthenticated() && isInitialized) {
                sendPlayerUpdate();
            }
            processChunkQueue();
        }
    }

    private void completeInitialization() {
        if (isInitialized) return;

        isInitialized = true;
        fullyInitialized = true;
        GameLogger.info("Game client initialization complete");

        if (initializationListener != null) {
            Gdx.app.postRunnable(() -> {
                try {
                    initializationListener.onInitializationComplete(true);
                } catch (Exception e) {
                    GameLogger.error("Error notifying initialization completion: " + e.getMessage());
                }
            });
        }
    }

    public void sendPokemonSpawn(NetworkProtocol.WildPokemonSpawn spawnData) {
        if (!isConnected() || !isAuthenticated() || isSinglePlayer) {
            return;
        }

        try {
            // Validate spawn data
            if (spawnData.data == null || spawnData.uuid == null) {
                GameLogger.error("Invalid Pokemon spawn data");
                return;
            }

            // Set timestamp if not already set
            if (spawnData.timestamp == 0) {
                spawnData.timestamp = System.currentTimeMillis();
            }

            // Send spawn data to server
            client.sendTCP(spawnData);

            // Track locally
            if (!trackedWildPokemon.containsKey(spawnData.uuid)) {
                // Create local Pokemon instance
                TextureRegion overworldSprite = TextureManager.getOverworldSprite(spawnData.data.getName());
                if (overworldSprite != null) {
                    WildPokemon pokemon = new WildPokemon(
                        spawnData.data.getName(),
                        spawnData.data.getLevel(),
                        (int) spawnData.x,
                        (int) spawnData.y,
                        overworldSprite
                    );
                    pokemon.setUuid(spawnData.uuid);
                    pokemon.setSpawnTime(spawnData.timestamp / 1000L);

                    if (GameContext.get().getWorld() != null) {
                        pokemon.setWorld(GameContext.get().getWorld());
                        Vector2 chunkPos = new Vector2(
                            Math.floorDiv((int) spawnData.x, World.CHUNK_SIZE * World.TILE_SIZE),
                            Math.floorDiv((int) spawnData.y, World.CHUNK_SIZE * World.TILE_SIZE)
                        );
                        GameContext.get().getWorld().getPokemonSpawnManager().addPokemonToChunk(pokemon, chunkPos);
                    }

                    trackedWildPokemon.put(spawnData.uuid, pokemon);
                    syncedPokemonData.put(spawnData.uuid, new NetworkSyncData());

                    GameLogger.info("Sent and tracked new Pokemon spawn: " + spawnData.data.getName() +
                        " at (" + spawnData.x + "," + spawnData.y + ")");
                } else {
                    GameLogger.error("Failed to load sprite for Pokemon: " + spawnData.data.getName());
                }
            } else {
                GameLogger.info("Pokemon already tracked locally with UUID: " + spawnData.uuid);
            }

        } catch (Exception e) {
            GameLogger.error("Failed to send Pokemon spawn: " + e.getMessage());
            if (!isConnected()) {
                handleConnectionFailure(e);
            }
        }
    }

    public Client getClient() {
        return client;
    }

    public void setInitializationListener(InitializationListener listener) {
        this.initializationListener = listener;
        // If already initialized, notify immediately
        if (isInitialized()) {
            Gdx.app.postRunnable(() -> listener.onInitializationComplete(true));
        }
    }

    private void loadSavedCredentials() {
        try {
            String savedUsername = credentials.getString("username", "");
            String savedPassword = credentials.getString("password", "");

            if (!savedUsername.isEmpty() && !savedPassword.isEmpty()) {
                this.localUsername = savedUsername;
                this.currentPassword = savedPassword;
                this.pendingUsername = savedUsername;
                this.pendingPassword = savedPassword;
                GameLogger.info("Loaded saved credentials for: " + savedUsername);
            } else {
                this.localUsername = "";
                this.currentPassword = "";
                this.pendingUsername = "";
                this.pendingPassword = "";
                GameLogger.info("No saved credentials found");
            }
        } catch (Exception e) {
            GameLogger.error("Failed to load credentials: " + e.getMessage());
        }
    }

    public void connect() {
        if (isConnecting.get() || isConnected()) {
            GameLogger.info("Already connecting or connected");
            return;
        }

        synchronized (connectionLock) {
            try {
                isConnecting.set(true);
                cleanupExistingConnection();

                client = new Client(BUFFER_SIZE, BUFFER_SIZE);
                Kryo kryo = client.getKryo();
                kryo.setReferences(false);
                NetworkProtocol.registerClasses(kryo);

                client.addListener(new Listener() {
                    @Override
                    public void connected(Connection connection) {
                        GameLogger.info("Connected to server");
                        connectionState = ConnectionState.CONNECTED;
                        isConnected.set(true);
                        isConnecting.set(false);
                        reconnectAttempts = 0;
                        if (reconnectionListener != null) {
                            reconnectionListener.onReconnectionSuccess();
                        }
                        if (pendingUsername != null && pendingPassword != null) {
                            com.badlogic.gdx.utils.Timer.schedule(new com.badlogic.gdx.utils.Timer.Task() {
                                @Override
                                public void run() {
                                    sendLoginRequest(pendingUsername, pendingPassword);
                                }
                            }, 0.5f);
                        } else {
                            GameLogger.error("No credentials available. Cannot authenticate.");
                            handleConnectionFailure(new Exception("Missing credentials"));
                        }
                    }

                    @Override
                    public void received(Connection connection, Object object) {
                        if (object instanceof NetworkProtocol.GetPlayerDataResponse ||
                            object instanceof NetworkProtocol.SavePlayerDataResponse) {
                            handlePlayerDataResponse(object);
                            return;
                        }
                        handleReceivedMessage(object);
                    }

                    @Override
                    public void disconnected(Connection connection) {
                        handleDisconnect("Connection lost");
                    }
                });

                client.start();

                GameLogger.info("Connecting to " + serverConfig.getServerIP() + ":" + serverConfig.getTcpPort());
                client.connect((int) CONNECTION_TIMEOUT, serverConfig.getServerIP(),
                    serverConfig.getTcpPort(), serverConfig.getUdpPort());

            } catch (Exception e) {
                GameLogger.error("Connection failed: " + e.getMessage());
                handleConnectionFailure(e);
                isConnecting.set(false);
                if (reconnectionListener != null) {
                    reconnectionListener.onReconnectionFailure(e.getMessage());
                }
            }
        }
    }

    private void sendLoginRequest(String username, String password) {
        if (!isConnected() || client == null) {
            GameLogger.error("Cannot send login - not connected");
            return;
        }

        try {
            if (username == null || username.trim().isEmpty() ||
                password == null || password.trim().isEmpty()) {
                GameLogger.error("Username or password is empty");
                handleLoginFailure("Invalid credentials");
                return;
            }

            NetworkProtocol.LoginRequest request = new NetworkProtocol.LoginRequest();
            request.username = username.trim();
            request.password = password.trim();
            request.timestamp = System.currentTimeMillis();

            GameLogger.info("Sending login request for: " + username);
            loginRequestSent = true;
            client.sendTCP(request);

        } catch (Exception e) {
            GameLogger.error("Failed to send login request: " + e.getMessage());
            handleConnectionFailure(e);
        }
    }

    private void handleConnectionFailure(Exception e) {
        GameLogger.error("Connection failure: " + e.getMessage());

        synchronized (connectionLock) {
            connectionState = ConnectionState.DISCONNECTED;
            isConnected.set(false);
            isAuthenticated.set(false);

            cleanupExistingConnection();
            isConnecting.set(false);
            if (loginResponseListener != null) {
                Gdx.app.postRunnable(() -> {
                    NetworkProtocol.LoginResponse response = new NetworkProtocol.LoginResponse();
                    response.success = false;
                    response.message = "Connection failed: " + e.getMessage();
                    loginResponseListener.onResponse(response);
                });
            }
        }
    }

    private void cleanupExistingConnection() {
        if (client != null) {
            try {
                if (client.isConnected()) {
                    client.close();
                }
                client.stop();
                isSinglePlayer = false;
            } catch (Exception e) {
                GameLogger.error("Error cleaning up connection: " + e.getMessage());
            }
        }
    }

    public void sendPlayerUpdate() {
        if (!isConnected() || !isAuthenticated() || GameContext.get().getPlayer() == null) return;

        float playerX = GameContext.get().getPlayer().getX();
        float playerY = GameContext.get().getPlayer().getY();

        NetworkProtocol.PlayerUpdate update = new NetworkProtocol.PlayerUpdate();
        update.username = getLocalUsername();
        update.x = playerX;
        update.y = playerY;
        update.direction = GameContext.get().getPlayer().getDirection();
        update.isMoving = GameContext.get().getPlayer().isMoving();
        update.timestamp = System.currentTimeMillis();
        client.sendTCP(update);
    }

    public void saveWorldState() {
        if (isSinglePlayer) {
            if (GameContext.get().getWorld() != null) {
                GameContext.get().getWorldManager().saveWorld(GameContext.get().getWorld().getWorldData());
            }
        } else {
            isAuthenticated.get();
        }
    }

    public void savePlayerState(PlayerData playerData) {
        if (isSinglePlayer) {
            if (GameContext.get().getWorld() != null) {
                GameContext.get().getWorld().getWorldData().savePlayerData(playerData.getUsername(), playerData, false);
                GameContext.get().getWorldManager().saveWorld(GameContext.get().getWorld().getWorldData());
                GameLogger.info("Saved singleplayer state for: " + playerData.getUsername());
            }
            return;
        }

        if (isAuthenticated.get()) {
            PlayerData saveData = playerData.copy();
            saveData.setX(playerData.getX() / World.TILE_SIZE);
            saveData.setY(playerData.getY() / World.TILE_SIZE);
            saveData.setInventoryItems(playerData.getInventoryItems());
            saveData.setPartyPokemon(playerData.getPartyPokemon());

            sendPlayerUpdateToServer(saveData);
        }
    }

    public void sendPlayerUpdateToServer(PlayerData playerData) {
        if (isSinglePlayer || !isConnected() || !isAuthenticated()) {
            return;
        }

        try {
            NetworkProtocol.PlayerUpdate update = new NetworkProtocol.PlayerUpdate();
            update.username = playerData.getUsername();
            update.x = playerData.getX();
            update.y = playerData.getY();
            update.direction = playerData.getDirection();
            update.isMoving = playerData.isMoving();
            update.wantsToRun = playerData.isWantsToRun();
            update.timestamp = System.currentTimeMillis();
            if (playerData.getInventoryItems() != null) {
                update.inventoryItems = playerData.getInventoryItems().toArray(new ItemData[0]);
            }
            if (playerData.getPartyPokemon() != null) {
                update.partyPokemon = playerData.getPartyPokemon();
            }

            client.sendTCP(update);
            GameLogger.info("Sent player update to server for: " + playerData.getUsername() +
                " at (" + update.x + "," + update.y + ")");

        } catch (Exception e) {
            GameLogger.error("Failed to send player update: " + e.getMessage());
            handleConnectionFailure(e);
        }
    }

    public Map<String, NetworkProtocol.PlayerUpdate> getPlayerUpdates() {
        Map<String, NetworkProtocol.PlayerUpdate> updates = new HashMap<>(playerUpdates);
        playerUpdates.clear();
        return updates;
    }

    public void saveState(PlayerData playerData) {
        if (isSinglePlayer) {
            if (GameContext.get().getWorld() != null) {
                GameContext.get().getWorld().getWorldData().savePlayerData(
                    playerData.getUsername(),
                    playerData,
                    false
                );
                GameContext.get().getWorldManager().saveWorld(GameContext.get().getWorld().getWorldData());
                GameLogger.info("Saved singleplayer state for: " + playerData.getUsername());
            }
        } else {
            if (isConnected() && isAuthenticated()) {
                try {
                    NetworkProtocol.SavePlayerDataRequest request = new NetworkProtocol.SavePlayerDataRequest();
                    request.playerData = playerData;
                    request.timestamp = System.currentTimeMillis();
                    client.sendTCP(request);
                    GameLogger.info("Sent player state to server for: " + playerData.getUsername());
                } catch (Exception e) {
                    GameLogger.error("Failed to send state to server: " + e.getMessage());
                }
            }
        }
    }

    private void handleWorldStateUpdate(NetworkProtocol.WorldStateUpdate update) {
        if (update == null || update.worldData == null) return;

        Gdx.app.postRunnable(() -> {
            try {
                GameContext.get().getWorld().setWorldData(update.worldData);

                GameContext.get().getWorld().initializeWorldFromData(update.worldData);

                GameLogger.info("World state updated from server.");

            } catch (Exception e) {
                GameLogger.error("Error handling world state update: " + e.getMessage());
            }
        });
    }

    private void setupReconnectionHandler() {
        scheduler.scheduleWithFixedDelay(() -> {
            if (connectionState == ConnectionState.DISCONNECTED && shouldReconnect.get() && !isDisposing.get()) {
                attemptReconnection();
            }
        }, RECONNECT_DELAY, RECONNECT_DELAY, TimeUnit.MILLISECONDS);
    }

    public void setServerConfig(ServerConnectionConfig serverConfig) {
        this.serverConfig = serverConfig;
    }

    public boolean isSinglePlayer() {
        return isSinglePlayer;
    }

    public void setSinglePlayer(boolean isSinglePlayer) {
        this.isSinglePlayer = isSinglePlayer;
    }

    public World getCurrentWorld() {
        return GameContext.get().getWorld();
    }


    public long getWorldSeed() {
        return worldSeed;
    }

    public WorldData getWorldData() {
        return worldData;
    }

    public void sendMessage(NetworkProtocol.ChatMessage message) {
        if (isSinglePlayer) {
            if (chatMessageHandler != null) {
                chatMessageHandler.accept(message);
            }
            return;
        }

        try {
            if (!isConnected() || !isAuthenticated()) {
                GameLogger.error("Cannot send chat message - not connected or authenticated");
                return;
            }
            if (message.timestamp == 0) {
                message.timestamp = System.currentTimeMillis();
            }
            if (message.type == null) {
                message.type = NetworkProtocol.ChatType.NORMAL;
            }
            client.sendTCP(message);

            GameLogger.info("Sent chat message from " + message.sender +
                ": " + message.content);

        } catch (Exception e) {
            GameLogger.error("Failed to send chat message: " + e.getMessage());

            if (!isConnected()) {
                handleConnectionFailure(e);
            }

            if (chatMessageHandler != null) {
                chatMessageHandler.accept(message);
            }
        }
    }

    public NetworkProtocol.ChatMessage createSystemMessage(String content) {
        NetworkProtocol.ChatMessage message = new NetworkProtocol.ChatMessage();
        message.sender = "System";
        message.content = content;
        message.timestamp = System.currentTimeMillis();
        message.type = NetworkProtocol.ChatType.SYSTEM;
        return message;
    }

    private void handleChatMessage(NetworkProtocol.ChatMessage message) {
        if (message == null || message.content == null) {
            return;
        }
        chatMessageQueue.offer(message);
        GameLogger.info("Chat message queued from " + message.sender +
            " of type " + message.type);
    }

    public String getLocalUsername() {
        return localUsername;
    }

    public void dispose() {
        synchronized (connectionLock) {
            if (isDisposing.get()) {
                return;
            }

            isDisposing.set(true);

            if (GameContext.get().getWorld() != null) {
                saveWorldState();
            }
            if (GameContext.get().getPlayer() != null) {
                savePlayerState(GameContext.get().getPlayer().getPlayerData());
            }

            scheduler.shutdownNow();
            try {
                scheduler.awaitTermination(2, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }

            if (client != null) {
                try {
                    NetworkProtocol.ForceDisconnect disconnect = new NetworkProtocol.ForceDisconnect();
                    disconnect.reason = "Client closing";
                    client.sendTCP(disconnect);
                } catch (Exception ignored) {
                }
                client.close();
            }

            if (disconnectHandler != null) {
                disconnectHandler.cleanup();
            }
            GameLogger.info("GameClient disposed");
        }
    }

    public void shutdown() {
        isShuttingDown.set(true);
        dispose();
    }
    private void scheduleReconnection() {
        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
            GameLogger.error("Max reconnection attempts reached");
            return;
        }

        long delay = RECONNECT_DELAY * (long) Math.pow(2, reconnectAttempts);
        reconnectAttempts++;

        scheduler.schedule(() -> {
            if (shouldReconnect.get() && !isDisposing.get()) {
                GameLogger.info("Attempting reconnection " + reconnectAttempts);
                cleanupExistingConnection();
                connect();
            }
        }, delay, TimeUnit.MILLISECONDS);
    }

    private void attemptReconnection() {
        synchronized (connectionLock) {
            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                GameLogger.error("Max reconnection attempts reached");
                if (chatMessageHandler != null) {
                    NetworkProtocol.ChatMessage message = createSystemMessage(
                        "Failed to reconnect after " + MAX_RECONNECT_ATTEMPTS + " attempts"
                    );
                    chatMessageHandler.accept(message);
                }
                return;
            }

            reconnectAttempts++;
            connect();
        }
    }

    private void handleReceivedMessage(Object object) {
        if (object instanceof NetworkProtocol.ChunkData) {
            handleChunkResponse((NetworkProtocol.ChunkData) object);
            return;
        }
        if (object instanceof NetworkProtocol.ServerShutdown) {
            NetworkProtocol.ServerShutdown shutdown = (NetworkProtocol.ServerShutdown) object;
            handleDisconnect(shutdown.reason);
            return;
        }
        if (object instanceof NetworkProtocol.LoginResponse) {
            NetworkProtocol.LoginResponse response = (NetworkProtocol.LoginResponse) object;
            handleLoginResponse(response);
        }
        if (object instanceof NetworkProtocol.ForceDisconnect) {
            NetworkProtocol.ForceDisconnect disconnect = (NetworkProtocol.ForceDisconnect) object;
            GameLogger.error("Received ForceDisconnect from server: " + disconnect.reason);
            handleDisconnect("Connection lost");
            return;
        }
        if (!isAuthenticated.get()) {
            if (!(object instanceof NetworkProtocol.LoginResponse ||
                object instanceof NetworkProtocol.ConnectionResponse)) {
                pendingMessages.offer(object);
                return;
            }
        }

        if (object instanceof NetworkProtocol.ChunkDataFragment) {
            handleChunkDataFragment((NetworkProtocol.ChunkDataFragment) object);
            return;
        }
        if (object instanceof NetworkProtocol.ChunkDataComplete) {
            handleChunkDataComplete((NetworkProtocol.ChunkDataComplete) object);
            return;
        }

        try {
            if (object instanceof NetworkProtocol.LoginResponse) {
                GameLogger.info("CRITICAL - Received LoginResponse");
                NetworkProtocol.LoginResponse response = (NetworkProtocol.LoginResponse) object;
                GameLogger.info("CRITICAL - Login success: " + response.success);
                GameLogger.info("CRITICAL - Login message: " + response.message);
                handleLoginResponse((NetworkProtocol.LoginResponse) object);
            } else if (object instanceof NetworkProtocol.ChatMessage) {
                handleChatMessage((NetworkProtocol.ChatMessage) object);
            } else if (object instanceof NetworkProtocol.PlayerUpdate) {
                handlePlayerUpdate((NetworkProtocol.PlayerUpdate) object);
            } else if (object instanceof NetworkProtocol.PlayerJoined) {
                handlePlayerJoined((NetworkProtocol.PlayerJoined) object);
            } else if (object instanceof NetworkProtocol.PlayerLeft) {
                handlePlayerLeft((NetworkProtocol.PlayerLeft) object);
            } else if (object instanceof NetworkProtocol.PlayerPosition) {
                handlePlayerPosition((NetworkProtocol.PlayerPosition) object);
            } else if (object instanceof NetworkProtocol.WildPokemonSpawn) {
                handlePokemonSpawn((NetworkProtocol.WildPokemonSpawn) object);
            } else if (object instanceof NetworkProtocol.WildPokemonDespawn) {
                handlePokemonDespawn((NetworkProtocol.WildPokemonDespawn) object);
            } else if (object instanceof NetworkProtocol.PokemonUpdate) {
                handlePokemonUpdate((NetworkProtocol.PokemonUpdate) object);
            } else if (object instanceof NetworkProtocol.WorldStateUpdate) {
                handleWorldStateUpdate((NetworkProtocol.WorldStateUpdate) object);
            } else if (object instanceof NetworkProtocol.WorldObjectUpdate) {
                handleWorldObjectUpdate((NetworkProtocol.WorldObjectUpdate) object);
            } else if (object instanceof NetworkProtocol.BlockPlacement) {
                handleBlockPlacement((NetworkProtocol.BlockPlacement) object);
            } else if (object instanceof NetworkProtocol.PlayerAction) {
                handlePlayerAction((NetworkProtocol.PlayerAction) object);
            }
        } catch (Exception e) {
            GameLogger.error("Error handling network message: " + e.getMessage());
        }

    }

    private void handlePlayerAction(NetworkProtocol.PlayerAction action) {
        Gdx.app.postRunnable(() -> {
            OtherPlayer otherPlayer = otherPlayers.get(action.playerId);
            if (otherPlayer != null) {
                otherPlayer.updateAction(action);
            }
        });
    }

    private void handleBlockPlacement(NetworkProtocol.BlockPlacement placement) {
        Gdx.app.postRunnable(() -> {
            if (GameContext.get().getWorld() != null) {
                PlaceableBlock.BlockType type = PlaceableBlock.BlockType.fromItemId(placement.blockTypeId);
                if (type != null) {
                    if (placement.action == NetworkProtocol.BlockAction.PLACE) {
                        GameContext.get().getWorld().getBlockManager().placeBlock(type, placement.tileX, placement.tileY);
                        GameLogger.info("Block placed by " + placement.username + " at (" + placement.tileX + ", " + placement.tileY + ")");
                    } else if (placement.action == NetworkProtocol.BlockAction.REMOVE) {
                        GameContext.get().getWorld().getBlockManager().removeBlock(placement.tileX, placement.tileY);
                        GameLogger.info("Block removed by " + placement.username + " at (" + placement.tileX + ", " + placement.tileY + ")");
                    }
                } else {
                    GameLogger.error("Unknown block type: " + placement.blockTypeId);
                }
            }
        });
    }

    private void handlePlayerPosition(NetworkProtocol.PlayerPosition positionMsg) {
        if (positionMsg == null || positionMsg.players == null) {
            GameLogger.error("Received empty PlayerPosition message.");
            return;
        }

        Gdx.app.postRunnable(() -> {
            try {
                synchronized (otherPlayers) {
                    for (Map.Entry<String, NetworkProtocol.PlayerUpdate> entry : positionMsg.players.entrySet()) {
                        String username = entry.getKey();
                        if (username.equals(localUsername)) continue;

                        NetworkProtocol.PlayerUpdate update = entry.getValue();
                        GameLogger.error("Received update for " + username + " at (" + update.x + "," + update.y + ")");

                        OtherPlayer otherPlayer = otherPlayers.computeIfAbsent(username,
                            k -> new OtherPlayer(username, update.x, update.y));

                        otherPlayer.updateFromNetwork(update);
                        playerUpdates.put(username, update);
                    }
                }
            } catch (Exception e) {
                GameLogger.error("Error in handlePlayerPosition: " + e.getMessage());
            }
        });
    }

    private void handlePlayerDataResponse(Object object) {
        try {
            if (object instanceof NetworkProtocol.GetPlayerDataResponse) {
                playerDataHandler.handleGetResponse((NetworkProtocol.GetPlayerDataResponse) object);
            } else if (object instanceof NetworkProtocol.SavePlayerDataResponse) {
                playerDataHandler.handleSaveResponse((NetworkProtocol.SavePlayerDataResponse) object);
            }
        } catch (Exception e) {
            GameLogger.error("Error handling player data response: " + e.getMessage());
        }
    }

    public void handleDisconnect(String reason) {
        synchronized (connectionLock) {
            connectionState = ConnectionState.DISCONNECTED;
            isConnected.set(false);
            isAuthenticated.set(false);
            cleanupConnection();
            if (disconnectHandler != null && !disconnectHandler.isHandlingDisconnect()) {
                disconnectHandler.handleDisconnect(reason);
            }

            if (!isDisposing.get() && shouldReconnect.get()) {
                scheduleReconnection();
            }
        }
    }

    private void cleanupConnection() {
        if (client != null) {
            try {
                client.close();
                client.stop();
                client = null;
            } catch (Exception e) {
                GameLogger.error("Error cleaning up connection: " + e.getMessage());
            }
        }
    }

    private void updatePokemonStates(float deltaTime) {
        for (Map.Entry<UUID, WildPokemon> entry : trackedWildPokemon.entrySet()) {
            WildPokemon pokemon = entry.getValue();
            NetworkSyncData syncData = syncedPokemonData.get(entry.getKey());

            if (syncData != null && syncData.targetPosition != null) {
                updatePokemonPosition(pokemon, syncData, deltaTime);
            }
            pokemon.update(deltaTime);
        }
    }

    private void updatePokemonPosition(WildPokemon pokemon, NetworkSyncData syncData, float deltaTime) {
        syncData.interpolationProgress = Math.min(1.0f,
            syncData.interpolationProgress + deltaTime * INTERPOLATION_SPEED);

        float newX = lerp(pokemon.getX(), syncData.targetPosition.x, syncData.interpolationProgress);
        float newY = lerp(pokemon.getY(), syncData.targetPosition.y, syncData.interpolationProgress);

        pokemon.setX(newX);
        pokemon.setY(newY);
        pokemon.updateBoundingBox();
    }

    private float lerp(float start, float end, float alpha) {
        return start + (end - start) * alpha;
    }

    private void updateOtherPlayers(float deltaTime) {
        otherPlayers.values().forEach(player -> {
            player.update(deltaTime);
        });
    }

    public void tick(float deltaTime) {
        if (!isConnected() || isSinglePlayer) return;
        if (isInitialized && !processingMessages) {
            processQueuedMessages();
        }
        if (isInitialized && GameContext.get().getPlayer() != null) {
            update(deltaTime);
        }
    }

    public void sendRegisterRequest(String username, String password) {
        if (isSinglePlayer) {
            GameLogger.info("Registration not needed in single player mode");
            return;
        }
        if (!isConnected() || client == null) {
            GameLogger.info("Client not connected - attempting to connect before registration");
            connect();

            pendingRegistrationUsername = username;
            pendingRegistrationPassword = password;
            return;
        }
        try {
            if (username == null || username.trim().isEmpty() ||
                password == null || password.trim().isEmpty()) {
                handleRegistrationFailure("Username and password are required");
                return;
            }

            String secureUsername = username.trim();
            String securePassword = password.trim();

            NetworkProtocol.RegisterRequest request = new NetworkProtocol.RegisterRequest();
            request.username = secureUsername;
            request.password = securePassword;

            GameLogger.info("Sending registration request for: " + secureUsername);
            client.sendTCP(request);

            this.localUsername = secureUsername;

        } catch (Exception e) {
            GameLogger.error("Failed to send registration request: " + e.getMessage());
            handleRegistrationFailure("Failed to send registration request: " + e.getMessage());
        }
    }

    private void handleRegistrationFailure(String message) {
        String failedUsername = pendingRegistrationUsername;

        pendingRegistrationUsername = null;
        pendingRegistrationPassword = null;

        if (registrationResponseListener != null) {
            NetworkProtocol.RegisterResponse response = new NetworkProtocol.RegisterResponse();
            response.success = false;
            response.message = message;
            response.username = failedUsername;

            Gdx.app.postRunnable(() -> {
                registrationResponseListener.onResponse(response);
            });
        }

        GameLogger.error("Registration failed for " + failedUsername + ": " + message);
    }

    private void processChatMessages() {
        NetworkProtocol.ChatMessage message;
        while ((message = chatMessageQueue.poll()) != null) {
            final NetworkProtocol.ChatMessage finalMessage = message;
            Gdx.app.postRunnable(() -> {
                if (chatMessageHandler != null) {
                    chatMessageHandler.accept(finalMessage);
                }
            });
        }
    }

    public boolean isInitialized() {
        return fullyInitialized;
    }

    public void setInitialized(boolean initialized) {
        this.isInitialized = initialized;
    }

    public boolean isInitializing() {
        return isInitializing;
    }

    public void requestChunk(Vector2 chunkPos) {
        if (!isConnected() || !isAuthenticated()) {
            GameLogger.error("Attempted to request chunk without authentication: " + chunkPos);
            return;
        }

        try {
            NetworkProtocol.ChunkRequest request = new NetworkProtocol.ChunkRequest();
            request.chunkX = (int) chunkPos.x;
            request.chunkY = (int) chunkPos.y;
            request.timestamp = System.currentTimeMillis();

            pendingChunks.add(chunkPos);
            client.sendTCP(request);
        } catch (Exception e) {
            pendingChunks.remove(chunkPos);
        }
    }

    public void handleChunkResponse(NetworkProtocol.ChunkData chunkData) {
        if (chunkData == null) return;

        Vector2 chunkPos = new Vector2(chunkData.chunkX, chunkData.chunkY);

        if (GameContext.get().getWorld() != null) {
            Gdx.app.postRunnable(() -> {
                try {
                    // Process the chunk data
                    GameContext.get().getWorld().processChunkData(chunkData);
                    pendingChunks.remove(chunkPos);

                    int totalRequired = (World.INITIAL_LOAD_RADIUS * 2 + 1) * (World.INITIAL_LOAD_RADIUS * 2 + 1);
                    int loaded = GameContext.get().getWorld().getChunks().size();

                    if (loaded >= totalRequired) {
                        completeInitialization();
                    }
                } catch (Exception e) {
                    GameLogger.error("Error processing chunk data: " + e.getMessage());
                }
            });
        }
    }

    private void handleWorldObjectUpdate(NetworkProtocol.WorldObjectUpdate update) {
        if (update == null || GameContext.get().getWorld() == null) {
            return;
        }

        Gdx.app.postRunnable(() -> {
            try {
                WorldObject.WorldObjectManager objectManager = GameContext.get().getWorld().getObjectManager();
                switch (update.type) {
                    case ADD:
                        WorldObject newObj = new WorldObject();
                        newObj.updateFromData(update.data);
                        objectManager.addObjectToChunk(newObj);
                        break;

                    case REMOVE:
                        objectManager.removeObjectById(update.objectId);
                        break;

                    case UPDATE:
                        objectManager.updateObject(update);
                        break;
                }
            } catch (Exception e) {
                GameLogger.error("Error processing world object update: " + e.getMessage());
            }
        });
    }

    public Player getActivePlayer() {
        return GameContext.get().getPlayer();
    }

    public void setActivePlayer(Player activePlayer) {
        GameContext.get().setPlayer(activePlayer);
    }

    private void processQueuedMessages() {
        if (pendingMessages.isEmpty()) {
            return;
        }

        GameLogger.info("Processing " + pendingMessages.size() + " queued messages");

        Object message;
        while ((message = pendingMessages.poll()) != null) {
            try {
                handleReceivedMessage(message);
            } catch (Exception e) {
                GameLogger.error("Error processing queued message: " + e.getMessage());
            }
        }
    }

    private void handleChunkDataFragment(NetworkProtocol.ChunkDataFragment fragment) {
        Vector2 chunkPos = new Vector2(fragment.chunkX, fragment.chunkY);
        ChunkFragmentAssembler assembler = fragmentAssemblers.computeIfAbsent(chunkPos,
            k -> new ChunkFragmentAssembler(fragment.totalFragments));

        assembler.addFragment(fragment);
    }

    public void processChunkQueue() {
        long now = System.currentTimeMillis();
        if (!chunkRequestQueue.isEmpty() &&
            now - lastRequestTime >= CHUNK_REQUEST_INTERVAL &&
            pendingChunks.size() < MAX_CONCURRENT_CHUNK_REQUESTS) {

            Vector2 nextChunk = chunkRequestQueue.poll();
            if (nextChunk != null && !chunks.containsKey(nextChunk) && !loadingChunks.containsKey(nextChunk)) {
                requestChunk(nextChunk);
                lastRequestTime = now;
            }
        }
    }

    private void handlePlayerUpdate(NetworkProtocol.PlayerUpdate update) {
        if (update == null || update.username == null || update.username.equals(localUsername)) {
            return;
        }

        Gdx.app.postRunnable(() -> {
            synchronized (otherPlayers) {
                OtherPlayer otherPlayer = otherPlayers.get(update.username);
                if (otherPlayer == null) {
                    otherPlayer = new OtherPlayer(
                        update.username,
                        update.x,
                        update.y
                    );
                    otherPlayers.put(update.username, otherPlayer);
                    GameLogger.info("Created new player: " + update.username);
                }

                otherPlayer.updateFromNetwork(update);
                playerUpdates.put(update.username, update);
            }
        });
    }

    private void handlePlayerJoined(NetworkProtocol.PlayerJoined joinMsg) {
        final String joinKey = joinMsg.username + "_" + joinMsg.timestamp;

        Gdx.app.postRunnable(() -> {
            synchronized (otherPlayers) {
                if (recentJoinEvents.contains(joinKey)) {
                    GameLogger.info("Skipping duplicate join event for: " + joinMsg.username);
                    return;
                }

                if (otherPlayers.containsKey(joinMsg.username)) {
                    GameLogger.info("Player " + joinMsg.username + " already exists, updating position");
                    OtherPlayer existingPlayer = otherPlayers.get(joinMsg.username);
                    existingPlayer.setPosition(new Vector2(joinMsg.x, joinMsg.y));
                    return;
                }
                OtherPlayer newPlayer = new OtherPlayer(
                    joinMsg.username,
                    joinMsg.x,
                    joinMsg.y
                );
                otherPlayers.put(joinMsg.username, newPlayer);

                recentJoinEvents.add(joinKey);
                com.badlogic.gdx.utils.Timer.schedule(new com.badlogic.gdx.utils.Timer.Task() {
                    @Override
                    public void run() {
                        recentJoinEvents.remove(joinKey);
                    }
                }, 5);

                if (chatMessageHandler != null) {
                    NetworkProtocol.ChatMessage joinNotification = new NetworkProtocol.ChatMessage();
                    joinNotification.sender = "System";
                    joinNotification.content = joinMsg.username + " has joined the game";
                    joinNotification.type = NetworkProtocol.ChatType.SYSTEM;
                    joinNotification.timestamp = System.currentTimeMillis();

                    chatMessageHandler.accept(joinNotification);
                }
            }
        });
    }

    public void sendBlockPlacement(NetworkProtocol.BlockPlacement placement) {
        if (!isConnected() || !isAuthenticated()) {
            return;
        }
        try {
            client.sendTCP(placement);
        } catch (Exception e) {
            GameLogger.error("Failed to send block placement: " + e.getMessage());
        }
    }

    private void handlePlayerLeft(NetworkProtocol.PlayerLeft leftMsg) {
        Gdx.app.postRunnable(() -> {
            OtherPlayer leftPlayer = otherPlayers.remove(leftMsg.username);
            if (leftPlayer != null) {
                leftPlayer.dispose();
            }

            playerUpdates.remove(leftMsg.username);
        });
    }

    private void handlePokemonSpawn(NetworkProtocol.WildPokemonSpawn spawnData) {
        if (spawnData == null || spawnData.uuid == null || spawnData.data == null) {
            GameLogger.error("Received invalid Pokemon spawn data");
            return;
        }

        Gdx.app.postRunnable(() -> {
            try {
                if (trackedWildPokemon.containsKey(spawnData.uuid)) {
                    return;
                }

                TextureRegion overworldSprite = TextureManager.getOverworldSprite(spawnData.data.getName());
                if (overworldSprite == null) {
                    GameLogger.error("Could not load sprite for Pokemon: " + spawnData.data.getName());
                    return;
                }

                WildPokemon pokemon = new WildPokemon(
                    spawnData.data.getName(),
                    spawnData.data.getLevel(),
                    (int) spawnData.x,
                    (int) spawnData.y,
                    overworldSprite
                );
                pokemon.setWorld(GameContext.get().getWorld());

                pokemon.setUuid(spawnData.uuid);
                pokemon.setDirection("down");
                pokemon.setSpawnTime(spawnData.timestamp / 1000L);

                trackedWildPokemon.put(spawnData.uuid, pokemon);
                syncedPokemonData.put(spawnData.uuid, new NetworkSyncData());

                if (GameContext.get().getWorld() != null && GameContext.get().getWorld().getPokemonSpawnManager() != null) {
                    GameContext.get().getWorld().getPokemonSpawnManager().addPokemonToChunk(
                        pokemon,
                        new Vector2(spawnData.x, spawnData.y)
                    );
                }
            } catch (Exception e) {
                GameLogger.error("Error handling Pokemon spawn: " + e.getMessage());
            }
        });
    }

    private void handlePokemonDespawn(NetworkProtocol.WildPokemonDespawn despawnData) {
        if (despawnData == null || despawnData.uuid == null) {
            return;
        }

        Gdx.app.postRunnable(() -> {
            try {
                WildPokemon pokemon = trackedWildPokemon.remove(despawnData.uuid);
                syncedPokemonData.remove(despawnData.uuid);

                if (pokemon != null && GameContext.get().getWorld() != null) {
                    pokemon.startDespawnAnimation();

                    com.badlogic.gdx.utils.Timer.schedule(new com.badlogic.gdx.utils.Timer.Task() {
                        @Override
                        public void run() {
                            GameContext.get().getWorld().getPokemonSpawnManager()
                                .removePokemon(despawnData.uuid);
                        }
                    }, 1.0f);
                }

                GameLogger.info("Handled Pokemon despawn for UUID: " + despawnData.uuid);

            } catch (Exception e) {
                GameLogger.error("Error handling Pokemon despawn: " + e.getMessage());
            }
        });
    }

    private void handlePokemonUpdate(NetworkProtocol.PokemonUpdate update) {
        if (update == null || update.uuid == null) return;

        Gdx.app.postRunnable(() -> {
            WildPokemon pokemon = trackedWildPokemon.get(update.uuid);
            NetworkSyncData syncData = syncedPokemonData.get(update.uuid);

            if (pokemon == null || syncData == null) {
                requestPokemonSpawnData(update.uuid);
                return;
            }

            syncData.targetPosition = new Vector2(update.x, update.y);
            syncData.direction = update.direction;
            syncData.isMoving = update.isMoving;
            syncData.lastUpdateTime = System.currentTimeMillis();
            syncData.interpolationProgress = 0f;

            pokemon.setDirection(update.direction);
            pokemon.setMoving(update.isMoving);

            if (update.level > 0) pokemon.setLevel(update.level);
            if (update.currentHp > 0) pokemon.setCurrentHp(update.currentHp);
            pokemon.setSpawnTime(update.timestamp / 1000L);

            if (pokemonUpdateHandler != null) {
                pokemonUpdateHandler.onUpdate(update);
            }
        });
    }

    public void sendPokemonUpdate(NetworkProtocol.PokemonUpdate update) {
        if (!isAuthenticated.get() || connectionState != ConnectionState.CONNECTED) return;

        try {
            if (update.timestamp == 0) {
                update.timestamp = System.currentTimeMillis();
            }
            client.sendTCP(update);
        } catch (Exception e) {
            GameLogger.error("Failed to send Pokemon update: " + e.getMessage());
        }
    }

    private void requestPokemonSpawnData(UUID pokemonId) {
        if (!isAuthenticated.get() || connectionState != ConnectionState.CONNECTED) return;

        try {
            NetworkProtocol.PokemonSpawnRequest request = new NetworkProtocol.PokemonSpawnRequest();
            request.uuid = pokemonId;
            client.sendTCP(request);
        } catch (Exception e) {
            GameLogger.error("Failed to request Pokemon spawn data: " + e.getMessage());
        }
    }

    public void sendWorldObjectUpdate(NetworkProtocol.WorldObjectUpdate update) {
        if (isSinglePlayer || !isConnected() || !isAuthenticated()) {
            return;
        }

        try {
            if (update.data != null && update.data.containsKey("type")) {
                String objectType = (String) update.data.get("type");
                if (objectType.equals("SUNFLOWER") ||
                    objectType.equals("BUSH") ||
                    objectType.equals("DEAD_TREE") ||
                    objectType.equals("CACTUS")) {
                    return;
                }
            }


            client.sendTCP(update);

        } catch (Exception e) {
            GameLogger.error("Failed to send world object update: " + e.getMessage());
            handleConnectionFailure(e);
        }
    }

    public void sendPlayerAction(NetworkProtocol.PlayerAction action) {
        if (client != null && client.isConnected()) {
            client.sendTCP(action);
        } else {
            GameLogger.error("Cannot send PlayerAction, client is not connected.");
        }
    }


    private void handleChunkData(NetworkProtocol.ChunkData chunkData) {
        if (chunkData == null) return;

        Vector2 chunkPos = new Vector2(chunkData.chunkX, chunkData.chunkY);

        if (GameContext.get().getWorld() != null) {
            Gdx.app.postRunnable(() -> {
                try {
                    // Process the chunk data
                    GameContext.get().getWorld().processChunkData(chunkData);

                    // Process blocks
                    if (chunkData.blockData != null) {
                        for (Map<String, Object> blockData : chunkData.blocks) {
                            String typeId = (String) blockData.get("type");
                            int tileX = ((Number) blockData.get("tileX")).intValue();
                            int tileY = ((Number) blockData.get("tileY")).intValue();
                            boolean isFlipped = blockData.get("isFlipped") != null && (Boolean) blockData.get("isFlipped");

                            PlaceableBlock.BlockType blockType = PlaceableBlock.BlockType.fromId(typeId);
                            if (blockType != null) {
                                PlaceableBlock block = new PlaceableBlock(blockType, new Vector2(tileX, tileY), null, isFlipped);
                                GameContext.get().getWorld().getBlockManager().placeBlock(blockType, tileX, tileY);
                            } else {
                                GameLogger.error("Unknown block type ID in chunk data: " + typeId);
                            }
                        }
                    }

                    // Process world objects
                    if (chunkData.worldObjects != null) {
                        List<WorldObject> objects = new ArrayList<>();
                        for (Map<String, Object> data : chunkData.worldObjects) {
                            WorldObject obj = new WorldObject();
                            obj.updateFromData(data);
                            objects.add(obj);
                        }
                        GameContext.get().getWorld().getObjectManager().setObjectsForChunk(chunkPos, objects);
                    }

                } catch (Exception e) {
                    GameLogger.error("Error processing chunk data: " + e.getMessage());
                }
            });
        }
    }

    public void sendPokemonDespawn(UUID pokemonId) {
        if (!isConnected() || client == null || isSinglePlayer) {
            return;
        }

        try {
            NetworkProtocol.WildPokemonDespawn despawnUpdate = new NetworkProtocol.WildPokemonDespawn();
            despawnUpdate.uuid = pokemonId;
            despawnUpdate.timestamp = System.currentTimeMillis();

            client.sendTCP(despawnUpdate);
            trackedWildPokemon.remove(pokemonId);
            syncedPokemonData.remove(pokemonId);

            GameLogger.info("Sent Pokemon despawn for ID: " + pokemonId);
        } catch (Exception e) {
            GameLogger.error("Failed to send Pokemon despawn: " + e.getMessage());
            if (!isConnected()) {
                handleConnectionFailure(e);
            }
        }
    }

    public void setChatMessageHandler(Consumer<NetworkProtocol.ChatMessage> handler) {
        this.chatMessageHandler = handler;
    }

    public void setLoginResponseListener(LoginResponseListener listener) {
        this.loginResponseListener = listener;
    }

    public void setRegistrationResponseListener(RegistrationResponseListener listener) {
        this.registrationResponseListener = listener;
    }

    public Map<String, OtherPlayer> getOtherPlayers() {
        return new HashMap<>(otherPlayers);
    }

    public boolean isAuthenticated() {
        return isAuthenticated.get();
    }

    public boolean isConnected() {
        return connectionState == ConnectionState.CONNECTED || connectionState == ConnectionState.AUTHENTICATED;
    }

    private void handleChunkDataComplete(NetworkProtocol.ChunkDataComplete complete) {
        Vector2 chunkPos = new Vector2(complete.chunkX, complete.chunkY);
        ChunkFragmentAssembler assembler = fragmentAssemblers.get(chunkPos);

        if (assembler != null && assembler.isComplete()) {
            NetworkProtocol.ChunkData fullChunk = assembler.buildCompleteChunk(complete.chunkX, complete.chunkY);
            handleChunkData(fullChunk);
            fragmentAssemblers.remove(chunkPos);
            pendingChunks.remove(chunkPos);
            processChunkQueue();
        }
    }


    private void handleLoginResponse(NetworkProtocol.LoginResponse response) {
        if (response.success) {
            isAuthenticated.set(true);
            localUsername = response.username;

            try {
                initializeWorldBasic(response.seed, response.worldTimeInMinutes, response.dayLength);

                Gdx.app.postRunnable(() -> {
                    if (GameContext.get().getPlayer() == null) {
                        Player player = new Player(response.username, GameContext.get().getWorld());
                        player.setPlayerData(response.playerData);
                        GameContext.get().setPlayer(player);
                    }
                    GameContext.get().getPlayer().setX(response.x);
                    GameContext.get().getPlayer().setY(response.y);

                    // Process any messages that were queued during authentication
                    processQueuedMessages();

                    if (loginResponseListener != null) {
                        loginResponseListener.onResponse(response);
                    }
                });

            } catch (Exception e) {
                GameLogger.error("Initial world setup failed: " + e.getMessage());
                handleLoginFailure("World initialization failed: " + e.getMessage());
            }
        } else {
            handleLoginFailure(response.message);
        }
    }

    private void handleLoginFailure(String message) {
        loginRequestSent = false;
        GameLogger.error("Login failed: " + message);

        if (loginResponseListener != null) {
            NetworkProtocol.LoginResponse failResponse = new NetworkProtocol.LoginResponse();
            failResponse.success = false;
            failResponse.message = message;
            Gdx.app.postRunnable(() -> loginResponseListener.onResponse(failResponse));
        }
    }

    public void setPendingCredentials(String username, String password) {
        if (username == null || password == null) {
            GameLogger.error("Cannot set null credentials");
            return;
        }

        GameLogger.info("Setting pending credentials for: " + username);
        this.pendingUsername = username.trim();
        this.pendingPassword = password.trim();
        if (isConnected() && !isAuthenticated.get() && !loginRequestSent) {
            sendLoginRequest(username, password);
        }
    }

    private void initializeWorldBasic(long seed, double worldTimeInMinutes, float dayLength) {
        try {
            GameLogger.info("Initializing basic world with seed: " + seed);
            if (worldData == null) {
                worldData = new WorldData("multiplayer");
                GameLogger.info("Created new WorldData instance");
            }

            WorldData.WorldConfig config = new WorldData.WorldConfig(seed);
            worldData.setConfig(config);
            worldData.setWorldTimeInMinutes(worldTimeInMinutes);
            worldData.setDayLength(dayLength);

            this.worldSeed = seed;
            new BiomeManager(seed);
            if (GameContext.get().getWorld() == null) {
                GameContext.get().setWorld(new World(worldData));
                GameLogger.info("Basic world initialization complete");
            }

        } catch (Exception e) {
            GameLogger.error("Failed to initialize basic world: " + e.getMessage());
            throw new RuntimeException("World initialization failed", e);
        }
    }

    private enum ConnectionState {
        DISCONNECTED,
        CONNECTING,
        CONNECTED,
        AUTHENTICATED
    }

    public interface ReconnectionListener {
        void onReconnectionSuccess();

        void onReconnectionFailure(String reason);
    }

    public interface InitializationListener {
        void onInitializationComplete(boolean success);
    }

    public interface LoginResponseListener {
        void onResponse(NetworkProtocol.LoginResponse response);
    }

    public interface RegistrationResponseListener {
        void onResponse(NetworkProtocol.RegisterResponse response);
    }

    public interface PokemonUpdateHandler {
        void onUpdate(NetworkProtocol.PokemonUpdate update);
    }

    private static class NetworkSyncData {
        Vector2 targetPosition;
        String direction;
        boolean isMoving;
        long lastUpdateTime;
        float interpolationProgress;

        NetworkSyncData() {
            this.lastUpdateTime = System.currentTimeMillis();
            this.interpolationProgress = 0f;
        }
    }

    public static class ChunkFragmentAssembler {
        private final int[][] tileData = new int[World.CHUNK_SIZE][World.CHUNK_SIZE];
        private final BitSet receivedFragments;
        private final int totalFragments;
        private BiomeType biomeType;
        private int fragmentsReceived = 0;

        ChunkFragmentAssembler(int totalFragments) {
            this.totalFragments = totalFragments;
            this.receivedFragments = new BitSet(totalFragments);
        }

        synchronized void addFragment(NetworkProtocol.ChunkDataFragment fragment) {
            if (!receivedFragments.get(fragment.fragmentIndex)) {
                System.arraycopy(fragment.tileData, 0, tileData[fragment.startX],
                    fragment.startY, fragment.fragmentSize);
                biomeType = fragment.biomeType;
                receivedFragments.set(fragment.fragmentIndex);
                fragmentsReceived++;
            }
        }

        boolean isComplete() {
            return fragmentsReceived == totalFragments;
        }

        NetworkProtocol.ChunkData buildCompleteChunk(int chunkX, int chunkY) {
            NetworkProtocol.ChunkData data = new NetworkProtocol.ChunkData();
            data.chunkX = chunkX;
            data.chunkY = chunkY;
            data.biomeType = biomeType;
            data.tileData = tileData;
            return data;
        }
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/client/GameClientSingleton.java
================
package io.github.pokemeetup.multiplayer.client;

import io.github.pokemeetup.multiplayer.server.config.ServerConfigManager;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.utils.GameLogger;


public class GameClientSingleton {
    private static final Object lock = new Object();
    private static GameClient instance;

    public static void resetInstance() {
        if (instance != null) {
            instance.dispose();
            instance = null;
        }
    }

    public static GameClient getInstance(ServerConnectionConfig config) {
        if (config == null) {
            config = ServerConfigManager.getDefaultServerConfig();
        }

        synchronized (lock) {
            try {
                validateConfig(config);

                if (instance != null) {
                    instance.dispose();
                    instance = null;
                }

                instance = new GameClient(config, false);

                return instance;

            } catch (Exception e) {
                GameLogger.error("Failed to initialize GameClient: " + e.getMessage());
                if (instance != null) {
                    instance.dispose();
                    instance = null;
                }
                throw new RuntimeException("Failed to initialize GameClient: " + e.getMessage(), e);
            }
        }
    }

    private static void validateConfig(ServerConnectionConfig config) {
        if (config.getServerIP() == null || config.getServerIP().isEmpty()) {
            throw new IllegalArgumentException("Server IP cannot be null or empty");
        }
        if (config.getTcpPort() <= 0) {
            throw new IllegalArgumentException("Invalid TCP port: " + config.getTcpPort());
        }
        if (config.getUdpPort() <= 0) {
            throw new IllegalArgumentException("Invalid UDP port: " + config.getUdpPort());
        }
    }

    public static synchronized GameClient getSinglePlayerInstance(Player player) {
        synchronized (lock) {
            try {
                if (instance != null) {
                    instance.dispose();
                    instance = null;
                }
                ServerConnectionConfig singlePlayerConfig = ServerConnectionConfig.getDefault();
                instance = new GameClient(singlePlayerConfig, true);
                instance.setActivePlayer(player);
                return instance;
            } catch (Exception e) {
                GameLogger.error("Error disposing GameClient: " + e.getMessage());
                throw new RuntimeException("Failed to initialize single player GameClient", e);

            }
        }
    }

    public static synchronized GameClient getSinglePlayerInstance() {
        synchronized (lock) {
            try {
                if (instance != null) {
                    instance.dispose();
                    instance = null;
                }

                ServerConnectionConfig singlePlayerConfig = ServerConnectionConfig.getDefault();
                instance = new GameClient(singlePlayerConfig, true);
                return instance;

            } catch (Exception e) {
                GameLogger.error("Failed to create single player GameClient: " + e.getMessage());
                throw new RuntimeException("Failed to initialize single player GameClient", e);
            }
        }
    }

    public static void clearInstance() {
        synchronized (lock) {
            if (instance != null) {
                try {
                    instance.dispose();
                } catch (Exception e) {
                    GameLogger.error("Error disconnecting GameClient: " + e.getMessage());
                }
                instance = null;
            }
        }
    }


}

================
File: main/java/io/github/pokemeetup/multiplayer/client/PlayerDataResponseHandler.java
================
package io.github.pokemeetup.multiplayer.client;

import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.utils.GameLogger;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.*;

public class PlayerDataResponseHandler {
    private final Map<UUID, CompletableFuture<PlayerData>> pendingRequests;
    private final Map<UUID, CachedPlayerData> dataCache;
    private static final long CACHE_DURATION = 60000; // 1 minute cache
    private static final int MAX_CACHE_SIZE = 100;

    private static class CachedPlayerData {
        final PlayerData data;
        final long timestamp;

        CachedPlayerData(PlayerData data) {
            this.data = data;
            this.timestamp = System.currentTimeMillis();
        }

        boolean isExpired() {
            return System.currentTimeMillis() - timestamp > CACHE_DURATION;
        }
    }

    public PlayerDataResponseHandler() {
        this.pendingRequests = new ConcurrentHashMap<>();
        this.dataCache = new ConcurrentHashMap<>();
        startCacheCleanupTask();
    }

    private void startCacheCleanupTask() {
        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread t = new Thread(r, "PlayerDataCache-Cleanup");
            t.setDaemon(true);
            return t;
        });

        executor.scheduleWithFixedDelay(() -> {
            try {
                cleanupCache();
            } catch (Exception e) {
                GameLogger.error("Error during cache cleanup: " + e.getMessage());
            }
        }, CACHE_DURATION, CACHE_DURATION, TimeUnit.MILLISECONDS);
    }

    private void cleanupCache() {
        dataCache.entrySet().removeIf(entry -> entry.getValue().isExpired());

        // If still too many entries, remove oldest ones
        if (dataCache.size() > MAX_CACHE_SIZE) {
            dataCache.entrySet().stream()
                .sorted((e1, e2) -> Long.compare(e1.getValue().timestamp, e2.getValue().timestamp))
                .limit(dataCache.size() - MAX_CACHE_SIZE)
                .forEach(entry -> dataCache.remove(entry.getKey()));
        }
    }

    public CompletableFuture<PlayerData> createRequest(UUID uuid) {
        // Check cache first
        CachedPlayerData cached = dataCache.get(uuid);
        if (cached != null && !cached.isExpired()) {
            return CompletableFuture.completedFuture(cached.data);
        }

        // Create new request
        CompletableFuture<PlayerData> future = new CompletableFuture<>();
        pendingRequests.put(uuid, future);
        return future;
    }

    public void handleGetResponse(NetworkProtocol.GetPlayerDataResponse response) {
        CompletableFuture<PlayerData> future = pendingRequests.remove(response.uuid);
        if (future != null) {
            if (response.success && response.playerData != null) {
                // Cache the data
                dataCache.put(response.uuid, new CachedPlayerData(response.playerData));
                future.complete(response.playerData);
            } else {
                future.completeExceptionally(new RuntimeException(response.message));
            }
        }
    }

    public void handleSaveResponse(NetworkProtocol.SavePlayerDataResponse response) {
        if (response.success) {
            // Clear cache for this UUID to ensure fresh data on next load
            dataCache.remove(response.uuid);
            GameLogger.info("Player data saved successfully for UUID: " + response.uuid);
        } else {
            GameLogger.error("Failed to save player data for UUID: " + response.uuid + " - " + response.message);
        }
    }

    public void clearCache() {
        dataCache.clear();
    }

    public void cancelRequest(UUID uuid) {
        CompletableFuture<PlayerData> future = pendingRequests.remove(uuid);
        if (future != null && !future.isDone()) {
            future.cancel(true);
        }
    }

    public void shutdown() {
        // Cancel all pending requests
        pendingRequests.forEach((uuid, future) -> {
            if (!future.isDone()) {
                future.cancel(true);
            }
        });
        pendingRequests.clear();
        dataCache.clear();
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/network/NetworkedPokeball.java
================
package io.github.pokemeetup.multiplayer.network;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

public class NetworkedPokeball extends NetworkedWorldObject {
    public NetworkedPokeball() {
        super();
    }

    public NetworkedPokeball(float x, float y, String textureName) {
        super(x, y, ObjectType.POKEBALL, textureName);
    }


}

================
File: main/java/io/github/pokemeetup/multiplayer/network/NetworkedTree.java
================
package io.github.pokemeetup.multiplayer.network;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

public class NetworkedTree extends NetworkedWorldObject {
    public NetworkedTree() {
        super();
    }

    public NetworkedTree(float x, float y, String textureName) {
        super(x, y, ObjectType.TREE, textureName);
    }

}

================
File: main/java/io/github/pokemeetup/multiplayer/network/NetworkedWorldObject.java
================
package io.github.pokemeetup.multiplayer.network;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Vector2;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class NetworkedWorldObject {
    protected String id;
    protected float x;
    protected float y;
    protected ObjectType type;
    protected boolean isDirty;
    protected Map<String, Object> additionalData;
    protected String textureName;

    public NetworkedWorldObject() {
        this.id = UUID.randomUUID().toString();
    }

    public NetworkedWorldObject(float x, float y, ObjectType type, String textureName) {
        this.id = UUID.randomUUID().toString();
        this.x = x;
        this.y = y;
        this.type = type;
        this.textureName = textureName;
        this.isDirty = true;
        this.additionalData = new HashMap<>();
    }


    public void updateFromNetwork(NetworkProtocol.WorldObjectUpdate update) {
        this.x = update.x;
        this.y = update.y;
        this.textureName = update.textureName; // Update texture identifier
        this.additionalData.clear();
        this.additionalData.putAll(update.data);
        isDirty = false;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public float getX() {
        return x;
    }

    public void setX(float x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    public ObjectType getType() {
        return type;
    }

    public void setType(ObjectType type) {
        this.type = type;
    }

    public boolean isDirty() {
        return isDirty;
    }

    public void setDirty(boolean dirty) {
        isDirty = dirty;
    }

    public Map<String, Object> getAdditionalData() {
        return additionalData;
    }

    public enum ObjectType {
        TREE,
        POKEBALL,
        ITEM,
        NPC
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/network/NetworkProtocol.java
================
package io.github.pokemeetup.multiplayer.network;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import com.esotericsoftware.kryonet.FrameworkMessage;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.multiplayer.server.entity.CreatureEntity;
import io.github.pokemeetup.multiplayer.server.entity.Entity;
import io.github.pokemeetup.multiplayer.server.entity.EntityType;
import io.github.pokemeetup.multiplayer.server.entity.PokeballEntity;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.system.data.BlockSaveData;
import io.github.pokemeetup.system.data.ItemData;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.PokemonData;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.ChunkPos;
import io.github.pokemeetup.utils.UUIDSerializer;

import java.io.Serializable;
import java.util.*;

public class NetworkProtocol {
    public static void registerClasses(Kryo kryo) {
        // Basic and commonly used classes
        kryo.register(UUID.class, new UUIDSerializer());
        kryo.register(Vector2.class);
        kryo.register(ArrayList.class);

        kryo.register(List.class);
        kryo.register(ChunkPos.class);
        kryo.register(int[][].class); // For the tileData 2D array
        kryo.register(HashMap.class);
        kryo.register(Map.class);
        kryo.register(java.util.concurrent.ConcurrentHashMap.class);
        kryo.register(PokemonData.Stats.class);
        kryo.register(PlayerAction.class);
        kryo.register(BlockPlacement.class);
        kryo.register(BlockAction.class);

        kryo.register(WorldData.class);
        kryo.register(WorldObjectData.class);
        kryo.register(io.github.pokemeetup.system.data.WorldData.class);
        kryo.register(io.github.pokemeetup.system.data.WorldData.WorldObjectData.class);
        kryo.register(io.github.pokemeetup.system.data.WorldData.WorldConfig.class);

        // Enums
        kryo.register(NetworkObjectUpdateType.class);
        kryo.register(NetworkedWorldObject.ObjectType.class);
        kryo.register(ChatType.class);
        kryo.register(ForceDisconnect.class);

        // Request and response classes
        kryo.register(LoginRequest.class);
        kryo.register(LoginResponse.class);
        kryo.register(RegisterRequest.class);
        kryo.register(RegisterResponse.class);
        kryo.register(ItemData.class);
        kryo.register(ItemData[].class);
        kryo.register(UUID.class);
        kryo.register(InventoryUpdate.class);
        kryo.register(ChunkData.class);
        kryo.register(BiomeType.class);
        // Game state and network classes
        kryo.register(PlayerPosition.class);
        kryo.register(PlayerUpdate.class);
        kryo.register(InventoryUpdate.class);
        kryo.register(PlayerJoined.class);
        kryo.register(PlayerLeft.class);
        kryo.register(WorldObjectUpdate.class);
        kryo.register(BlockSaveData.BlockData.class);
        // Register PlaceableBlock.BlockType
        kryo.register(PlaceableBlock.BlockType.class);
        kryo.register(Keepalive.class);
        // Complex data models and entities
        kryo.register(WorldState.class);
        kryo.register(PlayerState.class);
        kryo.register(ChunkUpdate.class);
        kryo.register(ChunkRequest.class);
        kryo.register(EntityUpdate.class);
        kryo.register(Entity.class);
        kryo.register(EntityType.class);
        registerPokemonClasses(kryo);
        // Networked entities
        kryo.register(NetworkedWorldObject.class);
        kryo.register(NetworkedTree.class);
        kryo.register(WorldStateUpdate.class);
        kryo.register(NetworkedPokeball.class);
        kryo.register(ConnectionResponse.class);
        kryo.register(ConnectionRequest.class);
        kryo.register(PokemonData.class);
        kryo.register(ConnectionStatus.class);
        kryo.register(Logout.class);
        kryo.register(UsernameCheckRequest.class);
        kryo.register(UsernameCheckResponse.class);
        kryo.register(BlockPlacement.class);
        kryo
            .register(io.github.pokemeetup.system.data.WorldData.class);
        kryo.register(PlayerData.class);
        kryo.register(PlayerData[].class);
        // Miscellaneous
        kryo.register(io.github.pokemeetup.system.data.WorldData.WorldConfig.class);

        kryo.register(TeamCreate.class);

        kryo.register(ServerShutdown.class);
        kryo.register(TeleportRequest.class);
        kryo.register(TeleportResponse.class);
        kryo.register(World.WorldObjectData.class);
        kryo.register(World.ChunkData.class);
        kryo.register(ChatMessage.class);
        kryo.register(TeamInvite.class);
        kryo.register(TeamHQUpdate.class);
        kryo.register(ChunkDataFragment.class);
        kryo.register(ChunkDataComplete.class);
        kryo.register(WorldInitData.class);
        kryo.register(ServerInfoRequest.class);
        kryo.register(ServerInfoResponse.class);
        kryo.register(SavePlayerDataRequest.class);
        kryo.register(SavePlayerDataResponse.class);
        kryo.register(GetPlayerDataRequest.class);
        kryo.register(GetPlayerDataResponse.class);
        kryo.register(FrameworkMessage.KeepAlive.class);
        kryo.register(FrameworkMessage.Ping.class);
        kryo.register(FrameworkMessage.RegisterTCP.class);
        kryo.register(FrameworkMessage.RegisterUDP.class);
        kryo.register(ServerInfo.class);
        // Additional Entity subclasses
        kryo.register(WorldObject.class);
        kryo.register(WorldObject.ObjectType.class);
        kryo.register(CreatureEntity.class);
        kryo.register(PokeballEntity.class);
        kryo.register(ForceDisconnect.class);
        kryo.register(ForceLogout.class);
        kryo.register(Object.class);
//            kryo.register(Keepalive.class);
        kryo.register(ReliableUpdate.class);
        kryo.register(ClientMessage.class);
        kryo.register(ServerResponse.class);
        kryo.register(ConnectionValidation.class);
        kryo.register(UUID.class, new com.esotericsoftware.kryo.Serializer<UUID>() {

            @Override
            public void write(Kryo kryo, Output output, UUID uuid) {
                output.writeLong(uuid.getMostSignificantBits());
                output.writeLong(uuid.getLeastSignificantBits());
            }

            @Override
            public UUID read(Kryo kryo, Input input, Class<UUID> type) {
                return new UUID(input.readLong(), input.readLong());
            }
        });
        kryo.setReferences(false);  // Disable object references
        kryo.setRegistrationRequired(false);  // Require class registration
    }

    public static void registerPokemonClasses(Kryo kryo) {
        kryo.register(PokemonUpdate.class);
        kryo.register(PokemonSpawn.class);
        kryo.register(PokemonDespawn.class);
        kryo.register(PokemonSpawnRequest.class);
        kryo.register(PartyUpdate.class);
        kryo.register(WildPokemonSpawn.class);
        kryo.register(WildPokemonDespawn.class);
        kryo.register(PokemonData.class);
        kryo.register(Pokemon.Stats.class);
        kryo.register(Pokemon.PokemonType.class);
        kryo.register(ArrayList.class);
        kryo.register(int[].class);
    }

    public enum ActionType {
        CHOP_START,
        CHOP_STOP,
        CHEST_OPEN,
        CHEST_CLOSE,
        PUNCH_START,
        PUNCH_STOP
    }

    public enum BlockAction {
        PLACE,
        REMOVE
    }

    public enum ChatType {
        NORMAL,
        SYSTEM,
        WHISPER,
        TEAM
    }

    public enum NetworkObjectUpdateType {
        ADD,
        UPDATE,
        REMOVE

    }

    public static class WorldObjectData {
        public float x;
        public float y;
        public WorldObject.ObjectType type;
    }

    // In NetworkProtocol.java, add:
    public static class WorldInitData {
        public long seed;
        public double worldTimeInMinutes;
        public float dayLength;
    }

    public static class ChunkRequest {
        public int chunkX;
        public int chunkY;
        public int fragmentSize = 8; // Size of each fragment
        public long timestamp;
    }

    public static class ChunkData {
        public int chunkX;
        public int chunkY;
        public BiomeType biomeType;
        public int[][] tileData;
        public List<BlockSaveData.BlockData> blockData;
        public List<Map<String, Object>> worldObjects;
        public List<Map<String, Object>> blocks; // Include this field
        public List<WorldObjectData> objects;
        public long timestamp;
    }

    public static class ChunkDataFragment {
        public int chunkX;
        public int chunkY;
        public int startX;
        public int startY;
        public int fragmentSize;
        public int[][] tileData;
        public BiomeType biomeType;
        public int fragmentIndex;
        public int totalFragments;
    }

    public static class ChunkDataComplete {
        public int chunkX;
        public int chunkY;
    }

    public static
    class LogoutResponse {
        public boolean success;
        public String message;
    }

    public static class ConnectionValidation {
        public String username;
        public long timestamp;
        public String sessionId; // Add a unique session ID for each connection
    }

    public static class ClientMessage {
        public static final int TYPE_LOGOUT = 1;

        public int type;
        public String username;
        public long timestamp;
        public Map<String, Object> data;
    }

    public static class ServerResponse {
        public boolean success;
        public String message;
        public long timestamp;
        public Map<String, Object> data;
    }

    public static class Logout {
        public String username;
        public long timestamp;
    }

    public static class ForceLogout {
        public String reason;
        public boolean serverShutdown;
    }

    public static class ServerInfo {
        public String name;
        public String motd; // Message of the day
        public String iconBase64; // Base64 encoded server icon
        public int playerCount;
        public int maxPlayers;
        public long ping;
        public String version;
    }

    public static class ServerInfoRequest {
        public long timestamp;
    }

    public static class ServerInfoResponse {
        public ServerInfo serverInfo;
        public long timestamp;
    }

    public static class ConnectionResponse {
        public boolean success;
        public String message;
        public String username;
        public String token;
    }

    public static class ConnectionRequest {
        public String version;
        public long timestamp;
    }

    public static class ConnectionStatus {
        public int connectionId;
        public String status;
        public long timestamp;
    }

    public static class PokemonUpdate implements Serializable {
        public UUID uuid;
        public float x;
        public float y;
        public String direction;
        public boolean isMoving;
        public boolean isAttacking;
        public PokemonData data;
        public long timestamp;
        public String status;  // e.g., "NORMAL", "FAINTED", "SLEEPING"
        public Map<String, Object> extraData = new HashMap<>();  // For extensibility
        public int level;
        public float currentHp;
    }

    public static class PokemonSpawnRequest implements Serializable {
        public UUID uuid;
        public long timestamp = System.currentTimeMillis();
        public String requestingPlayer; // Username of requesting client
    }

    public static class ChunkUpdate {
        public Vector2 position;
        public World.ChunkData chunkData;
        public List<World.WorldObjectData> objects;
    }

    public static class LoginResponse {
        public boolean success;
        public double worldTimeInMinutes;
        public float dayLength;
        public long seed;               // World seed
        public String message;
        public String username;
        public int x;
        public int y;
        public String worldName;
        public long timestamp;
        public long worldSeed;
        public PlayerData playerData;
        public io.github.pokemeetup.system.data.WorldData worldData;  // Add serializable world data
    }

    public static class WorldData implements Serializable {
        // Add fields that need to be synced to clients
        public long seed;
        public String name;
        public Map<String, Object> worldProperties;
        // Add other necessary world data
    }

    public static class UsernameCheckRequest {
        public String username;
        public long timestamp;
    }

    public static class UsernameCheckResponse {
        public String username;
        public boolean available;
        public String message;
    }

    public static class ServerShutdown {
        public String reason;
    }

    public static class PlayerJoined {
        public String username;
        public float x;
        public float y;
        public String direction = "down";
        public boolean isMoving = false;
        public ItemData[] inventoryItems;
        public long timestamp;
        public ItemData[] hotbarItems;
    }

    public static class PlayerLeft {
        public String username;
        public long timestamp;
    }

    public static class ReliableUpdate {
        public int sequence;
        public long timestamp;
        public NetworkProtocol.PlayerUpdate playerUpdate;
    }

    public static class ForceDisconnect {
        public String reason;
    }

    public static class Keepalive {
        public long timestamp;
    }

    // Update existing classes with timestamps
    public static class PlayerUpdate {
        public String username;
        public float x;
        public float y;
        public String direction;
        public List<PokemonData> partyPokemon;
        public boolean isMoving;
        // Add velocity for smoother movement
        public float velocityX;
        public float velocityY;
        public boolean wantsToRun;
        public ItemData[] inventoryItems;
        public ItemData[] hotbarItems;
        public long timestamp = System.currentTimeMillis();
    }

    // Add validation methods to request classes
    public static class LoginRequest {
        public String username;
        public String password;
        public long timestamp;
        public io.github.pokemeetup.system.data.WorldData worldData;

        @Override
        public String toString() {
            return "LoginRequest{" +
                "username='" + username + '\'' +
                ", hasPassword=" + (password != null && !password.isEmpty()) +
                ", timestamp=" + timestamp +
                '}';
        }
    }

    public static class RegisterRequest {
        public String username;
        public String password;
    }

    public static class InventoryUpdate {
        public String username;
        public ItemData[] inventoryItems;
    }

    public static class PlayerPosition {
        public HashMap<String, PlayerUpdate> players = new HashMap<>();
    }
    // Update the PlayerUpdate class in NetworkProtocol.java

    public static class ChatMessage {
        public String sender;
        public String content;
        public long timestamp;
        public ChatType type;
        public String recipient; // Add this field for private messages
    }

    public static class WeatherUpdate implements Serializable {
        public String weatherType;  // e.g., "RAIN", "CLEAR", "SNOW"
        public float intensity;     // 0.0 to 1.0
        public long duration;       // in milliseconds
        public long timestamp;
    }

    public static class SavePlayerDataRequest {
        public UUID uuid;
        public PlayerData playerData;
        public long timestamp;
    }

    public static class SavePlayerDataResponse {
        public UUID uuid;
        public boolean success;
        public String message;
        public long timestamp;
    }

    public static class GetPlayerDataRequest {
        public UUID uuid;
        public long timestamp;
    }

    public static class GetPlayerDataResponse {
        public UUID uuid;
        public PlayerData playerData;
        public boolean success;
        public String message;
        public long timestamp;
    }

    public static class TimeSync implements Serializable {
        public double worldTimeInMinutes;
        public long playedTime;
        public float dayLength;
        public long timestamp;
    }

    public static class WorldStateUpdate implements Serializable {
        public io.github.pokemeetup.system.data.WorldData worldData;
        public long timestamp;
        public Map<String, Object> extraData = new HashMap<>();  // For additional sync data
    }

    public static class TeamCreate {
        public String name;
        public String tag;
        public String leader;
        public long timestamp = System.currentTimeMillis();
    }

    public static class TeamInvite {
        public String teamName;
        public String inviter;
        public String invitee;
        public long timestamp = System.currentTimeMillis();
    }

    public static class TeamHQUpdate {
        public String teamName;
        public int x;
        public int y;
        public long timestamp = System.currentTimeMillis();
    }

    public static class PokemonSpawn {
        public UUID uuid;
        public String name;
        public int level;
        public float x;
        public float y;
        public PokemonData data;
        public long timestamp;
    }

    public static class PokemonDespawn {
        public UUID uuid;
        public long timestamp;
    }

    public static class PartyUpdate {
        public String username;
        public List<PokemonData> party;
        public long timestamp;
    }

    // Add to NetworkProtocol.java
    public static class TeleportRequest {
        public TeleportType type;
        public String player;
        public String target;  // For player teleports
        public String homeName;  // For home teleports
        public long timestamp;

        public enum TeleportType {
            SPAWN, HOME, PLAYER
        }
    }

    public static class WildPokemonSpawn {
        public UUID uuid;
        public float x;
        public float y;
        public PokemonData data;
        public long timestamp;
    }

    public static class WildPokemonDespawn {
        public UUID uuid;
        public long timestamp;
    }

    public static class RegisterResponse {
        public boolean success;
        public String message;
        public int x;
        public int y;
        public long worldSeed;  // Add this field
        public String username; // Added username field
    }

    public static class WorldObjectUpdate {
        public String objectId;
        public NetworkObjectUpdateType type;
        public float x;
        public float y;
        public String textureName;
        public NetworkedWorldObject.ObjectType objectType;
        public Map<String, Object> data;
    }

    // World State Classes
    public static class WorldState {
        public long timestamp;
        public List<EntityUpdate> entities;
        public List<PlayerState> players;
    }

    public static class PlayerState {
        public String username;
        public float x;
        public float y;
        public String direction;
        public boolean isMoving;
        public List<ItemData> inventory;
    }

    public static class EntityUpdate {
        public UUID entityId;
        public float x;
        public float y;
        public Vector2 velocity;
        public String entityType;
    }

    public  static class PlayerAction {
        public String playerId;
        public ActionType actionType;
        public Vector2 targetPosition;
    }

    public static class BlockPlacement {
        public String username;
        public String blockTypeId;
        public int tileX;
        public int tileY;
        public BlockAction action; // PLACE or REMOVE
    }

    public static class TeleportResponse {
        public String from;
        public String to;
        public boolean accepted;
        public long timestamp;
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/OtherPlayer.java
================
package io.github.pokemeetup.multiplayer;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.*;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.PlayerAnimations;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.utils.GameLogger;

import java.util.concurrent.atomic.AtomicBoolean;

public class OtherPlayer {
    private static final float INTERPOLATION_SPEED = 10f;
    private final String username;
    private final Inventory inventory;
    private final PlayerAnimations animations;
    private final Object positionLock = new Object();
    private final Object inventoryLock = new Object();
    private final AtomicBoolean isMoving;
    private final Vector2 targetPosition = new Vector2();
    private final Vector2 velocity = new Vector2();
    private boolean wantsToRun;
    private Vector2 position;
    private String direction;
    private float stateTime;
    private BitmapFont font;
    private float interpolationProgress;

    public OtherPlayer(String username, float x, float y) {
        this.username = (username != null && !username.isEmpty()) ? username : "Unknown";
        this.position = new Vector2(x, y);
        this.inventory = new Inventory();
        this.direction = "down";
        this.isMoving = new AtomicBoolean(false);
        this.wantsToRun = false;
        this.stateTime = 0;
        this.animations = new PlayerAnimations();

        GameLogger.info("Created OtherPlayer: " + this.username + " at (" + x + ", " + y + ")");
    }

    public void updateAction(NetworkProtocol.PlayerAction action) {
        switch (action.actionType) {
            case CHOP_START:
                animations.startChopping();
                break;
            case CHOP_STOP:
                animations.stopChopping();
                break;
            case PUNCH_START:
                animations.startPunching();
                break;
            case PUNCH_STOP:
                animations.stopPunching();
                break;
        }
    }


    public void updateFromNetwork(NetworkProtocol.PlayerUpdate update) {
        synchronized (this) {
            if (update == null) return;
            targetPosition.set(update.x, update.y);
            this.direction = update.direction;
            this.isMoving.set(update.isMoving);
            this.wantsToRun = update.wantsToRun;
            if (update.isMoving) {
                float dx = update.x - position.x;
                float dy = update.y - position.y;
                float distance = Vector2.len(dx, dy);

                if (distance > 0) {
                    velocity.set(dx / distance, dy / distance);
                    velocity.scl(update.wantsToRun ? 1.75f : 1f);
                }
            } else {
                velocity.setZero();
            }
        }
    }

    public void update(float deltaTime) {
        if (!position.epsilonEquals(targetPosition, 0.1f)) {
            interpolationProgress = Math.min(1.0f, interpolationProgress + deltaTime * INTERPOLATION_SPEED);
            position.x = MathUtils.lerp(position.x, targetPosition.x, interpolationProgress);
            position.y = MathUtils.lerp(position.y, targetPosition.y, interpolationProgress);
            isMoving.set(!position.epsilonEquals(targetPosition, 0.1f));
        } else {
            interpolationProgress = 0f;
            isMoving.set(false);
        }

        if (isMoving.get()) {
            stateTime += deltaTime;
        }
    }

    public void render(SpriteBatch batch) {
        TextureRegion currentFrame = animations.getCurrentFrame(
            direction,
            isMoving.get(),
            wantsToRun,
            stateTime
        );
        if (currentFrame == null) {
            GameLogger.error("OtherPlayer " + username + " has null currentFrame");
            return;
        }

        synchronized (positionLock) {
            if (currentFrame instanceof Sprite) {
                Sprite sprite = (Sprite) currentFrame;
                sprite.setPosition(position.x, position.y);
                sprite.setOrigin(0, 0);
                sprite.draw(batch);
            } else {
                batch.draw(currentFrame,
                    position.x,
                    position.y,
                    currentFrame.getRegionWidth(),
                    currentFrame.getRegionHeight()
                );
            }
        }

        renderUsername(batch);
    }



    private void renderUsername(SpriteBatch batch) {
        if (username == null || username.isEmpty()) return;

        ensureFontLoaded();
        GlyphLayout layout = new GlyphLayout(font, username);
        float textWidth = layout.width;

        synchronized (positionLock) {
            font.draw(batch, username,
                position.x + (Player.FRAME_WIDTH - textWidth) / 2,
                position.y + Player.FRAME_HEIGHT + 15);
        }
    }

    private void ensureFontLoaded() {
        if (font == null) {
            try {
                font = new BitmapFont(Gdx.files.internal("Skins/default.fnt"));
                font.getData().setScale(0.8f);
                GameLogger.error("Loaded font for OtherPlayer: " + username);
            } catch (Exception e) {
                GameLogger.error("Failed to load font for OtherPlayer: " + username + " - " + e.getMessage());
                font = new BitmapFont();
            }
        }
    }

    public void dispose() {

        animations.dispose();
        GameLogger.error(
            ("Disposed animations for OtherPlayer: " + username));
    }

    public Vector2 getPosition() {
        synchronized (positionLock) {
            return new Vector2(position);
        }
    }

    public void setPosition(Vector2 position) {
        this.position = position;
    }

    public Inventory getInventory() {
        synchronized (inventoryLock) {
            return inventory;
        }
    }

    public String getUsername() {
        return username;
    }

    public String getDirection() {
        synchronized (positionLock) {
            return direction;
        }
    }

    public boolean isMoving() {
        return isMoving.get();
    }

    public boolean isWantsToRun() {
        return wantsToRun;
    }

    public float getX() {
        synchronized (positionLock) {
            return position.x;
        }
    }

    public void setX(float x) {
        synchronized (positionLock) {
            this.position.x = x;
        }
    }

    public float getY() {
        synchronized (positionLock) {
            return position.y;
        }
    }

    public void setY(float y) {
        synchronized (positionLock) {
            this.position.y = y;
        }
    }

}

================
File: main/java/io/github/pokemeetup/multiplayer/PlayerManager.java
================
package io.github.pokemeetup.multiplayer;

import io.github.pokemeetup.multiplayer.server.ServerStorageSystem;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.utils.GameLogger;

import java.util.Collection;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class PlayerManager {
    private final Map<String, ServerPlayer> onlinePlayers = new ConcurrentHashMap<>();
    private final Map<UUID, String> uuidToUsername = new ConcurrentHashMap<>();
    private final ServerStorageSystem storage;

    public PlayerManager(ServerStorageSystem storage) {
        this.storage = storage;
        GameLogger.info("PlayerManager initialized with ServerStorageSystem");
    }


    public ServerPlayer getPlayer(String username) {
        return onlinePlayers.get(username);
    }


    public Collection<ServerPlayer> getOnlinePlayers() {
        return onlinePlayers.values();
    }

    public void removePlayer(String username) {
        ServerPlayer player = onlinePlayers.get(username);
        if (player != null) {
            try {
                UUID playerUUID = player.getUUID();
                // Get fresh copy of data
                PlayerData finalState = player.getData();

                // Save player data before removing
                storage.getPlayerDataManager().savePlayerData(playerUUID, finalState);
                storage.getPlayerDataManager().flush(); // Force immediate save

                // Remove after successful save
                onlinePlayers.remove(username);
                uuidToUsername.remove(playerUUID);

                GameLogger.info("Saved and removed player: " + username + " (UUID: " + playerUUID + ")");
            } catch (Exception e) {
                GameLogger.error("Error saving player data for " + username + ": " + e.getMessage());
            }
        }
    }



    public void dispose() {
        GameLogger.info("Starting PlayerManager disposal...");

        // Save each player's data
        for (Map.Entry<String, ServerPlayer> entry : onlinePlayers.entrySet()) {
            try {
                String username = entry.getKey();
                ServerPlayer player = entry.getValue();
                UUID playerUUID = player.getUUID();

                // Get fresh copy of data
                PlayerData finalState = player.getData();

                // Save with immediate flush
                storage.getPlayerDataManager().savePlayerData(playerUUID, finalState);
                storage.getPlayerDataManager().flush();

                GameLogger.info("Saved final state for: " + username + " (UUID: " + playerUUID + ")");
            } catch (Exception e) {
                GameLogger.error("Error saving player during dispose: " + e.getMessage());
            }
        }

        // Force final storage flush
        storage.flushPlayerData();

        // Clear collections
        onlinePlayers.clear();
        uuidToUsername.clear();

        GameLogger.info("PlayerManager disposal complete");
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/config/ServerConfigManager.java
================
// ServerConfigManager.java
package io.github.pokemeetup.multiplayer.server.config;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonWriter;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.JsonConfig;


public class ServerConfigManager {
    private static final String CONFIG_DIR = "configs";
    private static final String CONFIG_FILE = "servers.json";
    private static ServerConfigManager instance;
    private Array<ServerConnectionConfig> servers;

    public static ServerConnectionConfig getDefaultServerConfig() {
        return new ServerConnectionConfig(
            "localhost",
            54555,
            54556,
            "Default Server",
            true,
            100
        );
    }
    private ServerConfigManager() {
        servers = new Array<>();
        ensureConfigDirectory();
        loadServers();
        if (servers.isEmpty()) {
            addDefaultServer();
            saveServers();
        }
    }

    public static synchronized ServerConfigManager getInstance() {
        if (instance == null) {
            instance = new ServerConfigManager();
        }
        return instance;
    }


    public Array<ServerConnectionConfig> getServers() {
        return servers;
    }

    public void addServer(ServerConnectionConfig config) {
        if (!servers.contains(config, false)) {
            servers.add(config);
            saveServers();
            GameLogger.info("Added server: " + config.getServerName());
        }
    }

    private void ensureConfigDirectory() {
        try {
            FileHandle dir = Gdx.files.local(CONFIG_DIR);
            if (!dir.exists()) {
                dir.mkdirs();
            }
        } catch (Exception e) {
            GameLogger.info("Failed to create config directory: " + e.getMessage());
        }
    }

    private void loadServers() {
        try {
            FileHandle file = Gdx.files.local(CONFIG_DIR + "/" + CONFIG_FILE);
            if (file.exists()) {
                Json json = new Json();
                String fileContent = file.readString();
                GameLogger.info("Loading servers from: " + file.path());
                GameLogger.info("File content: " + fileContent);

                @SuppressWarnings("unchecked")
                Array<ServerConnectionConfig> loadedServers = json.fromJson(Array.class,
                    ServerConnectionConfig.class, fileContent);

                if (loadedServers != null && loadedServers.size > 0) {
                    servers = loadedServers;
                    GameLogger.info("Loaded " + servers.size + " servers");
                }
            }
        } catch (Exception e) {
            GameLogger.info("Error loading servers: " + e.getMessage());
            e.printStackTrace();
        }
    }


    private void addDefaultServer() {
        servers.add(new ServerConnectionConfig(
            "170.64.156.89",
            54555,
            54556,
            "Local Server",
            true,
            100
        ));
    }



    public void removeServer(ServerConnectionConfig server) {
        if (servers.removeValue(server, false)) {
            saveServers();
            GameLogger.info("Removed server: " + server.getServerName());
        }
    }

    private void saveServers() {
        try {
            FileHandle file = Gdx.files.local(CONFIG_DIR + "/" + CONFIG_FILE);

            Json json = JsonConfig.getInstance();
            json.setOutputType(JsonWriter.OutputType.json);

            // Create parent directories if they don't exist
            file.parent().mkdirs();

            String jsonStr = json.prettyPrint(servers);
            file.writeString(jsonStr, false);
            GameLogger.info("Saved " + servers.size + " servers to: " + file.path());
            GameLogger.info("Content: " + jsonStr);
        } catch (Exception e) {
            GameLogger.info("Error saving servers: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/config/ServerConnectionConfig.java
================
package io.github.pokemeetup.multiplayer.server.config;

import java.io.IOException;

public class ServerConnectionConfig {
    private static ServerConnectionConfig instance;
    private String serverIP;
    private int tcpPort;
    private int maxPlayers;
    private String iconPath;
    private String motd;
    private String version;
    private String dataDirectory;

    public void setIcon(String path) {
        this.iconPath = path;
    }

    public void setMotd(String motd) {
        this.motd = motd;
    }

    public String getIconPath() {
        return iconPath;
    }

    public void setIconPath(String iconPath) {
        this.iconPath = iconPath;
    }

    public String getMotd() {
        return motd;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    private int udpPort;
    private String serverName;
    private boolean isDefault;

    public ServerConnectionConfig(String serverIP, int tcpPort, int udpPort, String serverName, boolean isDefault, int maxPlayers) {
        this.serverIP = serverIP;
        this.tcpPort = tcpPort;
        this.udpPort = udpPort;
        this.maxPlayers = maxPlayers;
        this.serverName = serverName;
        this.isDefault = isDefault;
        setDataDirectory("worlds");
    }

    public ServerConnectionConfig() {
        setDataDirectory("worlds");
    }

    public static ServerConnectionConfig getInstance() {
        if (instance == null) {
            synchronized (ServerConnectionConfig.class) {
                if (instance == null) {
                    instance = new ServerConnectionConfig(
                        "170.64.156.89",
                        54555,
                        54556,
                        "Default Server",
                        false,
                        100
                    );
                }
            }
        }


        return instance;
    }

    private static void validateServerConnection(ServerConnectionConfig config) throws IOException {
        // Check if server is running
        try (java.net.Socket socket = new java.net.Socket()) {
            // Set a short timeout
            socket.connect(
                new java.net.InetSocketAddress(config.getServerIP(), config.getTcpPort()),
                2000
            );
        } catch (IOException e) {
            throw new IOException("Cannot connect to server at " +
                config.getServerIP() + ":" + config.getTcpPort() +
                " - " + e.getMessage());
        }
    }

    public void validate() {
        if (serverIP == null || serverIP.isEmpty()) {
            throw new IllegalArgumentException("Server IP cannot be empty");
        }
        if (tcpPort <= 0 || tcpPort > 65535) {
            throw new IllegalArgumentException("Invalid TCP port: " + tcpPort);
        }
        if (udpPort <= 0 || udpPort > 65535) {
            throw new IllegalArgumentException("Invalid UDP port: " + udpPort);
        }
        if (serverName == null || serverName.isEmpty()) {
            throw new IllegalArgumentException("Server name cannot be empty");
        }
        if (maxPlayers <= 0) {
            throw new IllegalArgumentException("Max players must be greater than 0");
        }
    }

    public static synchronized void setInstance(ServerConnectionConfig config) {
        instance = config;
    }

    public static ServerConnectionConfig getDefault() {
        return new ServerConnectionConfig("localhost", 55555, 55556, "Local Server", true, 100);
    }


    public int getMaxPlayers() {
        return maxPlayers;
    }

    public void setMaxPlayers(int maxPlayers) {
        this.maxPlayers = maxPlayers;
    }

    public String getDataDirectory() {
        return dataDirectory;
    }

    public void setDataDirectory(String dataDirectory) {
        this.dataDirectory = dataDirectory;
    }

    public String getServerIP() {
        return serverIP;
    }

    public void setServerIP(String serverIP) {
        this.serverIP = serverIP;
    }

    public int getTcpPort() {
        return tcpPort;
    }


    public void setTcpPort(int tcpPort) {
        this.tcpPort = tcpPort;
    }

    public int getUdpPort() {
        return udpPort;
    }


    public void setUdpPort(int udpPort) {
        this.udpPort = udpPort;
    }

    public String getServerName() {
        return serverName;
    }


    public void setServerName(String serverName) {
        this.serverName = serverName;
    }

    public boolean isDefault() {
        return isDefault;
    }

    public void setDefault(boolean aDefault) {
        isDefault = aDefault;
    }


    @Override
    public String toString() {
        return serverName + " (" + serverIP + ":" + tcpPort + ")";
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/DialogListener.java
================
package io.github.pokemeetup.multiplayer.server;

import com.badlogic.gdx.scenes.scene2d.Event;

public interface DialogListener {
    boolean handle(Event event);
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/entity/AIController.java
================
package io.github.pokemeetup.multiplayer.server.entity;

// Simple AI system for creatures
public interface AIController {
    void update();
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/entity/CreatureEntity.java
================
package io.github.pokemeetup.multiplayer.server.entity;

import com.badlogic.gdx.math.Vector2;

public class CreatureEntity extends Entity {
    private AIController aiController;
    private float movementSpeed = 100f;
    private float updateTimer = 0f;
    private static final float UPDATE_INTERVAL = 0.1f;

    public CreatureEntity(float x, float y) {
        super(EntityType.CREATURE, x, y);
        this.width = 32;
        this.height = 32;
        this.aiController = new SimpleAIController(this);
    }

    public CreatureEntity(AIController aiController) {
        this.aiController = aiController;
    }

    @Override
    public void update(float deltaTime) {
        // Update AI
        updateTimer += deltaTime;
        if (updateTimer >= UPDATE_INTERVAL) {
            updateTimer = 0;
            aiController.update();
        }

        // Update position
        position.add(
            velocity.x * movementSpeed * deltaTime,
            velocity.y * movementSpeed * deltaTime
        );
    }

    @Override
    public void handleCollision() {
        // Bounce off walls
        velocity.scl(-1);
    }

    @Override
    public void handleCollision(Entity other) {
        if (other instanceof CreatureEntity) {
            // Simple bounce off other creatures
            Vector2 normal = new Vector2(
                position.x - other.position.x,
                position.y - other.position.y
            ).nor();
            velocity.set(normal);
        }
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/entity/Entity.java
================
package io.github.pokemeetup.multiplayer.server.entity;

import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;

import java.util.UUID;

public abstract class Entity {
    private final UUID id;
    protected Vector2 position;
    protected Vector2 velocity;
    protected EntityType type;
    protected boolean isDead;
    protected float width;
    protected float height;

    protected Entity(EntityType type, float x, float y) {
        this.id = UUID.randomUUID();
        this.type = type;
        this.position = new Vector2(x, y);
        this.velocity = new Vector2();
        this.isDead = false;
    }   protected Entity() {
        this.id = UUID.randomUUID();
    }

    public abstract void update(float deltaTime);
    public abstract void handleCollision();
    public abstract void handleCollision(Entity other);

    public UUID getId() { return id; }
    public Vector2 getPosition() { return position; }
    public Vector2 getVelocity() { return velocity; }
    public EntityType getType() { return type; }
    public boolean isDead() { return isDead; }
    public Rectangle getBounds() {
        return new Rectangle(position.x, position.y, width, height);
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/entity/EntityEvents.java
================
package io.github.pokemeetup.multiplayer.server.entity;

import io.github.pokemeetup.multiplayer.server.events.BaseServerEvent;

// Event classes
public class EntityEvents {
    public static class EntitySpawnEvent extends BaseServerEvent {
        private final Entity entity;

        public EntitySpawnEvent(Entity entity) {
            this.entity = entity;
        }

        @Override
        public String getEventName() {
            return "EntitySpawn";
        }

        public Entity getEntity() {
            return entity;
        }
    }

    public static class EntityRemoveEvent extends BaseServerEvent {
        private final Entity entity;

        public EntityRemoveEvent(Entity entity) {
            this.entity = entity;
        }

        @Override
        public String getEventName() {
            return "EntityRemove";
        }

        public Entity getEntity() {
            return entity;
        }
    }

    public static class EntityCollisionEvent extends BaseServerEvent {
        private final Entity entity1;
        private final Entity entity2;

        public EntityCollisionEvent(Entity entity1, Entity entity2) {
            this.entity1 = entity1;
            this.entity2 = entity2;
        }

        @Override
        public String getEventName() {
            return "EntityCollision";
        }

        public Entity getEntity1() { return entity1; }
        public Entity getEntity2() { return entity2; }
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/entity/EntityFactory.java
================
package io.github.pokemeetup.multiplayer.server.entity;

public class EntityFactory {
    public static Entity createEntity(EntityType type, float x, float y) {
        switch (type) {
            case POKEBALL:
                return new PokeballEntity(x, y);
//            case ITEM:
//                return new ItemEntity(x, y);
//            case NPC:
//                return new NPCEntity(x, y);
            case CREATURE:
                return new CreatureEntity(x, y);
            default:
                throw new IllegalArgumentException("Unknown entity type: " + type);
        }
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/entity/EntityManager.java
================
package io.github.pokemeetup.multiplayer.server.entity;

import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.multiplayer.ServerPlayer;
import io.github.pokemeetup.multiplayer.server.events.BaseServerEvent;
import io.github.pokemeetup.multiplayer.server.events.EventManager;
import io.github.pokemeetup.system.gameplay.overworld.World;

import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class EntityManager {
    private final Map<UUID, Entity> entities;
    private final EventManager eventManager;
    private final World world;

    public EntityManager(World world, EventManager eventManager) {
        this.entities = new ConcurrentHashMap<>();
        this.eventManager = eventManager;
        this.world = world;
    }

    public Entity spawnEntity(EntityType type, float x, float y) {
        Entity entity = EntityFactory.createEntity(type, x, y);
        entities.put(entity.getId(), entity);
        eventManager.fireEvent(new EntityEvents.EntitySpawnEvent(entity));
        return entity;
    }

    public void removeEntity(UUID entityId) {
        Entity entity = entities.remove(entityId);
        if (entity != null) {
            eventManager.fireEvent(new EntityEvents.EntityRemoveEvent(entity));
        }
    }

    public void updateEntities(float deltaTime) {
        entities.values().forEach(entity -> {
            entity.update(deltaTime);
            handleEntityCollisions(entity);
        });
    }

    private void handleEntityCollisions(Entity entity) {
        // Check collision with world
        if (!world.isPassable((int)entity.getPosition().x, (int)entity.getPosition().y)) {
            entity.handleCollision();
        }

        // Check collisions with other entities
        entities.values().stream()
            .filter(other -> other != entity && entity.getBounds().overlaps(other.getBounds()))
            .forEach(other -> {
                entity.handleCollision(other);
                eventManager.fireEvent(new EntityEvents.EntityCollisionEvent(entity, other));
            });
    }
}

// Example entity implementations

================
File: main/java/io/github/pokemeetup/multiplayer/server/entity/EntityType.java
================
package io.github.pokemeetup.multiplayer.server.entity;

public enum EntityType {
    POKEBALL,
    ITEM,
    NPC,
    CREATURE,
    PLAYER
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/entity/PokeballEntity.java
================
package io.github.pokemeetup.multiplayer.server.entity;

import io.github.pokemeetup.multiplayer.ServerPlayer;
import io.github.pokemeetup.multiplayer.server.entity.Entity;
import io.github.pokemeetup.multiplayer.server.entity.EntityType;

public class PokeballEntity extends Entity {
    public PokeballEntity(float x, float y) {
        super(EntityType.POKEBALL, x, y);
        this.width = 16;
        this.height = 16;
    }

    @Override
    public void update(float deltaTime) {
        // Update position based on velocity
        position.add(velocity.x * deltaTime, velocity.y * deltaTime);
    }

    public PokeballEntity() {
    }

    @Override
    public void handleCollision() {
        // Stop movement on collision
        velocity.setZero();
    }

    @Override
    public void handleCollision(Entity other) {
        if (other != null && other.getType() != EntityType.PLAYER) {
            isDead = true; // Mark for removal when picked up
        }
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/entity/SimpleAIController.java
================
package io.github.pokemeetup.multiplayer.server.entity;

import io.github.pokemeetup.multiplayer.server.entity.AIController;
import io.github.pokemeetup.multiplayer.server.entity.CreatureEntity;

import java.util.Random;
public class SimpleAIController implements AIController {
    private final CreatureEntity entity;
    private float decisionTimer = 0f;
    private static final float DECISION_INTERVAL = 2f;
    private final Random random = new Random();

    public SimpleAIController(CreatureEntity entity) {
        this.entity = entity;
    }

    @Override
    public void update() {
        decisionTimer += 0.1f;
        if (decisionTimer >= DECISION_INTERVAL) {
            decisionTimer = 0;
            // Random movement decision
            entity.getVelocity().set(
                random.nextFloat() * 2 - 1,
                random.nextFloat() * 2 - 1
            ).nor();
        }
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/events/BaseServerEvent.java
================
package io.github.pokemeetup.multiplayer.server.events;

public abstract class BaseServerEvent implements ServerEvent {
    private final long timestamp;

    protected BaseServerEvent() {
        this.timestamp = System.currentTimeMillis();
    }

    @Override
    public long getTimestamp() {
        return timestamp;
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/events/EventListener.java
================
package io.github.pokemeetup.multiplayer.server.events;

public interface EventListener<T extends ServerEvent> {
    void onEvent(T event);
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/events/EventManager.java
================
package io.github.pokemeetup.multiplayer.server.events;

import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.*;


    public class EventManager {
        private final Map<Class<? extends ServerEvent>, List<EventListener<?>>> listeners;
        private final ExecutorService eventExecutor;
        private volatile boolean isShuttingDown = false;

        public EventManager() {
            this.listeners = new ConcurrentHashMap<>();
            this.eventExecutor = Executors.newFixedThreadPool(2);
        }



        public void fireEvent(ServerEvent event) {
            if (isShuttingDown) {
                GameLogger.info("Dropping event during shutdown: " + event.getEventName());
                return;
            }

            Class<? extends ServerEvent> eventClass = event.getClass();
            List<EventListener<?>> eventListeners = listeners.get(eventClass);

            if (eventListeners != null) {
                eventExecutor.submit(() -> {
                    for (EventListener<?> listener : eventListeners) {
                        try {
                            @SuppressWarnings("unchecked")
                            EventListener<ServerEvent> typedListener = (EventListener<ServerEvent>) listener;
                            typedListener.onEvent(event);
                        } catch (Exception e) {
                            GameLogger.info("Error handling event " + event.getEventName() + ": " + e.getMessage());
                            e.printStackTrace();
                        }
                    }
                });
            }
        }


    public void shutdown() {
        isShuttingDown = true;

        // Stop accepting new events
        eventExecutor.shutdown();

        try {
            // Wait for existing events to complete
            if (!eventExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                // Force shutdown if events don't complete in time
                List<Runnable> pendingEvents = eventExecutor.shutdownNow();
                GameLogger.info("Force-terminated " + pendingEvents.size() + " pending events");
            }
        } catch (InterruptedException e) {
            eventExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        } finally {
            // Clear all listeners
            listeners.clear();
        }
    }
    public <T extends ServerEvent> void registerListener(Class<T> eventClass, EventListener<T> listener) {
        listeners.computeIfAbsent(eventClass, k -> new ArrayList<>()).add(listener);
    }


}

================
File: main/java/io/github/pokemeetup/multiplayer/server/events/ServerEvent.java
================
package io.github.pokemeetup.multiplayer.server.events;

public interface ServerEvent {
    String getEventName();
    long getTimestamp();
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/GameStateHandler.java
================
package io.github.pokemeetup.multiplayer.server;

import com.badlogic.gdx.Screen;

public interface GameStateHandler {
    void returnToLogin(String message);
    void saveAndDispose();
    boolean isMultiplayerMode();
    void setScreen(Screen screen);
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/PlayerDataManager.java
================
package io.github.pokemeetup.multiplayer.server;

import com.badlogic.gdx.utils.Json;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.GameFileSystem;
import io.github.pokemeetup.utils.storage.JsonConfig;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class PlayerDataManager {
    private static final String PLAYER_DATA_DIR = "players/"; // Simplified path
    private final Map<UUID, PlayerData> playerCache;
    private final GameFileSystem fs;
    private final Json json;
    private volatile boolean isFlushInProgress = false;

    public PlayerDataManager() {
        this.playerCache = new ConcurrentHashMap<>();
        this.fs = GameFileSystem.getInstance();
        this.json = JsonConfig.getInstance();
        initializeDirectory();
    }

    private void initializeDirectory() {
        try {
            fs.createDirectory(PLAYER_DATA_DIR);
            GameLogger.info("Player data directory initialized at: " + PLAYER_DATA_DIR);
        } catch (Exception e) {
            GameLogger.error("Failed to create player data directory: " + e.getMessage());
            throw new RuntimeException("Player data storage initialization failed", e);
        }
    }

    public synchronized PlayerData loadPlayerData(UUID uuid) {
        // Check cache first
        PlayerData cached = playerCache.get(uuid);
        if (cached != null) {
            return cached.copy(); // Return copy to prevent direct cache modification
        }

        try {
            String path = getPlayerDataPath(uuid);
            if (!fs.exists(path)) {
                GameLogger.info("No existing data found for UUID: " + uuid);
                return null;
            }

            String jsonData = fs.readString(path);
            PlayerData playerData = json.fromJson(PlayerData.class, jsonData);

            if (playerData != null) {
                // Validate and repair if needed
                if (playerData.validateAndRepairState()) {
                    GameLogger.info("Repaired loaded player data for UUID: " + uuid);
                    savePlayerData(uuid, playerData); // Save repaired data
                }
                playerCache.put(uuid, playerData.copy());
                GameLogger.info("Successfully loaded player data for UUID: " + uuid);
                return playerData.copy();
            }
            return null;
        } catch (Exception e) {
            GameLogger.error("Failed to load player data for UUID: " + uuid + " - " + e.getMessage());
            return null;
        }
    }

    public synchronized void savePlayerData(UUID uuid, PlayerData playerData) {
        if (uuid == null || playerData == null) {
            GameLogger.error("Invalid save attempt with null UUID or PlayerData");
            return;
        }

        try {
            // Ensure directory exists first
            fs.createDirectory(PLAYER_DATA_DIR);

            // Validate data before saving
            if (!playerData.validateAndRepairState()) {
                GameLogger.error("Player data validation failed for UUID: " + uuid);
                return;
            }

            String tempPath = getPlayerDataPath(uuid) + ".temp";
            String finalPath = getPlayerDataPath(uuid);

            // Write to temp file first with pretty print for readability
            String jsonData = json.prettyPrint(playerData);
            fs.writeString(tempPath, jsonData);

            // Verify temp file
            if (!fs.exists(tempPath)) {
                throw new RuntimeException("Failed to write temporary player data file");
            }

            // Atomic move to final location
            if (fs.exists(finalPath)) {
                fs.deleteFile(finalPath);
            }
            fs.moveFile(tempPath, finalPath);

            // Update cache with a deep copy
            playerCache.put(uuid, playerData.copy());

            // Don't call flush() here anymore
            GameLogger.info("Successfully saved player data for UUID: " + uuid);

        } catch (Exception e) {
            GameLogger.error("Failed to save player data for UUID: " + uuid + " - " + e.getMessage());
            throw new RuntimeException("Player data save failed", e);
        }
    }
    private String getPlayerDataPath(UUID uuid) {
        return PLAYER_DATA_DIR + uuid.toString() + ".json";
    }

    private void initializePeriodicFlush() {
        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduler.scheduleWithFixedDelay(this::flush, 5, 5, TimeUnit.MINUTES);
    }


    public synchronized void flush() {
        if (isFlushInProgress) {
            return; // Prevent recursive flush
        }

        try {
            isFlushInProgress = true;
            GameLogger.info("Starting player data flush...");
            Map<UUID, PlayerData> dataToSave = new HashMap<>(playerCache);

            int successCount = 0;
            for (Map.Entry<UUID, PlayerData> entry : dataToSave.entrySet()) {
                try {
                    // Call savePlayerData directly without triggering another flush
                    savePlayerData(entry.getKey(), entry.getValue());
                    successCount++;
                } catch (Exception e) {
                    GameLogger.error("Failed to flush player data for UUID " +
                        entry.getKey() + ": " + e.getMessage());
                }
            }

            GameLogger.info("Player data flush complete - " +
                successCount + "/" + dataToSave.size() + " players saved successfully");

        } finally {
            isFlushInProgress = false;
        }
    }


    public void deletePlayerData(UUID uuid) {
        try {
            String path = getPlayerDataPath(uuid);
            if (fs.exists(path)) {
                fs.deleteFile(path);
                playerCache.remove(uuid);
                GameLogger.info("Deleted player data for UUID: " + uuid);
            }
        } catch (Exception e) {
            GameLogger.error("Failed to delete player data for UUID: " + uuid + " - " + e.getMessage());
        }
    }

    public void shutdown() {
        try {
            GameLogger.info("Starting PlayerDataManager shutdown...");
            flush(); // Ensure all cached data is saved
            playerCache.clear();
            GameLogger.info("PlayerDataManager shutdown complete");
        } catch (Exception e) {
            GameLogger.error("Error during PlayerDataManager shutdown: " + e.getMessage());
        }
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/PlayerEvents.java
================
package io.github.pokemeetup.multiplayer.server;

import io.github.pokemeetup.multiplayer.PlayerManager;
import io.github.pokemeetup.multiplayer.ServerPlayer;
import io.github.pokemeetup.multiplayer.server.events.BaseServerEvent;

public class PlayerEvents {
    public static class PlayerLoginEvent extends BaseServerEvent {
        private final ServerPlayer player;

        public PlayerLoginEvent(ServerPlayer player) {
            this.player = player;
        }

        @Override
        public String getEventName() {
            return "PlayerLogin";
        }

        public ServerPlayer getPlayer() {
            return player;
        }
    }

    public static class PlayerLogoutEvent extends BaseServerEvent {
        private final ServerPlayer player;

        public PlayerLogoutEvent(ServerPlayer player) {
            this.player = player;
        }

        @Override
        public String getEventName() {
            return "PlayerLogout";
        }

        public ServerPlayer getPlayer() {
            return player;
        }
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/plugin/JarPluginLoader.java
================
package io.github.pokemeetup.multiplayer.server.plugin;

import java.io.File;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.net.URLClassLoader;
import java.net.URL;
import java.util.List;



public class JarPluginLoader implements PluginLoader {
    @Override
    public boolean canLoad(File file) {
        return file.getName().endsWith(".jar");
    }

    @Override
    public ServerPlugin loadPlugin(File file) throws Exception {
        try (JarFile jarFile = new JarFile(file)) {
            // Get plugin.yml entry
            JarEntry configEntry = jarFile.getJarEntry("plugin.yml");
            if (configEntry == null) {
                throw new Exception("Missing plugin.yml in " + file.getName());
            }

            // Load plugin config
            PluginConfig config = PluginConfig.load(jarFile.getInputStream(configEntry));

            // Create class loader
            URL[] urls = { file.toURI().toURL() };
            try (URLClassLoader classLoader = new URLClassLoader(urls, getClass().getClassLoader())) {
                // Load main class
                Class<?> mainClass = Class.forName(config.getMainClass(), true, classLoader);
                Class<? extends ServerPlugin> pluginClass = mainClass.asSubclass(ServerPlugin.class);

                // Create plugin instance
                ServerPlugin plugin = pluginClass.getDeclaredConstructor().newInstance();
                return plugin;
            }
        }
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/plugin/PluginConfig.java
================
package io.github.pokemeetup.multiplayer.server.plugin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class PluginConfig {
    private String name;
    private String version;
    private String mainClass;
    private List<String> dependencies;


    public static PluginConfig load(InputStream input) {
        try {
            // Read the content as JSON
            StringBuilder content = new StringBuilder();
            try (Scanner scanner = new Scanner(input)) {
                while (scanner.hasNextLine()) {
                    content.append(scanner.nextLine()).append("\n");
                }
            }

            // Parse JSON to PluginConfig
            Gson gson = new GsonBuilder()
                .setPrettyPrinting()
                .create();

            PluginConfig config = gson.fromJson(content.toString(), PluginConfig.class);

            // Validate required fields
            if (config.name == null || config.name.isEmpty()) {
                throw new IllegalArgumentException("Plugin name is required");
            }
            if (config.mainClass == null || config.mainClass.isEmpty()) {
                throw new IllegalArgumentException("Main class is required");
            }
            if (config.version == null || config.version.isEmpty()) {
                config.version = "1.0.0";
            }
            if (config.dependencies == null) {
                config.dependencies = new ArrayList<>();
            }

            return config;
        } catch (Exception e) {
            throw new RuntimeException("Failed to load plugin config: " + e.getMessage(), e);
        }
    }


    // Getters
    public String getName() { return name; }
    public String getVersion() { return version; }
    public String getMainClass() { return mainClass; }
    public List<String> getDependencies() { return dependencies; }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/plugin/PluginLoader.java
================
package io.github.pokemeetup.multiplayer.server.plugin;

import io.github.pokemeetup.multiplayer.server.plugin.ServerPlugin;

import java.io.File;

public interface PluginLoader {
    boolean canLoad(File file);
    ServerPlugin loadPlugin(File file) throws Exception;
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/plugin/ServerPlugin.java
================
package io.github.pokemeetup.multiplayer.server.plugin;


import io.github.pokemeetup.system.servers.PluginContext;

public interface ServerPlugin {
    String getId();

    void onLoad(PluginContext manager);

    void onEnable();

    void onDisable();
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/ServerStorageSystem.java
================
package io.github.pokemeetup.multiplayer.server;

import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonWriter;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.GameFileSystem;
import io.github.pokemeetup.utils.storage.JsonConfig;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class ServerStorageSystem {
    public static final String SERVER_BASE_DIR = "";
    public static final String SERVER_WORLD_DIR = SERVER_BASE_DIR + "worlds/";
    private final Json json;
    private final Map<String, WorldData> worldCache;
    private final GameFileSystem fs;
    private final PlayerDataManager playerDataManager;
    public synchronized void flushPlayerData() {
        try {
            GameLogger.info("Flushing player data to disk...");
            playerDataManager.flush();
        } catch (Exception e) {
            GameLogger.error("Failed to flush player data: " + e.getMessage());
        }
    }
    public ServerStorageSystem() {
        this.json = JsonConfig.getInstance();
        this.json.setOutputType(JsonWriter.OutputType.json);
        this.worldCache = new ConcurrentHashMap<>();
        this.fs = GameFileSystem.getInstance();
        this.playerDataManager = new PlayerDataManager();
        initializeDirectories();
    }

    public boolean worldExists(String name) {
        try {
            String worldPath = SERVER_WORLD_DIR + name + "/world.json";
            return fs.exists(worldPath);
        } catch (Exception e) {
            GameLogger.error("Error checking world existence: " + e.getMessage());
            return false;
        }
    }

    private void initializeDirectories() {
        try {
            // Create all required directories
            fs.createDirectory(SERVER_BASE_DIR);
            fs.createDirectory(SERVER_WORLD_DIR);
            fs.createDirectory(SERVER_WORLD_DIR + "backups/");

            GameLogger.info("Server storage directories initialized");
        } catch (Exception e) {
            GameLogger.error("Failed to create server storage directories: " + e.getMessage());
            throw new RuntimeException("Server storage initialization failed", e);
        }
    }

    public synchronized WorldData loadWorld(String name) {
        // Check cache first
        WorldData cached = worldCache.get(name);
        if (cached != null) {
            return cached;
        }

        try {
            String worldPath = SERVER_WORLD_DIR + name + "/world.json";
            if (!fs.exists(worldPath)) {
                GameLogger.info("World file not found: " + name);
                return null;
            }

            String content = fs.readString(worldPath);
            WorldData world = json.fromJson(WorldData.class, content);

            if (world != null) {
                worldCache.put(name, world);
                GameLogger.info("Loaded world from server storage: " + name);
            }

            return world;
        } catch (Exception e) {
            GameLogger.error("Failed to load world: " + name + " - " + e.getMessage());
            return null;
        }
    }

    public synchronized void saveWorld(WorldData world) {
        if (world == null) return;

        try {
            String worldPath = SERVER_WORLD_DIR + world.getName() + "/";
            fs.createDirectory(worldPath);

            // Create backup first
            createWorldBackup(world);

            // Save using temporary file
            String tempPath = worldPath + "world.json.temp";
            String finalPath = worldPath + "world.json";

            String jsonData = json.prettyPrint(world);
            fs.writeString(tempPath, jsonData);

            // If temporary file was written successfully, move it to the actual file
            if (fs.exists(finalPath)) {
                fs.deleteFile(finalPath);
            }
            fs.moveFile(tempPath, finalPath);

            // Update cache
            worldCache.put(world.getName(), world);

            GameLogger.info("Saved world to server storage: " + world.getName());
        } catch (Exception e) {
            GameLogger.error("Failed to save world: " + world.getName() + " - " + e.getMessage());
            throw new RuntimeException("World save failed", e);
        }
    }

    public void savePlayerData(String username, PlayerData data) {
        UUID playerUUID = UUID.nameUUIDFromBytes(username.getBytes());
        playerDataManager.savePlayerData(playerUUID, data);
    }

    public PlayerData loadPlayerData(String username) {
        UUID playerUUID = UUID.nameUUIDFromBytes(username.getBytes());
        return playerDataManager.loadPlayerData(playerUUID);
    }

    public Map<String, WorldData> getAllWorlds() {
        String[] worldDirs = fs.list(SERVER_WORLD_DIR);
        Map<String, WorldData> worlds = new HashMap<>();

        if (worldDirs != null) {
            for (String dir : worldDirs) {
                WorldData world = loadWorld(dir);
                if (world != null) {
                    worlds.put(world.getName(), world);
                }
            }
        }

        return worlds;
    }


    public void deletePlayerData(UUID uuid) {
        playerDataManager.deletePlayerData(uuid);
    }

    public void createWorldBackup(WorldData world) {
        if (world == null) {
            GameLogger.error("Cannot create backup of null world");
            return;
        }

        try {
            String worldName = world.getName();
            if (worldName == null || worldName.trim().isEmpty()) {
                GameLogger.error("Cannot backup world with null/empty name");
                return;
            }

            String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
            String backupDir = SERVER_WORLD_DIR + worldName + "/backups/";

            // Create backup directory if it doesn't exist
            fs.createDirectory(backupDir);

            String backupPath = backupDir + "world_" + timestamp + ".json";
            String jsonData = json.prettyPrint(world);
            fs.writeString(backupPath, jsonData);

            GameLogger.info("Created backup of world: " + worldName);
        } catch (Exception e) {
            GameLogger.error("Failed to create world backup: " + e.getMessage());
        }
    }


    public void deleteWorld(String name) {
        String worldPath = SERVER_WORLD_DIR + name;
        if (fs.exists(worldPath)) {
            fs.deleteDirectory(worldPath);
            worldCache.remove(name);
            GameLogger.info("Deleted world from server storage: " + name);
        }
    }

    public PlayerDataManager getPlayerDataManager() {
        return playerDataManager;
    }

    public void shutdown() {
        // Save all cached data
        for (WorldData world : worldCache.values()) {
            saveWorld(world);
        }
        playerDataManager.shutdown();
        GameLogger.info("Storage system shutdown complete");
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/storage/FileStorage.java
================
package io.github.pokemeetup.multiplayer.server.storage;

import com.badlogic.gdx.utils.Json;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.JsonConfig;

import java.io.IOException;
import java.nio.file.*;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.concurrent.ConcurrentHashMap;

public class FileStorage implements StorageSystem {
    private static final String MULTIPLAYER_ROOT = "multiplayer/";
    private final Path baseDir;
    private final Path worldsDir;
    private final Path playersDir;
    private final Json json;
    private final ConcurrentHashMap<String, PlayerData> playerCache;
    private final ConcurrentHashMap<String, WorldData> worldCache;
    // Cache for multiplayer data
    private long serverSeed; // Add this to ensure consistent generation
    public FileStorage(String baseDirectory) {
        // Always use multiplayer root
        this.baseDir = Paths.get(baseDirectory, MULTIPLAYER_ROOT);
        this.worldsDir = baseDir.resolve("worlds");
        this.playersDir = baseDir.resolve("players");

        this.json = JsonConfig.getInstance();
        this.serverSeed = System.currentTimeMillis(); // Initialize with a default

        this.playerCache = new ConcurrentHashMap<>();
        this.worldCache = new ConcurrentHashMap<>();

        GameLogger.info("Initializing multiplayer storage at: " + baseDir);
    }


    private void createWorldBackup(String worldName) {
        try {
            Path worldFile = worldsDir.resolve(worldName + "/world.json");
            Path backupDir = worldsDir.resolve(worldName + "/backups");
            Files.createDirectories(backupDir);
            Path backupFile = backupDir.resolve("world_backup.json"); // fixed name
            Files.copy(worldFile, backupFile, StandardCopyOption.REPLACE_EXISTING);
            GameLogger.info("Created backup of world: " + worldName + " at " + backupFile.toAbsolutePath());
        } catch (Exception e) {
            GameLogger.error("Failed to create backup of world: " + worldName + " - " + e.getMessage());
        }
    }

    @Override
    public void initialize() throws IOException {
        // Create directory structure
        Files.createDirectories(worldsDir);
        Files.createDirectories(playersDir);

        // Load existing multiplayer data
        loadExistingData();
        worldCache.forEach((worldName, data) -> {
            createWorldBackup(worldName);
        });

        GameLogger.info("Multiplayer storage initialized");
    }

    private void loadExistingData() throws IOException {
        // Load player data
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(playersDir, "*.json")) {
            for (Path file : stream) {
                String username = file.getFileName().toString().replace(".json", "");
                PlayerData data = loadPlayerData(username);
                if (data != null) {
                    playerCache.put(username, data);
                    GameLogger.info("Loaded multiplayer player data: " + username);
                }
            }
        }

        // Load world data
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(worldsDir, "*.json")) {
            for (Path file : stream) {
                String worldName = file.getFileName().toString().replace(".json", "");
                WorldData data = loadWorldData(worldName);
                if (data != null) {
                    worldCache.put(worldName, data);
                    GameLogger.info("Loaded multiplayer world: " + worldName);
                }
            }
        }
    }
    @Override
    public void savePlayerData(String username, PlayerData data) throws IOException {
        try {
            if (data != null) {
                // Always ensure clean data copy for server storage
                PlayerData saveData = data.copy();
                saveData.validateAndRepairState();

                // Store in server's file system
                Path file = playersDir.resolve(username + ".json");
                String jsonData = json.prettyPrint(saveData);
                Files.write(file, jsonData.getBytes(),
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING);

                // Update cache
                playerCache.put(username, saveData);
                GameLogger.info("Server saved player data for: " + username);
            }
        } catch (Exception e) {
            GameLogger.error("Server failed to save player data: " + username);
            throw e;
        }
    }

    @Override
    public PlayerData loadPlayerData(String username) {
        // Check cache first
        PlayerData cached = playerCache.get(username);
        if (cached != null) {
            return cached;
        }

        try {
            Path file = playersDir.resolve(username + ".json");
            if (Files.exists(file)) {
                String jsonData = Files.readString(file);
                PlayerData data = json.fromJson(PlayerData.class, jsonData);
                if (data != null) {
                    playerCache.put(username, data);
                }
                return data;
            }
        } catch (IOException e) {
            GameLogger.error("Error loading multiplayer player data: " + username + " - " + e.getMessage());
        }
        return null;
    }

    @Override
    public void saveWorldData(String worldName, WorldData data) throws IOException {
        Path worldFile = worldsDir.resolve(worldName + "/world.json");
        Path backupDir = worldsDir.resolve(worldName + "/backups");

        try {
            Files.createDirectories(worldFile.getParent());
            Files.createDirectories(backupDir);

            // Ensure world config uses server seed
            if (data.getConfig() == null) {
                data.setConfig(new WorldData.WorldConfig(serverSeed));
            } else {
                data.getConfig().setSeed(serverSeed);
            }

            // Create backup
            if (Files.exists(worldFile)) {
                Path backup = backupDir.resolve("world_backup_" +
                    new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()) + ".json");
                Files.copy(worldFile, backup, StandardCopyOption.REPLACE_EXISTING);
            }

            // Save world data with validated player data
            for (PlayerData playerData : data.getPlayers().values()) {
                if (playerData != null) {
                    playerData.validateAndRepairState();
                }
            }

            String jsonData = json.prettyPrint(data);
            Files.writeString(worldFile, jsonData, StandardOpenOption.CREATE,
                StandardOpenOption.TRUNCATE_EXISTING);
            worldCache.put(worldName, data);


        } catch (Exception e) {
            GameLogger.error("Failed to save world: " + worldName + " - " + e.getMessage());
            throw e;
        }
    }


    @Override
    public WorldData loadWorldData(String worldName) {
        try {
            WorldData cached = worldCache.get(worldName);
            if (cached != null) {
                return cached;
            }

            Path worldFile = worldsDir.resolve(worldName + "/world.json");
            if (Files.exists(worldFile)) {
                String jsonData = Files.readString(worldFile);
                WorldData data = json.fromJson(WorldData.class, jsonData);

                // Ensure server seed is used
                if (data != null) {
                    if (data.getConfig() == null) {
                        data.setConfig(new WorldData.WorldConfig(serverSeed));
                    } else {
                        data.getConfig().setSeed(serverSeed);
                    }

                    // Validate player data
                    for (PlayerData playerData : data.getPlayers().values()) {
                        if (playerData != null) {
                            playerData.validateAndRepairState();
                        }
                    }

                    worldCache.put(worldName, data);
                }
                return data;
            }
            return null;
        } catch (Exception e) {
            GameLogger.error("Error loading world: " + worldName + " - " + e.getMessage());
            return null;
        }
    }


    @Override
    public void clearCache() {
        playerCache.clear();
        worldCache.clear();
    }

    @Override
    public void shutdown() {
        GameLogger.info("Shutting down multiplayer storage...");

        // Save all cached data
        playerCache.forEach((username, data) -> {
            try {
                savePlayerData(username, data);
            } catch (IOException e) {
                GameLogger.error("Error saving player data during shutdown: " + e.getMessage());
            }
        });

        worldCache.forEach((worldName, data) -> {
            try {
                saveWorldData(worldName, data);
            } catch (IOException e) {
                GameLogger.error("Error saving world data during shutdown: " + e.getMessage());
            }
        });

        clearCache();
        GameLogger.info("Multiplayer storage shutdown complete");
    }
}

================
File: main/java/io/github/pokemeetup/multiplayer/server/storage/StorageSystem.java
================
package io.github.pokemeetup.multiplayer.server.storage;

import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.WorldData;
import java.io.IOException;

public interface StorageSystem {
    void initialize() throws IOException;
    void savePlayerData(String username, PlayerData data) throws IOException;
    PlayerData loadPlayerData(String username);
    void saveWorldData(String worldName, WorldData data) throws IOException;
    WorldData loadWorldData(String worldName);
    void clearCache();
    void shutdown();
}

================
File: main/java/io/github/pokemeetup/multiplayer/ServerPlayer.java
================
package io.github.pokemeetup.multiplayer;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.PokemonData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class ServerPlayer {
    private final String username;
    private final UUID uuid;
    private PlayerData playerData;
    private final Inventory inventory;
    private final List<PokemonData> partyPokemon;
    private final Object inventoryLock = new Object();
    private final Object positionLock = new Object();
    private WorldObject choppingObject;

    public ServerPlayer(String username, PlayerData playerData) {
        List<PokemonData> partyPokemon1;
        this.username = username;
        this.uuid = UUID.nameUUIDFromBytes(username.getBytes());
        this.playerData = playerData;

        this.inventory = new Inventory();
        partyPokemon1 = new ArrayList<>();
        if (playerData.getInventoryItems() != null) {
            this.inventory.setAllItems(playerData.getInventoryItems());
        }
        if (playerData.getPartyPokemon()!= null) {
            partyPokemon1 = playerData.getPartyPokemon();
        }

        this.partyPokemon = partyPokemon1;
        GameLogger.info("Created ServerPlayer: " + username + " (UUID: " + uuid + ") " +
            "at position (" + playerData.getX() + ", " + playerData.getY() + ")");
    }

    public WorldObject getChoppingObject() {
        return choppingObject;
    }

    public void setChoppingObject(WorldObject object) {
        this.choppingObject = object;
    }

    public UUID getUUID() {
        return uuid;
    }
    private final Object dataLock = new Object();


    private List<ItemData> validateItems(ItemData[] items) {
        List<ItemData> validatedItems = new ArrayList<>();
        for (ItemData item : items) {
            if (item != null) {
                if (item.getUuid() == null) {
                    item.setUuid(UUID.randomUUID());
                }
                if (item.getCount() <= 0 || item.getCount() > 64) {
                    item.setCount(1);
                }
                validatedItems.add(item);
            } else {
                validatedItems.add(null);
            }
        }
        return validatedItems;
    }

    public PlayerData getData() {
        synchronized (dataLock) {
            // Create a fresh copy with current state
            PlayerData currentData = playerData.copy();

            // Ensure inventory is synced
            synchronized (inventoryLock) {
                currentData.setInventoryItems(new ArrayList<>(inventory.getAllItems()));
            }

            // Ensure pokemon party is synced
            synchronized (partyPokemon) {
                currentData.setPartyPokemon(new ArrayList<>(partyPokemon));
            }

            return currentData;
        }
    }

    public void setData(PlayerData newData) {
        synchronized (dataLock) {
            if (newData == null) {
                GameLogger.error("Attempted to set null PlayerData for " + username);
                return;
            }

            try {
                // Create deep copy and validate
                PlayerData validatedData = newData.copy();
                if (validatedData.validateAndRepairState()) {
                    GameLogger.info("Repaired player data during update for: " + username);
                }

                this.playerData = validatedData;

                // Update inventory atomically
                synchronized (inventoryLock) {
                    if (validatedData.getInventoryItems() != null) {
                        this.inventory.clear();
                        for (ItemData item : validatedData.getInventoryItems()) {
                            if (item != null) {
                                this.inventory.addItem(item.copy());
                            }
                        }
                    }
                }

                // Update party atomically
                synchronized (partyPokemon) {
                    this.partyPokemon.clear();
                    if (validatedData.getPartyPokemon() != null) {
                        for (PokemonData pokemon : validatedData.getPartyPokemon()) {
                            if (pokemon != null) {
                                this.partyPokemon.add(pokemon.copy());
                            }
                        }
                    }
                }

            } catch (Exception e) {
                GameLogger.error("Failed to update player data for " + username + ": " + e.getMessage());
            }
        }
    }

    public int getTileX() {
        return (int) (playerData.getX() / World.TILE_SIZE);
    }

    public int getTileY() {
        return (int) (playerData.getY() / World.TILE_SIZE);
    }

    public Vector2 getPosition() {
        synchronized (positionLock) {
            return new Vector2(playerData.getX(), playerData.getY());
        }
    }

    public List<ItemData> getInventoryItems() {
        synchronized (inventoryLock) {
            return inventory.getAllItems();
        }
    }

    public String getUsername() {
        return username;
    }

    public String getDirection() {
        synchronized (positionLock) {
            return playerData.getDirection();
        }
    }

    public boolean isMoving() {
        synchronized (positionLock) {
            return playerData.isMoving();
        }
    }

    public boolean isRunning() {
        return playerData.isWantsToRun();
    }

    public void setRunning(boolean running) {
        playerData.setWantsToRun(running);
    }

    public Inventory getInventory() {
        return inventory;
    }
}

================
File: main/java/io/github/pokemeetup/oldsystems/PlayerDataV1.java
================
package io.github.pokemeetup.oldsystems;

    import java.util.ArrayList;
    import java.util.List;

    /**
     * Temporary class to represent io.github.pokemeetup.system.data.PlayerData in version 1.
     */
    public class PlayerDataV1 {
        private String username;
        private float x = 0;
        private float y = 0;
        private String direction = "down"; // Default to "down"
        private boolean isMoving = false;
        private boolean wantsToRun = false;
        private List<String> inventoryItems = new ArrayList<>();
        private List<String> hotbarItems = new ArrayList<>();
        private boolean isDirty;

        // Default constructor for Json serialization
        public PlayerDataV1() {}

        // Getters and Setters
        public String getUsername() {
            return username;
        }

        public void setUsername(String username) {
            this.username = username;
        }

        public float getX() {
            return x;
        }

        public void setX(float x) {
            this.x = x;
        }

        public float getY() {
            return y;
        }

        public void setY(float y) {
            this.y = y;
        }

        public String getDirection() {
            return direction;
        }

        public void setDirection(String direction) {
            this.direction = direction;
        }

        public boolean isMoving() {
            return isMoving;
        }

        public void setMoving(boolean moving) {
            isMoving = moving;
        }

        public boolean isWantsToRun() {
            return wantsToRun;
        }

        public void setWantsToRun(boolean wantsToRun) {
            this.wantsToRun = wantsToRun;
        }

        public List<String> getInventoryItems() {
            return inventoryItems;
        }

        public void setInventoryItems(List<String> inventoryItems) {
            this.inventoryItems = inventoryItems;
        }

        public List<String> getHotbarItems() {
            return hotbarItems;
        }

        public void setHotbarItems(List<String> hotbarItems) {
            this.hotbarItems = hotbarItems;
        }

        public boolean isDirty() {
            return isDirty;
        }

        public void setDirty(boolean dirty) {
            isDirty = dirty;
        }

        // Method to create a copy
        public PlayerDataV1 copy() {
            PlayerDataV1 copy = new PlayerDataV1();
            copy.username = this.username;
            copy.x = this.x;
            copy.y = this.y;
            copy.direction = this.direction;
            copy.isMoving = this.isMoving;
            copy.wantsToRun = this.wantsToRun;
            copy.inventoryItems = new ArrayList<>(this.inventoryItems);
            copy.hotbarItems = new ArrayList<>(this.hotbarItems);
            copy.isDirty = this.isDirty;
            return copy;
        }
    }

================
File: main/java/io/github/pokemeetup/pokemon/attacks/LearnableMove.java
================
package io.github.pokemeetup.pokemon.attacks;

import io.github.pokemeetup.pokemon.Pokemon;

public class LearnableMove {
    private String moveName;
    private int levelLearned;
    private boolean isStartingMove;
    private Pokemon.PokemonType moveType;
    private int power;
    private int accuracy;
    private int pp;
    private String description;

    public LearnableMove() {
        // Default constructor
    }

    // Getters and setters
    public String getMoveName() {
        return moveName;
    }

    public void setMoveName(String moveName) {
        this.moveName = moveName;
    }

    public int getLevelLearned() {
        return levelLearned;
    }

    public void setLevelLearned(int levelLearned) {
        this.levelLearned = levelLearned;
    }

    public boolean isStartingMove() {
        return isStartingMove;
    }

    public void setStartingMove(boolean startingMove) {
        isStartingMove = startingMove;
    }

    public Pokemon.PokemonType getMoveType() {
        return moveType;
    }

    public void setMoveType(Pokemon.PokemonType moveType) {
        this.moveType = moveType;
    }

    public int getPower() {
        return power;
    }

    public void setPower(int power) {
        this.power = power;
    }

    public int getAccuracy() {
        return accuracy;
    }

    public void setAccuracy(int accuracy) {
        this.accuracy = accuracy;
    }

    public int getPp() {
        return pp;
    }

    public void setPp(int pp) {
        this.pp = pp;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}

================
File: main/java/io/github/pokemeetup/pokemon/attacks/Move.java
================
package io.github.pokemeetup.pokemon.attacks;

import io.github.pokemeetup.pokemon.Pokemon;

import java.util.HashMap;
import java.util.Map;

public class Move {
    private String name;
    private Pokemon.PokemonType type;
    private int power;
    private int accuracy;
    private int pp;
    private int maxPp;

    public void setName(String name) {
        this.name = name;
    }

    public void setType(Pokemon.PokemonType type) {
        this.type = type;
    }

    public void setPower(int power) {
        this.power = power;
    }

    public void setAccuracy(int accuracy) {
        this.accuracy = accuracy;
    }

    public void setPp(int pp) {
        this.pp = pp;
    }

    public void setMaxPp(int maxPp) {
        this.maxPp = maxPp;
    }

    public void setSpecial(boolean special) {
        isSpecial = special;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public void setEffect(MoveEffect effect) {
        this.effect = effect;
    }

    public void setCanFlinch(boolean canFlinch) {
        this.canFlinch = canFlinch;
    }

    private boolean isSpecial;
    private String description;

    private MoveEffect effect;
    private boolean canFlinch;

    // Constructors, Getters, and Setters

    public Move() {
        // Default constructor
    }

    public String getName() {
        return name;
    }

    public Pokemon.PokemonType getType() {
        return type;
    }

    public int getPower() {
        return power;
    }

    public int getAccuracy() {
        return accuracy;
    }

    public int getPp() {
        return pp;
    }

    public int getMaxPp() {
        return maxPp;
    }

    public boolean isSpecial() {
        return isSpecial;
    }

    public String getDescription() {
        return description;
    }

    public MoveEffect getEffect() {
        return effect;
    }

    public boolean canFlinch() {
        return canFlinch;
    }

    public static class MoveEffect {
        private Pokemon.Status statusEffect;
        private Map<String, Integer> statModifiers;
        private String effectType;
        private float chance;
        private String animation;
        private String sound;
        private int duration;       // Added duration field

        public MoveEffect() {
            this.statModifiers = new HashMap<>();
        }
        public int getDuration() {
            return duration;
        }

        public void setDuration(int duration) {
            this.duration = duration;
        }


        // Getters and Setters

        public Pokemon.Status getStatusEffect() {
            return statusEffect;
        }

        public void setStatusEffect(Pokemon.Status statusEffect) {
            this.statusEffect = statusEffect;
        }

        public Map<String, Integer> getStatModifiers() {
            return statModifiers;
        }

        public void setStatModifiers(Map<String, Integer> statModifiers) {
            this.statModifiers = statModifiers;
        }

        public String getEffectType() {
            return effectType;
        }

        public void setEffectType(String effectType) {
            this.effectType = effectType;
        }

        public float getChance() {
            return chance;
        }

        public void setChance(float chance) {
            this.chance = chance;
        }

        public String getAnimation() {
            return animation;
        }

        public void setAnimation(String animation) {
            this.animation = animation;
        }

        public String getSound() {
            return sound;
        }

        public void setSound(String sound) {
            this.sound = sound;
        }
    }

    // Builder pattern for move creation
    public static class Builder {
        private final Move move;

        public Builder(String name, Pokemon.PokemonType type) {
            move = new Move();
            move.name = name;
            move.type = type;
        }

        public Builder power(int power) {
            move.power = power;
            return this;
        }

        public Builder accuracy(int accuracy) {
            move.accuracy = accuracy;
            return this;
        }

        public Builder pp(int pp) {
            move.pp = pp;
            move.maxPp = pp;
            return this;
        }

        public Builder special(boolean isSpecial) {
            move.isSpecial = isSpecial;
            return this;
        }

        public Builder description(String description) {
            move.description = description;
            return this;
        }

        public Builder effect(MoveEffect effect) {
            move.effect = effect;
            return this;
        }

        public Builder canFlinch(boolean canFlinch) {
            move.canFlinch = canFlinch;
            return this;
        }

        public Move build() {
            return move;
        }
    }
}

================
File: main/java/io/github/pokemeetup/pokemon/attacks/MoveLoader.java
================
package io.github.pokemeetup.pokemon.attacks;

import com.google.gson.*;
import io.github.pokemeetup.pokemon.Pokemon;

import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.*;

public class MoveLoader {
    public static Map<String, Move> loadMovesFromJson(String jsonContent) {
        Gson gson = new GsonBuilder().create();
        Map<String, Move> moves = new HashMap<>();

        try {
            // Parse the JSON string
            JsonObject jsonObject = JsonParser.parseString(jsonContent).getAsJsonObject();

            // Get the "moves" object
            JsonObject movesJson = jsonObject.getAsJsonObject("moves");

            // Iterate over each move
            for (Map.Entry<String, JsonElement> entry : movesJson.entrySet()) {
                String moveName = entry.getKey();
                JsonObject moveJson = entry.getValue().getAsJsonObject();

                Move move = parseMove(moveName, moveJson);
                moves.put(moveName, move);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse moves JSON: " + e.getMessage());
        }

        return moves;
    }
    public static Map<String, Move> loadMoves(String jsonFilePath) throws IOException {
        Gson gson = new GsonBuilder().create();
        Map<String, Move> moves = new HashMap<>();

        // Read the JSON file
        JsonObject jsonObject;
        try (FileReader reader = new FileReader(jsonFilePath)) {
            jsonObject = JsonParser.parseReader(reader).getAsJsonObject();
        }

        // Get the "moves" object
        JsonObject movesJson = jsonObject.getAsJsonObject("moves");

        // Iterate over each move
        for (Map.Entry<String, JsonElement> entry : movesJson.entrySet()) {
            String moveName = entry.getKey();
            JsonObject moveJson = entry.getValue().getAsJsonObject();

            Move move = parseMove(moveName, moveJson);
            moves.put(moveName, move);
        }

        return moves;
    }

    private static Move parseMove(String moveName, JsonObject moveJson) {
        // Extract basic fields
        String typeStr = moveJson.get("type").getAsString();
        int power = moveJson.get("power").getAsInt();
        int accuracy = moveJson.get("accuracy").getAsInt();
        int pp = moveJson.get("pp").getAsInt();
        boolean isSpecial = moveJson.get("isSpecial").getAsBoolean();
        String description = moveJson.get("description").getAsString();

        // Convert type string to enum
        Pokemon.PokemonType type = Pokemon.PokemonType.valueOf(typeStr);

        // Initialize the builder
        Move.Builder builder = new Move.Builder(moveName, type)
            .power(power)
            .accuracy(accuracy)
            .pp(pp)
            .special(isSpecial)
            .description(description);

        // Parse effects if present
        if (moveJson.has("effects")) {
            JsonObject effectsJson = moveJson.getAsJsonObject("effects");
            Move.MoveEffect effect = parseMoveEffect(effectsJson);
            builder.effect(effect);
        }

        return builder.build();
    }

    private static Move.MoveEffect parseMoveEffect(JsonObject effectsJson) {
        Move.MoveEffect effect = new Move.MoveEffect();

        // Set effect type
        if (effectsJson.has("type")) {
            effect.setEffectType(effectsJson.get("type").getAsString());
        }

        // Set chance
        if (effectsJson.has("chance")) {
            effect.setChance(effectsJson.get("chance").getAsFloat());
        } else {
            effect.setChance(1.0f);  // Default chance
        }

        // Set status effect
        if (effectsJson.has("status")) {
            String statusStr = effectsJson.get("status").getAsString();
            Pokemon.Status status = Pokemon.Status.valueOf(statusStr);
            effect.setStatusEffect(status);
        }

        // Set stat modifiers
        if (effectsJson.has("statChanges")) {
            JsonObject statChangesJson = effectsJson.getAsJsonObject("statChanges");
            Map<String, Integer> statModifiers = new HashMap<>();
            for (Map.Entry<String, JsonElement> statEntry : statChangesJson.entrySet()) {
                String stat = statEntry.getKey();
                int change = statEntry.getValue().getAsInt();
                statModifiers.put(stat, change);
            }
            effect.setStatModifiers(statModifiers);
        }

        // Set animation and sound
        if (effectsJson.has("animation")) {
            effect.setAnimation(effectsJson.get("animation").getAsString());
        }
        if (effectsJson.has("sound")) {
            effect.setSound(effectsJson.get("sound").getAsString());
        }

        return effect;
    }
}

================
File: main/java/io/github/pokemeetup/pokemon/data/PokemonDatabase.java
================
package io.github.pokemeetup.pokemon.data;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.utils.JsonReader;
import com.badlogic.gdx.utils.JsonValue;
import com.google.gson.Gson;
import io.github.pokemeetup.FileSystemDelegate;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.pokemon.attacks.MoveLoader;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.GameFileSystem;

import java.io.IOException;
import java.util.*;

public class PokemonDatabase {
    private static final String POKEMON_DATA_FILE = "Data/pokemon.json";  // Capital D
    private static final String MOVE_DATA_FILE = "Data/moves.json";      // Capital D
    private static final Map<String, PokemonTemplate> pokemonTemplates = new HashMap<>();
    private static final Map<String, BaseStats> pokemonStats = new HashMap<>();
    private static boolean isInitialized = false;

    // Map to store all moves loaded from moves.json
    private static Map<String, Move> allMoves = new HashMap<>();

    public static PokemonTemplate getTemplate(String name) {
        if (!isInitialized) {
            initialize();
        }
        return pokemonTemplates.get(name);
    }


        public static void initialize() {
            if (isInitialized) {
                return;
            }

            try {
                GameLogger.info("Initializing Pokemon Database...");
                FileSystemDelegate delegate = GameFileSystem.getInstance().getDelegate();

                // First load moves
                try {
                    String movesJson = delegate.readString(MOVE_DATA_FILE);
                    GameLogger.info("Loaded moves.json content (length: " + movesJson.length() + ")");

                    // Load moves using updated MoveLoader
                    allMoves.putAll(MoveLoader.loadMovesFromJson(movesJson));
                    GameLogger.info("Successfully loaded " + allMoves.size() + " moves");

                    // Log first few moves for verification
                    int count = 0;
                    for (Map.Entry<String, Move> entry : allMoves.entrySet()) {
                        if (count++ < 3) {
                            GameLogger.info("Loaded move: " + entry.getKey() + " (" +
                                entry.getValue().getType() + ", Power: " +
                                entry.getValue().getPower() + ")");
                        }
                    }
                } catch (Exception e) {
                    GameLogger.error("Failed to load moves: " + e.getMessage());
                    throw e;
                }

                // Then load Pokemon data
                try {
                    String pokemonJson = delegate.readString(POKEMON_DATA_FILE);
                    GameLogger.info("Loaded pokemon.json content (length: " + pokemonJson.length() + ")");

                    JsonReader reader = new JsonReader();
                    JsonValue root = reader.parse(pokemonJson);
                    JsonValue pokemonArray = root.get("pokemon");

                    if (pokemonArray == null) {
                        throw new RuntimeException("Invalid pokemon.json format - missing 'pokemon' array");
                    }

                    int pokemonCount = 0;
                    for (JsonValue pokemonValue = pokemonArray.child;
                         pokemonValue != null;
                         pokemonValue = pokemonValue.next) {
                        try {
                            String name = pokemonValue.getString("name");
                            if (name == null || name.isEmpty()) {
                                continue;
                            }

                            Pokemon.PokemonType primaryType = Pokemon.PokemonType.valueOf(
                                pokemonValue.getString("primaryType").toUpperCase());
                            Pokemon.PokemonType secondaryType = getSecondaryType(pokemonValue);
                            List<MoveEntry> moves = loadPokemonMoves(pokemonValue.get("moves"));

                            BaseStats stats = new BaseStats(
                                name,
                                pokemonValue.getInt("baseHp"),
                                pokemonValue.getInt("baseAttack"),
                                pokemonValue.getInt("baseDefense"),
                                pokemonValue.getInt("baseSpAtk"),
                                pokemonValue.getInt("baseSpDef"),
                                pokemonValue.getInt("baseSpeed"),
                                primaryType,
                                secondaryType,
                                moves
                            );
                            pokemonStats.put(name, stats);

                            // Create template
                            PokemonTemplate template = new PokemonTemplate();
                            template.name = name;
                            template.primaryType = primaryType;
                            template.secondaryType = secondaryType;
                            template.baseStats = stats;
                            template.moves = moves;
                            template.width = pokemonValue.getFloat("width", 1.0f);
                            template.height = pokemonValue.getFloat("height", 1.0f);

                            pokemonTemplates.put(name, template);
                            pokemonCount++;

                            // Log first few Pokemon for verification
                            if (pokemonCount <= 3) {
                                GameLogger.info("Loaded Pokemon: " + name + " (" +
                                    primaryType + (secondaryType != null ? "/" + secondaryType : "") +
                                    ") with " + moves.size() + " moves");
                            }

                        } catch (Exception e) {
                            GameLogger.error("Error loading Pokemon entry: " + e.getMessage());
                        }
                    }

                    GameLogger.info("Successfully loaded " + pokemonCount + " Pokemon");
                    isInitialized = true;

                } catch (Exception e) {
                    GameLogger.error("Failed to load Pokemon data: " + e.getMessage());
                    throw e;
                }

            } catch (Exception e) {
                GameLogger.error("Pokemon database initialization failed: " + e.getMessage());
                e.printStackTrace();
                throw new RuntimeException("Failed to initialize Pokemon database", e);
            }
        }
    public static BaseStats getStats(String name) {
        if (!isInitialized) {
            initialize();
        }

        BaseStats stats = pokemonStats.get(name);
        if (stats == null) {
            GameLogger.error("No stats found for Pokemon: " + name);
            // Return default stats to prevent null pointer exceptions
            return new BaseStats(
                name,
                45,  // Default HP
                45,  // Default Attack
                45,  // Default Defense
                45,  // Default Sp. Attack
                45,  // Default Sp. Defense
                45,  // Default Speed
                Pokemon.PokemonType.NORMAL,  // Default primary type
                null,  // No secondary type
                new ArrayList<>()  // Empty moves list
            );
        }
        return stats;
    }

    private static List<MoveEntry> loadPokemonMoves(JsonValue movesArray) {
        List<MoveEntry> moves = new ArrayList<>();
        if (movesArray != null && movesArray.isArray()) {
            for (JsonValue moveValue = movesArray.child; moveValue != null; moveValue = moveValue.next) {
                try {
                    String moveName = moveValue.getString("name");
                    int level = moveValue.getInt("level");
                    moves.add(new MoveEntry(moveName, level));
                } catch (Exception e) {
                    GameLogger.error("Error loading move: " + e.getMessage());
                }
            }
        }
        return moves;
    }

    private static Pokemon.PokemonType getSecondaryType(JsonValue pokemonValue) {
        try {
            // Check if secondaryType exists and is not empty/null
            if (pokemonValue.has("secondaryType")) {
                String secondaryType = pokemonValue.getString("secondaryType", "").trim();
                if (!secondaryType.isEmpty()) {
                    return Pokemon.PokemonType.valueOf(secondaryType.toUpperCase());
                }
            }
        } catch (Exception e) {
            GameLogger.info("No secondary type for Pokemon: " + pokemonValue.getString("name", "unknown"));
        }
        return null;
    }
    public static Pokemon createPokemon(String name, int level) {
        if (!isInitialized) {
            initialize();
        }

        PokemonTemplate template = pokemonTemplates.get(name);
        if (template == null) {
            GameLogger.error("Pokemon template not found: " + name);
            return null;
        }

        try {
            Pokemon.Builder builder = new Pokemon.Builder(name, level)
                .withType(template.primaryType, template.secondaryType);

            // Calculate stats based on level and base stats
            int hp = calculateStat(template.baseStats.baseHp, level, true);
            int attack = calculateStat(template.baseStats.baseAttack, level, false);
            int defense = calculateStat(template.baseStats.baseDefense, level, false);
            int spAtk = calculateStat(template.baseStats.baseSpAtk, level, false);
            int spDef = calculateStat(template.baseStats.baseSpDef, level, false);
            int speed = calculateStat(template.baseStats.baseSpeed, level, false);

            builder.withStats(hp, attack, defense, spAtk, spDef, speed);

            // Assign moves based on level
            List<Move> startingMoves = getMovesForLevel(template.moves, level);
            builder.withMoves(startingMoves);

            return builder.build();

        } catch (Exception e) {
            GameLogger.error("Error creating Pokemon: " + e.getMessage());
            return null;
        }
    }
    public static List<Move> getMovesForLevel(List<MoveEntry> moveEntries, int level) {
        List<Move> moves = new ArrayList<>();

        try {
            // Create case-insensitive map of moves
            Map<String, Move> moveMap = new HashMap<>();
            for (Map.Entry<String, Move> entry : allMoves.entrySet()) {
                moveMap.put(entry.getKey().toLowerCase(), entry.getValue());
            }

            // Filter moves learned at or before given level
            List<MoveEntry> learnedMoves = new ArrayList<>();
            for (MoveEntry entry : moveEntries) {
                if (entry.level <= level) {
                    learnedMoves.add(entry);
                }
            }

            // Sort by level ascending
            learnedMoves.sort(Comparator.comparingInt(e -> e.level));

            // Get most recent 4 moves
            int movesToAdd = Math.min(learnedMoves.size(), 4);
            for (int i = learnedMoves.size() - movesToAdd; i < learnedMoves.size(); i++) {
                MoveEntry moveEntry = learnedMoves.get(i);
                String moveName = moveEntry.name.toLowerCase(); // Convert to lowercase for comparison

                Move move = moveMap.get(moveName);
                if (move != null) {
                    moves.add(cloneMove(move));
                    GameLogger.info("Added move: " + moveEntry.name + " (Level " + moveEntry.level + ")");
                } else {
                    // Log available moves when not found
                    GameLogger.error("Move not found: " + moveEntry.name);
                    GameLogger.error("Available moves: " + String.join(", ", moveMap.keySet()));
                }
            }

        } catch (Exception e) {
            GameLogger.error("Error loading moves: " + e.getMessage());
            e.printStackTrace();
        }

        return moves;
    }
    public static Move cloneMove(Move move) {
        // Clone the MoveEffect if present
        Move.MoveEffect clonedEffect = null;
        if (move.getEffect() != null) {
            clonedEffect = cloneMoveEffect(move.getEffect());
        }

        return new Move.Builder(move.getName(), move.getType())
            .power(move.getPower())
            .accuracy(move.getAccuracy())
            .pp(move.getPp())
            .special(move.isSpecial())
            .description(move.getDescription())
            .effect(clonedEffect)
            .build();
    }

    private static Move.MoveEffect cloneMoveEffect(Move.MoveEffect effect) {
        Move.MoveEffect clonedEffect = new Move.MoveEffect();
        clonedEffect.setEffectType(effect.getEffectType());
        clonedEffect.setChance(effect.getChance());
        clonedEffect.setAnimation(effect.getAnimation());
        clonedEffect.setSound(effect.getSound());
        clonedEffect.setStatusEffect(effect.getStatusEffect());
        clonedEffect.setDuration(effect.getDuration());
        clonedEffect.setStatModifiers(new HashMap<>(effect.getStatModifiers()));
        return clonedEffect;
    }


    public static Move getMoveByName(String moveName) {
        return allMoves.get(moveName);
    }

    private static int calculateStat(int base, int level, boolean isHp) {
        int iv = 15; // Using a default IV for simplicity
        int ev = 0;  // Starting with 0 EVs

        if (isHp) {
            return ((2 * base + iv + (ev / 4)) * level / 100) + level + 10;
        } else {
            return ((2 * base + iv + (ev / 4)) * level / 100) + 5;
        }
    }

    public static class MoveEntry {
        public final String name;
        public final int level;

        public MoveEntry(String name, int level) {
            this.name = name;
            this.level = level;
        }
    }

    public static class PokemonTemplate {
        public Pokemon.PokemonType primaryType;
        public Pokemon.PokemonType secondaryType;
        public BaseStats baseStats;
        public List<MoveEntry> moves; // List of moves with levels
        String name;
        float width;
        float height;
    }

    public static class BaseStats {
        public final String name;
        public final int baseHp;
        public final int baseAttack;
        public final int baseDefense;
        public final int baseSpAtk;
        public final int baseSpDef;
        public final int baseSpeed;
        public final Pokemon.PokemonType primaryType;
        public final Pokemon.PokemonType secondaryType; // Can be null
        public final List<MoveEntry> moves; // List of moves with levels

        public BaseStats(String name, int baseHp, int baseAttack, int baseDefense,
                         int baseSpAtk, int baseSpDef, int baseSpeed,
                         Pokemon.PokemonType primaryType, Pokemon.PokemonType secondaryType,
                         List<MoveEntry> moves) {
            this.name = name;
            this.baseHp = baseHp;
            this.baseAttack = baseAttack;
            this.baseDefense = baseDefense;
            this.baseSpAtk = baseSpAtk;
            this.baseSpDef = baseSpDef;
            this.baseSpeed = baseSpeed;
            this.primaryType = primaryType;
            this.secondaryType = secondaryType;
            this.moves = moves != null ? moves : new ArrayList<>();
        }
    }

}

================
File: main/java/io/github/pokemeetup/pokemon/Pokemon.java
================
package io.github.pokemeetup.pokemon;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.pokemon.data.PokemonDatabase;
import io.github.pokemeetup.system.battle.BattleCompletionHandler;
import io.github.pokemeetup.system.gameplay.PokemonAnimations;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.UUID;

public class Pokemon {
    private static final int BASE_EXP_REQUIREMENT = 100; // Base exp needed for level 2
    private static Weather currentWeather = Weather.CLEAR;
    private static int weatherTurns = 0;
    public String name;
    private Status status = Status.NONE;
    private int sleepTurns = 0;
    private int toxicCounter = 1;
    private boolean flinched = false;
    private int confusedTurns = 0;
    private boolean canMove = true;
    public int level;
    private String nature;
    private boolean isShiny;
    private UUID uuid;
    private int baseExperience;
    private int currentExperience;
    private int experienceToNextLevel;
    private BattleCompletionHandler completionHandler;
    private boolean battleWon;
    public Stats stats;
    public List<Move> moves;
    public PokemonType primaryType;
    public PokemonType secondaryType;
    public float currentHp;
    private TextureRegion iconSprite;

    public int getCurrentExperience() {
        return currentExperience;
    }

    private TextureRegion frontSprite;
    private TextureRegion backSprite;
    private TextureRegion frontShinySprite;
    private TextureRegion backShinySprite;
    private PokemonAnimations animations;
    private Vector2 position;
    private String direction;
    private boolean isMoving;
    private TextureRegion[] iconFrames; // Array to hold both frames
    private int currentIconFrame;       // Index to track the current frame
    private float frameDuration = 0.5f; // Duration each frame is shown in seconds
    private float frameTimer = 0;
    public Pokemon(String name, int level) {
        this.uuid = UUID.randomUUID();
        this.name = name;
        this.level = level;
        this.nature = generateNature();
        this.isShiny = calculateShinyStatus();
        this.stats = new Stats();
        TextureRegion iconSheet = TextureManager.getPokemonicon().findRegion(name.toUpperCase() + "_icon");
        this.moves = new ArrayList<>();
        iconFrames = new TextureRegion[2];
        iconFrames[0] = new TextureRegion(iconSheet, 0, 0, iconSheet.getRegionWidth() / 2, iconSheet.getRegionHeight());
        iconFrames[1] = new TextureRegion(iconSheet, iconSheet.getRegionWidth() / 2, 0, iconSheet.getRegionWidth() / 2, iconSheet.getRegionHeight());

        this.position = new Vector2();
        this.direction = "down";
        this.isMoving = false;
        this.currentHp = stats.getHp();
        loadIcons(TextureManager.getPokemonicon());
        loadFront(TextureManager.getPokemonfront());
        loadBack(TextureManager.getPokemonback());
        loadOverworld(TextureManager.getPokemonoverworld());
    }

    public void heal() {
        this.currentHp = this.stats.getHp();
        this.status = Status.NONE;
        this.toxicCounter = 1;
        this.flinched = false;
        this.confusedTurns = 0;
    }
    public static void applyWeatherEffects(Pokemon pokemon) {
        if (weatherTurns > 0) {
            switch (currentWeather) {
                case SANDSTORM:
                    if (pokemon.primaryType != PokemonType.ROCK &&
                        pokemon.primaryType != PokemonType.GROUND &&
                        pokemon.primaryType != PokemonType.STEEL) {
                        pokemon.currentHp -= pokemon.stats.getHp() / 16;
                    }
                    break;

                case HAIL:
                    if (pokemon.primaryType != PokemonType.ICE) {
                        pokemon.currentHp -= pokemon.stats.getHp() / 16;
                    }
                    break;
            }
            weatherTurns--;
            if (weatherTurns <= 0) {
                currentWeather = Weather.CLEAR;
            }
        }
    }

    public boolean hasStatus() {
        return status != Status.NONE;
    }

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status newStatus) {
        // Some types are immune to certain statuses
        if (newStatus == Status.PARALYZED &&
            (primaryType == PokemonType.ELECTRIC || secondaryType == PokemonType.ELECTRIC)) {
            return;
        }
        if (newStatus == Status.POISONED &&
            (primaryType == PokemonType.POISON || secondaryType == PokemonType.POISON ||
                primaryType == PokemonType.STEEL || secondaryType == PokemonType.STEEL)) {
            return;
        }
        if (newStatus == Status.BURNED &&
            (primaryType == PokemonType.FIRE || secondaryType == PokemonType.FIRE)) {
            return;
        }
        if (newStatus == Status.FROZEN &&
            (primaryType == PokemonType.ICE || secondaryType == PokemonType.ICE)) {
            return;
        }

        this.status = newStatus;

        // Initialize status-specific counters
        switch (newStatus) {
            case ASLEEP:
                sleepTurns = new Random().nextInt(3) + 2; // Sleep lasts 2-4 turns
                break;
            case BADLY_POISONED:
                toxicCounter = 1;
                break;
            default:
                break;
        }
    }

    public void cureStatus() {
        this.status = Status.NONE;
        this.sleepTurns = 0;
        this.toxicCounter = 1;
        this.flinched = false;
        this.confusedTurns = 0;
        this.canMove = true;
    }

    public boolean canAttack() {
        if (currentHp <= 0) {
            return false;
        }

        if (flinched) {
            flinched = false; // Reset flinch
            return false;
        }

        // Handle confusion
        if (confusedTurns > 0) {
            confusedTurns--;
            if (new Random().nextFloat() < 0.33f) { // 33% chance to hurt itself
                float damage = calculateStat(40, 0, 0); // Base power of confusion self-hit
                currentHp = Math.max(0, currentHp - damage);
                return false;
            }
        }

        // Handle status effects
        switch (status) {
            case PARALYZED:
                if (new Random().nextFloat() < 0.25f) { // 25% chance to be fully paralyzed
                    return false;
                }
                break;

            case FROZEN:
                if (new Random().nextFloat() < 0.20f) { // 20% chance to thaw each turn
                    status = Status.NONE;
                    return true;
                }
                return false;

            case ASLEEP:
                sleepTurns--;
                if (sleepTurns <= 0) {
                    status = Status.NONE;
                    return true;
                }
                return false;

            default:
                break;
        }

        return true;
    }

    public void applyEndOfTurnEffects() {
        switch (status) {
            case POISONED:
                currentHp = Math.max(0, currentHp - (stats.getHp() / 8));
                break;

            case BADLY_POISONED:
                currentHp = Math.max(0, currentHp - ((stats.getHp() * toxicCounter) / 16));
                toxicCounter = Math.min(toxicCounter + 1, 15);
                break;

            case BURNED:
                currentHp = Math.max(0, currentHp - (stats.getHp() / 16));
                break;
        }

        if (currentHp <= 0) {
            status = Status.FAINTED;
        }
    }

    public float getStatusModifier(Move move) {
        if (status == Status.BURNED && !move.isSpecial()) {
            return 0.5f; // Burn halves physical attack
        }
        if (status == Status.PARALYZED) {
            return 0.5f; // Paralysis halves speed (implement in speed calculations)
        }
        return 1.0f;
    }

    // Add to Builder class


    private void checkLevelUp() {
        int currentLevel = level;
        int expNeeded = getExperienceForNextLevel();

        while (currentExperience >= expNeeded) {
            levelUp();
            GameLogger.info(String.format("%s gained %d experience points!",
                getName(), currentExperience - expNeeded));

            // Update experience for next level check
            currentExperience -= expNeeded;
            expNeeded = getExperienceForNextLevel();
        }
    }
    public void addExperience(int exp) {
        currentExperience += exp;
        checkLevelUp();
    }

    // Add these methods
    public int getBaseExperience() {
        // Base experience varies by Pokemon
        switch (name.toUpperCase()) {
            case "CHARMANDER":
            case "BULBASAUR":
            case "SQUIRTLE":
                return 64;
            case "PIDGEY":
            case "RATTATA":
                return 50;
            case "PIKACHU":
                return 112;
            default:
                return 60;
        }
    }

    public TextureRegion getCurrentIconFrame(float delta) {
        // Update the timer
        frameTimer += delta;
        if (frameTimer >= frameDuration) {
            frameTimer = 0;
            currentIconFrame = (currentIconFrame + 1) % iconFrames.length; // Toggle between frames
        }
        return iconFrames[currentIconFrame];
    }

    private void loadIcons(TextureAtlas atlas) {
        String baseName = name.toUpperCase();
//        GameLogger.info("Loading sprites for: " + baseName);
        // Load battle and icon sprites
        iconSprite = atlas.findRegion(baseName + "_icon");
        // Load overworld sprite sheet
    }

    private void loadOverworld(TextureAtlas atlas) {
        String baseName = name.toUpperCase();
        TextureRegion overworldSheet = atlas.findRegion(baseName + "_overworld");
        if (overworldSheet != null) {
            animations = new PokemonAnimations(overworldSheet);
        } else {
            GameLogger.error("Failed to load overworld sprite sheet for: " + name);
        }
    }
    private void levelUp() {
        level++;
        GameLogger.info(getName() + " leveled up to " + level + "!");

        // Save old stats for comparison
        int oldHp = stats.getHp();
        int oldAttack = stats.getAttack();
        int oldDefense = stats.getDefense();
        int oldSpAtk = stats.getSpecialAttack();
        int oldSpDef = stats.getSpecialDefense();
        int oldSpeed = stats.getSpeed();

        // Recalculate stats
        calculateStats();

        // Show stat increases
        showStatIncrease("HP", oldHp, stats.getHp());
        showStatIncrease("Attack", oldAttack, stats.getAttack());
        showStatIncrease("Defense", oldDefense, stats.getDefense());
        showStatIncrease("Sp. Atk", oldSpAtk, stats.getSpecialAttack());
        showStatIncrease("Sp. Def", oldSpDef, stats.getSpecialDefense());
        showStatIncrease("Speed", oldSpeed, stats.getSpeed());

        // Heal Pokemon on level up (optional)
        currentHp = stats.getHp();

        // Check for new moves
        learnNewMovesAtLevel(level);
    }private void showStatIncrease(String statName, int oldValue, int newValue) {
        int increase = newValue - oldValue;
        if (increase > 0) {
            GameLogger.info(getName() + "'s " + statName + " increased by " + increase + "!");
        }
    }

    private void learnNewMovesAtLevel(int level) {
        // Get the list of move entries from the PokemonDatabase
        List<PokemonDatabase.MoveEntry> moveEntries = PokemonDatabase.getTemplate(name).moves;
        for (PokemonDatabase.MoveEntry entry : moveEntries) {
            if (entry.level == level) {
                // Learn the new move
                Move newMove = PokemonDatabase.getMoveByName(entry.name);
                if (newMove != null) {
                    // Clone the move
                    Move clonedMove = PokemonDatabase.cloneMove(newMove);
                    // If already have 4 moves, replace the oldest one or prompt the player
                    if (moves.size() < 4) {
                        moves.add(clonedMove);
                    } else {
                        // Replace the first move (you can implement move replacement logic as needed)
                        moves.remove(0);
                        moves.add(clonedMove);
                    }
                    GameLogger.info(name + " learned " + entry.name + "!");
                }
            }
        }
    }


    private void loadFront(TextureAtlas atlas) {
        String baseName = name.toUpperCase();
        // Load battle and icon sprites
        frontSprite = atlas.findRegion(baseName + "_front");
        frontShinySprite = atlas.findRegion(baseName + "_front_shiny");
        // Load overworld sprite sheet

    }

    private void loadBack(TextureAtlas atlas) {
        String baseName = name.toUpperCase();
        // Load battle and icon sprites
        backSprite = atlas.findRegion(baseName + "_back");
        backShinySprite = atlas.findRegion(baseName + "_back_shiny");

    }

    public void update(float delta) {
        if (animations != null) {
            animations.update(delta);
        }
    }

    public TextureRegion getIconSprite() {
        return iconSprite;
    }

    public void setIconSprite(TextureRegion iconSprite) {
        this.iconSprite = iconSprite;
    }

    public TextureRegion getFrontSprite() {
        return frontSprite;
    }

    public void setFrontSprite(TextureRegion frontSprite) {
        this.frontSprite = frontSprite;
    }

    public TextureRegion getBackSprite() {
        return backSprite;
    }

    public void setBackSprite(TextureRegion backSprite) {
        this.backSprite = backSprite;
    }

    public TextureRegion getFrontShinySprite() {
        return frontShinySprite;
    }

    public void setFrontShinySprite(TextureRegion frontShinySprite) {
        this.frontShinySprite = frontShinySprite;
    }

    public TextureRegion getBackShinySprite() {
        return backShinySprite;
    }

    public void setBackShinySprite(TextureRegion backShinySprite) {
        this.backShinySprite = backShinySprite;
    }

    public Vector2 getPosition() {
        return position;
    }

    public void setPosition(Vector2 position) {
        this.position = position;
    }

    public String getDirection() {
        return direction;
    }

    public void setDirection(String direction) {
        this.direction = direction;
    }

    public boolean isMoving() {
        return isMoving;
    }

    public void setMoving(boolean moving) {
        isMoving = moving;
    }

    public void render(SpriteBatch batch) {
        if (animations != null) {
            TextureRegion currentFrame = animations.getCurrentFrame(direction, isMoving, Gdx.graphics.getDeltaTime());
            batch.draw(currentFrame, position.x, position.y);
//            GameLogger.info("Rendering Pokémon: " + name + " at position: " + position);
        }
    }

    private String generateNature() {
        String[] natures = {"Hardy", "Lonely", "Brave", "Adamant", "Naughty", "Bold", "Docile",
            "Relaxed", "Impish", "Lax", "Timid", "Hasty", "Serious", "Jolly",
            "Naive", "Modest", "Mild", "Quiet", "Bashful", "Rash", "Calm",
            "Gentle", "Sassy", "Careful", "Quirky"};
        return natures[new Random().nextInt(natures.length)];
    }

    private boolean calculateShinyStatus() {
        return new Random().nextInt(4096) == 0; // 1/4096 chance in modern games
    }

    // Getters and setters
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getLevel() {
        return level;
    }

    public void setLevel(int level) {
        this.level = level;
    }

    public String getNature() {
        return nature;
    }

    public void setNature(String nature) {
        this.nature = nature;
    }

    public boolean isShiny() {
        return isShiny;
    }

    public void setShiny(boolean shiny) {
        isShiny = shiny;
    }

    public UUID getUuid() {
        return uuid;
    }

    public void setUuid(UUID uuid) {
        this.uuid = uuid;
    }

    public Stats getStats() {
        return stats;
    }

    public void setStats(Stats stats) {
        this.stats = stats;
    }

    public List<Move> getMoves() {
        return moves;
    }

    public void setMoves(List<Move> moves) {
        this.moves = moves;
    }

    public PokemonType getPrimaryType() {
        return primaryType;
    }

    public void setPrimaryType(PokemonType type) {
        this.primaryType = type;
    }

    public PokemonType getSecondaryType() {
        return secondaryType;
    }

    public void setSecondaryType(PokemonType type) {
        this.secondaryType = type;
    }

    public int getCurrentHp() {
        return (int) currentHp;
    }

    public void setCurrentHp(float hp) {
        this.currentHp = hp;
    }

    public PokemonAnimations getAnimations() {
        return animations;
    }

    public int getToxicCounter() {
        return toxicCounter;
    }

    public void incrementToxicCounter() {
        toxicCounter = Math.min(toxicCounter + 1, 15); // Cap at 15
    }

    public void resetToxicCounter() {
        toxicCounter = 1;
    }

    public void setAnimations(PokemonAnimations animations) {
        this.animations = animations;
    }


    public int getExperienceForNextLevel() {
        // Using a modified cubic growth formula for smoother progression
        return (int)(BASE_EXP_REQUIREMENT * Math.pow(level, 2.5) / 5);
    }

    private int calculateStat(int base, int iv, int ev) {
        // Apply nature modifier (random 10% variance)
        float natureModifier = 1.0f + (new Random().nextFloat() * 0.2f - 0.1f);

        // Standard Pokemon stat formula with nature consideration
        return (int)(((2 * base + iv + ev / 4) * level / 100f + 5) * natureModifier);
    }
    void calculateStats() {
        // Base stats - these should vary by Pokemon species
        int baseHp = 45;
        int baseAtk = 49;
        int baseDef = 49;
        int baseSpAtk = 65;
        int baseSpDef = 65;
        int baseSpd = 45;

        // Calculate new stats using Pokemon formula
        stats.setHp(((2 * baseHp + stats.ivs[0] + stats.evs[0] / 4) * level / 100) + level + 10);
        stats.setAttack(calculateStat(baseAtk, stats.ivs[1], stats.evs[1]));
        stats.setDefense(calculateStat(baseDef, stats.ivs[2], stats.evs[2]));
        stats.setSpecialAttack(calculateStat(baseSpAtk, stats.ivs[3], stats.evs[3]));
        stats.setSpecialDefense(calculateStat(baseSpDef, stats.ivs[4], stats.evs[4]));
        stats.setSpeed(calculateStat(baseSpd, stats.ivs[5], stats.evs[5]));
        if (status == Status.PARALYZED) {
            stats.setSpeed(stats.getSpeed() / 2); // Paralysis halves speed
        }
    }

    public enum Status {
        NONE,
        PARALYZED,
        POISONED,
        BADLY_POISONED,
        BURNED,
        FROZEN,
        ASLEEP,
        FAINTED
    }

    // Add weather effect handling (can be expanded later)
    public enum Weather {
        CLEAR,
        RAIN,
        SUNNY,
        SANDSTORM,
        HAIL
    }

    public enum PokemonType {
        NORMAL, FIRE, WATER, ELECTRIC, GRASS, ICE, FIGHTING, POISON, GROUND, FLYING,
        PSYCHIC, BUG, ROCK, GHOST, DRAGON, DARK, STEEL, FAIRY,UNKNOWN
    }

    public static class Stats {
        public int[] ivs;
        public int[] evs;
        private int hp;
        private int attack;
        private int defense;
        private int specialAttack;
        private int specialDefense;
        private int speed;

        public Stats() {
            this.ivs = generateIVs();
            this.evs = new int[6];
        }

        private int[] generateIVs() {
            int[] ivs = new int[6];
            Random random = new Random();
            for (int i = 0; i < 6; i++) {
                ivs[i] = random.nextInt(32);
            }
            return ivs;
        }

        // Getters and setters
        public int getHp() {
            return hp;
        }

        public void setHp(int hp) {
            this.hp = hp;
        }

        public int getAttack() {
            return attack;
        }

        public void setAttack(int attack) {
            this.attack = attack;
        }

        public int getDefense() {
            return defense;
        }

        public void setDefense(int defense) {
            this.defense = defense;
        }

        public int getSpecialAttack() {
            return specialAttack;
        }

        public void setSpecialAttack(int specialAttack) {
            this.specialAttack = specialAttack;
        }

        public int getSpecialDefense() {
            return specialDefense;
        }

        public void setSpecialDefense(int specialDefense) {
            this.specialDefense = specialDefense;
        }

        public int getSpeed() {
            return speed;
        }

        public void setSpeed(int speed) {
            this.speed = speed;
        }
    }

    public static class Builder {
        private Pokemon pokemon;

        public Builder(String name, int level) {
            pokemon = new Pokemon(name, level);
        }

        public Builder withType(PokemonType primary, PokemonType secondary) {
            pokemon.setPrimaryType(primary);
            pokemon.setSecondaryType(secondary);
            return this;
        }

        public Builder withStats(int hp, int attack, int defense, int spAtk, int spDef, int speed) {
            pokemon.getStats().setHp(hp);
            pokemon.getStats().setAttack(attack);
            pokemon.getStats().setDefense(defense);
            pokemon.getStats().setSpecialAttack(spAtk);
            pokemon.getStats().setSpecialDefense(spDef);
            pokemon.getStats().setSpeed(speed);
            pokemon.setCurrentHp(hp);
            return this;
        }

        public Builder withMoves(List<Move> moves) {
            pokemon.setMoves(new ArrayList<>(moves));
            return this;
        }public Builder withStatus(Status status) {
            pokemon.setStatus(status);
            return this;
        }

        public Pokemon build() {
            if (pokemon.getMoves().isEmpty()) {
            }
            return pokemon;
        }
    }
}

================
File: main/java/io/github/pokemeetup/pokemon/PokemonDespawnAnimation.java
================
package io.github.pokemeetup.pokemon;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class PokemonDespawnAnimation {
    private static final float DESPAWN_DURATION = 1.0f; // Total animation time in seconds
    private static final float SPARKLE_DURATION = 0.3f; // Duration for each sparkle
    private static final int NUM_SPARKLES = 6; // Number of sparkle particles

    private float animationTime = 0f;
    private final List<Sparkle> sparkles;
    private boolean isComplete = false;
    private final Vector2 position;
    private final Random random;

    private static class Sparkle {
        float x, y;
        float angle;
        float lifeTime;

        Sparkle(float x, float y, float angle) {
            this.x = x;
            this.y = y;
            this.angle = angle;
            this.lifeTime = 0f;
        }
    }

    public PokemonDespawnAnimation(float x, float y) {
        this.position = new Vector2(x, y);
        this.sparkles = new ArrayList<>();
        this.random = new Random();
        initializeSparkles();
    }

    private void initializeSparkles() {
        for (int i = 0; i < NUM_SPARKLES; i++) {
            float angle = (360f / NUM_SPARKLES) * i;
            sparkles.add(new Sparkle(position.x, position.y, angle));
        }
    }

    public boolean update(float delta) {
        animationTime += delta;

        // Update sparkles
        for (Sparkle sparkle : sparkles) {
            sparkle.lifeTime += delta;
            // Move sparkles outward in a spiral pattern
            float radius = (sparkle.lifeTime / DESPAWN_DURATION) * 32f;
            float rotationSpeed = 360f * (sparkle.lifeTime / DESPAWN_DURATION);
            sparkle.angle += rotationSpeed * delta;
            sparkle.x = position.x + radius * MathUtils.cosDeg(sparkle.angle);
            sparkle.y = position.y + radius * MathUtils.sinDeg(sparkle.angle);
        }

        return animationTime >= DESPAWN_DURATION;
    }

    public void render(SpriteBatch batch, TextureRegion pokemonSprite, float width, float height) {
        if (isComplete) return;

        float progress = animationTime / DESPAWN_DURATION;
        float alpha = 1.0f - progress;
        float scale = 1.0f - (progress * 0.5f);

        // Save batch color
        Color prevColor = batch.getColor();

        // Render fading Pokémon
        batch.setColor(prevColor.r, prevColor.g, prevColor.b, alpha);
        float scaledWidth = width * scale;
        float scaledHeight = height * scale;
        float xOffset = (width - scaledWidth) / 2;
        float yOffset = (height - scaledHeight) / 2;

        batch.draw(pokemonSprite,
            position.x + xOffset, position.y + yOffset,
            scaledWidth / 2, scaledHeight / 2,
            scaledWidth, scaledHeight,
            1f, 1f, 0);

        // Render sparkles
        TextureRegion sparkleTexture = TextureManager.ui.findRegion("sparkle");
        if (sparkleTexture != null) {
            for (Sparkle sparkle : sparkles) {
                float sparkleProgress = sparkle.lifeTime / SPARKLE_DURATION;
                float sparkleAlpha = 1.0f - (sparkleProgress > 1f ? 1f : sparkleProgress);
                float sparkleScale = 0.5f - (sparkleProgress * 0.3f);

                batch.setColor(1f, 1f, 1f, sparkleAlpha);
                batch.draw(sparkleTexture,
                    sparkle.x - (8f * sparkleScale), sparkle.y - (8f * sparkleScale),
                    8f, 8f,
                    16f * sparkleScale, 16f * sparkleScale,
                    1f, 1f, sparkle.angle);
            }
        }

        // Restore batch color
        batch.setColor(prevColor);
    }

    public boolean isComplete() {
        return isComplete;
    }
}

================
File: main/java/io/github/pokemeetup/pokemon/PokemonParty.java
================
package io.github.pokemeetup.pokemon;

import io.github.pokemeetup.pokemon.attacks.Move;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class PokemonParty {
    public static final int MAX_PARTY_SIZE = 6;
    private final List<Pokemon> party;
    public final Object partyLock = new Object();

    public PokemonParty() {
        this.party = new ArrayList<>(MAX_PARTY_SIZE);
    }

    public void addPokemon(Pokemon pokemon) {
        synchronized (partyLock) {
            if (party.size() >= MAX_PARTY_SIZE) {
                return;
            }
            party.add(pokemon);
        }
    }public Pokemon getFirstPokemon() {
        synchronized (partyLock) {
            return party.isEmpty() ? null : party.get(0);
        }
    }

    // Add healing method to Pokemon class (if not already present)


    public void clearParty() {
        party.clear();
    }

    public Pokemon removePokemon(int index) {
        synchronized (partyLock) {
            if (index >= 0 && index < party.size()) {
                return party.remove(index);
            }
            return null;
        }
    }

    public void swapPositions(int index1, int index2) {
        synchronized (partyLock) {
            if (index1 >= 0 && index1 < party.size() &&
                index2 >= 0 && index2 < party.size()) {
                Collections.swap(party, index1, index2);
            }
        }
    }

    public Pokemon getPokemon(int index) {
        synchronized (partyLock) {
            if (index >= 0 && index < party.size()) {
                return party.get(index);
            }
            return null;
        }
    }

    public List<Pokemon> getParty() {
        synchronized (partyLock) {
            return new ArrayList<>(party);
        }
    }

    public int getSize() {
        synchronized (partyLock) {
            return party.size();
        }
    }

    public boolean isFull() {
        synchronized (partyLock) {
            return party.size() >= MAX_PARTY_SIZE;
        }
    }

    public void healAllPokemon() {
        synchronized (partyLock) {
            for (Pokemon pokemon : party) {
                // Restore HP and PP
                pokemon.setCurrentHp(pokemon.getStats().getHp());
                for (Move move : pokemon.getMoves()) {
//                    move.restore();
                }
            }
        }
    }
}

================
File: main/java/io/github/pokemeetup/pokemon/WildPokemon.java
================
package io.github.pokemeetup.pokemon;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.pokemon.data.PokemonDatabase;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.system.gameplay.PokemonAnimations;
import io.github.pokemeetup.system.gameplay.overworld.PokemonSpawnManager;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.entityai.PokemonAI;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Random;

import static io.github.pokemeetup.system.gameplay.PokemonAnimations.IDLE_BOUNCE_DURATION;


public class WildPokemon extends Pokemon {
    private static final float SCALE = 2.0f;
    private static final float TILE_SIZE = 32f;
    private static final float MOVEMENT_DURATION = 0.75f;  // Slower, smoother movement
    private static final float RENDER_SCALE = 1.5f;
    private static final float COLLISION_SCALE = 0.8f;

    private static final float FRAME_WIDTH = World.TILE_SIZE;
    private static final float FRAME_HEIGHT = World.TILE_SIZE;
    private static final float IDLE_BOUNCE_HEIGHT = 2f;
    private final PokemonAnimations animations;
    private final float width;
    private final float height;
    private final Rectangle boundingBox;
    private float pixelX;
    private float pixelY;
    private World world;
    private int gridX;
    private boolean isMoving;
    private Vector2 startPosition;
    private Vector2 targetPosition;
    private float movementProgress;
    private PokemonAI ai;
    private int gridY;
    private float x;
    private float y;
    private long spawnTime;
    private String direction;
    private boolean isExpired = false;
    private boolean isAddedToParty = false;
    private boolean isDespawning = false;
    private float elapsedMovementTime = 0f;
    private PokemonDespawnAnimation despawnAnimation;
    private float idleTimer = 0f;
    private float idleAnimationTime = 0;
    private boolean isIdling = false;
    private float currentMoveTime = 0f;
    private boolean isInterpolating = false;
    private float lastUpdateX;
    private float lastUpdateY;

    public WildPokemon(String name, int level, int pixelX, int pixelY, TextureRegion overworldSprite) {
        super(name, level);
        this.pixelX = pixelX;
        this.pixelY = pixelY;
        this.x = pixelX;
        this.y = pixelY;
        this.startPosition = new Vector2(pixelX, pixelY);
        this.targetPosition = new Vector2(pixelX, pixelY);
        this.direction = "down";
        this.animations = new PokemonAnimations(overworldSprite);
        this.width = World.TILE_SIZE * SCALE;
        this.height = World.TILE_SIZE * SCALE;
        float collisionWidth = TILE_SIZE * COLLISION_SCALE;
        float collisionHeight = TILE_SIZE * COLLISION_SCALE;
        this.boundingBox = new Rectangle(
            this.pixelX + (TILE_SIZE - collisionWidth) / 2f,
            this.pixelY + (height - collisionHeight) / 2f,
            collisionWidth,
            collisionHeight
        );
        setSpawnTime((long) (System.currentTimeMillis() / 1000f));
        PokemonDatabase.PokemonTemplate template = PokemonDatabase.getTemplate(name);
        if (template != null) {
            // Set base stats from template
            this.setPrimaryType(template.primaryType);
            this.setSecondaryType(template.secondaryType);

            // Calculate and set stats based on level
            int baseHp = template.baseStats.baseHp;
            int baseAtk = template.baseStats.baseAttack;
            int baseDef = template.baseStats.baseDefense;
            int baseSpAtk = template.baseStats.baseSpAtk;
            int baseSpDef = template.baseStats.baseSpDef;
            int baseSpd = template.baseStats.baseSpeed;

            Stats stats = this.getStats();
            stats.setHp(calculateStat(baseHp, stats.ivs[0], stats.evs[0], level, true));
            stats.setAttack(calculateStat(baseAtk, stats.ivs[1], stats.evs[1], level, false));
            stats.setDefense(calculateStat(baseDef, stats.ivs[2], stats.evs[2], level, false));
            stats.setSpecialAttack(calculateStat(baseSpAtk, stats.ivs[3], stats.evs[3], level, false));
            stats.setSpecialDefense(calculateStat(baseSpDef, stats.ivs[4], stats.evs[4], level, false));
            stats.setSpeed(calculateStat(baseSpd, stats.ivs[5], stats.evs[5], level, false));

            // Set current HP to max HP
            this.setCurrentHp(stats.getHp());

            // Initialize moves based on level
            initializeMovesForLevel(template.moves, level);
        }

        this.ai = new PokemonAI(this);
    }
    private void initializeMovesForLevel(List<PokemonDatabase.MoveEntry> availableMoves, int level) {
        List<Move> learnedMoves = new ArrayList<>();

        // Sort moves by level requirement
        availableMoves.sort((a, b) -> Integer.compare(b.level, a.level));

        // Get up to 4 moves that the Pokemon can know at its current level
        for (PokemonDatabase.MoveEntry entry : availableMoves) {
            if (entry.level <= level && learnedMoves.size() < 4) {
                Move move = PokemonDatabase.getMoveByName(entry.name);
                if (move != null) {
                    learnedMoves.add(PokemonDatabase.cloneMove(move));
                }
            }
        }

        this.setMoves(learnedMoves);
    }


    public World getWorld() {
        return world;
    }

    public void setWorld(World world) {
        this.world = world;
    }

    public void updateFromNetworkUpdate(NetworkProtocol.PokemonUpdate update) {
        if (update == null) {
            GameLogger.error("Received null PokemonUpdate in updateFromNetworkUpdate");
            return;
        }

        // Update position
        this.x = update.x * World.TILE_SIZE + (World.TILE_SIZE - this.width) / 2f;
        this.y = update.y * World.TILE_SIZE + (World.TILE_SIZE - this.height) / 2f;
        updateBoundingBox();

        // Update level if it has changed
        if (this.getLevel() != update.level) {
            this.setLevel(update.level);
            GameLogger.info(getName() + " leveled up to " + this.getLevel());
        }

        // Update other attributes as needed
        // Assuming NetworkProtocol.PokemonUpdate has fields like currentHp, statusEffects, etc.

        if (update.currentHp != -1) { // Assuming -1 signifies no update
            setCurrentHp(update.currentHp);
            GameLogger.info(getName() + " HP updated to " + update.currentHp);
        }

    }


    private int calculateStat(int base, int iv, int ev, int level, boolean isHp) {
        if (isHp) {
            return ((2 * base + iv + ev / 4) * level / 100) + level + 10;
        } else {
            return ((2 * base + iv + ev / 4) * level / 100) + 5;
        }
    }
    public boolean isAddedToParty() {
        return isAddedToParty;
    }

    public void setAddedToParty(boolean addedToParty) {
        isAddedToParty = addedToParty;
    }

    public Rectangle getBoundingBox() {
        return boundingBox;
    }

    @Override
    public PokemonAnimations getAnimations() {
        return animations;
    }

    public float getWidth() {
        return width;
    }

    public float getHeight() {
        return height;
    }


    public void setSpawnTime(long spawnTime) {
        this.spawnTime = spawnTime;
    }

    @Override
    public String getDirection() {
        return direction;
    }

    public void setDirection(String direction) {
        this.direction = direction;
    }

    @Override
    public boolean isMoving() {
        return isMoving;
    }

    public void setMoving(boolean moving) {
        this.isMoving = moving;
    }

    public void updateBoundingBox() {
        if (boundingBox != null) {
            float collisionWidth = World.TILE_SIZE * COLLISION_SCALE;
            float collisionHeight = World.TILE_SIZE * COLLISION_SCALE;

            // Center the collision box regardless of render size
            boundingBox.setPosition(
                x + (World.TILE_SIZE - collisionWidth) / 2f,
                y + (World.TILE_SIZE - collisionHeight) / 2f
            );
            boundingBox.setSize(collisionWidth, collisionHeight);
        }
    }

    public TextureRegion getCurrentFrame() {
        if (animations != null) {
            return animations.getCurrentFrame(direction, isMoving, Gdx.graphics.getDeltaTime());
        }
        return null;
    }

    private void updateIdleAnimation(float delta) {
        idleTimer += delta;

        // Start new idle animation
        if (!isIdling && idleTimer >= MathUtils.random(2f, 4f)) {
            isIdling = true;
            idleTimer = 0;
            idleAnimationTime = 0;
        }

        // Update current idle animation
        if (isIdling) {
            idleAnimationTime += delta;
            if (idleAnimationTime >= IDLE_BOUNCE_DURATION) {
                isIdling = false;
                idleAnimationTime = 0;
            }
        }
    }

    public void update(float delta, World world) {
        if (world == null) return;

        // Update AI first
        if (ai != null) {
            ai.update(delta, world);
        }

        // Update movement and animations
        if (isMoving) {
            updateMovement(delta);
            isIdling = false;
            idleAnimationTime = 0;
        } else {
            updateIdleAnimation(delta);
        }

        // Update animations
        if (animations != null) {
            animations.update(delta);

            // Sync animation state with movement
            if (isMoving != animations.isMoving()) {
                if (isMoving) {
                    animations.startMoving(direction);
                } else {
                    animations.stopMoving();
                }
            }
        }
    }

    private float calculateSmoothProgress(float progress) {
        return progress * progress * (3 - 2 * progress);
    }

    private void completeMovement() {
        isInterpolating = false;
        isMoving = false;
        currentMoveTime = 0f;

        // Ensure final position is exactly on target
        setX(targetPosition.x);
        setY(targetPosition.y);

        // Stop walking animation
        if (animations != null) {
            animations.stopMoving();
        }

        updateBoundingBox();

    }
    private void updateMovement(float delta) {
        if (!isMoving || !isInterpolating) return;

        currentMoveTime += delta;
        movementProgress = Math.min(currentMoveTime / MOVEMENT_DURATION, 1.0f);

        // Use smooth step interpolation
        float smoothProgress = calculateSmoothProgress(movementProgress);

        // Calculate new position
        float newX = MathUtils.lerp(startPosition.x, targetPosition.x, smoothProgress);
        float newY = MathUtils.lerp(startPosition.y, targetPosition.y, smoothProgress);

        // Only update if position actually changed
        if (newX != lastUpdateX || newY != lastUpdateY) {
            setX(newX);
            setY(newY);
            lastUpdateX = newX;
            lastUpdateY = newY;
            updateBoundingBox();
        }

        // Check if movement is complete
        if (movementProgress >= 1.0f) {
            completeMovement();
        }
    }

    public void moveToTile(int targetTileX, int targetTileY, String newDirection) {
        if (!isMoving) {
            // Store current position as start
            startPosition.set(x, y);
            lastUpdateX = x;
            lastUpdateY = y;

            // Calculate target position in pixels
            float targetPixelX = targetTileX * World.TILE_SIZE;
            float targetPixelY = targetTileY * World.TILE_SIZE;
            targetPosition.set(targetPixelX, targetPixelY);

            // Set movement state
            this.direction = newDirection;
            this.isMoving = true;
            this.isInterpolating = true;
            this.currentMoveTime = 0f;

            // Calculate actual distance for movement duration
            float distance = Vector2.dst(startPosition.x, startPosition.y,
                targetPosition.x, targetPosition.y);

            // Adjust movement duration based on distance
            this.movementProgress = 0f;

            // Start walking animation
            animations.startMoving(direction);

        }
    }

    public float getX() {
        return x;
    }

    public void setX(float x) {
        this.pixelX = x;
        this.x = x;
        updateBoundingBox();
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.pixelY = y;
        this.y = y;
        updateBoundingBox();
    }

    public PokemonAI getAi() {
        return ai;
    }

    public void render(SpriteBatch batch) {
        if (isDespawning) {
            if (despawnAnimation != null) {
                despawnAnimation.render(batch, getCurrentFrame(), FRAME_WIDTH, FRAME_HEIGHT);
            }
            return;
        }

        TextureRegion frame = getCurrentFrame();
        if (frame != null) {
            float renderX = x;
            float renderY = y;

            if (!isMoving && isIdling) {
                float bounceOffset = IDLE_BOUNCE_HEIGHT *
                    MathUtils.sin(idleAnimationTime * MathUtils.PI2 / IDLE_BOUNCE_DURATION);
                renderY += bounceOffset;
            }

            // Scale and center the sprite
            float width = FRAME_WIDTH * RENDER_SCALE;
            float height = FRAME_HEIGHT * RENDER_SCALE;
            float offsetX = (width - FRAME_WIDTH) / 2f;
            float offsetY = (height - FRAME_HEIGHT) / 2f;

            // Save original batch color
            Color originalColor = batch.getColor().cpy();

            if (world != null) {
                // Get base color from the world
                Color baseColor = world.getCurrentWorldColor();

                // Convert position to tile coordinates
                int tileX = (int) (x / World.TILE_SIZE);
                int tileY = (int) (y / World.TILE_SIZE);
                Vector2 tilePos = new Vector2(tileX, tileY);

                // Get light level at this position
                Float lightLevel = world.getLightLevelAtTile(tilePos);
                if (lightLevel != null && lightLevel > 0) {
                    Color lightColor = new Color(1f, 0.9f, 0.7f, 1f);
                    baseColor = baseColor.cpy().lerp(lightColor, lightLevel);
                }

                // Set the adjusted color
                batch.setColor(baseColor);
            }

            // Draw with smooth interpolation
            batch.draw(frame,
                renderX - offsetX,
                renderY - offsetY,
                width,
                height);

            // Restore original batch color
            batch.setColor(originalColor);
        }
    }


    public boolean isExpired() {
        if (isExpired) return true;
        float currentTime = System.currentTimeMillis() / 1000f;
        return currentTime - spawnTime > PokemonSpawnManager.POKEMON_DESPAWN_TIME;
    }
    public boolean isDespawning() {
        return isDespawning;
    }

    public void startDespawnAnimation() {
        if (!isDespawning) {
            isDespawning = true;
            despawnAnimation = new PokemonDespawnAnimation(getX(), getY());
        }
    }
}

================
File: main/java/io/github/pokemeetup/screens/ChestScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.InputProcessor;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.screens.otherui.InventorySlotUI;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingSystem;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.InventoryConverter;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;

import java.util.Objects;

public class ChestScreen implements Screen, InventoryScreenInterface {
    private static final int SLOT_SIZE = 40;
    private final ChestData chestData;
    private final SpriteBatch batch;
    private final Vector2 chestPosition;
    private final GameScreen gameScreen;
    private final Stage stage;
    private final Skin skin;
    private final Player player;
    private final Table inventoryTable;
    private final Table mainTable;
    private final Table chestTable;
    private boolean isVisible = false;
    private Item heldItem = null;
    private final Table closeButtonTable;
    private Group heldItemGroup;
    private Image heldItemImage;
    private Label heldItemCountLabel;
    private boolean isClosing = false;

    public ChestScreen(Player player, Skin skin, ChestData chestData, Vector2 chestPosition, GameScreen gameScreen) {
        this.player = player;
        this.skin = skin;
        this.chestData = chestData;
        this.chestPosition = chestPosition;
        this.stage = new Stage(new ScreenViewport());
        this.batch = new SpriteBatch();
        this.gameScreen = gameScreen;
        this.mainTable = new Table();
        this.chestTable = new Table();
        this.inventoryTable = new Table();
        this.closeButtonTable = new Table();
        setupHeldItemDisplay();
        setupUI();
    }

    public Stage getStage() {
        return stage;
    }

    @Override
    public Inventory getInventory() {
        return player.getInventory();
    }

    @Override
    public Player getPlayer() {
        return player;
    }

    @Override
    public ItemData getHeldItem() {
        return InventoryConverter.itemToItemData(heldItem);
    }

    @Override
    public void setHeldItem(Item item) {
        this.heldItem = item;
        updateHeldItemDisplay();
    }

    @Override
    public CraftingSystem getCraftingSystem() {
        return null; // Chest doesn't use crafting
    }

    @Override
    public ItemContainer getChestData() {
        return chestData;
    }

    private void createChestInventoryGrid() {
        chestTable.clear();
        chestTable.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        chestTable.pad(10);

        Label titleLabel = new Label("Storage", skin);
        chestTable.add(titleLabel).colspan(9).pad(5).row();

        Table grid = new Table();
        grid.defaults().space(4);

        // Debug logging
        GameLogger.info("Creating chest grid for chest at: " + chestPosition);
        GameLogger.info("Chest data contents: " + (chestData != null ? chestData.toString() : "null"));

        int cols = 9;
        for (int i = 0; i < chestData.getSize(); i++) {
            InventorySlotData slotData = chestData.getSlotData(i);
            InventorySlotUI slot = new InventorySlotUI(slotData, skin, this);
            chestTable.add(slot).size(SLOT_SIZE);
            if ((i + 1) % cols == 0) {
                chestTable.row();
            }
        }

        chestTable.add(grid);
    }

    @Override
    public Item getHeldItemObject() {
        return heldItem;
    }

    private void createPlayerInventoryGrid() {
        inventoryTable.clear();
        inventoryTable.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        inventoryTable.pad(10);

        // Title
        Label titleLabel = new Label("Inventory", skin);
        inventoryTable.add(titleLabel).colspan(9).pad(5).row();

        // Grid of slots
        Table grid = new Table();
        grid.defaults().space(4);

        int cols = 9;
        for (int i = 0; i < player.getInventory().getSize(); i++) {
            InventorySlotData slotData = new InventorySlotData(i, InventorySlotData.SlotType.INVENTORY, player.getInventory());
// No need to set slotType again

            InventorySlotUI slot = new InventorySlotUI(slotData, skin, this);


            grid.add(slot).size(SLOT_SIZE);
            if ((i + 1) % cols == 0) {
                grid.row();
            }
        }
        inventoryTable.add(grid);
    }

    private void updateUI() {
        createChestInventoryGrid();
        createPlayerInventoryGrid();
    }

    private void setupHeldItemDisplay() {
        heldItemImage = new Image();
        heldItemImage.setSize(32, 32);
        heldItemImage.setVisible(false);

        heldItemCountLabel = new Label("", skin);
        heldItemCountLabel.setVisible(false);

        heldItemGroup = new Group();
        heldItemGroup.addActor(heldItemImage);
        heldItemGroup.addActor(heldItemCountLabel);

        heldItemGroup.setTouchable(Touchable.disabled);
        stage.addActor(heldItemGroup); // Add heldItemGroup to the stage
    }

    private void setupUI() {
        stage.clear();
        mainTable.clear();

        mainTable.setFillParent(true);
        mainTable.center();

        // Set mainTable as touchable
        mainTable.setTouchable(Touchable.enabled);

        // Add a listener to consume input events
        mainTable.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                // Consume the event to prevent it from propagating
                event.stop();
            }
        });

        // Set up background
        Pixmap bgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(0, 0, 0, 0.5f);
        bgPixmap.fill();
        Texture bgTexture = new Texture(bgPixmap);
        mainTable.setBackground(new TextureRegionDrawable(bgTexture) {
            @Override
            public void draw(com.badlogic.gdx.graphics.g2d.Batch batch, float x, float y, float width, float height) {
                batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);
                super.draw(batch, x, y, width, height);
            }
        });
        bgPixmap.dispose();

        Label titleLabel = new Label("Chest", skin);
        titleLabel.setFontScale(1.5f);
        mainTable.add(titleLabel).pad(20).row();

        chestTable.clear();
        inventoryTable.clear();
        chestTable.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        chestTable.pad(10);
        createChestInventoryGrid();
        mainTable.add(chestTable).pad(10).row();
        inventoryTable.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        inventoryTable.pad(10);
        createPlayerInventoryGrid();
        mainTable.add(inventoryTable).pad(10).row();
        TextButton closeButton = new TextButton("Close", skin);
        closeButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (gameScreen != null) {
                    gameScreen.closeChestScreen();
                }
            }
        });

        closeButtonTable.clear();
        closeButtonTable.add(closeButton).size(100, 40).pad(10);
        mainTable.add(closeButtonTable).row();
        mainTable.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                event.stop();
                return true;
            }

            @Override
            public boolean keyUp(InputEvent event, int keycode) {
                event.stop();
                return true;
            }

            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
                event.stop();
                return true;
            }
        });

        stage.addActor(mainTable);
        stage.addActor(heldItemGroup);
    }

    @Override
    public void show() {
        if (isVisible) return;
        isVisible = true;
        isClosing = false;

        try {
            this.heldItem = null; // Clear any previously held item
            updateHeldItemDisplay(); // Update the UI accordingly
            setupUI();
            updateUI();

            if (stage != null) {
                stage.getViewport().update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
            }

            GameLogger.info("Chest screen shown successfully");
        } catch (Exception e) {
            GameLogger.error("Error showing chest screen: " + e.getMessage());
            isVisible = false;
        }
    }

    @Override
    public void hide() {
        if (isClosing) return; // Prevent multiple hide() calls
        isClosing = true;

        if (!isVisible) {
            isClosing = false;
            return;
        }

        ItemData heldItemData = InventoryConverter.itemToItemData(this.heldItem);
        isVisible = false;

        try {
            if (heldItemData != null) {
                player.getInventory().addItem(heldItemData);
                this.heldItem = null; // Clear the heldItem
                updateHeldItemDisplay(); // Update the UI to reflect that there's no held item
            }

            // Save chest state before closing
            saveChestState();

            // Clean up UI elements
            if (stage != null) {
                stage.clear();
            }

            // Reset chest handler state
            if (gameScreen != null && gameScreen.getChestHandler() != null) {
                gameScreen.getChestHandler().setChestOpen(false);
                gameScreen.getChestHandler().reset();
            }

            // Play close sound
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.CHEST_CLOSE);

        } catch (Exception e) {
            GameLogger.error("Error during chest close: " + e.getMessage());
        } finally {
            isClosing = false;
        }
    }


    private void saveChestState() {
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.CHEST_CLOSE);

        // Save final chest state
        if (player != null && player.getWorld() != null) {
            PlaceableBlock block = player.getWorld().getBlockManager().getBlockAt(
                (int) chestPosition.x, (int) chestPosition.y);
            if (block != null) {
                block.setChestOpen(false);
                block.setChestData(chestData); // Ensure final state is saved

                // Force save the chunk
                int chunkX = Math.floorDiv((int) chestPosition.x, World.CHUNK_SIZE);
                int chunkY = Math.floorDiv((int) chestPosition.y, World.CHUNK_SIZE);
                Vector2 chunkPos = new Vector2(chunkX, chunkY);

                Chunk chunk = player.getWorld().getChunks().get(chunkPos);
                if (chunk != null) {
                    player.getWorld().saveChunkData(chunkPos, chunk);
                }
            }
        }

        if (gameScreen != null && gameScreen.getChestHandler() != null) {
            gameScreen.getChestHandler().setChestOpen(false);
            gameScreen.getChestHandler().reset();
        }
    }

    @Override
    public void render(float delta) {
        if (!isVisible) return;

        // Don't clear the screen - we want to see the game world behind
        Gdx.gl.glEnable(GL20.GL_BLEND);
        Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        // Update the UI
        stage.act(delta);
        stage.draw();
        updateHeldItemPosition();
        Gdx.gl.glDisable(GL20.GL_BLEND);
    }

    public void updateHeldItemDisplay() {
        if (heldItem != null) {
            TextureRegion texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase() + "_item");
            if (texture == null) {
                texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase());
            }

            if (texture != null) {
                heldItemImage.setDrawable(new TextureRegionDrawable(texture));
                heldItemImage.setVisible(true);

                if (heldItem.getCount() > 1) {
                    heldItemCountLabel.setText(String.valueOf(heldItem.getCount()));
                    heldItemCountLabel.setVisible(true);
                } else {
                    heldItemCountLabel.setVisible(false);
                }
                heldItemGroup.setVisible(true); // Make the group visible
            } else {
                heldItemImage.setVisible(false);
                heldItemCountLabel.setVisible(false);
                heldItemGroup.setVisible(false);
            }
        } else {
            heldItemImage.setVisible(false);
            heldItemCountLabel.setVisible(false);
            heldItemGroup.setVisible(false); // Hide the group when no held item
        }
    }

    private void updateHeldItemPosition() {
        if (heldItemGroup != null && heldItemGroup.isVisible()) {
            float x = Gdx.input.getX() - 16;
            float y = Gdx.graphics.getHeight() - Gdx.input.getY() - 16;
            heldItemGroup.setPosition(x, y);
        }
    }


    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        updateUI();
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void dispose() {
        if (stage != null) {
            stage.dispose();
        }
        if (batch != null) {
            batch.dispose();
        }
    }

    public boolean isVisible() {
        return isVisible;
    }

    public void setVisible(boolean visible) {
        this.isVisible = visible;
    }
}

================
File: main/java/io/github/pokemeetup/screens/CraftingTableScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.InputMultiplexer;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.screens.otherui.InventorySlotUI;
import io.github.pokemeetup.system.InputManager;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingGrid;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingSystem;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventoryObserver;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.InventoryConverter;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.ArrayList;
import java.util.List;

public class CraftingTableScreen implements Screen, InventoryScreenInterface, InventoryObserver, CraftingSystem.CraftingSystemObserver {
    private static final int SLOT_SIZE = 32;
    private static final int GRID_SIZE = 3;
    private final Stage stage;
    private final Player player;
    private final World world;
    private final GameClient gameClient;
    private final Inventory inventory;
    private final CraftingSystem craftingSystem;
    private final Skin skin;
    private final List<InventorySlotUI> inventorySlots = new ArrayList<>();
    private final GameScreen gameScreen;
    private final InputManager inputManager;
    private Vector2 craftingTablePosition;
    private List<InventorySlotUI> craftingSlots;
    private InventorySlotUI resultSlot;
    private boolean isVisible = false;
    private Item heldItem = null;
    private InventorySlotData[] inventorySlotData;
    private Group heldItemGroup;
    private Image heldItemImage;
    private Label heldItemCountLabel;
    private CraftingGrid craftingGrid; // New field

    public CraftingTableScreen(Player player, Skin skin, World world, GameClient gameClient, GameScreen screen, InputManager inputManager) {
        if (player == null) {
            throw new IllegalArgumentException("Player cannot be null");
        }
        this.player = player;
        this.world = world;
        this.gameClient = gameClient;
        this.stage = new Stage(new ScreenViewport());
        this.skin = skin;
        this.inventory = player.getInventory();
        this.craftingSlots = new ArrayList<>();
        this.gameScreen = screen;
        this.inputManager = inputManager;
        this.craftingGrid = new CraftingGrid(GRID_SIZE * GRID_SIZE);

        this.craftingSystem = new CraftingSystem(inventory, GRID_SIZE, craftingGrid); // 3x3 grid
        craftingSystem.addObserver(this);

        initializeInventoryData();
        setupHeldItemDisplay();

        // First initialize the crafting grid
        initializeCraftingGrid();

        // Then setup the UI which uses the initialized slots
        setupUI(skin);

        inventory.addObserver(this);
    }

    @Override
    public Item getHeldItemObject() {
        return heldItem;
    }

    @Override
    public CraftingSystem getCraftingSystem() {
        return craftingSystem;
    }

    @Override
    public ItemContainer getChestData() {
        return null;
    }

    private Table createInventorySection() {
        Table container = new Table();
        container.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        container.pad(10);

        Table gridTable = new Table();
        gridTable.defaults().space(4);

        inventorySlots.clear();
        int cols = 9;

        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            InventorySlotUI slot = new InventorySlotUI(inventorySlotData[i], skin, this);
            inventorySlots.add(slot);

            gridTable.add(slot).size(SLOT_SIZE);
            if ((i + 1) % cols == 0) {
                gridTable.row();
            }
        }

        container.add(gridTable);
        return container;
    }

    private void initializeCraftingGrid() {
        craftingSlots.clear();

        for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            InventorySlotData slotData = new InventorySlotData(i, InventorySlotData.SlotType.EXPANDED_CRAFTING, craftingGrid);
            InventorySlotUI slot = new InventorySlotUI(slotData, skin, this);
            craftingSlots.add(slot);

            // Register slot observer with crafting system
            craftingSystem.addSlotObserver(i, slot);
        }
    }

    public Stage getStage() {
        return stage;
    }

    public World getWorld() {
        return world;
    }

    public GameClient getGameClient() {
        return gameClient;
    }


    public Skin getSkin() {
        return skin;
    }


    // Add validation method
    private void validateInitialization() {
        if (craftingSlots == null || craftingSlots.isEmpty()) {
            GameLogger.error("Crafting slots not properly initialized!");
            throw new IllegalStateException("CraftingTableScreen not properly initialized");
        }
    }


    private Table createCraftingSection() {
        Table container = new Table();
        container.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        container.pad(10);

        Table craftingGridTable = new Table();
        craftingGridTable.defaults().size(SLOT_SIZE).pad(2);

        // Create crafting slots and add them to the grid
        for (int row = 0; row < GRID_SIZE; row++) {
            for (int col = 0; col < GRID_SIZE; col++) {
                int index = row * GRID_SIZE + col;
                InventorySlotUI slotUI = craftingSlots.get(index);
                craftingGridTable.add(slotUI);
            }
            craftingGridTable.row();
        }

        // Create result slot
        InventorySlotData resultSlotData = new InventorySlotData(-1, InventorySlotData.SlotType.CRAFTING_RESULT, craftingGrid);
        resultSlotData.setSlotType(InventorySlotData.SlotType.CRAFTING_RESULT);
        resultSlot = new InventorySlotUI(resultSlotData, skin, this);

        // Create the crafting table layout
        Table craftingTable = new Table();
        craftingTable.add(craftingGridTable);
        craftingTable.add(new Image(TextureManager.ui.findRegion("arrow"))).padLeft(10).padRight(10);
        craftingTable.add(resultSlot).size(SLOT_SIZE);

        container.add(craftingTable);
        return container;
    }


    private void setupUI(Skin skin) {
        validateInitialization();

        Table mainTable = new Table();
        mainTable.setFillParent(true);

        // Semi-transparent background
        Pixmap bgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(0, 0, 0, 0.2f);
        bgPixmap.fill();
        mainTable.setBackground(new TextureRegionDrawable(new TextureRegion(new Texture(bgPixmap))));
        bgPixmap.dispose();

        // Create sections
        Table craftingContainer = createCraftingSection();
        mainTable.add(craftingContainer).pad(10).row();

        Table inventoryContainer = createInventorySection();
        mainTable.add(inventoryContainer).pad(10).row();

        // Close button
        // Fix close button implementation
        // Close button
        TextButton closeButton = new TextButton("Close", skin);
        closeButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                gameScreen.closeExpandedCrafting();
            }
        });

        mainTable.add(closeButton).size(100, 40).pad(10);

        // Add main table to stage
        stage.addActor(mainTable);


    }

    private void initializeInventoryData() {
        this.inventorySlotData = new InventorySlotData[Inventory.INVENTORY_SIZE];
        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            inventorySlotData[i] = new InventorySlotData(i, InventorySlotData.SlotType.INVENTORY, inventory);
            inventorySlotData[i].setSlotType(InventorySlotData.SlotType.INVENTORY);
        }

        // Load current inventory state
        List<ItemData> items = inventory.getAllItems();
        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            if (i < items.size() && items.get(i) != null) {
                ItemData item = items.get(i);
                inventorySlotData[i].setItem(item.getItemId(), item.getCount(), item.getUuid());
            }
        }
    }

    private void returnItemsToInventory() {
        // Only return items when closing the crafting table
        if (!isVisible) {
            if (heldItem != null) {
                inventory.addItem(new ItemData(heldItem.getName(), heldItem.getCount(), heldItem.getUuid()));
                setHeldItem(null);
            }
            craftingSystem.returnItemsToInventory();
        }
    }

    @Override
    public void onCraftingResultChanged(ItemData newResult) {
        GameLogger.info("Crafting result changed - updating result slot");
        resultSlot.updateSlot();
    }


    @Override
    public void show() {
        isVisible = true;
        setupInputProcessors();
        updateInventorySlots(); // Refresh inventory display
    }

    private void updateInventorySlots() {
        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            InventorySlotData slotData = inventorySlotData[i];
            ItemData item = inventory.getItemAt(i);
            if (item != null) {
                slotData.setItem(item.getItemId(), item.getCount(), item.getUuid());
            } else {
                slotData.clear();
            }
        }

        for (InventorySlotUI slot : inventorySlots) {
            slot.forceUpdate();
        }
    }


    private void setupInputProcessors() {
        InputMultiplexer multiplexer = new InputMultiplexer();
        multiplexer.addProcessor(stage);
        Gdx.input.setInputProcessor(multiplexer);
    }

    @Override
    public void render(float delta) {
        if (!isVisible) return;

        // Check if player is still in range
        if (!isPlayerInRange()) {
            close();
            return;
        }

        Gdx.gl.glClearColor(0, 0, 0, 0.5f);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        stage.act(delta);
        stage.draw();

        // Update held item position if any
        updateHeldItemPosition();
    }

    private void close() {
        GameLogger.info("Closing crafting table screen");
        hide();  // This will handle cleanup properly
        setupInputProcessors(); // Reset input handling
    }


    private void returnHeldItemToInventory() {
        if (heldItem != null) {
            ItemData itemData = new ItemData(heldItem.getName(), heldItem.getCount(), heldItem.getUuid());
            if (inventory.addItem(itemData)) {
                setHeldItem(null);
                GameLogger.info("Returned held item to inventory: " + itemData.getItemId());
            }
        }
    }


    private void setupHeldItemDisplay() {
        heldItemImage = new Image();
        heldItemImage.setSize(SLOT_SIZE, SLOT_SIZE);
        heldItemImage.setVisible(false);

        heldItemCountLabel = new Label("", skin);
        heldItemCountLabel.setVisible(false);

        heldItemGroup = new Group();
        heldItemGroup.addActor(heldItemImage);
        heldItemGroup.addActor(heldItemCountLabel);

        stage.addActor(heldItemGroup);

        heldItemGroup.setTouchable(Touchable.disabled);
    }

    private void cleanupHeldItemResources() {
        if (heldItemGroup != null) {
            heldItemGroup.clear();
            heldItemGroup.remove();
            heldItemGroup = null;
        }
    }


    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void onInventoryChanged() {
        GameLogger.info("Inventory changed - updating inventory slots");

    }


    @Override
    public void dispose() {
        GameLogger.info("Disposing CraftingTableScreen resources");

        try {
            // Return any held items to inventory first
            if (heldItem != null) {
                returnHeldItemToInventory();
            }

            // Return crafting grid items to inventory
            returnItemsToInventory();

            // Dispose of stage and resources
            if (stage != null) {
                stage.dispose();
            }

            // Clear all slots
            if (craftingSlots != null) {
                craftingSlots.clear();
            }

            // Dispose of textures and other resources
            if (heldItemGroup != null) {
                heldItemGroup.remove();
                heldItemGroup = null;
            }

            // Clear references
            craftingSlots = null;
            resultSlot = null;
            heldItem = null;

            GameLogger.info("CraftingTableScreen disposed successfully");

        } catch (Exception e) {
            GameLogger.error("Error during CraftingTableScreen disposal: " + e.getMessage());
        }
    }


    @Override
    public void pause() {

    }

    @Override
    public void resume() {

    }


    public void updateHeldItemDisplay() {
        if (heldItemGroup == null) {
            setupHeldItemDisplay();
        }

        heldItemGroup.clear();

        if (heldItem != null) {
            // Load texture
            TextureRegion texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase() + "_item");
            if (texture == null) {
                texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase());
            }

            if (texture != null) {
                heldItemImage = new Image(texture);
                heldItemImage.setSize(32, 32);
                heldItemGroup.addActor(heldItemImage);

                if (heldItem.getCount() > 1) {
                    heldItemCountLabel = new Label(String.valueOf(heldItem.getCount()), skin);
                    heldItemCountLabel.setPosition(24, 0);
                    heldItemGroup.addActor(heldItemCountLabel);
                }

                heldItemGroup.setVisible(true);
                heldItemGroup.toFront();
            }
        } else {
            heldItemGroup.setVisible(false);
        }
    }

    @Override
    public void hide() {
        isVisible = false;
        if (heldItem != null) {
            returnHeldItemToInventory();
        }
        returnItemsToInventory();
        cleanupHeldItemResources();
        GameLogger.info("CraftingTableScreen hidden");
    }

    private boolean isPlayerInRange() {
        if (craftingTablePosition == null) return false;
        float distance = Vector2.dst(
            player.getTileX(), player.getTileY(),
            craftingTablePosition.x, craftingTablePosition.y
        );
        return distance <= 2; // Within 2 tiles
    }

    @Override
    public Inventory getInventory() {
        return inventory;
    }

    @Override
    public Player getPlayer() {
        return player;
    }

    @Override
    public ItemData getHeldItem() {
        return InventoryConverter.itemToItemData(heldItem);
    }

    @Override
    public void setHeldItem(Item item) {
        this.heldItem = item;
        updateHeldItemDisplay();
    }

    public boolean isVisible() {
        return isVisible;
    }

    public void updatePosition(Vector2 newPosition) {
        this.craftingTablePosition = newPosition;
    }

    private void updateHeldItemPosition() {
        if (heldItem != null && heldItemGroup != null) {
            float x = Gdx.input.getX() - SLOT_SIZE / 2f;
            float y = Gdx.graphics.getHeight() - Gdx.input.getY() - SLOT_SIZE / 2f;

            heldItemGroup.setPosition(x, y);
            heldItemGroup.toFront();
        }
    }


}

================
File: main/java/io/github/pokemeetup/screens/DisconnectionScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Timer;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.DisconnectionManager;
import io.github.pokemeetup.utils.GameLogger;

public class DisconnectionScreen implements Screen {
    private static final float RETRY_INTERVAL = 5f; // 5 seconds between retries
    private static final int MAX_RETRY_ATTEMPTS = 3;
    private static final float BUTTON_WIDTH = 200f;
    private static final float BUTTON_HEIGHT = 50f;

    private final CreatureCaptureGame game;
    private final Stage stage;
    private final Skin skin;
    private final Table mainTable;
    private final Label statusLabel;
    private final Label countdownLabel;
    private final TextButton retryButton;
    private final TextButton exitButton;
    private final DisconnectionManager disconnectionManager;

    private int retryAttempts = 0;
    private float countdownTime = RETRY_INTERVAL;
    private boolean isRetrying = false;
    private boolean disposed = false;
    private String disconnectReason;

    private final Timer.Task countdownTask = new Timer.Task() {
        @Override
        public void run() {
            if (countdownTime > 0) {
                countdownTime -= 1;
                updateCountdownLabel();
            } else {
                stopCountdown();
                attemptReconnection();
            }
        }
    };

    public DisconnectionScreen(CreatureCaptureGame game, String reason, DisconnectionManager manager) {
        this.game = game;
        this.disconnectReason = reason;
        this.disconnectionManager = manager;
        this.stage = new Stage(new ScreenViewport());
        this.skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));

        // Create main table for layout
        mainTable = new Table();
        mainTable.setFillParent(true);

        // Create UI components with custom styling
        Label titleLabel = new Label("Connection Lost", createLabelStyle());
        titleLabel.setFontScale(2f);

        statusLabel = new Label(reason, createLabelStyle());
        countdownLabel = new Label("", createLabelStyle());

        retryButton = createButton("Retry Connection", new Color(0.2f, 0.6f, 1f, 1f));
        exitButton = createButton("Exit to Menu", new Color(1f, 0.3f, 0.3f, 1f));

        // Layout components
        mainTable.add(titleLabel).pad(20).row();
        mainTable.add(statusLabel).pad(10).row();
        mainTable.add(countdownLabel).pad(10).row();

        // Button table for horizontal layout
        Table buttonTable = new Table();
        buttonTable.add(retryButton).pad(10).width(BUTTON_WIDTH).height(BUTTON_HEIGHT);
        buttonTable.add(exitButton).pad(10).width(BUTTON_WIDTH).height(BUTTON_HEIGHT);

        mainTable.add(buttonTable).pad(20).row();

        // Add overlay shadow effect
        Table overlayTable = new Table();
        overlayTable.setFillParent(true);
        overlayTable.setBackground(skin.newDrawable("white", new Color(0f, 0f, 0f, 0.8f)));

        // Add tables to stage
        stage.addActor(overlayTable);
        stage.addActor(mainTable);

        // Set up input processing
        Gdx.input.setInputProcessor(stage);

        // Add button listeners
        setupButtonListeners();

        GameLogger.info("DisconnectionScreen initialized with reason: " + reason);
    }

    private Label.LabelStyle createLabelStyle() {
        Label.LabelStyle style = new Label.LabelStyle(skin.getFont("default-font"), Color.WHITE);
        return style;
    }

    private TextButton createButton(String text, Color color) {
        TextButton.TextButtonStyle style = new TextButton.TextButtonStyle();
        style.font = skin.getFont("default-font");
        style.fontColor = Color.WHITE;
        style.up = skin.newDrawable("default-round", color);
        style.down = skin.newDrawable("default-round-down", color.cpy().mul(0.8f));
        style.over = skin.newDrawable("default-round", color.cpy().mul(1.2f));

        TextButton button = new TextButton(text, style);
        button.pad(10);
        return button;
    }

    private void setupButtonListeners() {
        retryButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                if (!isRetrying) {
                    startRetryCountdown();
                }
            }
        });

        exitButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                exitToMenu();
            }
        });
    }

    @Override
    public void render(float delta) {
        // Clear screen with dark background
        Gdx.gl.glClearColor(0.1f, 0.1f, 0.15f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        // Update countdown if active
        if (isRetrying) {
            countdownTime -= delta;
            if (countdownTime <= 0) {
                stopCountdown();
                attemptReconnection();
            }
            updateCountdownLabel();
        }

        // Update and draw stage
        stage.act(delta);
        stage.draw();
    }

    private void startRetryCountdown() {
        if (retryAttempts >= MAX_RETRY_ATTEMPTS) {
            statusLabel.setText("Maximum retry attempts reached");
            retryButton.setDisabled(true);
            return;
        }

        isRetrying = true;
        countdownTime = RETRY_INTERVAL;
        retryButton.setDisabled(true);
        updateCountdownLabel();
        GameLogger.info("Starting retry countdown");
    }

    private void stopCountdown() {
        isRetrying = false;
        countdownTime = RETRY_INTERVAL;
        retryButton.setDisabled(false);
        countdownLabel.setText("");

        if (countdownTask.isScheduled()) {
            countdownTask.cancel();
        }
    }

    private void updateCountdownLabel() {
        countdownLabel.setText(String.format("Retrying in %.0f seconds...", Math.max(0, countdownTime)));
        countdownLabel.setAlignment(Align.center);
    }

    private void attemptReconnection() {
        if (disconnectionManager != null) {
            disconnectionManager.attemptReconnect();
        }
    }

    private void exitToMenu() {
        if (disconnectionManager != null) {
            disconnectionManager.cleanup();
        }
        game.setScreen(new LoginScreen(game));
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        mainTable.invalidate(); // Reflow the UI
    }

    @Override
    public void show() {
        Gdx.input.setInputProcessor(stage);
    }
    @Override
    public void dispose() {
        if (!disposed) {
            stage.dispose();
            disposed = true;
            GameLogger.info("DisconnectionScreen disposed");
        }
    }

    @Override
    public void hide() {
        // Remove input processor when screen is hidden
        if (Gdx.input.getInputProcessor() == stage) {
            Gdx.input.setInputProcessor(null);
        }
    }

    @Override
    public void pause() {
        // Pause any active countdowns or animations
        if (isRetrying) {
            stopCountdown();
        }
    }

    @Override
    public void resume() {
        // Ensure input processor is set when screen resumes
        Gdx.input.setInputProcessor(stage);
    }

    public void onReconnectionSuccess() {
        Gdx.app.postRunnable(() -> {
            stopCountdown();
            statusLabel.setText("Connection restored!");
            // Add success animation or feedback here if desired
            Timer.schedule(new Timer.Task() {
                @Override
                public void run() {
                    if (disconnectionManager != null) {
                        disconnectionManager.onReconnectionSuccess();
                    }
                }
            }, 1); // Wait 1 second before returning to game
        });
    }

    public void onReconnectionFailure(String reason) {
        Gdx.app.postRunnable(() -> {
            stopCountdown();
            statusLabel.setText("Reconnection failed: " + reason);
            if (retryAttempts >= MAX_RETRY_ATTEMPTS) {
                retryButton.setDisabled(true);
                Timer.schedule(new Timer.Task() {
                    @Override
                    public void run() {
                        exitToMenu();
                    }
                }, 2); // Wait 2 seconds before exiting to menu
            }
        });
    }

    public void updateStatus(String status) {
        Gdx.app.postRunnable(() -> {
            statusLabel.setText(status);
        });
    }

    private void fadeOut(Runnable onComplete) {
        mainTable.addAction(com.badlogic.gdx.scenes.scene2d.actions.Actions.sequence(
            com.badlogic.gdx.scenes.scene2d.actions.Actions.fadeOut(0.5f),
            com.badlogic.gdx.scenes.scene2d.actions.Actions.run(onComplete)
        ));
    }

    private void fadeIn() {
        mainTable.getColor().a = 0;
        mainTable.addAction(com.badlogic.gdx.scenes.scene2d.actions.Actions.fadeIn(0.5f));
    }

    public boolean isRetrying() {
        return isRetrying;
    }

    public int getRetryAttempts() {
        return retryAttempts;
    }
}

================
File: main/java/io/github/pokemeetup/screens/GameScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.*;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.*;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Scaling;
import com.badlogic.gdx.utils.Timer;
import com.badlogic.gdx.utils.viewport.FitViewport;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.chat.ChatSystem;
import io.github.pokemeetup.chat.CommandManager;
import io.github.pokemeetup.chat.commands.GiveCommand;
import io.github.pokemeetup.chat.commands.SetWorldSpawnCommand;
import io.github.pokemeetup.chat.commands.SpawnCommand;
import io.github.pokemeetup.chat.commands.TeleportPositionCommand;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.multiplayer.OtherPlayer;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.multiplayer.server.ServerStorageSystem;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.PokemonParty;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.screens.otherui.*;
import io.github.pokemeetup.system.*;
import io.github.pokemeetup.system.battle.BattleInitiationHandler;
import io.github.pokemeetup.system.battle.BattleSystemHandler;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.gameplay.inventory.ChestInteractionHandler;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.*;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;
import io.github.pokemeetup.utils.textures.BattleAssets;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.InventoryConverter;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.List;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

import static io.github.pokemeetup.system.gameplay.overworld.World.INITIAL_LOAD_RADIUS;
import static io.github.pokemeetup.system.gameplay.overworld.World.TILE_SIZE;

public class GameScreen implements Screen, PickupActionHandler, BattleInitiationHandler {
    private static final float TARGET_VIEWPORT_WIDTH_TILES = 24f;
    private static final float UPDATE_INTERVAL = 0.1f;
    private static final float CAMERA_LERP = 5.0f;
    private static final float BATTLE_UI_FADE_DURATION = 0.5f;
    private static final float BATTLE_SCREEN_WIDTH = 800;
    private static final float BATTLE_SCREEN_HEIGHT = 480;
    private static final float MOVEMENT_REPEAT_DELAY = 0.1f;
    public static boolean SHOW_DEBUG_INFO = false;
    private final CreatureCaptureGame game;
    private final ScheduledExecutorService screenInitScheduler = Executors.newSingleThreadScheduledExecutor();
    private final AtomicBoolean initializationComplete = new AtomicBoolean(false);
    private final AtomicBoolean starterSelectionInProgress = new AtomicBoolean(false);
    private final CommandManager commandManager;
    public boolean isMultiplayer;
    Actor aButton;
    Actor zButton;
    Actor xButton;
    Actor yButton;
    Actor startButton;
    Actor selectButton;
    private ChestInteractionHandler chestHandler = new ChestInteractionHandler();
    private float ACTION_BUTTON_SIZE;
    private float DPAD_SIZE;
    private float BUTTON_PADDING;
    private Vector2 joystickCenter = new Vector2();
    private Vector2 joystickCurrent = new Vector2();
    private int initializationTimer = 0;
    private ServerStorageSystem storageSystem;
    private Stage pokemonPartyStage;
    private PokemonPartyUI pokemonPartyUI;
    private ChatSystem chatSystem;
    private Table partyDisplay;
    private float updateTimer = 0;
    private BitmapFont font;
    private OrthographicCamera camera;
    private InputHandler inputHandler;
    private String username;
    private Rectangle inventoryButton;
    private Rectangle menuButton;
    private ShapeRenderer shapeRenderer;
    private Skin skin;
    private Skin uiSkin;
    private Stage stage;
    private FitViewport cameraViewport;
    private boolean transitioning = false;
    private boolean controlsInitialized = false;
    private StarterSelectionTable starterTable;
    private boolean inputBlocked = false;
    private float debugTimer = 0;
    private boolean initializedworld = false;
    private volatile boolean isDisposing = false;
    private BattleTable battleTable;
    private BattleAssets battleAssets;
    private Skin battleSkin;
    private boolean inBattle = false;
    private Stage battleStage;
    private boolean battleInitialized = false;
    private boolean battleUIFading = false;
    private Table androidControlsTable;
    private Table closeButtonTable;
    private Table dpadTable;
    private Rectangle upButton, downButton, leftButton, rightButton;
    private String currentDpadDirection = null;
    private float movementTimer = 0f;
    private boolean isHoldingDirection = false;
    private boolean isRunPressed = false;
    private AndroidMovementController movementController;
    private Runnable pendingStarterInit = null;
    private volatile boolean awaitingStarterSelection = false;
    private BattleSystemHandler battleSystem;
    private boolean commandsEnabled = false;
    private InputManager inputManager;
    private ChestScreen chestScreen;

    public GameScreen(CreatureCaptureGame game, String username, GameClient gameClient) {
        this.game = game;
        this.username = username;
        GameContext.get().setGameClient(gameClient);
        this.commandManager = new CommandManager();
        registerAllCommands();
        this.isMultiplayer = !gameClient.isSinglePlayer();

        GameContext.get().setUiStage(new Stage(new ScreenViewport()));
        this.battleSystem = new BattleSystemHandler();
        try {
            // Initialize basic UI first
            initializeBasicResources();

            initializeWorldAndPlayer();
            this.inputManager = new InputManager(this);
            Player player = GameContext.get().getPlayer();
            // Check if new player needs starter
            if (player != null && player.getPokemonParty().getSize() == 0) {
                GameLogger.info("New player detected - handling starter selection");
                handleNewPlayer();
            } else {
                completeInitialization();
            }
            this.inputManager.updateInputProcessors();

        } catch (Exception e) {
            GameLogger.error("GameScreen initialization failed: " + e.getMessage());
            throw new RuntimeException("Failed to initialize game screen", e);
        }
    }

    public GameScreen(CreatureCaptureGame game, String username, GameClient gameClient, boolean commandsEnabled) {
        this.game = game;
        this.username = username;
        this.commandsEnabled = commandsEnabled;
        this.commandManager = new CommandManager();
        registerAllCommands();
        GameContext.get().setGameClient(gameClient);
        this.isMultiplayer = !gameClient.isSinglePlayer();
        GameContext.get().setUiStage(new Stage(new ScreenViewport()));

        this.battleSystem = new BattleSystemHandler();
        try {
            // Initialize basic UI first
            initializeBasicResources();

            initializeWorldAndPlayer();
            this.inputManager = new InputManager(this);
            Player player = GameContext.get().getPlayer();
            // Check if new player needs starter
            if (player != null && player.getPokemonParty().getSize() == 0) {
                GameLogger.info("New player detected - handling starter selection");
                handleNewPlayer();
            } else {
                // Complete normal initialization
                completeInitialization();
            }

        } catch (Exception e) {
            GameLogger.error("GameScreen initialization failed: " + e.getMessage());
            throw new RuntimeException("Failed to initialize game screen", e);
        }
    }

    public Skin getSkin() {
        return skin;
    }

    public InputManager getInputManager() {
        return inputManager;
    }

    public CreatureCaptureGame getGame() {
        return game;
    }

    public StarterSelectionTable getStarterTable() {
        return starterTable;
    }

    public InputHandler getInputHandler() {
        return inputHandler;
    }

    public Stage getUiStage() {
        return GameContext.get().getUiStage();
    }


    public CraftingTableScreen getCraftingScreen() {
        return GameContext.get().getCraftingScreen();
    }

    public void setCraftingScreen(CraftingTableScreen craftingScreen) {
        GameContext.get().setCraftingScreen(craftingScreen);
    }

    public BattleTable getBattleTable() {
        return battleTable;
    }

    public GameMenu getGameMenu() {
        return GameContext.get().getGameMenu();
    }

    public void setGameMenu(GameMenu gameMenu) {
        GameContext.get().setGameMenu(gameMenu);
    }

    public Stage getBattleStage() {
        return battleStage;
    }

    public InventoryScreen getInventoryScreen() {
        return GameContext.get().getInventoryScreen();
    }


    public BuildModeUI getBuildModeUI() {
        return GameContext.get().getBuildModeUI();
    }

    public ChestInteractionHandler getChestHandler() {
        return chestHandler;
    }

    public OrthographicCamera getCamera() {
        return camera;
    }

    private void handleNewPlayer() {
        starterSelectionInProgress.set(true);
        Gdx.app.postRunnable(() -> {
            try {
                starterTable = new StarterSelectionTable(skin);
                starterTable.setSelectionListener(new StarterSelectionTable.SelectionListener() {
                    @Override
                    public void onStarterSelected(Pokemon starter) {
                        handleStarterSelection(starter);
                    }

                    @Override
                    public void onSelectionStart() {
                        // Input is now going to the starter table
                        inputBlocked = true;
                    }
                });

                starterTable.setFillParent(true);
                starterTable.setTouchable(Touchable.enabled); // Ensure table is interactable
                GameContext.get().getUiStage().addActor(starterTable);

                // Give UI stage input focus
                Gdx.input.setInputProcessor(GameContext.get().getUiStage());
                GameContext.get().getUiStage().setKeyboardFocus(starterTable);

                // Update input manager state
                inputManager.setUIState(InputManager.UIState.STARTER_SELECTION);
                inputManager.updateInputProcessors();

                GameLogger.info("Starter selection UI initialized and input set to uiStage.");

            } catch (Exception e) {
                GameLogger.error("Error creating starter selection UI: " + e.getMessage() + e);
            }
        });
    }

    public void openChestScreen(Vector2 chestPosition, ChestData chestData) {
        // Initialize chest screen as needed
        if (chestScreen == null) {
            chestScreen = new ChestScreen(GameContext.get().getPlayer(), skin, chestData, chestPosition, this);
        }
        chestScreen.show();
        inputManager.setUIState(InputManager.UIState.CHEST_SCREEN);
    }

    public void closeChestScreen() {
        if (chestScreen != null) {
            chestScreen.hide();
        }
        inputManager.setUIState(InputManager.UIState.NORMAL);
    }

    // In GameScreen.java
    public void openExpandedCrafting(Vector2 craftingTablePosition) {
        if (GameContext.get().getCraftingScreen() == null) {
            GameContext.get().setCraftingScreen(new CraftingTableScreen(
                GameContext.get().getPlayer(),
                skin,
                GameContext.get().getWorld(),
                GameContext.get().getGameClient(), this, inputManager
            ));
        }
        GameContext.get().getCraftingScreen().updatePosition(craftingTablePosition);
        inputManager.setUIState(InputManager.UIState.CRAFTING);
    }

    public void closeExpandedCrafting() {
        inputManager.setUIState(InputManager.UIState.NORMAL);
        if (GameContext.get().getCraftingScreen() != null) {
            GameContext.get().getCraftingScreen().hide();
        }
    }

    private void handleMultiplayerInitialization(boolean success) {
        if (success) {
            try {
                initializeWorldAndPlayer();

                if (GameContext.get().getPlayer() != null && GameContext.get().getPlayer().getPokemonParty().getSize() == 0) {
                    GameLogger.info("New player detected - handling starter selection");
                    awaitingStarterSelection = true;
                    starterSelectionInProgress.set(true);
                    initializationComplete.set(false);

                    Gdx.app.postRunnable(() -> {
                        try {
                            if (starterTable != null) {
                                starterTable.remove();
                            }

                            GameLogger.info("Creating StarterSelectionTable");
                            starterTable = new StarterSelectionTable(skin);
                            starterTable.setSelectionListener(new StarterSelectionTable.SelectionListener() {
                                @Override
                                public void onStarterSelected(Pokemon starter) {
                                    handleStarterSelection(starter);
                                }

                                @Override
                                public void onSelectionStart() {
                                    inputBlocked = true;
                                }
                            });

                            starterTable.setFillParent(true);
                            stage.addActor(starterTable);
                            starterTable.toFront();
                            InputMultiplexer multiplexer = new InputMultiplexer();
                            multiplexer.addProcessor(stage);

                            GameLogger.info("Starter selection UI initialized");

                        } catch (Exception e) {
                            GameLogger.error("Failed to create starter selection: " + e.getMessage());
                            handleInitializationFailure();
                        }
                    });

                    return;
                }
                completeInitialization();

            } catch (Exception e) {
                GameLogger.error("Failed to initialize multiplayer: " + e.getMessage());
                handleInitializationFailure();
            }
        } else {
            handleInitializationFailure();
        }
    }

    @Override
    public void show() {
        if (GameContext.get().getPlayer() != null) {
            GameContext.get().getPlayer().initializeResources();
        }
        initializeBuildMode();

        if (pendingStarterInit != null) {
            Gdx.app.postRunnable(pendingStarterInit);
            pendingStarterInit = null;
            return;
        }

        inputManager.updateInputProcessors(); // Ensure InputManager sets up InputProcessors

        if (GameContext.get().getWorld() != null && GameContext.get().getPlayer() != null) {
            Vector2 playerPos = new Vector2(GameContext.get().getPlayer().getTileX(), GameContext.get().getPlayer().getTileY());
            GameContext.get().getWorld().requestInitialChunks(playerPos);
            GameLogger.info("Requested initial chunks around player at: " + playerPos);
        }
        GameContext.get().getUiStage().setKeyboardFocus(null);
        GameLogger.info("Keyboard focus set to null to prevent input blocking");
    }

    private void handleClientInitialization(boolean success) {
        if (success) {
            Gdx.app.postRunnable(() -> {
                try {
                    initializeWorld();

                    if (GameContext.get().getPlayer() != null) {
                        if (GameContext.get().getPlayer().getPokemonParty() == null) {
                            GameContext.get().getPlayer().setPokemonParty(new PokemonParty());
                        }

                        // Initialize player data if needed
                        if (GameContext.get().getPlayer().getPlayerData() == null) {
                            PlayerData newData = new PlayerData(GameContext.get().getPlayer().getUsername());
                            GameContext.get().getPlayer().updateFromPlayerData(newData);
                        }

                        GameContext.get().getPlayer().initializeResources();
                    }

                    // Check for starter Pokemon requirement
                    if (GameContext.get().getPlayer() != null && GameContext.get().getPlayer().getPokemonParty().getSize() == 0) {
                        GameLogger.info("New player detected - initiating starter selection");
                        awaitingStarterSelection = true;
                        initiateStarterSelection();
                        return;
                    }

                    completeInitialization();

                    GameLogger.info("Client initialization complete");

                } catch (Exception e) {
                    GameLogger.error("CRITICAL - Error during initialization: " + e.getMessage());
                    handleInitializationFailure();
                }
            });
        } else {
            handleInitializationFailure();
        }
    }

    private void registerAllCommands() {
        GameLogger.info("Registering commands...");
        commandManager.registerCommand(new GiveCommand());
        commandManager.registerCommand(new SpawnCommand());
        commandManager.registerCommand(new SetWorldSpawnCommand());
        commandManager.registerCommand(new TeleportPositionCommand());
    }

    private void completeInitialization() {
        try {
            initializeGameSystems();
            inputManager.updateInputProcessors();

            initializationComplete.set(true);
            GameLogger.info("Game initialization complete");

        } catch (Exception e) {
            GameLogger.error("Failed to complete initialization: " + e.getMessage());
            game.setScreen(new LoginScreen(game));
        }
    }

    public boolean isInitialized() {
        boolean isInitComplete = initializationComplete.get();
        boolean isStarterInProgress = starterSelectionInProgress.get();
        GameLogger.info("isInitialized() called - initializationComplete: " + isInitComplete +
            ", starterSelectionInProgress: " + isStarterInProgress);
        return isInitComplete || isStarterInProgress;
    }

    public void setInitialized(boolean initialized) {
        this.initializedworld = initialized;
    }

    public GameClient getGameClient() {
        return GameContext.get().getGameClient();
    }

    private void initializeBasicResources() {
        GameLogger.info("Initializing basic resources");

        try {
            // 1. Graphics resources
            GameContext.get().setBatch(new SpriteBatch());
            SpriteBatch uiBatch = new SpriteBatch();
            this.shapeRenderer = new ShapeRenderer();

            // 2. Camera and viewport setup - CRITICAL: Do this first
            this.camera = new OrthographicCamera();
            float baseWidth = TARGET_VIEWPORT_WIDTH_TILES * TILE_SIZE;
            float baseHeight = baseWidth * ((float) Gdx.graphics.getHeight() / Gdx.graphics.getWidth());
            this.cameraViewport = new FitViewport(baseWidth, baseHeight, camera);
            camera.position.set(baseWidth / 2f, baseHeight / 2f, 0); // Set initial position
            camera.update();
            cameraViewport.update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);

            // 3. UI resources
            this.skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));
            this.uiSkin = this.skin;
            this.font = new BitmapFont(Gdx.files.internal("Skins/default.fnt"));

            // 4. Stages with viewports
            GameContext.get().setUiStage(new Stage(new ScreenViewport(), uiBatch));
            this.pokemonPartyStage = new Stage(new ScreenViewport());
            this.stage = new Stage(new ScreenViewport());
            this.battleStage = new Stage(new FitViewport(BATTLE_SCREEN_WIDTH, BATTLE_SCREEN_HEIGHT));

            GameLogger.info("Basic resources initialized successfully");
        } catch (Exception e) {
            GameLogger.error("Failed to initialize basic resources: " + e.getMessage());
            throw new RuntimeException("Failed to initialize basic resources", e);
        }
    }

    private void initializeChatSystem() {
        if (chatSystem != null) {
            return;
        }

        float screenWidth = Gdx.graphics.getWidth();
        float screenHeight = Gdx.graphics.getHeight();
        float chatWidth = Math.max(ChatSystem.MIN_CHAT_WIDTH, screenWidth * 0.25f);
        float chatHeight = Math.max(ChatSystem.MIN_CHAT_HEIGHT, screenHeight * 0.3f);

        // Pass commandsEnabled to ChatSystem
        chatSystem = new ChatSystem(GameContext.get().getUiStage(), skin, GameContext.get().getGameClient(), username, commandManager, commandsEnabled);
        GameLogger.info("Chat system initialized. Commands " +
            (commandsEnabled ? "enabled" : "disabled"));
        chatSystem.setSize(chatWidth, chatHeight);
        chatSystem.setPosition(
            ChatSystem.CHAT_PADDING,
            screenHeight - chatHeight - ChatSystem.CHAT_PADDING
        );

        // Set up chat system properties
        chatSystem.setZIndex(Integer.MAX_VALUE);
        chatSystem.setVisible(true);
        chatSystem.setTouchable(Touchable.enabled);

        // Create background
        Pixmap bgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(0, 0, 0, 0.8f);
        bgPixmap.fill();
        TextureRegion bgTexture = new TextureRegion(new Texture(bgPixmap));
        chatSystem.setBackground(new TextureRegionDrawable(bgTexture));
        bgPixmap.dispose();

        // Add to UI stage
        GameContext.get().getUiStage().addActor(chatSystem);
        chatSystem.toFront();

        GameLogger.info("Chat system initialized at: " + ChatSystem.CHAT_PADDING + "," +
            (screenHeight - chatHeight - ChatSystem.CHAT_PADDING));
    }

    private void initializeWorldAndPlayer() {
        GameLogger.info("Initializing world and player");

        try {
            // 1. Initialize or obtain world
            if (GameContext.get().getWorld() == null) {
                if (isMultiplayer) {
                    GameContext.get().setWorld(GameContext.get().getGameClient().getCurrentWorld());
                    if (GameContext.get().getWorld() == null) {
                        throw new IllegalStateException("No world available from GameClient");
                    }
                } else {
                    GameContext.get().setWorld(new World(
                        "singleplayer_world",
                        System.currentTimeMillis(),
                        new BiomeManager(System.currentTimeMillis())
                    ));
                }
            }

            // 2. Set up player
            if (isMultiplayer) {
                GameContext.get().setPlayer(GameContext.get().getGameClient().getActivePlayer());
                if (GameContext.get().getPlayer() == null) {
                    throw new IllegalStateException("No player available from GameClient");
                }
            } else {
                GameContext.get().setPlayer(game.getPlayer());
                if (GameContext.get().getPlayer() == null) {
                    GameContext.get().setPlayer(new Player(username, GameContext.get().getWorld()));
                }
            }

            // 3. Initialize world data and components
            if (isMultiplayer) {
                GameContext.get().getWorld().initializeFromServer(
                    GameContext.get().getGameClient().getWorldSeed(),
                    GameContext.get().getWorld().getWorldData().getWorldTimeInMinutes(),
                    GameContext.get().getWorld().getWorldData().getDayLength()
                );
            }

            // 4. Initialize player resources and world connection
            GameContext.get().getPlayer().initializeResources();
            GameContext.get().getPlayer().initializeInWorld(GameContext.get().getWorld());
            GameContext.get().getWorld().setPlayer(GameContext.get().getPlayer());
            GameContext.get().getPlayer().setRenderPosition(GameContext.get().getPlayer().getPosition());
            // 5. Load initial chunks around player
            Vector2 playerPos = new Vector2(
                (float) GameContext.get().getPlayer().getTileX() / World.CHUNK_SIZE,
                (float) GameContext.get().getPlayer().getTileY() / World.CHUNK_SIZE
            );
            GameContext.get().getWorld().loadChunksAroundPositionSynchronously(playerPos, INITIAL_LOAD_RADIUS);

            if (!GameContext.get().getWorld().areAllChunksLoaded()) {
                GameLogger.info("Forcing load of missing chunks...");
                GameContext.get().getWorld().forceLoadMissingChunks();
            }

            if (camera != null) {
                camera.position.set(
                    GameContext.get().getPlayer().getX() + Player.FRAME_WIDTH / 2f,
                    GameContext.get().getPlayer().getY() + Player.FRAME_HEIGHT / 2f,
                    0
                );
                camera.update();
            }


        } catch (Exception e) {
            GameLogger.error("Failed to initialize world and player: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }


    private void initializeGameSystems() {

        // 1. Camera and viewport
        setupCamera();

        initializeChatSystem();

        // 2. Input handling
        this.chestHandler = new ChestInteractionHandler();
        this.inputHandler = new InputHandler(this, this, this, chestHandler, inputManager);

        // 4. UI Components
        GameContext.get().setGameMenu(new GameMenu(game, uiSkin, inputManager));
        createPartyDisplay();

        // 5. Battle assets
        initializeBattleAssets();

        // 6. Platform specific
        if (Gdx.app.getType() == Application.ApplicationType.Android) {
            this.movementController = new AndroidMovementController(GameContext.get().getPlayer(), inputHandler);
            initializeAndroidControls();
        }

        GameLogger.info("Game systems initialized successfully");
    }

    private void initializeBattleAssets() {
        try {
            battleAssets = new BattleAssets();
            battleAssets.initialize();


            try {
                FileHandle skinFile = Gdx.files.internal("atlas/ui-gfx-atlas.json");
                if (skinFile.exists()) {
                    battleSkin = new Skin(skinFile);
                    battleSkin.addRegions(TextureManager.getUi());
                    GameLogger.info("Battle skin loaded successfully");
                } else {
                    GameLogger.info("No battle skin found - using default styles");
                    // Continue without skin - will use direct texture regions
                }
            } catch (Exception skinEx) {
                GameLogger.error("Could not load battle skin: " + skinEx.getMessage() + " - continuing without skin");
                // Continue without skin
                if (battleSkin != null) {
                    battleSkin.dispose();
                    battleSkin = null;
                }
            }

        } catch (Exception e) {
            GameLogger.error("Failed to initialize battle assets: " + e.getMessage());
            cleanup();
            throw new RuntimeException("Battle initialization failed", e);
        }
    }

    private void retryInitialization() {
        initializationComplete.set(false);

        try {
            if (GameContext.get().getGameClient() != null) {
                GameContext.get().getGameClient().connect();
            }
        } catch (Exception e) {
            GameLogger.error("Failed to retry initialization: " + e.getMessage());
            handleClientInitialization(false);
        }
    }

    private void initializeWorld() {
        try {
            if (isMultiplayer) {
                GameContext.get().setPlayer(GameContext.get().getGameClient().getActivePlayer());
            } else {
                GameContext.get().setPlayer(game.getPlayer());

            }
            if (GameContext.get().getWorld() != null) {
                GameContext.get().setWorld(GameContext.get().getGameClient().getCurrentWorld());
                GameLogger.info("Using existing world from GameClient");
                return;
            } else if (GameContext.get().getWorld() == null) {
                String defaultWorldName = isMultiplayer ?
                    CreatureCaptureGame.MULTIPLAYER_WORLD_NAME :
                    "singleplayer_world";
                GameLogger.info("No world name provided, using default: " + defaultWorldName);
                GameContext.get().setWorld(new World(
                    defaultWorldName,
                    GameContext.get().getGameClient().getWorldSeed(),
                    new BiomeManager(GameContext.get().getGameClient().getWorldSeed())
                ));
            }
            if (GameContext.get().getPlayer() != null) {
                GameContext.get().getPlayer().initializeInWorld(GameContext.get().getWorld());
                GameContext.get().getWorld().setPlayer(GameContext.get().getPlayer());
                GameContext.get().getPlayer().setWorld(GameContext.get().getWorld());
            }
            this.storageSystem = new ServerStorageSystem();

            GameLogger.info("World initialization complete");

        } catch (Exception e) {
            GameLogger.error("Failed to initialize world: " + e.getMessage());
            throw new RuntimeException("World initialization failed", e);
        }
    }

    private void handleInitializationFailure() {
        Gdx.app.postRunnable(() -> {
            Dialog dialog = new Dialog("Initialization Error", skin) {
                @Override
                protected void result(Object obj) {
                    if ((Boolean) obj) {
                        // Retry initialization
                        handleMultiplayerInitialization(true);
                    } else {
                        // Return to login screen
                        game.setScreen(new LoginScreen(game));
                    }
                }
            };

            dialog.text("Failed to initialize game. Would you like to retry?");
            dialog.button("Retry", true);
            dialog.button("Cancel", false);
            dialog.show(stage);
        });
    }

    public ChatSystem getChatSystem() {
        return chatSystem;
    }

    public void toggleInventory() {
        if (inputManager.getCurrentState() == InputManager.UIState.INVENTORY) {
            inputManager.setUIState(InputManager.UIState.NORMAL);
            if (GameContext.get().getInventoryScreen() != null) {
                GameContext.get().getInventoryScreen().hide();
            }
        } else {
            inputManager.setUIState(InputManager.UIState.INVENTORY);
            if (GameContext.get().getInventoryScreen() == null) {
                GameContext.get().setInventoryScreen(new InventoryScreen(GameContext.get().getPlayer(), skin, GameContext.get().getPlayer().getInventory(), inputManager));
            }
            GameContext.get().getInventoryScreen().show();
            inputManager.updateInputProcessors();
        }
    }

    public void toggleGameMenu() {
        if (inputManager.getCurrentState() == InputManager.UIState.MENU) {
            inputManager.setUIState(InputManager.UIState.NORMAL);
        } else {
            inputManager.setUIState(InputManager.UIState.MENU);
        }
    }

    private void initializeBattleComponents(Pokemon validPokemon, WildPokemon nearestPokemon) {
        // Lock Pokemon in place
        battleSystem.lockPokemonForBattle(nearestPokemon);

        // Initialize battle stage
        battleStage = new Stage(new FitViewport(800, 480));
        battleStage.getViewport().update(
            Gdx.graphics.getWidth(),
            Gdx.graphics.getHeight(),
            true
        );

        // Create battle table
        battleTable = new BattleTable(
            battleStage,
            battleSkin,
            validPokemon,
            nearestPokemon
        );

        battleTable.setFillParent(true);
        battleTable.setVisible(true);
        battleStage.addActor(battleTable);

        setupBattleCallbacks(nearestPokemon);
        battleInitialized = true;
    }

    private void handleStarterSelection(Pokemon starter) {
        try {
            GameLogger.info("Processing starter selection: " + starter.getName());
            GameContext.get().getPlayer().getPokemonParty().addPokemon(starter);
            GameContext.get().getPlayer().updatePlayerData();

            // Save if multiplayer
            if (!GameContext.get().getGameClient().isSinglePlayer()) {
                GameContext.get().getGameClient().savePlayerState(GameContext.get().getPlayer().getPlayerData());
            }

            // Remove starter selection UI
            if (starterTable != null) {
                starterTable.remove();
                starterTable = null;
            }

            // Reset input block and state
            inputBlocked = false;
            inputManager.setUIState(InputManager.UIState.NORMAL);
            inputManager.updateInputProcessors();

            // Also clear keyboard focus
            if (GameContext.get().getUiStage() != null) {
                GameContext.get().getUiStage().setKeyboardFocus(null);
                GameContext.get().getUiStage().unfocusAll();
            }

            completeInitialization();
            GameLogger.info("Starter selection complete - proceeding with initialization");

        } catch (Exception e) {
            GameLogger.error("Failed to process starter selection: " + e.getMessage() + e);
        }
    }

    private void initiateStarterSelection() {
        GameLogger.info("CRITICAL - Initiating starter selection");
        starterSelectionInProgress.set(true);

        try {

            if (GameContext.get().getUiStage() == null) {
                GameContext.get().setUiStage(new Stage(new ScreenViewport()));
            }

            inputManager.updateInputProcessors();

            if (starterTable == null) {
                starterTable = new StarterSelectionTable(skin);
                starterTable.setSelectionListener(new StarterSelectionTable.SelectionListener() {
                    @Override
                    public void onStarterSelected(Pokemon starter) {
                        handleStarterSelection(starter);
                    }

                    @Override
                    public void onSelectionStart() {
                        inputBlocked = true;
                    }
                });

                starterTable.setFillParent(true);
                GameContext.get().getUiStage().addActor(starterTable);
                starterTable.toFront();
            }

            GameLogger.info("Starter selection UI initialized");

        } catch (Exception e) {
            GameLogger.error("Failed to initialize starter selection: " + e.getMessage());
            handleStarterSelectionError(e);
        }
    }

    private void handleStarterSelectionError(Exception e) {
        GameLogger.error("Starter selection error: " + e.getMessage());

        Gdx.app.postRunnable(() -> {
            // Clean up any partial state
            if (starterTable != null) {
                starterTable.remove();
                starterTable = null;
            }

            // Show error dialog
            Dialog dialog = new Dialog("Error", skin) {
                @Override
                protected void result(Object obj) {
                    if ((Boolean) obj) {
                        // Retry starter selection
                        initiateStarterSelection();
                    } else {
                        // Return to login screen
                        game.setScreen(new LoginScreen(game));
                    }
                }
            };

            dialog.text("Failed to process starter selection.\nWould you like to try again?");
            dialog.button("Retry", true);
            dialog.button("Back to Login", false);
            dialog.show(GameContext.get().getUiStage());
        });
    }

    private void handleInitializationError() {
        GameLogger.error("Game initialization failed");

        Gdx.app.postRunnable(() -> {
            Dialog dialog = new Dialog("Error", skin) {
                @Override
                protected void result(Object obj) {
                    if ((Boolean) obj) {
                        // Retry initialization
                        retryInitialization();
                    } else {
                        // Return to login screen
                        game.setScreen(new LoginScreen(game));
                    }
                }
            };

            dialog.text("Failed to initialize game. Would you like to retry?");
            dialog.button("Retry", true);
            dialog.button("Cancel", false);
            dialog.show(stage);
        });
    }

    private void createPartyDisplay() {
        partyDisplay = new Table();
        partyDisplay.setFillParent(true);
        partyDisplay.bottom();
        partyDisplay.padBottom(20f);

        Table slotsTable = new Table();
        slotsTable.setBackground(
            new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg"))
        );
        slotsTable.pad(4f);

        List<Pokemon> party = GameContext.get().getPlayer().getPokemonParty().getParty();

        for (int i = 0; i < PokemonParty.MAX_PARTY_SIZE; i++) {
            Pokemon pokemon = (party.size() > i) ? party.get(i) : null;
            Table slotCell = createPartySlotCell(i, pokemon);
            slotsTable.add(slotCell).size(64).pad(2);
        }

        partyDisplay.add(slotsTable);
        GameContext.get().getUiStage().addActor(partyDisplay);
    }

    @Override
    public void hide() {

    }

    private void ensureSaveDirectories() {
        FileHandle saveDir = Gdx.files.local("save");
        if (!saveDir.exists()) {
            saveDir.mkdirs();
        }
    }

    public World getWorld() {
        return GameContext.get().getWorld();
    }

    public Player getPlayer() {
        return GameContext.get().getPlayer();
    }

    private Table createPartySlotCell(int index, Pokemon pokemon) {
        Table cell = new Table();
        boolean isSelected = index == 0;

        TextureRegionDrawable slotBg = new TextureRegionDrawable(
            TextureManager.ui.findRegion(isSelected ? "slot_selected" : "slot_normal")
        );
        cell.setBackground(slotBg);

        if (pokemon != null) {
            Table contentStack = new Table();
            contentStack.setFillParent(true);

            Image pokemonIcon = new Image(pokemon.getCurrentIconFrame(Gdx.graphics.getDeltaTime()));
            pokemonIcon.setScaling(Scaling.fit);

            contentStack.add(pokemonIcon).size(40).padTop(4).row();

            Label levelLabel = new Label("Lv." + pokemon.getLevel(), skin);
            levelLabel.setFontScale(0.8f);
            contentStack.add(levelLabel).padTop(2).row();

            ProgressBar hpBar = new ProgressBar(0, pokemon.getStats().getHp(), 1, false, skin);
            hpBar.setValue(pokemon.getCurrentHp());
            contentStack.add(hpBar).width(40).height(4).padTop(2);

            cell.add(contentStack).expand().fill();
        }

        return cell;
    }

    private void updateSlotVisuals() {
        partyDisplay.clearChildren();
        createPartyDisplay();
    }

    public PlayerData getCurrentPlayerState() {
        PlayerData currentState = new PlayerData(GameContext.get().getPlayer().getUsername());
        // Use InventoryConverter to extract inventory data
        InventoryConverter.extractInventoryDataFromPlayer(GameContext.get().getPlayer(), currentState);
        return currentState;
    }

    private boolean isPokemonPartyVisible() {
        return pokemonPartyUI != null && pokemonPartyUI.isVisible();
    }

    private void updateAndroidControlPositions() {
        if (Gdx.app.getType() != Application.ApplicationType.Android) {
            return;
        }

        try {
            float screenWidth = Gdx.graphics.getWidth();
            float screenHeight = Gdx.graphics.getHeight();
            float buttonSize = screenHeight * 0.1f;
            float padding = buttonSize * 0.5f;

            if (joystickCenter == null) {
                joystickCenter = new Vector2(screenWidth * 0.15f, screenHeight * 0.2f);
            } else {
                joystickCenter.set(screenWidth * 0.15f, screenHeight * 0.2f);
            }

            if (joystickCurrent == null) {
                joystickCurrent = new Vector2(joystickCenter);
            } else {
                joystickCurrent.set(joystickCenter);
            }
            if (inventoryButton == null) {
                inventoryButton = new Rectangle(
                    screenWidth - (buttonSize * 2 + padding * 2),
                    screenHeight - (buttonSize + padding),
                    buttonSize,
                    buttonSize
                );
            } else {
                inventoryButton.set(
                    screenWidth - (buttonSize * 2 + padding * 2),
                    screenHeight - (buttonSize + padding),
                    buttonSize,
                    buttonSize
                );
            }

            if (menuButton == null) {
                menuButton = new Rectangle(
                    screenWidth - (buttonSize + padding),
                    screenHeight - (buttonSize + padding),
                    buttonSize,
                    buttonSize
                );
            } else {
                menuButton.set(
                    screenWidth - (buttonSize + padding),
                    screenHeight - (buttonSize + padding),
                    buttonSize,
                    buttonSize
                );
            }

            GameLogger.info("Updated Android controls - Screen: " + screenWidth + "x" + screenHeight +
                ", Joystick at: " + joystickCenter.x + "," + joystickCenter.y);

        } catch (Exception e) {
            GameLogger.error("Error updating Android controls: " + e.getMessage());
            e.printStackTrace();

            initializeAndroidControlsSafe();
        }
    }

    private void initializeAndroidControlsSafe() {
        try {
            float screenWidth = Math.max(Gdx.graphics.getWidth(), 480); // Minimum safe width
            float screenHeight = Math.max(Gdx.graphics.getHeight(), 320); // Minimum safe height
            float buttonSize = Math.min(screenHeight * 0.1f, 64); // Limit maximum size
            float padding = buttonSize * 0.5f;

            joystickCenter = new Vector2(screenWidth * 0.15f, screenHeight * 0.2f);
            joystickCurrent = new Vector2(joystickCenter);

            inventoryButton = new Rectangle(
                screenWidth - (buttonSize * 2 + padding * 2),
                screenHeight - (buttonSize + padding),
                buttonSize,
                buttonSize
            );

            menuButton = new Rectangle(
                screenWidth - (buttonSize + padding),
                screenHeight - (buttonSize + padding),
                buttonSize,
                buttonSize
            );

            GameLogger.info("Initialized safe Android controls");
        } catch (Exception e) {
            GameLogger.error("Failed to initialize safe Android controls: " + e.getMessage());
        }
    }

    private void ensureAndroidControlsInitialized() {
        if (Gdx.app.getType() == Application.ApplicationType.Android &&
            (joystickCenter == null || joystickCurrent == null ||
                inventoryButton == null || menuButton == null)) {

            initializeAndroidControlsSafe();
        }
    }

    private boolean canInteract() {
        // Check if player is in battle or menu
        if (inBattle) {
            return false;
        }

        // Check if any animations or transitions are happening
        return !transitioning && !inputBlocked;
    }

    @Override
    public void handleBattleInitiation() {
        if (!canInteract()) {
            GameLogger.info("Cannot start battle - player is busy");
            return;
        }

        if (battleSystem.isInBattle()) {
            GameLogger.info("Battle already in progress");
            return;
        }

        WildPokemon nearestPokemon = GameContext.get().getWorld().getNearestInteractablePokemon(GameContext.get().getPlayer());
        if (nearestPokemon == null || nearestPokemon.isAddedToParty()) {
            return;
        }

        // Check for valid Pokemon
        if (GameContext.get().getPlayer().getPokemonParty() == null || GameContext.get().getPlayer().getPokemonParty().getSize() == 0) {
            if (chatSystem != null) {
                NetworkProtocol.ChatMessage message = createSystemMessage(
                    "You need a Pokemon to battle!");
                chatSystem.handleIncomingMessage(message);
            }
            GameLogger.info("Cannot battle - player has no Pokemon");
            return;
        }

        Pokemon validPokemon = findFirstValidPokemon(GameContext.get().getPlayer().getPokemonParty());
        if (validPokemon == null) {
            if (chatSystem != null) {
                NetworkProtocol.ChatMessage message = createSystemMessage(
                    "All your Pokemon need to be healed!");
                chatSystem.handleIncomingMessage(message);
            }
            GameLogger.info("Cannot battle - no healthy Pokemon");
            return;
        }

        try {
            // Initialize battle components first
            initializeBattleComponents(validPokemon, nearestPokemon);

            // Then let UIControlManager handle the state transition
            inputManager.setUIState(InputManager.UIState.BATTLE);

            // Start battle system after UI transition begins
            battleSystem.startBattle();
            inBattle = true;

            GameLogger.info("Battle initialized successfully with " +
                validPokemon.getName() + " vs " + nearestPokemon.getName());

        } catch (Exception e) {
            GameLogger.error("Failed to initialize battle: " + e.getMessage());
            cleanup();
            battleSystem.endBattle();
        }
    }

    private Pokemon findFirstValidPokemon(PokemonParty party) {
        if (party == null) return null;

        for (Pokemon pokemon : party.getParty()) {
            if (pokemon != null && pokemon.getCurrentHp() > 0) {
                return pokemon;
            }
        }
        return null;
    }

    private void setupBattleCallbacks(WildPokemon wildPokemon) {
        if (battleTable == null) {
            GameLogger.error("Cannot setup callbacks - battleTable is null");
            return;
        }

        battleTable.setCallback(new BattleTable.BattleCallback() {
            @Override
            public void onBattleEnd(boolean playerWon) {
                if (playerWon) {
                    handleBattleVictory(wildPokemon);
                    wildPokemon.startDespawnAnimation();

                    Timer.schedule(new Timer.Task() {
                        @Override
                        public void run() {
                            if (GameContext.get().getWorld() != null && GameContext.get().getWorld().getPokemonSpawnManager() != null) {
                                GameContext.get().getWorld().getPokemonSpawnManager().removePokemon(wildPokemon.getUuid());
                            }
                        }
                    }, 1.5f);

                    if (chatSystem != null) {
                        NetworkProtocol.ChatMessage message = createSystemMessage(
                            "Victory! " + GameContext.get().getPlayer().getPokemonParty().getFirstPokemon().getName() +
                                " defeated " + wildPokemon.getName() + "!"
                        );
                        chatSystem.handleIncomingMessage(message);
                    }
                } else {
                    // Handle defeat
                    handleBattleDefeat();

                    // Release wild Pokemon
                    if (wildPokemon.getAi() != null) {
                        wildPokemon.getAi().setPaused(false);
                    }

                    if (chatSystem != null) {
                        NetworkProtocol.ChatMessage message = createSystemMessage(
                            GameContext.get().getPlayer().getPokemonParty().getFirstPokemon().getName() +
                                " was defeated by wild " + wildPokemon.getName() + "!"
                        );
                        chatSystem.handleIncomingMessage(message);
                    }
                }

                // Clean up battle state
                battleSystem.endBattle();
                endBattle(playerWon, wildPokemon);
            }

            @Override
            public void onTurnEnd(Pokemon activePokemon) {
                GameLogger.info("Turn ended for: " + activePokemon.getName());

                // Update UI if needed
                if (pokemonPartyUI != null) {
                    pokemonPartyUI.updateUI();
                }
            }

            @Override
            public void onStatusChange(Pokemon pokemon, Pokemon.Status newStatus) {
                GameLogger.info("Status changed for " + pokemon.getName() + ": " + newStatus);

                // Show status message
                String statusMessage = pokemon.getName() + " is now " + newStatus.toString().toLowerCase() + "!";
                if (chatSystem != null) {
                    chatSystem.handleIncomingMessage(createSystemMessage(statusMessage));
                }

                if (pokemonPartyUI != null) {
                    pokemonPartyUI.updateUI();
                }

                // Play status effect sound
                if (newStatus != null) {
                    switch (newStatus) {
                        case BURNED:
                            AudioManager.getInstance().playSound(AudioManager.SoundEffect.DAMAGE);
                            break;
                        case PARALYZED:
                        case POISONED:
                        case BADLY_POISONED:
                            AudioManager.getInstance().playSound(AudioManager.SoundEffect.NOT_EFFECTIVE);
                            break;
                    }
                }
            }

            @Override
            public void onMoveUsed(Pokemon user, Move move, Pokemon target) {
                GameLogger.info(user.getName() + " used " + move.getName());

                // Play move sound
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.MOVE_SELECT);

                // Show move message
                String moveMessage = user.getName() + " used " + move.getName() + "!";
                if (chatSystem != null) {
                    chatSystem.handleIncomingMessage(createSystemMessage(moveMessage));
                }
            }
        });
    }

    public void endBattle(boolean playerWon, WildPokemon wildPokemon) {
        if (battleTable != null && battleTable.hasParent()) {
            battleTable.addAction(Actions.sequence(
                Actions.fadeOut(BATTLE_UI_FADE_DURATION),
                Actions.run(() -> {
                    try {
                        if (playerWon) {
                            handleBattleVictory(wildPokemon);
                        } else {
                            handleBattleDefeat();
                        }

                        cleanup();

                    } catch (Exception e) {
                        GameLogger.error("Error ending battle: " + e.getMessage());
                        cleanup();
                    }
                })
            ));
            battleUIFading = true;
            inBattle = false;
        } else {
            cleanup();
        }
    }

    private void cleanup() {
        if (isDisposing) return;
        isDisposing = true;

        try {
            Gdx.app.postRunnable(() -> {
                try {
                    // Only clear references without disposing textures
                    if (battleTable != null) {
                        battleTable.clear(); // Just clear children, don't dispose
                    }

                    if (battleStage != null) {
                        battleStage.clear();
                    }
                    if (battleSystem != null) {
                        battleSystem.endBattle();
                    }

                    // Reset states
                    inBattle = false;
                    transitioning = false;
                    inputBlocked = false;
                    battleInitialized = false;
                    battleUIFading = false;
                    isDisposing = false;
                    inputManager.updateInputProcessors();

                    GameLogger.info("Battle cleanup complete - Resources preserved for future battles");
                } catch (Exception e) {
                    GameLogger.error("Error during battle cleanup: " + e.getMessage());
                }
            });
        } catch (Exception e) {
            GameLogger.error("Error queuing cleanup: " + e.getMessage());
        }
    }

    private void handleBattleVictory(WildPokemon wildPokemon) {
        // Award experience
        int expGain = calculateExperienceGain(wildPokemon);
        GameContext.get().getPlayer().getPokemonParty().getFirstPokemon().addExperience(expGain);

        // Show victory message and sound
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.BATTLE_WIN);
        if (chatSystem != null) {
            chatSystem.handleIncomingMessage(createSystemMessage(
                "Victory! " + GameContext.get().getPlayer().getPokemonParty().getFirstPokemon().getName() +
                    " gained " + expGain + " experience!"
            ));
        }
    }

    private void handleBattleDefeat() {
        // Heal the party
        GameContext.get().getPlayer().getPokemonParty().healAllPokemon();

        // Play defeat sound and show message
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.DAMAGE);
        if (chatSystem != null) {
            chatSystem.handleIncomingMessage(createSystemMessage(
                "Your Pokémon have been healed!"
            ));
        }
    }

    private int calculateExperienceGain(WildPokemon wildPokemon) {
        // Basic experience calculation
        return wildPokemon.getBaseExperience() * wildPokemon.getLevel() / 7;
    }

    private NetworkProtocol.ChatMessage createSystemMessage(String content) {
        NetworkProtocol.ChatMessage message = new NetworkProtocol.ChatMessage();
        message.sender = "System";
        message.content = content;
        message.timestamp = System.currentTimeMillis();
        message.type = NetworkProtocol.ChatType.SYSTEM;
        return message;
    }

    private void renderOtherPlayers(SpriteBatch batch, Rectangle viewBounds) {
        if (GameContext.get().getGameClient() == null || GameContext.get().getGameClient().isSinglePlayer()) {
            return;
        }

        Map<String, OtherPlayer> otherPlayers = GameContext.get().getGameClient().getOtherPlayers();

        synchronized (otherPlayers) {
            // Sort players by Y position for correct depth
            List<OtherPlayer> sortedPlayers = new ArrayList<>(otherPlayers.values());
            sortedPlayers.sort((p1, p2) -> Float.compare(p2.getY(), p1.getY()));

            for (OtherPlayer otherPlayer : sortedPlayers) {
                if (otherPlayer == null) continue;

                float playerX = otherPlayer.getX();
                float playerY = otherPlayer.getY();

                // Only render if within view bounds
                if (viewBounds.contains(playerX, playerY)) {
                    otherPlayer.render(batch);
                }
            }
        }
    }

    private void setupCamera() {
        if (camera == null) {
            camera = new OrthographicCamera();
        }

        float baseWidth = TARGET_VIEWPORT_WIDTH_TILES * TILE_SIZE;
        float baseHeight = baseWidth * ((float) Gdx.graphics.getHeight() / Gdx.graphics.getWidth());

        if (cameraViewport == null) {
            cameraViewport = new FitViewport(baseWidth, baseHeight, camera);
        }

        cameraViewport.update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false);

        if (GameContext.get().getPlayer() != null) {
            camera.position.set(
                GameContext.get().getPlayer().getX() + Player.FRAME_WIDTH / 2f,
                GameContext.get().getPlayer().getY() + Player.FRAME_HEIGHT / 2f,
                0
            );
        } else {
            // Default position if no player
            camera.position.set(baseWidth / 2f, baseHeight / 2f, 0);
        }

        camera.update();
        GameLogger.info("Camera setup - viewport: " + baseWidth + "x" + baseHeight);
    }

    private void updateCamera() {
        if (GameContext.get().getPlayer() != null) {
            float targetX = GameContext.get().getPlayer().getX() + Player.FRAME_WIDTH / 2f;
            float targetY = GameContext.get().getPlayer().getY() + Player.FRAME_HEIGHT / 2f;
            float lerp = CAMERA_LERP * Gdx.graphics.getDeltaTime();
            camera.position.x += (targetX - camera.position.x) * lerp;
            camera.position.y += (targetY - camera.position.y) * lerp;

            camera.update();
        }
    }

    private void renderLoadingScreen() {
        GameContext.get().getBatch().begin();
        font.draw(GameContext.get().getBatch(), "Loading world...",
            (float) Gdx.graphics.getWidth() / 2 - 50,
            (float) Gdx.graphics.getHeight() / 2);
        GameContext.get().getBatch().end();
    }

    @Override
    public void render(float delta) {

        if (GameContext.get().getGameClient() != null && GameContext.get().getGameClient().isConnected()) {
            GameContext.get().getGameClient().update(delta);
            GameContext.get().getGameClient().tick(delta);
        }
        if (camera != null && starterTable == null) {
            updateCamera();
        }
        if (GameContext.get().getPlayer() != null && GameContext.get().getPlayer().getPokemonParty().getSize() == 0) {
            GameContext.get().getUiStage().act(delta);
            GameContext.get().getUiStage().draw();
            return;
        }

        if (Gdx.input.isKeyJustPressed(Input.Keys.F3)) {
            GameContext.get().getWorld().getBiomeManager().debugBiomeDistribution(10000);
            GameContext.get().getWorld().getBiomeManager().debugNoiseDistribution(10000);
        }
        if (Gdx.input.isKeyJustPressed(Input.Keys.W)) {
            GameLogger.info("Current Weather: " + GameContext.get().getWorld().getWeatherSystem().getCurrentWeather());
            GameLogger.info("Weather Intensity: " + GameContext.get().getWorld().getWeatherSystem().getIntensity());
            GameLogger.info("Particle Count: " + GameContext.get().getWorld().getWeatherSystem().getParticles().size());
        }
        if (GameContext.get().getWorld() == null) {
            return;
        }
        if (!GameContext.get().getWorld().areInitialChunksLoaded()) {
            GameContext.get().getWorld().requestInitialChunks(new Vector2(GameContext.get().getPlayer().getTileX(), GameContext.get().getPlayer().getTileY()));
            renderLoadingScreen();
            return;
        }

        // Clear screen
        Gdx.gl.glClearColor(0, 0, 0, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        if (movementController != null) {
            movementController.update();
        }
        if (GameContext.get().getPlayer() != null && GameContext.get().getPlayer().getPokemonParty().getSize() == 0) {
            Gdx.gl.glClearColor(0.1f, 0.1f, 0.2f, 1);
            Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

            GameContext.get().getUiStage().act(delta);
            GameContext.get().getUiStage().draw();

            debugTimer += delta;
            if (debugTimer >= 1.0f) {
                debugTimer = 0;
            }
            return;
        }
        GameContext.get().getBatch().begin();
        GameContext.get().getBatch().setProjectionMatrix(camera.combined);

        if (GameContext.get().getWorld() != null && GameContext.get().getPlayer() != null) {
            Rectangle viewBounds = new Rectangle(
                camera.position.x - (camera.viewportWidth * camera.zoom) / 2,
                camera.position.y - (camera.viewportHeight * camera.zoom) / 2,
                camera.viewportWidth * camera.zoom,
                camera.viewportHeight * camera.zoom
            );
            GameContext.get().getBatch().setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

            GameContext.get().getWorld().render(GameContext.get().getBatch(), viewBounds, GameContext.get().getPlayer(), this);


            if (GameContext.get().getGameClient() != null) {
                if (!GameContext.get().getGameClient().isSinglePlayer()) {
                    renderOtherPlayers(GameContext.get().getBatch(), viewBounds);
                }
            }

        }
        if (SHOW_DEBUG_INFO) {
            renderDebugInfo();
        }
        if (inputManager.getCurrentState() == InputManager.UIState.CRAFTING) {
            if (GameContext.get().getCraftingScreen() != null) {
                GameContext.get().getBatch().end();

                GameContext.get().getCraftingScreen().render(delta);

                GameContext.get().getBatch().begin();
            }
        }


        GameContext.get().getBatch().end();


        if (inputManager.getCurrentState() == InputManager.UIState.BUILD_MODE) {
            if (GameContext.get().getBuildModeUI() != null) {
                GameContext.get().getBuildModeUI().render(GameContext.get().getBatch(), camera);
            }
        }
        // Handle world initialization
        if (GameContext.get().getWorld() != null && !initializedworld) {
            if (!GameContext.get().getWorld().areAllChunksLoaded()) {
                initializationTimer += (int) delta;
                if (initializationTimer > 5f) {
                    GameLogger.info("Attempting to force load missing chunks...");
                    GameContext.get().getWorld().forceLoadMissingChunks();
                    initializationTimer = 0;
                }
            } else {
                initializedworld = true;
                GameLogger.info("All chunks successfully loaded");
            }
        }
        if (isHoldingDirection && currentDpadDirection != null) {
            movementTimer += delta;
            if (movementTimer >= MOVEMENT_REPEAT_DELAY) {
                GameContext.get().getPlayer().move(currentDpadDirection);
                movementTimer = 0f;
            }
            GameContext.get().getPlayer().setRunning(isRunPressed);
        }

        // Enable blending for UI elements
        Gdx.gl.glEnable(GL20.GL_BLEND);
        Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        if (GameContext.get().getUiStage() != null) {
            GameContext.get().getUiStage().getViewport().apply();
            GameContext.get().getUiStage().act(delta);
            GameContext.get().getUiStage().draw();
        }

        // Then draw battleStage
        if (inBattle) {
            if (battleStage != null && !isDisposing) {
                battleStage.act(delta);
                if (battleTable != null && battleTable.hasParent()) {
                    battleStage.draw();
                }
            }
        }


        if (inputManager.getCurrentState() == InputManager.UIState.MENU) {
            if (GameContext.get().getGameMenu() != null) {
                GameContext.get().getGameMenu().render();
            }
        }
        if (inputManager.getCurrentState() == InputManager.UIState.INVENTORY) {
            if (GameContext.get().getInventoryScreen() != null) {
                // Enable blending for semi-transparent background
                Gdx.gl.glEnable(GL20.GL_BLEND);
                Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

                // Draw dark background
                shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
                shapeRenderer.setColor(0, 0, 0, 0.7f);
                shapeRenderer.rect(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
                shapeRenderer.end();

                // Render inventory
                GameContext.get().getInventoryScreen().render(delta);

                Gdx.gl.glDisable(GL20.GL_BLEND);
            }
        }


        if (chestScreen != null && chestScreen.isVisible()) {
            chestScreen.render(delta);
        }

        // Pokemon party rendering
        if (isPokemonPartyVisible()) {
            pokemonPartyStage.act(delta);
            pokemonPartyStage.draw();
        }


        // Android controls
        if (Gdx.app.getType() == Application.ApplicationType.Android && controlsInitialized) {
            ensureAndroidControlsInitialized();
            renderAndroidControls();
        }

        Gdx.gl.glDisable(GL20.GL_BLEND);

        // Game state updates
        if (GameContext.get().getWorld() != null && GameContext.get().getPlayer() != null) {
            float deltaTime = Gdx.graphics.getDeltaTime();
            GameContext.get().getPlayer().update(deltaTime);
            // Camera update
            if (!inBattle && !transitioning) {
                updateCamera();
            }

            if (isMultiplayer) {
                // Other systems updates
                updateOtherPlayers(delta);

                if (GameContext.get().getGameClient() != null) {
                    GameContext.get().getGameClient().tick(delta);
                }
                if (GameContext.get().getWorld() != null) {
                    GameContext.get().getWorld().update(delta, new Vector2(GameContext.get().getPlayer().getTileX(), GameContext.get().getPlayer().getTileY()),
                        Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), this);
                }
            } else {
                GameContext.get().getPlayer().validateResources();
                float viewportWidthPixels = camera.viewportWidth * camera.zoom;
                float viewportHeightPixels = camera.viewportHeight * camera.zoom;
                GameContext.get().getWorld().update(delta,
                    new Vector2(GameContext.get().getPlayer().getTileX(), GameContext.get().getPlayer().getTileY()),
                    viewportWidthPixels,
                    viewportHeightPixels, this
                );
            }

            handleInput();
            if (inputHandler != null &&
                (inputManager.getCurrentState() == InputManager.UIState.NORMAL ||
                    inputManager.getCurrentState() == InputManager.UIState.BUILD_MODE)) {
                inputHandler.update(delta);
            }

            updateTimer += delta;

            // Handle multiplayer updates
            if (isMultiplayer && updateTimer >= UPDATE_INTERVAL) {
                updateTimer = 0;
                NetworkProtocol.PlayerUpdate update = new NetworkProtocol.PlayerUpdate();
                update.username = GameContext.get().getPlayer().getUsername();
                update.x = GameContext.get().getPlayer().getX();
                update.y = GameContext.get().getPlayer().getY();
                update.direction = GameContext.get().getPlayer().getDirection();
                update.isMoving = GameContext.get().getPlayer().isMoving();
                update.wantsToRun = GameContext.get().getPlayer().isRunning();
                update.timestamp = System.currentTimeMillis();
                if (GameContext.get().getGameClient() == null) {
                    return;
                }
                GameContext.get().getGameClient().sendPlayerUpdate();
                // Handle incoming updates
                Map<String, NetworkProtocol.PlayerUpdate> updates = GameContext.get().getGameClient().getPlayerUpdates();
                if (!updates.isEmpty()) {
                    synchronized (GameContext.get().getGameClient().getOtherPlayers()) {
                        for (NetworkProtocol.PlayerUpdate playerUpdate : updates.values()) {
                            if (!playerUpdate.username.equals(GameContext.get().getPlayer().getUsername())) {
                                OtherPlayer op = GameContext.get().getGameClient().getOtherPlayers().get(playerUpdate.username);
                                if (op == null) {
                                    op = new OtherPlayer(playerUpdate.username, playerUpdate.x, playerUpdate.y);
                                    GameContext.get().getGameClient().getOtherPlayers().put(playerUpdate.username, op);
                                    GameLogger.info("Created new player: " + playerUpdate.username);
                                }
                                op.updateFromNetwork(playerUpdate);
                            }
                        }
                    }
                }
            }
        }
    }

    private String formatPlayedTime(long millis) {
        long seconds = millis / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;

        seconds = seconds % 60;
        minutes = minutes % 60;

        return String.format("%02dh %02dm %02ds", hours, minutes, seconds);
    }

    private void updateOtherPlayers(float delta) {
        if (isMultiplayer) {
            if (GameContext.get().getGameClient() == null) {
                return;
            }
            Map<String, OtherPlayer> others = GameContext.get().getGameClient().getOtherPlayers();
            if (!others.isEmpty()) {
                for (OtherPlayer otherPlayer : others.values()) {
                    try {
                        otherPlayer.update(delta);
                    } catch (Exception e) {
                        GameLogger.error("Error updating other player: " + e.getMessage());
                    }
                }
            }
        }
    }

    private void renderDebugInfo() {
        GameContext.get().getBatch().setProjectionMatrix(GameContext.get().getUiStage().getCamera().combined);
        font.setColor(Color.WHITE);

        float debugY = 25;

        // Add FPS display at the top
        int fps = Gdx.graphics.getFramesPerSecond();
        font.draw(GameContext.get().getBatch(), "FPS: " + fps, 10, debugY);
        debugY += 20;

        float pixelX = GameContext.get().getPlayer().getX();
        float pixelY = GameContext.get().getPlayer().getY();
        int tileX = (int) Math.floor(pixelX / TILE_SIZE);
        int tileY = (int) Math.floor(pixelY / TILE_SIZE);
        Biome currentBiome = GameContext.get().getWorld().getBiomeAt(tileX, tileY);
        font.draw(GameContext.get().getBatch(), String.format("Pixels: (%d, %d)", (int) pixelX, (int) pixelY), 10, debugY);
        debugY += 20;
        font.draw(GameContext.get().getBatch(), String.format("Tiles: (%d, %d)", tileX, tileY), 10, debugY);
        debugY += 20;
        font.draw(GameContext.get().getBatch(), "Direction: " + GameContext.get().getPlayer().getDirection(), 10, debugY);
        debugY += 20;
        font.draw(GameContext.get().getBatch(), "Biome: " + currentBiome.getName(), 10, debugY);
        debugY += 20;

        font.draw(GameContext.get().getBatch(), "Active Pokemon: " + getTotalPokemonCount(), 10, debugY);
        debugY += 20;

        String timeString = DayNightCycle.getTimeString(GameContext.get().getWorld().getWorldData().getWorldTimeInMinutes());
        font.draw(GameContext.get().getBatch(), "Time: " + timeString, 10, debugY);
        debugY += 20;

        if (!isMultiplayer) {
            long playedTimeMillis = GameContext.get().getWorld().getWorldData().getPlayedTime();
            String playedTimeStr = formatPlayedTime(playedTimeMillis);
            font.draw(GameContext.get().getBatch(), "Total Time Played: " + playedTimeStr, 10, debugY);
        }
    }

    private void handleInput() {

        if (chatSystem != null && chatSystem.isActive()) {
            return;
        }

        if (inBattle) {
            return;
        }

        if (inputManager.getCurrentState() == InputManager.UIState.NORMAL) {
            handleGameInput();
        }
    }

    public ChestScreen getChestScreen() {
        return chestScreen;
    }

    public void setChestScreen(ChestScreen chestScreen) {
        this.chestScreen = chestScreen;
    }

    private void handleGameInput() {
        if (inBattle) {
            return;
        }
        if (inputBlocked) {
            return;
        }

        if (Gdx.input.isKeyJustPressed(Input.Keys.F3)) {
            SHOW_DEBUG_INFO = !SHOW_DEBUG_INFO;
        }


        handleMovementInput();
    }


    public void initializeBuildMode() {
        if (GameContext.get().getBuildModeUI() == null && GameContext.get().getPlayer() != null) {
            GameContext.get().setBuildModeUI(new BuildModeUI(skin));
            GameContext.get().getUiStage().addActor(GameContext.get().getBuildModeUI());
            GameContext.get().getBuildModeUI().setVisible(false); // Start hidden
            GameLogger.info("BuildModeUI initialized");
        }
    }


    private void handleMovementInput() {
        if (Gdx.input.isKeyPressed(Input.Keys.ANY_KEY)) {
            String direction = null;
            if (Gdx.input.isKeyPressed(Input.Keys.UP)) direction = "up";
            else if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) direction = "down";
            else if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) direction = "left";
            else if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) direction = "right";

            if (direction != null) {
                GameContext.get().getPlayer().move(direction);
            }
        }
    }

    private int getTotalPokemonCount() {
        if (GameContext.get().getWorld() != null && GameContext.get().getWorld().getPokemonSpawnManager() != null) {
            return GameContext.get().getWorld().getPokemonSpawnManager().getAllWildPokemon().size();
        }
        return 0;
    }

    private void logInventoryState(String context) {
        if (GameContext.get().getPlayer() == null || GameContext.get().getPlayer().getInventory() == null) {
            GameLogger.error(context + ": Player or inventory is null");
            return;
        }

        GameLogger.info("\n=== Inventory State: " + context + " ===");
        List<ItemData> items = GameContext.get().getPlayer().getInventory().getAllItems();
        GameLogger.info("Total slots: " + items.size());
        GameLogger.info("Non-null items: " + items.stream().filter(Objects::nonNull).count());

        GameLogger.info("=====================================\n");
    }


    @Override
    public void resize(int width, int height) {
        if (GameContext.get().getPlayer() != null) {
            GameContext.get().getPlayer().validateResources();
        }
        if (starterTable != null) {
            starterTable.resize(width, height);
        }

        ACTION_BUTTON_SIZE = height * 0.12f;
        DPAD_SIZE = height * 0.3f;
        BUTTON_PADDING = width * 0.02f;

        if (controlsInitialized) {
            androidControlsTable.clearChildren();
            createDpad();
            createActionButtons();
        }
        if (GameContext.get().getBuildModeUI() != null) {
            GameContext.get().getBuildModeUI().resize(width);
        }

        if (dpadTable != null) {
            dpadTable.clear();
            createDpad();
        }

        cameraViewport.update(width, height, false);

        if (GameContext.get().getInventoryScreen() != null) {
            GameContext.get().getInventoryScreen().resize(width, height);

            if (closeButtonTable != null && closeButtonTable.getParent() != null) {
                closeButtonTable.invalidate();
            }
        }
        if (GameContext.get().getCraftingScreen() != null) {
            GameContext.get().getCraftingScreen().resize(width, height);
        }
        for (Actor actor : stage.getActors()) {
            if (actor instanceof StarterSelectionTable) {
                ((StarterSelectionTable) actor).resize(width, height);
                starterTable.resize(width, height);
                break;
            }
        }
        if (GameContext.get().getUiStage() != null) {
            GameContext.get().getUiStage().getViewport().update(width, height, true);
            GameLogger.info("Stage viewport updated to: " + width + "x" + height);

            if (starterTable != null && GameContext.get().getPlayer().getPokemonParty().getSize() == 0) {
                starterTable.setFillParent(true);
                GameLogger.info("Starter table position after resize: " +
                    starterTable.getX() + "," + starterTable.getY());
            }
        }
        if (battleStage != null) {
            battleStage.getViewport().update(width, height, true);
            if (battleTable != null) {
                battleTable.invalidate();
                battleTable.validate();
            }
        }
        if (GameContext.get().getUiStage() != null) {
            GameContext.get().getUiStage().getViewport().update(width, height, true);
        }
        if (GameContext.get().getGameMenu() != null && GameContext.get().getGameMenu().getStage() != null) {
            GameContext.get().getGameMenu().getStage().getViewport().update(width, height, true);
        }
        if (pokemonPartyStage != null) {
            pokemonPartyStage.getViewport().update(width, height, true);
        }
        if (chatSystem != null) {
            float chatWidth = Math.max(ChatSystem.MIN_CHAT_WIDTH, width * 0.25f);
            float chatHeight = Math.max(ChatSystem.MIN_CHAT_HEIGHT, height * 0.3f);

            chatSystem.setSize(chatWidth, chatHeight);
            chatSystem.setPosition(
                ChatSystem.CHAT_PADDING,
                height - chatHeight - ChatSystem.CHAT_PADDING
            );
            chatSystem.resize(width, height);
        }
        if (controlsInitialized) {
            joystickCenter.set(width * 0.2f, height * 0.25f);
            joystickCurrent.set(joystickCenter);

            if (androidControlsTable != null) {
                androidControlsTable.invalidateHierarchy();
            }
        }
        ensureAndroidControlsInitialized();
        updateAndroidControlPositions();

        updateCamera();
        GameLogger.info("Screen resized to: " + width + "x" + height);
    }

    private ItemData generateRandomItemData() {
        List<String> itemNames = new ArrayList<>(ItemManager.getAllFindableItemNames());
        if (itemNames.isEmpty()) {
            GameLogger.error("No items available in ItemManager to generate random item.");
            return null;
        }
        int index = MathUtils.random(itemNames.size() - 1);
        String itemName = itemNames.get(index);
        ItemData itemData = InventoryConverter.itemToItemData(ItemManager.getItem(itemName));
        if (itemData != null) {
            itemData.setCount(1);
            itemData.setUuid(UUID.randomUUID());
            return itemData;
        }
        GameLogger.error("Failed to retrieve ItemData for item: " + itemName);
        return null;
    }


    public void handlePickupAction() {
        WorldObject nearestPokeball = GameContext.get().getWorld().getNearestPokeball();
        if (nearestPokeball == null) {
            GameLogger.info("No pokeball found nearby");
            return;
        }
        GameLogger.info("Player position: " + GameContext.get().getPlayer().getX() + "," + GameContext.get().getPlayer().getY());
        GameLogger.info("Pokeball position: " + nearestPokeball.getPixelX() + "," + nearestPokeball.getPixelY());

        if (GameContext.get().getPlayer().canPickupItem(nearestPokeball.getPixelX(), nearestPokeball.getPixelY())) {
            GameContext.get().getWorld().removeWorldObject(nearestPokeball);

            ItemData randomItemData = generateRandomItemData();
            if (randomItemData == null) {
                GameLogger.error("Failed to generate random item data.");
                return;
            }

            boolean added = false;
            try {
                added = InventoryConverter.addItemToInventory(GameContext.get().getPlayer().getInventory(), randomItemData);
            } catch (Exception e) {
                GameLogger.error("Error adding item to inventory: " + e.getMessage());
            }

            NetworkProtocol.ChatMessage pickupMessage = new NetworkProtocol.ChatMessage();
            pickupMessage.sender = "System";
            pickupMessage.timestamp = System.currentTimeMillis();

            if (added) {
                pickupMessage.content = "You found: " + randomItemData.getItemId() + " (×" + randomItemData.getCount() + ")";
                pickupMessage.type = NetworkProtocol.ChatType.SYSTEM;
                GameLogger.info("Item added to inventory: " + randomItemData.getItemId());

                AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);

                GameContext.get().getPlayer().updatePlayerData();

                logInventoryState("Post-pickup inventory state:");
            } else {
                pickupMessage.content = "Inventory full! Couldn't pick up: " + randomItemData.getItemId();
                pickupMessage.type = NetworkProtocol.ChatType.SYSTEM;
                GameLogger.info("Inventory full. Cannot add: " + randomItemData.getItemId());
            }

            // Send message to chat
            if (chatSystem != null) {
                chatSystem.handleIncomingMessage(pickupMessage);
            }
        } else {
            GameLogger.info("Cannot pick up pokeball - too far or wrong direction");
        }
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    public SpriteBatch getBatch() {
        return GameContext.get().getBatch();
    }

    @Override
    public void dispose() {
        if (isDisposing) return;
        isDisposing = true;

        try {
            if (GameContext.get().getPlayer() != null && GameContext.get().getWorld() != null) {
                PlayerData finalState = getCurrentPlayerState();
                GameContext.get().getWorld().getWorldData().savePlayerData(GameContext.get().getPlayer().getUsername(), finalState, false);

                GameContext.get().getWorld().save();

                GameLogger.info("Final save complete for player: " + GameContext.get().getPlayer().getUsername() +
                    " in world: " + GameContext.get().getWorld().getName());
            }

            Gdx.app.postRunnable(() -> {
                try {
                    if (chestScreen != null) {
                        chestScreen.dispose();
                    }
                    if (GameContext.get().getBuildModeUI() != null) {
                        GameContext.get().getBuildModeUI().dispose();
                        GameContext.get().setBuildModeUI(null);
                    }

                    if (pokemonPartyStage != null) {
                        pokemonPartyStage.clear();
                        pokemonPartyStage.dispose();
                        pokemonPartyStage = null;
                    }

                    if (GameContext.get().getUiStage() != null) {
                        GameContext.get().getUiStage().clear();
                        GameContext.get().getUiStage().dispose();
                        GameContext.get().setUiStage(null);
                    }

                    if (GameContext.get().getBatch() != null) {
                        GameContext.get().getBatch().dispose();
                        GameContext.get().setBatch(null);
                    }

                    if (shapeRenderer != null) {
                        shapeRenderer.dispose();
                        shapeRenderer = null;
                    }

                    if (GameContext.get().getPlayer() != null) {
                        GameContext.get().getPlayer().dispose();
                        GameContext.get().setPlayer(null);
                    }

                    for (OtherPlayer op : GameContext.get().getGameClient().getOtherPlayers().values()) {
                        if (op != null) op.dispose();
                    }
                    GameContext.get().getGameClient().dispose();

                    if (!screenInitScheduler.isShutdown()) {
                        screenInitScheduler.shutdown();
                        try {
                            if (!screenInitScheduler.awaitTermination(2, TimeUnit.SECONDS)) {
                                screenInitScheduler.shutdownNow();
                            }
                        } catch (InterruptedException e) {
                            screenInitScheduler.shutdownNow();
                            Thread.currentThread().interrupt();
                        }
                    }

                    GameLogger.info("GameScreen disposed successfully");
                } catch (Exception e) {
                    GameLogger.error("Error during GameScreen disposal: " + e.getMessage());
                }
            });
        } catch (Exception e) {
            GameLogger.error("Error during disposal: " + e.getMessage());
        }
    }

    private void initializeAndroidControls() {
        if (Gdx.app.getType() != Application.ApplicationType.Android || controlsInitialized) {
            return;
        }

        try {
            float screenWidth = Gdx.graphics.getWidth();
            float screenHeight = Gdx.graphics.getHeight();

            ACTION_BUTTON_SIZE = screenHeight * 0.12f; // Increase from 0.1f to 0.12f
            DPAD_SIZE = screenHeight * 0.3f;
            BUTTON_PADDING = screenWidth * 0.02f;      // Padding between buttons
            androidControlsTable = new Table();
            androidControlsTable.setFillParent(true);

            createDpad();

            createActionButtons();

            GameContext.get().getUiStage().addActor(androidControlsTable);

            createDpadHitboxes();

            controlsInitialized = true;
            GameLogger.info("Android controls initialized");

        } catch (Exception e) {
            GameLogger.error("Failed to initialize Android controls: " + e.getMessage());
        }
    }


    private Actor createColoredButton(String label, Color color, float size) {
        Pixmap pixmap = new Pixmap((int) size, (int) size, Pixmap.Format.RGBA8888);
        pixmap.setColor(color.r, color.g, color.b, 0.8f);
        pixmap.fillCircle((int) size / 2, (int) size / 2, (int) size / 2);
        TextureRegionDrawable drawable = new TextureRegionDrawable(new Texture(pixmap));
        pixmap.dispose();

        TextButton.TextButtonStyle style = new TextButton.TextButtonStyle();
        style.up = drawable;
        style.down = drawable.tint(Color.DARK_GRAY);
        style.font = skin.getFont("default-font");
        style.fontColor = Color.WHITE;

        TextButton button = new TextButton(label, style);
        Container<TextButton> buttonContainer = new Container<>(button);
        buttonContainer.setTransform(true);
        buttonContainer.size(size * 1.5f);
        buttonContainer.setOrigin(Align.center);
        buttonContainer.setTouchable(Touchable.enabled);
        float fontScale = size / 60f;
        button.getLabel().setFontScale(fontScale);

        button.getLabel().setAlignment(Align.center);

        button.setSize(size, size);

        return buttonContainer;
    }

    private void createActionButtons() {
        // Create buttons
        aButton = createColoredButton("A", Color.GREEN, ACTION_BUTTON_SIZE);
        xButton = createColoredButton("X", Color.BLUE, ACTION_BUTTON_SIZE);
        yButton = createColoredButton("Y", Color.YELLOW, ACTION_BUTTON_SIZE);
        zButton = createColoredButton("Z", Color.PURPLE, ACTION_BUTTON_SIZE);
        startButton = createColoredButton("Start", Color.WHITE, ACTION_BUTTON_SIZE);
        selectButton = createColoredButton("Select", Color.GRAY, ACTION_BUTTON_SIZE);

        // Set touchable
        aButton.setTouchable(Touchable.enabled);
        xButton.setTouchable(Touchable.enabled);
        yButton.setTouchable(Touchable.enabled);
        zButton.setTouchable(Touchable.enabled);
        startButton.setTouchable(Touchable.enabled);
        selectButton.setTouchable(Touchable.enabled);

        // Position action buttons
        Table actionButtonTable = new Table();
        actionButtonTable.setFillParent(true);
        actionButtonTable.bottom().right().pad(BUTTON_PADDING * 2);
        actionButtonTable.row();
        actionButtonTable.add(startButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);
        actionButtonTable.add(selectButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);
        actionButtonTable.row();
        actionButtonTable.add(yButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);
        actionButtonTable.add(zButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);
        actionButtonTable.row();
        actionButtonTable.add(xButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);
        actionButtonTable.add(aButton).size(ACTION_BUTTON_SIZE).pad(BUTTON_PADDING);

        GameContext.get().getUiStage().addActor(actionButtonTable);

        addButtonListeners();
    }

    private void addButtonListeners() {
        ((Container<TextButton>) aButton).getActor().addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                inputHandler.handleInteraction();
            }
        });

        ((Container<TextButton>) xButton).getActor().addListener(new InputListener() {
            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
                inputHandler.startChopOrPunch();
                return true;
            }

            @Override
            public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
                inputHandler.stopChopOrPunch();
            }
        });

        ((Container<TextButton>) yButton).getActor().addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                inputHandler.toggleBuildMode();
            }
        });

        ((Container<TextButton>) zButton).getActor().addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                toggleInventory();
            }
        });

        ((Container<TextButton>) startButton).getActor().addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                handleStartButtonPress();
            }
        });

        ((Container<TextButton>) selectButton).getActor().addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                handleSelectButtonPress();
            }
        });
    }

    private void handleStartButtonPress() {
        toggleGameMenu();
    }

    private void handleSelectButtonPress() {

        SHOW_DEBUG_INFO = !SHOW_DEBUG_INFO;
    }

    private void createDpad() {

        float dpadSize = DPAD_SIZE;
        float paddingLeft = BUTTON_PADDING * 2;
        float paddingBottom = BUTTON_PADDING * 2;

        // Create D-pad touch area
        Image dpadTouchArea = new Image();
        dpadTouchArea.setSize(dpadSize, dpadSize);
        dpadTouchArea.setPosition(paddingLeft, paddingBottom);
        dpadTouchArea.setColor(1, 1, 1, 0);
        dpadTouchArea.setTouchable(Touchable.enabled);

        // Add touch listener to the D-pad area
        dpadTouchArea.addListener(new InputListener() {
            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
                float absoluteX = event.getStageX();
                float absoluteY = event.getStageY();
                movementController.handleTouchDown(absoluteX, absoluteY);
                return true;
            }

            @Override
            public void touchDragged(InputEvent event, float x, float y, int pointer) {
                float absoluteX = event.getStageX();
                float absoluteY = event.getStageY();
                movementController.handleTouchDragged(absoluteX, absoluteY);
            }

            @Override
            public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
                movementController.handleTouchUp();
            }
        });

        GameContext.get().getUiStage().addActor(dpadTouchArea);
    }

    private void createDpadHitboxes() {
        float screenWidth = Gdx.graphics.getWidth();
        float screenHeight = Gdx.graphics.getHeight();
        float dpadCenterX = screenWidth * 0.15f;
        float dpadCenterY = screenHeight * 0.2f;
        float buttonSize = 145f;
        upButton = new Rectangle(
            dpadCenterX - buttonSize / 2,
            dpadCenterY + buttonSize / 4,
            buttonSize,
            buttonSize
        );

        downButton = new Rectangle(
            dpadCenterX - buttonSize / 2,
            dpadCenterY - buttonSize - buttonSize / 4,
            buttonSize,
            buttonSize
        );

        leftButton = new Rectangle(
            dpadCenterX - buttonSize - buttonSize / 4,
            dpadCenterY - buttonSize / 2,
            buttonSize,
            buttonSize
        );

        rightButton = new Rectangle(
            dpadCenterX + buttonSize / 4,
            dpadCenterY - buttonSize / 2,
            buttonSize,
            buttonSize
        );

    }


    private void renderAndroidControls() {
        if (!controlsInitialized || movementController == null) return;

        Gdx.gl.glEnable(GL20.GL_BLEND);
        Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);

        if (movementController.isActive()) {
            // Draw base circle
            Vector2 center = movementController.getJoystickCenter();
            float maxRadius = movementController.getMaxRadius();

            // Base circle (lighter)
            shapeRenderer.setColor(0.3f, 0.3f, 0.3f, 0.3f);
            shapeRenderer.circle(center.x, center.y, maxRadius);

            // Draw joystick knob
            Vector2 current = movementController.getJoystickCurrent();
            float knobSize = maxRadius * 0.3f;

            // Knob shadow
            shapeRenderer.setColor(0.0f, 0.0f, 0.0f, 0.4f);
            shapeRenderer.circle(current.x, current.y, knobSize + 2);

            // Knob (brighter when moved further)
            float intensity = 0.5f + (movementController.getMagnitude() * 0.5f);
            shapeRenderer.setColor(intensity, intensity, intensity, 0.8f);
            shapeRenderer.circle(current.x, current.y, knobSize);
        }

        shapeRenderer.end();
        Gdx.gl.glDisable(GL20.GL_BLEND);
    }


    public class AndroidInputProcessor extends InputAdapter {
        private final AndroidMovementController movementController;
        private final Actor aButton;
        private final Actor zButton;
        private final Actor xButton;
        private final Actor yButton;
        private final Actor startButton;
        private final Actor selectButton;

        public AndroidInputProcessor(AndroidMovementController movementController,
                                     Actor aButton, Actor zButton,
                                     Actor xButton, Actor yButton,
                                     Actor startButton, Actor selectButton) {
            this.movementController = movementController;
            this.aButton = aButton;
            this.zButton = zButton;
            this.xButton = xButton;
            this.yButton = yButton;
            this.startButton = startButton;
            this.selectButton = selectButton;
        }

        @Override
        public boolean touchDown(int screenX, int screenY, int pointer, int button) {
            float touchX = screenX;
            float touchY = Gdx.graphics.getHeight() - screenY; // Flip Y coordinate

            if (isTouchOnButton(touchX, touchY, aButton)) {
                inputHandler.handleInteraction();
                return true;
            }

            if (isTouchOnButton(touchX, touchY, xButton)) {
                inputHandler.startChopOrPunch();
                return true;
            }

            if (isTouchOnButton(touchX, touchY, yButton)) {
                inputHandler.toggleBuildMode();
                return true;
            }

            if (isTouchOnButton(touchX, touchY, zButton)) {
                toggleInventory();
                return true;
            }

            if (isTouchOnButton(touchX, touchY, startButton)) {
                handleStartButtonPress();
                return true;
            }

            if (isTouchOnButton(touchX, touchY, selectButton)) {
                handleSelectButtonPress();
                return true;
            }

            // D-pad handling
            movementController.handleTouchDown((int) touchX, (int) touchY);
            return true;
        }

        @Override
        public boolean touchDragged(int screenX, int screenY, int pointer) {
            float touchX = screenX;
            float touchY = Gdx.graphics.getHeight() - screenY;
            movementController.handleTouchDragged((int) touchX, (int) touchY);
            return true;
        }

        @Override
        public boolean touchUp(int screenX, int screenY, int pointer, int button) {
            movementController.handleTouchUp();
            inputHandler.stopChopOrPunch();
            return false;
        }

        private boolean isTouchOnButton(float x, float y, Actor button) {
            return x >= button.getX() && x <= button.getX() + button.getWidth()
                && y >= button.getY() && y <= button.getY() + button.getHeight();
        }
    }

}

================
File: main/java/io/github/pokemeetup/screens/InventoryScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.ParticleEffect;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.*;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.system.InputManager;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.*;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingGrid;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingSystem;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventoryObserver;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.screens.otherui.InventorySlotUI;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.InventoryConverter;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.*;
import java.util.List;

public class InventoryScreen implements Screen, InventoryObserver, CraftingSystem.CraftingSystemObserver, InventoryScreenInterface {
    private static final int SLOT_SIZE = 40;

    private final Skin skin;
    private final Stage stage;
    private final SpriteBatch batch;
    private final ShapeRenderer shapeRenderer;
    private final Player player;
    private final Inventory inventory;
    private final CraftingSystem craftingSystem;
    private final List<InventorySlotUI> craftingSlotUIs;
    private final CraftingGrid craftingGrid;
    private List<InventorySlotData> inventorySlots;
    private Group heldItemGroup;
    private Image heldItemImage;
    private InputManager inputManager;
    private Label heldItemCountLabel;
    private Item heldItem = null;
    private InventorySlotUI craftingResultSlotUI;
    private boolean visible = false;

    public InventoryScreen(Player player, Skin skin, Inventory inventory, InputManager inputManager) {
        this.player = player;
        this.skin = skin;
        this.craftingGrid = new CraftingGrid(4); // 2x2 grid
        this.inventory = inventory;
        this.inputManager = inputManager;
        this.stage = new Stage(new ScreenViewport());
        this.batch = new SpriteBatch();
        this.shapeRenderer = new ShapeRenderer();

        this.craftingSystem = new CraftingSystem(inventory, 2, craftingGrid);
        this.craftingSystem.addObserver(this);

        setupHeldItemDisplay();
        initializeInventorySlots();
        this.craftingSlotUIs = new ArrayList<>();

        setupUI();
        inventory.addObserver(this);

        GameLogger.info("InventoryScreen initialized");
        // Removed stage listener that handled global touches.
        // Now rely solely on InventorySlotUI logic for item placement.
    }

    @Override
    public Item getHeldItemObject() {
        return heldItem;
    }

    @Override
    public void show() {
        if (!visible) {
            GameLogger.info("InventoryScreen show() called");
            visible = true;

            // If desired, we can ensure no items are incorrectly held by the player on show,
            // but let's just leave as-is to match the stable approach from CraftingTableScreen.

            // Reload inventory once on show
            reloadInventory();

            if (stage != null) {
                stage.setKeyboardFocus(null);
                stage.unfocusAll();
            }
        }
    }

    @Override
    public void render(float delta) {
        if (!visible) return;
        Gdx.gl.glEnable(GL20.GL_BLEND);
        Gdx.gl.glBlendFunc(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        stage.act(Math.min(delta, 1 / 30f));
        updateHeldItemPosition();
        stage.draw();

        Gdx.gl.glDisable(GL20.GL_BLEND);
    }

    private void updateHeldItemPosition() {
        if (heldItemGroup != null && heldItemGroup.isVisible()) {
            float x = Gdx.input.getX() - 16;
            float y = Gdx.graphics.getHeight() - Gdx.input.getY() - 16;
            heldItemGroup.setPosition(x, y);
        }
    }

    public Stage getStage() {
        return stage;
    }

    @Override
    public CraftingSystem getCraftingSystem() {
        return craftingSystem;
    }

    @Override
    public ItemContainer getChestData() {
        return null;
    }

    private void initializeInventorySlots() {
        inventorySlots = new ArrayList<>();
        List<ItemData> currentItems = inventory.getAllItems();
        GameLogger.info("InventoryScreen: Inventory has " + currentItems.size() + " slots.");
        int nonNullItemCount = 0;

        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            InventorySlotData slotData = new InventorySlotData(i, InventorySlotData.SlotType.INVENTORY, inventory);
            ItemData itemData = i < currentItems.size() ? currentItems.get(i) : null;

            if (itemData != null) {
                if (itemData.getMaxDurability() <= 0) {
                    Item itemTemplate = ItemManager.getItem(itemData.getItemId());
                    if (itemTemplate != null) {
                        itemData.setMaxDurability(itemTemplate.getMaxDurability());
                    }
                }
                if (itemData.getDurability() <= 0) {
                    itemData.setDurability(itemData.getMaxDurability());
                }

                slotData.setItemData(itemData);
                GameLogger.info("InventoryScreen: Loaded item into slot " + i + ": " +
                    itemData.getItemId() + " x" + itemData.getCount() +
                    ", durability: " + itemData.getDurability() + "/" + itemData.getMaxDurability());
                nonNullItemCount++;
            }

            inventorySlots.add(slotData);
        }

        GameLogger.info("InventoryScreen: Total non-null items loaded: " + nonNullItemCount);
    }

    private void setupUI() {
        Table mainTable = new Table();
        mainTable.setFillParent(true);
        mainTable.center();

        Pixmap bgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(0, 0, 0, 0.2f);
        bgPixmap.fill();
        Texture bgTexture = new Texture(bgPixmap);
        TextureRegionDrawable background = new TextureRegionDrawable(new TextureRegion(bgTexture));
        mainTable.setBackground(background);
        bgPixmap.dispose();

        Table craftingContainer = new Table();
        craftingContainer.setBackground(createBackground());
        craftingContainer.pad(10);

        Table craftingGrid1 = new Table();
        craftingGrid1.defaults().space(4);

        for (int y = 0; y < 2; y++) {
            for (int x = 0; x < 2; x++) {
                final int index = y * 2 + x;
                InventorySlotData craftSlotData = new InventorySlotData(index, InventorySlotData.SlotType.CRAFTING, craftingGrid);

                InventorySlotUI craftSlot = new InventorySlotUI(craftSlotData, skin, this);
                craftingSlotUIs.add(craftSlot);
                craftingSystem.addSlotObserver(index, craftSlot);

                craftingGrid1.add(craftSlot).size(SLOT_SIZE);
                if (x == 1) craftingGrid1.row();
            }
        }

        Image arrowImage = new Image(TextureManager.ui.findRegion("arrow"));

        InventorySlotData resultSlotData = new InventorySlotData(-1, InventorySlotData.SlotType.CRAFTING_RESULT, craftingGrid);
        craftingResultSlotUI = new InventorySlotUI(resultSlotData, skin, this);

        craftingContainer.add(craftingGrid1).padRight(20);
        craftingContainer.add(arrowImage).size(32, 32).padRight(20);
        craftingContainer.add(craftingResultSlotUI).size(SLOT_SIZE);

        mainTable.add(craftingContainer).padBottom(20);
        mainTable.row();

        Table gridTable = new Table();
        gridTable.setName("gridTable");
        gridTable.setBackground(createBackground());
        gridTable.pad(10);

        List<InventorySlotUI> inventorySlotUIs = new ArrayList<>();

        int cols = 9;
        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            InventorySlotUI slotUI = createSlotUI(i);
            gridTable.add(slotUI).size(SLOT_SIZE).pad(2);
            inventorySlotUIs.add(slotUI);
            if ((i + 1) % cols == 0) {
                gridTable.row();
            }
        }

        for (InventorySlotUI slotUI : inventorySlotUIs) {
            slotUI.updateSlot();
        }

        mainTable.add(gridTable);

        mainTable.row();
        TextButton closeButton = new TextButton("Close", skin);
        closeButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                hide();
            }
        });
        mainTable.add(closeButton).size(100, 40).pad(10);

        stage.addActor(mainTable);
        stage.addActor(heldItemGroup);
    }

    private Drawable createBackground() {
        return new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg"))
            .tint(new Color(0.2f, 0.2f, 0.2f, 0.6f));
    }

    public void reloadInventory() {
        GameLogger.info("Reloading inventory (only on show or controlled calls)...");
        if (inventory != null) {
            List<ItemData> currentItems = inventory.getAllItems();

            for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                InventorySlotData slotData = inventorySlots.get(i);
                ItemData item = i < currentItems.size() ? currentItems.get(i) : null;

                if (item != null) {
                    slotData.setItemData(item);
                } else {
                    slotData.clear();
                }
                slotData.notifyObservers();
            }
        }
    }

    @Override
    public void onCraftingResultChanged(ItemData newResult) {
        if (craftingResultSlotUI != null) {
            craftingResultSlotUI.forceUpdate();
        }
    }

    private void setupHeldItemDisplay() {
        heldItemImage = new Image();
        heldItemImage.setSize(32, 32);
        heldItemImage.setVisible(false);

        heldItemCountLabel = new Label("", skin);
        heldItemCountLabel.setVisible(false);

        heldItemGroup = new Group();
        heldItemGroup.addActor(heldItemImage);
        heldItemGroup.addActor(heldItemCountLabel);

        heldItemGroup.setTouchable(Touchable.disabled);
    }

    private InventorySlotUI createSlotUI(int index) {
        InventorySlotData slotData = inventorySlots.get(index);
        return new InventorySlotUI(slotData, skin, this);
    }

    @Override
    public void updateHeldItemDisplay() {
        if (heldItemGroup == null) return;

        heldItemImage.setVisible(false);
        heldItemCountLabel.setVisible(false);
        heldItemGroup.setVisible(false);

        if (heldItem != null) {
            TextureRegion texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase() + "_item");
            if (texture == null) {
                texture = TextureManager.items.findRegion(heldItem.getName().toLowerCase());
            }

            if (texture != null) {
                heldItemImage.setDrawable(new TextureRegionDrawable(texture));
                heldItemImage.setVisible(true);
                if (heldItem.getCount() > 1) {
                    heldItemCountLabel.setText(String.valueOf(heldItem.getCount()));
                    heldItemCountLabel.setVisible(true);
                } else {
                    heldItemCountLabel.setVisible(false);
                }
                heldItemGroup.setVisible(true);
                heldItemGroup.toFront();
            }
        }
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void pause() {
    }

    public void setVisible(boolean visible) {
        this.visible = visible;
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
        if (visible) {
            GameLogger.info("InventoryScreen hide() called");
            visible = false;

            // If there's still a held item, return it to the inventory now
            if (heldItem != null) {
                ItemData heldItemData = InventoryConverter.itemToItemData(heldItem);
                if (heldItemData != null) {
                    getInventory().addItem(heldItemData);
                }
                setHeldItem(null);
            }

            // Return crafting items
            craftingSystem.returnItemsToInventory();

            if (stage != null) {
                stage.setKeyboardFocus(null);
                stage.unfocusAll();
            }
            inputManager.setUIState(InputManager.UIState.NORMAL);
        }
    }

    @Override
    public void dispose() {
        stage.dispose();
        batch.dispose();
        shapeRenderer.dispose();
    }

    @Override
    public ItemData getHeldItem() {
        return InventoryConverter.itemToItemData(heldItem);
    }

    @Override
    public synchronized void setHeldItem(Item item) {
        if (item == null || item.getCount() <= 0) {
            this.heldItem = null;
        } else {
            Item newHeldItem = new Item(item.getName());
            newHeldItem.setCount(item.getCount());
            newHeldItem.setUuid(item.getUuid() != null ? item.getUuid() : UUID.randomUUID());
            newHeldItem.setDurability(item.getDurability());
            newHeldItem.setMaxDurability(item.getMaxDurability());
            this.heldItem = newHeldItem;
        }
        updateHeldItemDisplay();
    }

    @Override
    public Inventory getInventory() {
        return inventory;
    }

    @Override
    public void onInventoryChanged() {
        // Just log the change. The slots will update themselves when data changes.
        GameLogger.info("Inventory changed - not reloading display immediately");
        // No forced reloadInventory() call here to avoid conflicts.
    }

    @Override
    public Player getPlayer() {
        return player;
    }

    static class ParticleEffectActor extends Actor {
        private final ParticleEffect effect;

        public ParticleEffectActor(ParticleEffect effect) {
            this.effect = effect;
            effect.start();
        }

        @Override
        public void draw(Batch batch, float parentAlpha) {
            effect.setPosition(getX(), getY());
            effect.draw(batch, Gdx.graphics.getDeltaTime());
        }

        @Override
        public void act(float delta) {
            super.act(delta);
            effect.update(delta);
        }
    }
}

================
File: main/java/io/github/pokemeetup/screens/InventoryScreenInterface.java
================
package io.github.pokemeetup.screens;

import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingSystem;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;

public interface InventoryScreenInterface {
    Inventory getInventory();
    Player getPlayer();
    void updateHeldItemDisplay();
    Item getHeldItemObject();  // Add this method
    ItemData getHeldItem();
    void setHeldItem(Item item);
    CraftingSystem getCraftingSystem();
    ItemContainer getChestData();
}

================
File: main/java/io/github/pokemeetup/screens/LoadingScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.ProgressBar;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class LoadingScreen implements Screen {
    private static final float PROGRESS_BAR_WIDTH = 300;
    private static final float PROGRESS_BAR_HEIGHT = 20;
    private static final float UPDATE_INTERVAL = 0.1f; // Update every 100ms

    private final CreatureCaptureGame game;
    private Screen nextScreen;
    private final Stage stage;
    private final ProgressBar progressBar;
    private final Label statusLabel;
    private final Label progressLabel;
    private boolean disposed = false;
    private float progress = 0;
    private float elapsedTime = 0;
    private float updateTimer = 0;
    private String currentStatus = "Initializing...";

    public LoadingScreen(CreatureCaptureGame game, Screen nextScreen) {
        this.game = game;
        this.nextScreen = nextScreen;
        this.stage = new Stage(new ScreenViewport());
        Skin skin = new Skin(Gdx.files.internal("atlas/ui-gfx-atlas.json"));
        Table mainTable = new Table();
        mainTable.setFillParent(true);
        ProgressBar.ProgressBarStyle progressStyle = new ProgressBar.ProgressBarStyle();
        progressStyle.background = skin.getDrawable("progress-bar-bg");
        progressStyle.knob = skin.getDrawable("progress-bar-knob");
        progressStyle.knobBefore = skin.getDrawable("progress-bar-bg");

        progressBar = new ProgressBar(0, 1, 0.01f, false, progressStyle);
        progressBar.setSize(PROGRESS_BAR_WIDTH, PROGRESS_BAR_HEIGHT);

        // Labels
        Label.LabelStyle labelStyle = new Label.LabelStyle(skin.getFont("default-font"), Color.WHITE);
        statusLabel = new Label("", labelStyle);
        progressLabel = new Label("", labelStyle);

        // Layout
        mainTable.add(statusLabel).pad(10).row();
        mainTable.add(progressBar).width(PROGRESS_BAR_WIDTH).height(PROGRESS_BAR_HEIGHT).pad(10).row();
        mainTable.add(progressLabel).pad(10);

        stage.addActor(mainTable);

        GameLogger.info("Loading screen initialized");
    }

    public void setNextScreen(Screen screen) {
        this.nextScreen = screen;
        GameLogger.info("Next screen set: " + screen.getClass().getSimpleName());
    }

    @Override
    public void render(float delta) {
        elapsedTime += delta;
        updateTimer += delta;

        // Update status at intervals
        if (updateTimer >= UPDATE_INTERVAL) {
            updateTimer = 0;
            updateLoadingStatus();
        }

        // Clear screen
        Gdx.gl.glClearColor(0.1f, 0.1f, 0.1f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        // Check if next screen is ready
        if (nextScreen instanceof GameScreen) {
            GameScreen gameScreen = (GameScreen) nextScreen;

            if (gameScreen.isInitialized()) {
                GameLogger.info("Game screen initialized, transitioning...");
                progress = 1;
                updateUI();
                // Add small delay before transition
                if (elapsedTime > 0.5f) {
                    game.setScreen(nextScreen);
                    dispose();
                    return;
                }
            } else {
                updateProgress();
            }
        }

        stage.act(delta);
        stage.draw();
    }

    private void updateLoadingStatus() {
        if (nextScreen instanceof GameScreen) {
            GameScreen gameScreen = (GameScreen) nextScreen;
            String newStatus = getStatusMessage(gameScreen);

            if (!newStatus.equals(currentStatus)) {
                currentStatus = newStatus;
                statusLabel.setText(currentStatus);
                GameLogger.info("Loading status: " + currentStatus);
            }
        }
        updateUI();
    }

    private String getStatusMessage(GameScreen gameScreen) {
        if (progress < 0.3f) return "Initializing world...";
        if (progress < 0.6f) return "Loading chunks...";
        if (progress < 0.9f) return "Preparing game...";
        return "Starting game...";
    }

    private void updateProgress() {
        // Update progress based on actual loading state
        if (GameContext.get().getWorld() != null && GameContext.get().getWorld().getChunks() != null) {
            int totalRequired = (World.INITIAL_LOAD_RADIUS * 2 + 1) *
                (World.INITIAL_LOAD_RADIUS * 2 + 1);
            int loaded = GameContext.get().getWorld().getChunks().size();
            progress = Math.min(0.9f, (float) loaded / totalRequired);
        }
    }

    private void updateUI() {
        progressBar.setValue(progress);
        progressLabel.setText(String.format("%.0f%%", progress * 100));
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void dispose() {
        if (!disposed) {
            GameLogger.info("Disposing loading screen");
            stage.dispose();
            disposed = true;
        }
    }

    @Override
    public void show() {}

    @Override
    public void pause() {}

    @Override
    public void resume() {}

    @Override
    public void hide() {}
}

================
File: main/java/io/github/pokemeetup/screens/LoginScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Preferences;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.Timer;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.client.GameClientSingleton;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.multiplayer.server.config.ServerConfigManager;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;

public class LoginScreen implements Screen {
    public static final String SERVERS_PREFS = "ServerPrefs";
    public static final float MIN_WIDTH = 300f;
    public static final float MAX_WIDTH = 500f;
    private static final String DEFAULT_SERVER_ICON = "ui/default-server-icon.png";
    private static final int MIN_HEIGHT = 600;
    private static final float CONNECTION_TIMEOUT = 30f;
    private static final int MAX_CONNECTION_ATTEMPTS = 3;
    public final Stage stage;
    public final Skin skin;
    public final CreatureCaptureGame game;
    private final Preferences prefs;
    public Array<ServerConnectionConfig> servers; // Adding the servers variable
    public TextField usernameField;
    public TextField passwordField;
    public CheckBox rememberMeBox;
    public Label feedbackLabel;
    public ServerConnectionConfig selectedServer;
    private Table serverListTable;
    private Table mainTable;
    private TextButton loginButton;
    private TextButton registerButton;
    private TextButton backButton;
    private ProgressBar connectionProgress;
    private Label statusLabel;
    private float connectionTimer;
    private boolean isConnecting = false;
    private int connectionAttempts = 0;
    private ScrollPane serverListScrollPane;

    public LoginScreen(CreatureCaptureGame game) {
        this.game = game;
        this.stage = new Stage(new ScreenViewport());
        this.skin = new Skin(Gdx.files.internal("atlas/ui-gfx-atlas.json"));
        this.prefs = Gdx.app.getPreferences("LoginPrefs");
        loadServers();

        createUIComponents();

        setupListeners();

        initializeUI();

        loadSavedCredentials();

        Gdx.input.setInputProcessor(stage);
    }

    private static ServerConnectionConfig getServerConnectionConfig(ServerEntry entry) {
        ServerConnectionConfig config = new ServerConnectionConfig(
            entry.ip,
            entry.tcpPort,
            entry.udpPort,
            entry.name,
            entry.isDefault,
            entry.maxPlayers
        );
        config.setMotd(entry.motd);
        config.setIconPath(entry.iconPath != null ? entry.iconPath : DEFAULT_SERVER_ICON);
        return config;
    }

    private void createUIComponents() {
        mainTable = new Table();
        mainTable.setFillParent(true);

        // Create buttons first
        TextButton.TextButtonStyle buttonStyle = new TextButton.TextButtonStyle();
        buttonStyle.up = skin.getDrawable("button");
        buttonStyle.down = skin.getDrawable("button-pressed");
        buttonStyle.over = skin.getDrawable("button-over");
        buttonStyle.font = skin.getFont("default-font");

        loginButton = new TextButton("Login", buttonStyle);
        registerButton = new TextButton("Register", buttonStyle);
        backButton = new TextButton("Back", buttonStyle);

        // Create custom text field style
        TextField.TextFieldStyle textFieldStyle = new TextField.TextFieldStyle(skin.get(TextField.TextFieldStyle.class));
        textFieldStyle.font = skin.getFont("default-font");
        textFieldStyle.fontColor = Color.WHITE;
        textFieldStyle.background = new TextureRegionDrawable(TextureManager.ui.findRegion("textfield"));
        textFieldStyle.cursor = skin.getDrawable("cursor");
        textFieldStyle.selection = skin.getDrawable("selection");
        textFieldStyle.messageFontColor = new Color(0.7f, 0.7f, 0.7f, 1f);

        // Create input fields
        usernameField = new TextField("", textFieldStyle);
        usernameField.setMessageText("Enter username");

        passwordField = new TextField("", textFieldStyle);
        passwordField.setMessageText("Enter password");
        passwordField.setPasswordMode(true);
        passwordField.setPasswordCharacter('*');

        // Create checkbox
        rememberMeBox = new CheckBox(" Remember Me", skin);

        // Create labels
        feedbackLabel = new Label("", skin);
        feedbackLabel.setWrap(true);

        statusLabel = new Label("", skin);
        statusLabel.setWrap(true);

        // Create progress bar
        ProgressBar.ProgressBarStyle progressStyle = new ProgressBar.ProgressBarStyle();
        progressStyle.background = skin.getDrawable("progress-bar-bg");
        progressStyle.knob = skin.getDrawable("progress-bar-knob");
        progressStyle.knobBefore = skin.getDrawable("progress-bar-bg");

        connectionProgress = new ProgressBar(0, 1, 0.01f, false, progressStyle);
        connectionProgress.setVisible(false);

        // Create server list
        serverListScrollPane = createServerList();
    }

    private ScrollPane createServerList() {
        serverListTable = new Table();
        serverListTable.top();

        // Add servers
        for (ServerConnectionConfig server : servers) {
            Table serverEntry = createServerEntry(server);
            serverListTable.add(serverEntry).expandX().fillX().padBottom(2).row();
        }

        // Create scroll pane with styling
        ScrollPane.ScrollPaneStyle scrollStyle = new ScrollPane.ScrollPaneStyle();
        scrollStyle.background = new TextureRegionDrawable(TextureManager.ui.findRegion("textfield"));
        scrollStyle.vScroll = skin.getDrawable("scrollbar-v");
        scrollStyle.vScrollKnob = skin.getDrawable("scrollbar-knob-v");

        ScrollPane scrollPane = new ScrollPane(serverListTable, scrollStyle);
        scrollPane.setScrollingDisabled(true, false);
        scrollPane.setFadeScrollBars(false);
        scrollPane.setOverscroll(false, false);

        return scrollPane;
    }

    private Table createServerEntry(final ServerConnectionConfig server) {
        Table entry = new Table();
        entry.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("info-box-bg")));
        entry.pad(10);

        // Server icon with error handling
        Table iconContainer = new Table();
        try {
            if (server.getIconPath() != null && !server.getIconPath().isEmpty()) {
                FileHandle iconFile = Gdx.files.internal(server.getIconPath());
                if (iconFile.exists()) {
                    Image icon = new Image(new TextureRegionDrawable(new TextureRegion(new Texture(iconFile))));
                    iconContainer.add(icon).size(32, 32);
                } else {
                    // Use default icon
                    Image defaultIcon = new Image(TextureManager.ui.findRegion("default-server-icon"));
                    iconContainer.add(defaultIcon).size(32, 32);
                }
            } else {
                // Use default icon
                Image defaultIcon = new Image(TextureManager.ui.findRegion("default-server-icon"));
                iconContainer.add(defaultIcon).size(32, 32);
            }
        } catch (Exception e) {
            GameLogger.error("Failed to load server icon: " + e.getMessage());
            // Use default icon
            Image defaultIcon = new Image(TextureManager.ui.findRegion("default-server-icon"));
            iconContainer.add(defaultIcon).size(32, 32);
        }

        // Server info
        Table infoTable = new Table();
        infoTable.left();

        Label nameLabel = new Label(server.getServerName(), skin);
        nameLabel.setFontScale(1.1f);

        Label motdLabel = new Label(server.getMotd() != null ? server.getMotd() : "Welcome!", skin);
        motdLabel.setColor(0.8f, 0.8f, 0.8f, 1f);

        Label addressLabel = new Label(server.getServerIP() + ":" + server.getTcpPort(), skin);
        addressLabel.setColor(0.7f, 0.7f, 0.7f, 1f);

        infoTable.add(nameLabel).left().row();
        infoTable.add(motdLabel).left().padTop(2).row();
        infoTable.add(addressLabel).left().padTop(2);

        entry.add(iconContainer).padRight(10);
        entry.add(infoTable).expandX().fillX().left();

        // Selection handling
        entry.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                selectedServer = server;
                updateServerSelection(entry);
            }

            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                if (selectedServer != server) {
                    entry.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("textfield-active")));
                }
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                if (selectedServer != server) {
                    entry.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("textfield")));
                }
            }
        });

        return entry;
    }

    private void updateServerSelection(Table selectedEntry) {
        // Update visual selection for all entries
        for (Cell<?> cell : serverListTable.getCells()) {
            Actor actor = cell.getActor();
            if (actor instanceof Table) {
                Table entry = (Table) actor;
                TextureRegionDrawable background;
                if (entry == selectedEntry) {
                    background = new TextureRegionDrawable(TextureManager.ui.findRegion("textfield-active"));
                    background.setMinWidth(entry.getWidth());
                    background.setMinHeight(entry.getHeight());
                    entry.setBackground(background);
                } else {
                    background = new TextureRegionDrawable(TextureManager.ui.findRegion("textfield"));
                    background.setMinWidth(entry.getWidth());
                    background.setMinHeight(entry.getHeight());
                    entry.setBackground(background);
                }
            }
        }
    }

    private void initializeUI() {
        float screenWidth = Gdx.graphics.getWidth();
        float contentWidth = Math.min(500, screenWidth * 0.9f);

        // Create dark panel container
        Table darkPanel = new Table();
        darkPanel.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("window")));
        darkPanel.pad(20);

        // Title
        Label titleLabel = new Label("PokeMeetup", skin);
        titleLabel.setFontScale(2f);
        darkPanel.add(titleLabel).padBottom(30).row();

        // Server selection section
        Label serverLabel = new Label("Select Server", skin);
        serverLabel.setFontScale(1.2f);
        darkPanel.add(serverLabel).left().padBottom(10).row();

        // Server list container
        darkPanel.add(serverListScrollPane)
            .width(contentWidth - 40)
            .height(180)
            .padBottom(20)
            .row();

        // Login fields
        Table fieldsTable = new Table();
        fieldsTable.defaults().width(contentWidth - 40).padBottom(10);

        // Username field with label
        Table usernameRow = new Table();
        Label usernameLabel = new Label("Username:", skin);
        usernameRow.add(usernameLabel).width(80).right().padRight(10);
        usernameRow.add(usernameField).expandX().fillX().height(36);
        fieldsTable.add(usernameRow).row();

        // Password field with label
        Table passwordRow = new Table();
        Label passwordLabel = new Label("Password:", skin);
        passwordRow.add(passwordLabel).width(80).right().padRight(10);
        passwordRow.add(passwordField).expandX().fillX().height(36);
        fieldsTable.add(passwordRow).row();

        // Remember me checkbox
        rememberMeBox = new CheckBox(" Remember Me", skin);
        fieldsTable.add(rememberMeBox).left().padTop(5).row();

        darkPanel.add(fieldsTable).row();

        // Buttons
        Table buttonTable = new Table();
        float buttonWidth = (contentWidth - 60) / 2;

        // Login and Register buttons
        Table actionButtons = new Table();
        actionButtons.add(loginButton).width(buttonWidth).padRight(10);
        actionButtons.add(registerButton).width(buttonWidth);
        buttonTable.add(actionButtons).padBottom(10).row();

        // Back button
        buttonTable.add(backButton).width(buttonWidth);

        darkPanel.add(buttonTable).padTop(20).padBottom(10).row();

        // Status elements
        Table statusTable = new Table();
        statusTable.add(statusLabel).width(contentWidth - 40).padBottom(5).row();
        statusTable.add(connectionProgress).width(contentWidth - 40).height(4).padBottom(5).row();
        statusTable.add(feedbackLabel).width(contentWidth - 40);

        darkPanel.add(statusTable).row();

        // Add to main table
        mainTable.add(darkPanel);
        // Select first server by default if available

        stage.addActor(mainTable);
        if (servers.isEmpty()) {
            return;
        }
        if (servers != null && servers.size > 0) {
            selectedServer = servers.first();
            updateServerSelection((Table) serverListTable.getCells().first().getActor());
        }
    }

    private void attemptLogin() {
        if (isConnecting) {
            return;
        }

        String username = usernameField.getText().trim();
        String password = passwordField.getText().trim();

        if (!validateInput(username, password)) {
            return;
        }

        if (selectedServer == null) {
            showError("Please select a server");
            return;
        }

        // Show loading feedback
        isConnecting = true;
        setUIEnabled(false);
        statusLabel.setText("Connecting to server...");
        statusLabel.setColor(Color.WHITE);
        connectionProgress.setVisible(true);
        connectionProgress.setValue(0);
        feedbackLabel.setText("");

        // Track login state
        final AtomicBoolean loginCompleted = new AtomicBoolean(false);
        final AtomicBoolean transitionStarted = new AtomicBoolean(false);

        try {
            // Cleanup existing client
            if (GameContext.get().getGameClient() != null) {
                GameContext.get().getGameClient().dispose();
                GameClientSingleton.resetInstance();
            }

            // Create new client
            GameContext.get().setGameClient(new GameClient(
                selectedServer,
                false
            ));

            // Set up response handlers
            GameContext.get().getGameClient().setLoginResponseListener(response -> {
                if (loginCompleted.get()) {
                    return; // Prevent duplicate processing
                }
                loginCompleted.set(true);

                Gdx.app.postRunnable(() -> {
                    if (response.success) {
                        handleSuccessfulLogin(response, transitionStarted);
                    } else {
                        handleLoginFailure(response.message);
                    }
                });
            });

            // Set initialization listener
            GameContext.get().getGameClient().setInitializationListener(success -> {
                if (transitionStarted.get()) {
                    return; // Prevent duplicate transitions
                }

                Gdx.app.postRunnable(() -> {
                    if (success) {
                        proceedToGame(transitionStarted);
                    } else {
                        handleInitializationFailure();
                    }
                });
            });

            // Start progress animation
            Timer.schedule(new Timer.Task() {
                float progress = 0;

                @Override
                public void run() {
                    if (!isConnecting) {
                        cancel();
                        return;
                    }
                    progress += 0.05f;
                    connectionProgress.setValue(Math.min(0.9f, progress));
                }
            }, 0, 0.05f);

            // Set credentials and connect
            GameContext.get().getGameClient().setPendingCredentials(username, password);
            GameContext.get().getGameClient().connect();

        } catch (Exception e) {
            handleLoginError(e);
        }
    }

    private void showRetryDialog() {
        Dialog dialog = new Dialog("Connection Failed", skin) {
            @Override
            protected void result(Object obj) {
                if ((Boolean) obj) {
                    attemptLogin();
                } else {
                    setUIEnabled(true);
                }
            }
        };

        dialog.text("Would you like to try connecting again?");
        dialog.button("Retry", true);
        dialog.button("Cancel", false);
        dialog.show(stage);
    }

    private void handleSuccessfulLogin(NetworkProtocol.LoginResponse response, AtomicBoolean transitionStarted) {
        if (transitionStarted.get()) {
            return;
        }
        transitionStarted.set(true);

        try {
            // Update progress
            connectionProgress.setValue(0.95f);
            statusLabel.setText("Loading world...");

            // Create loading screen
            LoadingScreen loadingScreen = new LoadingScreen(game, null);
            game.setScreen(loadingScreen);

            GameContext.get().setGameScreen(new GameScreen(
                game,
                response.username,
                GameContext.get().getGameClient()
            ));

            // Update loading screen target
            loadingScreen.setNextScreen(GameContext.get().getGameScreen());

            // Save credentials if needed
            if (rememberMeBox.isChecked()) {
                saveCredentials(usernameField.getText(), passwordField.getText());
            }

            // Clean up
            dispose();

        } catch (Exception e) {
            transitionStarted.set(false);
            handleGameCreationError(e);
        }
    }

    // In LoginScreen.java - Update handleLoginResponse
    private void handleLoginResponse(NetworkProtocol.LoginResponse response) {
        isConnecting = false;

        if (response.success) {
            GameLogger.info("Login successful, transitioning to loading screen");
            try {
                // Create loading screen
                LoadingScreen loadingScreen = new LoadingScreen(game, null);
                GameContext.get().setGameScreen(new GameScreen(game, response.username,
                    GameContext.get().getGameClient()));

                // Verify game screen creation
                if (!GameContext.get().getGameScreen().isInitialized()) {
                    showError("Failed to initialize game screen");
                    return;
                }

                // Set next screen and transition
                loadingScreen.setNextScreen(GameContext.get().getGameScreen());
                game.setScreen(loadingScreen);

                // Save credentials if needed
                if (rememberMeBox.isChecked()) {
                    saveCredentials(usernameField.getText(), passwordField.getText());
                }

                dispose(); // Clean up login screen

            } catch (Exception e) {
                GameLogger.error("Failed to transition to game: " + e.getMessage());
                showError("Failed to start game: " + e.getMessage());
                setUIEnabled(true);
            }
        } else {
            showError(response.message != null ? response.message : "Login failed");
            setUIEnabled(true);
        }
    }

    private void handleAlreadyLoggedIn() {
        isConnecting = false;
        connectionProgress.setVisible(false);

        // Show warning dialog
        Dialog dialog = new Dialog("Already Logged In", skin) {
            @Override
            protected void result(Object obj) {
                if ((Boolean) obj) {
                    // User chose to force login - attempt relogin with force flag
                    forceRelogin();
                } else {
                    // User cancelled - reset UI
                    setUIEnabled(true);
                    statusLabel.setText("");
                    feedbackLabel.setText("Login cancelled");
                }
            }
        };

        dialog.text("This account is already logged in.\nWould you like to disconnect the other session?");
        dialog.button("Yes, log out other session", true);
        dialog.button("Cancel", false);
        dialog.show(stage);
    }

    private void forceRelogin() {
        if (GameContext.get().getGameClient() != null) {
            GameContext.get().getGameClient().dispose();
        }

        String username = usernameField.getText().trim();
        String password = passwordField.getText().trim();

        // Show reconnecting status
        statusLabel.setText("Reconnecting...");
        setUIEnabled(false);
        connectionProgress.setVisible(true);
        connectionProgress.setValue(0);

        // Create new client with force login flag
        try {
            GameContext.get().setGameClient(new GameClient(selectedServer, false));

            // Set login response listener
            GameContext.get().getGameClient().setLoginResponseListener(this::handleForceLoginResponse);

            // Set force login flag and credentials
            GameContext.get().getGameClient().setPendingCredentials(username, password);
            GameContext.get().getGameClient().connect();

        } catch (Exception e) {
            GameLogger.error("Force relogin failed: " + e.getMessage());
            handleLoginFailure("Failed to reconnect: " + e.getMessage());
        }
    }

    private void handleForceLoginResponse(NetworkProtocol.LoginResponse response) {
        Gdx.app.postRunnable(() -> {
            if (response.success) {
                // Successfully forced login
                handleSuccessfulLoginAttempt(response);
            } else {
                // Failed to force login
                handleLoginFailure(response.message);
            }
        });
    }

    private void handleSuccessfulLoginAttempt(NetworkProtocol.LoginResponse response) {
        // Disable UI during transition
        setUIEnabled(false);
        statusLabel.setText("Initializing game...");
        connectionProgress.setValue(0.9f);

        try {
            // Validate game client state
            if (GameContext.get().getGameClient() == null || !GameContext.get().getGameClient().isConnected()) {
                throw new IllegalStateException("Invalid game client state");
            }

            // Create loading screen
            LoadingScreen loadingScreen = new LoadingScreen(game, null);
            game.setScreen(loadingScreen);

            // Initialize game screen
            GameScreen gameScreen = new GameScreen(
                game,
                response.username,
                GameContext.get().getGameClient()
            );

            // Update loading screen target
            loadingScreen.setNextScreen(gameScreen);

            // Save credentials if needed
            if (rememberMeBox.isChecked()) {
                saveCredentials(usernameField.getText(), passwordField.getText());
            }

            // Clean up login screen
            dispose();

        } catch (Exception e) {
            GameLogger.error("Error during game initialization: " + e.getMessage());
            handleGameCreationError(e);
        }
    }

    private void handleGameCreationError(Exception e) {
        Gdx.app.postRunnable(() -> {
            // Clean up any partial state
            if (GameContext.get().getGameClient() != null) {
                GameContext.get().getGameClient().dispose();
                GameContext.get().setGameClient(null);
            }

            // Reset UI state
            isConnecting = false;
            connectionProgress.setVisible(false);
            setUIEnabled(true);

            // Show error dialog
            Dialog dialog = new Dialog("Login Error", skin);
            dialog.text("Failed to start game: " + e.getMessage() + "\nPlease try again.");
            dialog.button("OK", true);
            dialog.show(stage);
        });
    }

    @Override
    public void render(float delta) {
        // Update connection timeout if connecting
        if (isConnecting) {
            connectionTimer += delta;
            connectionProgress.setValue(connectionTimer / CONNECTION_TIMEOUT);

            if (connectionTimer >= CONNECTION_TIMEOUT) {
                handleConnectionTimeout();
                return;
            }
        }

        // Regular rendering
        Gdx.gl.glClearColor(0.1f, 0.1f, 0.1f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        stage.act(delta);
        stage.draw();

        // Update game client if exists
        if (GameContext.get().getGameClient() != null) {
            GameContext.get().getGameClient().tick(delta);
        }
    }

    private void handleConnectionTimeout() {
        isConnecting = false;
        connectionTimer = 0;
        connectionProgress.setVisible(false);

        if (connectionAttempts < MAX_CONNECTION_ATTEMPTS) {
            showRetryDialog();
        } else {
            showError("Connection failed after multiple attempts. Please try again later.");
            setUIEnabled(true);

        }


    }

    private void handleConnectionError(Exception e) {
        Gdx.app.postRunnable(() -> {
            showError("Connection failed: " + e.getMessage());
            setUIEnabled(true);
            isConnecting = false;
            connectionProgress.setVisible(false);


        });
    }

    private void startConnection(String username, String password, ServerConnectionConfig server) {
        isConnecting = true;
        connectionTimer = 0;
        setUIEnabled(false);

        // Update UI feedback
        statusLabel.setText("Connecting to server...");
        statusLabel.setColor(Color.WHITE);
        connectionProgress.setVisible(true);
        connectionProgress.setValue(0);
        feedbackLabel.setText("");

        try {
            GameLogger.info("Starting connection to: " + server.getServerIP() + ":" +
                server.getTcpPort() + "/" + server.getUdpPort());

            // Reset existing client
            if (GameContext.get().getGameClient() != null) {
                GameContext.get().getGameClient().dispose();
            }
            GameClientSingleton.resetInstance();

            // Create new client instance
            GameContext.get().setGameClient(GameClientSingleton.getInstance(server));
            if (GameContext.get().getGameClient() == null) {
                GameLogger.error("Failed to initialize GameClient.");
                handleConnectionError(new Exception("Failed to initialize GameClient."));
                return;
            }

            // Set up login response listener BEFORE connecting
            GameContext.get().getGameClient().setLoginResponseListener(this::handleLoginResponse);

            // Set up initialization listener
            GameContext.get().getGameClient().setInitializationListener(success -> {
                if (success) {
                    GameLogger.info("Game client initialization successful");

                    // CRITICAL: Create and switch to game screen immediately
                    Gdx.app.postRunnable(() -> {
                        try {
                            GameContext.get().setGameScreen(new GameScreen(
                                game,
                                username,
                                GameContext.get().getGameClient()
                            )  );
                            game.setScreen(GameContext.get().getGameScreen());
                            dispose(); // Clean up login screen
                        } catch (Exception e) {
                            GameLogger.error("Failed to create game screen: " + e.getMessage());
                            showError("Failed to start game: " + e.getMessage());
                            setUIEnabled(true);
                            isConnecting = false;
                        }
                    });
                } else {
                    GameLogger.error("Game client initialization failed");
                    showError("Failed to initialize game");
                    setUIEnabled(true);
                    isConnecting = false;
                }
            });

            // Set credentials and connect
            GameContext.get().getGameClient().setPendingCredentials(username, password);
            GameContext.get().getGameClient().connect();

            GameLogger.info("Connection attempt started for user: " + username);

        } catch (Exception e) {
            GameLogger.error("Connection error: " + e.getMessage());
            handleConnectionError(e);
        }
    }

    private void setupListeners() {
        if (loginButton != null) {
            loginButton.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    if (!isConnecting) {
                        attemptLogin();
                    } else {
                        GameLogger.info("Login already in progress");
                    }
                }
            });

        }

        if (registerButton != null) {
            registerButton.addListener(new ChangeListener() {
                @Override
                public void changed(ChangeEvent event, Actor actor) {
                    if (!isConnecting) {
                        attemptRegistration();
                    }
                }
            });
        }

        if (backButton != null) {
            backButton.addListener(new ChangeListener() {
                @Override
                public void changed(ChangeEvent event, Actor actor) {
                    if (!isConnecting) {
                        game.setScreen(new ModeSelectionScreen(game));
                    }
                }
            });
        }

        // Add enter key listener
        stage.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                if (keycode == Input.Keys.ENTER && !isConnecting) {
                    attemptLogin();
                    return true;
                }
                return false;
            }
        });
    }

    @Override
    public void dispose() {
        stage.dispose();
    }

    @Override
    public void resize(int width, int height) {
        // Enforce minimum dimensions
        width = (int) Math.max(width, MIN_WIDTH);
        height = Math.max(height, MIN_HEIGHT);

        GameLogger.info("Resizing login screen to: " + width + "x" + height);

        stage.getViewport().update(width, height, true);

        // Recalculate UI dimensions
        float contentWidth = Math.min(MAX_WIDTH, width * 0.9f);

        // Update main container size
        if (mainTable != null) {
            mainTable.setWidth(contentWidth);
            mainTable.invalidateHierarchy();
        }

        // Update server list if it exists
        if (serverListScrollPane != null) {
            serverListScrollPane.setWidth(contentWidth - 40);
            serverListScrollPane.invalidateHierarchy();
        }

    }

    private void updateStatusLabel(String status, Color color) {
        statusLabel.setText(status);
        statusLabel.setColor(color);
    }

    private void handleLoginError(Exception e) {
        Gdx.app.postRunnable(() -> {
            isConnecting = false;
            connectionProgress.setVisible(false);

            // Clean up any partial client state
            if (GameContext.get().getGameClient() != null) {
                GameContext.get().getGameClient().dispose();
                GameContext.get().setGameClient(null);
            }

            // Show error to user
            String errorMessage = "Login failed: " +
                (e.getMessage() != null ? e.getMessage() : "Unknown error occurred");
            showError(errorMessage);

            // Re-enable UI
            setUIEnabled(true);

            GameLogger.error("Login error: " + e.getMessage());
            e.printStackTrace();
        });
    }

    private void handleInitializationFailure() {
        Gdx.app.postRunnable(() -> {
            isConnecting = false;
            connectionProgress.setVisible(false);

            // Clean up resources
            if (GameContext.get().getGameClient() != null) {
                GameContext.get().getGameClient().dispose();
                GameContext.get().setGameClient(null);
            }

            // Show error dialog with retry option
            Dialog dialog = new Dialog("Initialization Failed", skin) {
                @Override
                protected void result(Object obj) {
                    if ((Boolean) obj) {
                        // Retry connection
                        attemptLogin();
                    } else {
                        // Reset UI state
                        setUIEnabled(true);
                        statusLabel.setText("");
                    }
                }
            };

            dialog.text("Failed to initialize game. Would you like to try again?");
            dialog.button("Retry", true);
            dialog.button("Cancel", false);
            dialog.show(stage);

            GameLogger.error("Game initialization failed");
        });
    }

    private void proceedToGame(AtomicBoolean transitionStarted) {
        if (transitionStarted.get()) {
            return;
        }
        transitionStarted.set(true);

        try {
            validateGameClient();
            GameScreen gameScreen = createGameScreen();

            if (gameScreen != null) {
                // Create and show loading screen
                LoadingScreen loadingScreen = new LoadingScreen(game, gameScreen);
                game.setScreen(loadingScreen);

                // Save credentials if needed
                if (rememberMeBox.isChecked()) {
                    saveCredentials(usernameField.getText(), passwordField.getText());
                }

                // Clean up
                dispose();
            }
        } catch (Exception e) {
            transitionStarted.set(false);
            handleGameTransitionError(e);
        }
    }

    private GameScreen createGameScreen() {
        try {
            String username = usernameField.getText().trim();
            World currentWorld = GameContext.get().getGameClient().getCurrentWorld();

            if (currentWorld == null) {
                throw new IllegalStateException("World not initialized");
            }

            GameContext.get().setGameScreen(new GameScreen(
                game,
                username,
                GameContext.get().getGameClient()
            ));

            // Verify initialization
            if (!GameContext.get().getGameScreen().isInitialized()) {
                throw new IllegalStateException("Game screen failed to initialize");
            }

            return GameContext.get().getGameScreen();

        } catch (Exception e) {
            GameLogger.error("Failed to create game screen: " + e.getMessage());
            return null;
        }
    }

    void handleGameTransitionError(Exception e) {
        Gdx.app.postRunnable(() -> {
            if (GameContext.get().getGameClient() != null) {
                GameContext.get().getGameClient().dispose();
                GameContext.get().setGameClient(null);
            }
            Dialog dialog = new Dialog("Error", skin);
            dialog.text("Failed to start game: " + e.getMessage() + "\nPlease try again.");
            dialog.button("OK", true);
            dialog.show(stage);
            setUIEnabled(true);
            statusLabel.setText("");
            connectionProgress.setVisible(false);
            isConnecting = false;
        });
    }

    private void validateGameClient() {
        if (GameContext.get().getGameClient() == null) {
            throw new IllegalStateException("GameClient is null");
        }

        if (!GameContext.get().getGameClient().isInitialized()) {
            throw new IllegalStateException("GameClient not fully initialized");
        }

        if (GameContext.get().getGameClient().getCurrentWorld() == null) {
            throw new IllegalStateException("World not initialized");
        }
    }

    // Helper method to show errors in a consistent way
    private void showError(String message) {
        Gdx.app.postRunnable(() -> {
            feedbackLabel.setColor(Color.RED);
            feedbackLabel.setText(message);

            // Add screen shake effect for feedback
            stage.addAction(Actions.sequence(
                Actions.moveBy(5f, 0f, 0.05f),
                Actions.moveBy(-10f, 0f, 0.05f),
                Actions.moveBy(5f, 0f, 0.05f)
            ));

            GameLogger.error(message);
        });
    }

    private void setUIEnabled(boolean enabled) {
        float alpha = enabled ? 1f : 0.6f;

        // Disable/enable input fields
        usernameField.setDisabled(!enabled);
        passwordField.setDisabled(!enabled);
        rememberMeBox.setDisabled(!enabled);

        // Disable/enable buttons
        loginButton.setDisabled(!enabled);
        registerButton.setDisabled(!enabled);
        backButton.setDisabled(!enabled);

        // Update visual feedback
        usernameField.setColor(1, 1, 1, alpha);
        passwordField.setColor(1, 1, 1, alpha);
        loginButton.setColor(1, 1, 1, alpha);
        registerButton.setColor(1, 1, 1, alpha);
        backButton.setColor(1, 1, 1, alpha);
        rememberMeBox.setColor(1, 1, 1, alpha);

        // Disable/enable server list entries
        if (serverListTable != null) {
            for (Cell<?> cell : serverListTable.getCells()) {
                Actor actor = cell.getActor();
                if (actor instanceof Table) {
                    actor.setTouchable(enabled ? Touchable.enabled : Touchable.disabled);
                    actor.setColor(1, 1, 1, alpha);
                }
            }
        }
    }

    public void loadServers() {
        try {
            if (servers == null) {
                servers = new Array<>();
            }
            servers.clear();

            ServerConnectionConfig defaultServer = ServerConnectionConfig.getInstance();
            defaultServer.setIconPath(DEFAULT_SERVER_ICON);
            servers.add(defaultServer);

            Preferences serverPrefs = Gdx.app.getPreferences(SERVERS_PREFS);
            String savedServers = serverPrefs.getString("servers", "");

            if (!savedServers.isEmpty()) {
                Json json = new Json();
                for (String serverString : savedServers.split("\\|")) {
                    try {
                        if (!serverString.trim().isEmpty()) {
                            ServerEntry entry = json.fromJson(ServerEntry.class, serverString);
                            if (entry != null && !isDefaultServer(entry)) {
                                ServerConnectionConfig config = getServerConnectionConfig(entry);
                                servers.add(config);
                                GameLogger.info("Loaded server: " + config.getServerName());
                            }
                        }
                    } catch (Exception e) {
                        GameLogger.error("Error loading saved server: " + e.getMessage());
                    }
                }
            }

        } catch (Exception e) {
            GameLogger.error("Error loading servers: " + e.getMessage());
            // Ensure we at least have the default server
            if (servers == null || servers.isEmpty()) {
                servers = new Array<>();
                ServerConnectionConfig defaultServer = ServerConnectionConfig.getInstance();
                defaultServer.setIconPath(DEFAULT_SERVER_ICON);
                servers.add(defaultServer);
            }
        }
    }

    private boolean isDefaultServer(ServerEntry entry) {
        return entry.isDefault && "localhost".equals(entry.ip) && entry.tcpPort == 54555;
    }

    private void saveCredentials(String username, String password) {
        GameLogger.info("Saving credentials for: " + username + ", remember: " + true);
        prefs.putBoolean("rememberMe", true);
        if (true) {
            prefs.putString("username", username);
            prefs.putString("password", password);
            GameLogger.info("Credentials saved to preferences");
        } else {
            prefs.remove("username");
            prefs.remove("password");
            GameLogger.info("Credentials removed from preferences");
        }
        prefs.flush();
    }

    private void loadSavedCredentials() {
        GameLogger.info("Loading saved credentials");
        boolean rememberMe = prefs.getBoolean("rememberMe", false);

        if (rememberMe) {
            String savedUsername = prefs.getString("username", "");
            String savedPassword = prefs.getString("password", "");

            GameLogger.info("Found saved credentials for: " + savedUsername +
                " (Has password: " + !savedPassword.isEmpty() + ")");

            usernameField.setText(savedUsername);
            passwordField.setText(savedPassword);
            rememberMeBox.setChecked(true);
        } else {
            GameLogger.info("No saved credentials found");
        }
    }


    private void attemptRegistration() {
        String username = usernameField.getText().trim();
        String password = passwordField.getText().trim();

        if (!validateRegistrationInput(username, password)) {
            return;
        }

        if (selectedServer == null) {
            showError("Please select a server");
            return;
        }

        // Show immediate UI feedback
        isConnecting = true;
        setUIEnabled(false);
        statusLabel.setText("Creating account...");
        statusLabel.setColor(Color.WHITE);
        connectionProgress.setVisible(true);
        connectionProgress.setValue(0);
        feedbackLabel.setText("");

        CompletableFuture.runAsync(() -> {
            try {
                if (GameContext.get().getGameClient() != null) {
                    GameContext.get().getGameClient().dispose();
                    GameClientSingleton.resetInstance();
                }

                GameContext.get().setGameClient(new GameClient(
                    selectedServer,
                    false
                ));

                GameContext.get().getGameClient().setRegistrationResponseListener(response -> {
                    Gdx.app.postRunnable(() -> {
                        handleRegistrationResponse(response);
                    });
                });

                GameContext.get().getGameClient().connect();

                Thread.sleep(100);

                GameContext.get().getGameClient().sendRegisterRequest(username, password);

            } catch (Exception e) {
                Gdx.app.postRunnable(() -> handleRegistrationError(e));
            }
        });

        // Start progress animation
        Timer.schedule(new Timer.Task() {
            float progress = 0;

            @Override
            public void run() {
                if (!isConnecting) {
                    cancel();
                    return;
                }
                progress += 0.05f;
                connectionProgress.setValue(Math.min(0.9f, progress));
            }
        }, 0, 0.05f);
    }

    private void handleRegistrationResponse(NetworkProtocol.RegisterResponse response) {
        isConnecting = false;
        connectionProgress.setValue(1);

        if (response.success) {
            // Show success animation
            stage.addAction(Actions.sequence(
                Actions.run(() -> {
                    statusLabel.setText("Account created successfully!");
                    statusLabel.setColor(Color.GREEN);
                    connectionProgress.setColor(Color.GREEN);
                }),
                Actions.delay(1f),
                Actions.run(() -> {
                    // Pre-fill username and clear password
                    usernameField.setText(response.username);
                    passwordField.setText("");

                    // Reset UI state
                    statusLabel.setText("Ready to login");
                    statusLabel.setColor(Color.WHITE);
                    connectionProgress.setVisible(false);
                    setUIEnabled(true);

                    // Show success dialog
                    showSuccessDialog();
                })
            ));
        } else {
            stage.addAction(Actions.sequence(
                Actions.run(() -> {
                    showError(response.message != null ? response.message : "Registration failed");
                    connectionProgress.setVisible(false);
                    setUIEnabled(true);
                }),
                Actions.delay(0.5f),
                Actions.run(() -> {
                    // Re-enable after short delay
                    setUIEnabled(true);
                })
            ));
        }

        // Cleanup
        if (GameContext.get().getGameClient() != null) {
            GameContext.get().getGameClient().dispose();
            GameContext.get().setGameClient(null);
        }
    }

    private void handleLoginFailure(String message) {
        Gdx.app.postRunnable(() -> {
            isConnecting = false;
            connectionProgress.setVisible(false);
            setUIEnabled(true);
            showError(message);

            if (GameContext.get().getGameClient() != null) {
                GameContext.get().getGameClient().dispose();
                GameContext.get().setGameClient(null);
            }
        });
    }

    private void handleTransitionError(Exception e) {
        Gdx.app.postRunnable(() -> {
            isConnecting = false;
            connectionProgress.setVisible(false);
            setUIEnabled(true);

            Dialog errorDialog = new Dialog("Error", skin);
            errorDialog.text("Failed to start game: " + e.getMessage() + "\nWould you like to try again?");
            errorDialog.button("Retry", true);
            errorDialog.button("Cancel", false);
            errorDialog.setMovable(false);

            errorDialog.setPosition(
                (stage.getWidth() - errorDialog.getWidth()) / 2,
                (stage.getHeight() - errorDialog.getHeight()) / 2
            );

            errorDialog.show(stage);
        });
    }


    private void showErrorMessage(String title, String message) {
        Dialog dialog = new Dialog(title, skin) {
            @Override
            protected void result(Object obj) {
                feedbackLabel.setColor(Color.RED);
                feedbackLabel.setText(message);
            }
        };
        dialog.text(message);
        dialog.button("OK", true);
        dialog.show(stage);
    }

    private void setupButtonListeners(TextButton loginButton, TextButton registerButton, TextButton backButton) {
        loginButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                attemptLogin();
            }
        });

        registerButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                attemptRegistration();
            }
        });

        backButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                fadeToScreen(new ModeSelectionScreen(game));
            }
        });
    }

    private void handleRegistrationError(Exception e) {
        Gdx.app.postRunnable(() -> {
            showError("Registration failed: " + e.getMessage());
            setUIEnabled(true);
            isConnecting = false;
            connectionProgress.setVisible(false);

            if (GameContext.get().getGameClient() != null) {
                GameContext.get().getGameClient().dispose();
                GameContext.get().setGameClient(null);
            }
        });
    }

    private void showSuccessDialog() {
        Dialog dialog = new Dialog("Registration Successful", skin) {
            @Override
            protected void result(Object obj) {
                if ((Boolean) obj) {
                    // Clear password and update UI
                    passwordField.setText("");
                    statusLabel.setText("Ready to login");
                    statusLabel.setColor(Color.WHITE);
                    feedbackLabel.setText("");
                }
            }
        };

        dialog.text("Your account has been created successfully!\nYou can now log in with your credentials.");
        dialog.button("OK", true);
        dialog.setMovable(false);
        dialog.setModal(true);

        // Center the dialog
        dialog.setPosition(
            (stage.getWidth() - dialog.getWidth()) / 2,
            (stage.getHeight() - dialog.getHeight()) / 2
        );

        dialog.show(stage);
    }

    private boolean validateRegistrationInput(String username, String password) {
        if (username.isEmpty() || password.isEmpty()) {
            showErrorMessage("Invalid Input", "Username and password cannot be empty.");
            return false;
        }

        if (username.length() < 3 || username.length() > 20) {
            showErrorMessage("Invalid Username",
                "Username must be between 3 and 20 characters.");
            return false;
        }

        if (!username.matches("^[a-zA-Z0-9_]+$")) {
            showErrorMessage("Invalid Username",
                "Username can only contain letters, numbers, and underscores.");
            return false;
        }

        String passwordError = validatePassword(password);
        if (passwordError != null) {
            showErrorMessage("Invalid Password", passwordError);
            return false;
        }

        return true;
    }

    private String validatePassword(String password) {
        if (password.length() < 8) {
            return "Password must be at least 8 characters long.";
        }
        if (!password.matches(".*[A-Z].*")) {
            return "Password must contain at least one uppercase letter.";
        }
        if (!password.matches(".*[a-z].*")) {
            return "Password must contain at least one lowercase letter.";
        }
        if (!password.matches(".*\\d.*")) {
            return "Password must contain at least one number.";
        }
        if (!password.matches(".*[!@#$%^&*()\\[\\]{}_+=\\-.,].*")) {
            return "Password must contain at least one special character.";
        }
        return null;
    }

    private boolean validateInput(String username, String password) {
        if (username.isEmpty() || password.isEmpty()) {
            feedbackLabel.setText("Username and password are required");
            return false;
        }
        return true;
    }

    private void fadeToScreen(Screen next) {
        game.setScreen(next);
        dispose();
    }

    @Override
    public void hide() {
    }

    @Override
    public void show() {
    }

    @Override
    public void pause() {
        // Implement if needed
    }

    @Override
    public void resume() {
        // Implement if needed
    }

    private ServerConnectionConfig getSelectedServerConfig() {
        return selectedServer != null ? selectedServer : ServerConfigManager.getDefaultServerConfig();
    }

    // Updated ServerEntry class with icon support
    private static class ServerEntry {
        public String name;
        public String ip;
        public int tcpPort;
        public int udpPort;
        public String motd;
        public boolean isDefault;
        public int maxPlayers;
        public String iconPath;

        public ServerEntry() {
        }

        public ServerEntry(String name, String ip, int tcpPort, int udpPort,
                           String motd, boolean isDefault, int maxPlayers, String iconPath) {
            this.name = name;
            this.ip = ip;
            this.tcpPort = tcpPort;
            this.udpPort = udpPort;
            this.motd = motd;
            this.isDefault = isDefault;
            this.maxPlayers = maxPlayers;
            this.iconPath = iconPath;
        }
    }


}

================
File: main/java/io/github/pokemeetup/screens/ModeSelectionScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.*;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.utils.textures.TextureManager;

public class ModeSelectionScreen implements Screen {
    private final CreatureCaptureGame game;
    private final Stage stage;
    private final Skin skin;
    private final Timer timer;
    private BitmapFont font;

    public ModeSelectionScreen(CreatureCaptureGame game) {
        this.game = game;
        this.stage = new Stage(new ScreenViewport());
        game.reinitializeGame();
        Gdx.input.setInputProcessor(stage);

        this.skin = new Skin();
        this.timer = new Timer();

        try {
            this.font = initializeSkin();
            Gdx.app.log("SkinSetup", "Successfully initialized the skin.");
        } catch (Exception e) {
            showError("Failed to initialize UI: " + e.getMessage());
            Gdx.app.error("SkinSetup", "Failed to initialize UI", e);
            return;
        }
        AudioManager.getInstance().setMusicEnabled(true);
        createUI();
    }

    private BitmapFont initializeSkin() {
        // Add BitmapFont with larger font size
        BitmapFont font = new BitmapFont(Gdx.files.internal("Skins/default.fnt")); // Use a larger font file
        skin.add("default", font);

        // Define Colors
        skin.add("white", Color.WHITE);
        skin.add("black", Color.BLACK);
        skin.add("gray", Color.GRAY);

        // Create drawables
        Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        pixmap.setColor(Color.WHITE);
        pixmap.fill();
        skin.add("white", new Texture(pixmap));

        // Clean up the pixmap
        pixmap.dispose();

        // Create styles
        TextButton.TextButtonStyle textButtonStyle = new TextButton.TextButtonStyle();
        textButtonStyle.up = skin.newDrawable("white", Color.DARK_GRAY);
        textButtonStyle.down = skin.newDrawable("white", Color.LIGHT_GRAY);
        textButtonStyle.over = skin.newDrawable("white", Color.GRAY);
        textButtonStyle.font = skin.getFont("default");
        textButtonStyle.fontColor = Color.WHITE;
        skin.add("default", textButtonStyle);

        Label.LabelStyle labelStyle = new Label.LabelStyle();
        labelStyle.font = skin.getFont("default");
        labelStyle.fontColor = Color.WHITE;
        skin.add("default", labelStyle);

        // Create and add WindowStyle
        Window.WindowStyle windowStyle = new Window.WindowStyle();
        windowStyle.titleFont = skin.getFont("default");
        windowStyle.background = skin.newDrawable("white", new Color(0.2f, 0.2f, 0.2f, 0.8f));
        windowStyle.titleFontColor = Color.WHITE;
        skin.add("default", windowStyle);

        return font;
    }

    private void createUI() {
        // Create root table
        Table rootTable = new Table();
        rootTable.setFillParent(true);

        Table mainTable = new Table();
        mainTable.setFillParent(true);
        TextureRegion backgroundRegion = new TextureRegionDrawable(TextureManager.ui.findRegion("ethereal")).getRegion();
        Image backgroundImage = new Image(backgroundRegion);
        backgroundImage.setFillParent(true);
        stage.addActor(backgroundImage);

        stage.addActor(backgroundImage);
        // Add root table on top
        stage.addActor(rootTable);

        // Title Label
        Label titleLabel = new Label("MineMon", skin);
        titleLabel.setFontScale(1.5f);

        // Version Label
        Label versionLabel = new Label("Version 1.0", skin);
        versionLabel.setFontScale(0.8f);

        // Buttons with styles
        TextButton.TextButtonStyle buttonStyle = skin.get("default", TextButton.TextButtonStyle.class);
        buttonStyle.font.getData().setScale(1.2f);

        TextButton singlePlayerButton = new TextButton("Single Player", buttonStyle);
        TextButton multiplayerButton = new TextButton("Multiplayer", buttonStyle);
        TextButton exitButton = new TextButton("Exit Game", buttonStyle);

        // Build the UI layout
        rootTable.pad(20);
        rootTable.defaults().pad(10).width(Value.percentWidth(0.6f, rootTable)).height(50);

        rootTable.add(titleLabel).expandX().center().row();
        rootTable.add(versionLabel).expandX().center().padBottom(30).row();
        rootTable.add(singlePlayerButton).row();
        rootTable.add(multiplayerButton).row();
        rootTable.add(exitButton).row();

        // Add button listeners
        singlePlayerButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                game.setScreen(new WorldSelectionScreen(game));
                dispose();
            }
        });

        multiplayerButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                game.setScreen(new LoginScreen(game));
                dispose();
            }
        });

        exitButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                Gdx.app.exit();
            }
        });
    }

    private void showError(String message) {
        Dialog dialog = new Dialog("Error", skin);
        dialog.text(message);
        dialog.button("OK");
        dialog.show(stage);
    }

    @Override
    public void render(float delta) {
        // Handle back button on Android
        if (Gdx.input.isKeyJustPressed(Input.Keys.BACK)) {
            Gdx.app.exit();
            return;
        }

        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        stage.act(delta);
        stage.draw();
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
    }

    @Override
    public void dispose() {
        stage.dispose();
        skin.dispose();
        font.dispose();
        if (timer != null) {
            timer.clear();
        }
    }

    // Other required Screen methods...
    @Override
    public void show() {
        AudioManager.getInstance().playMenuMusic();
    }


    @Override
    public void hide() {
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }
}

================
File: main/java/io/github/pokemeetup/screens/otherui/BattleTable.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Interpolation;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.actions.SequenceAction;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.ObjectMap;
import com.badlogic.gdx.utils.Scaling;
import com.badlogic.gdx.utils.viewport.FitViewport;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.HashMap;
import java.util.List;

public class BattleTable extends Table {
    private static final float PLAYER_PLATFORM_Y = 0.12f; // Lowered from 0.18f
    private static final float ENEMY_PLATFORM_Y = 0.48f;  // Lowered from 0.58f
    private static final float CONTROLS_BOTTOM_PADDING = 20f;
    private static final float BUTTON_HEIGHT = 45f;
    private static final float BUTTON_PADDING = 10f;
    private static final float INFO_BOX_PADDING = 15f;
    private static final float POKEMON_SCALE = 1.5f;
    private static final float PLATFORM_SCALE = 1.0f;
    private static final float PLAYER_PLATFORM_X = 0.15f;
    private static final float ENEMY_PLATFORM_X = 0.75f;
    private static final float PLATFORM_WIDTH_RATIO = 0.25f;
    private static final float BUTTON_WIDTH = 160f;
    private static final float HP_BAR_WIDTH = 100;    // Adjust HP bar width to match HUD

    private static final float PLATFORM_VERTICAL_OFFSET = 20f;

    private static final float BASE_WIDTH = 800f;
    private static final float BASE_HEIGHT = 480f;
    private static final float POKEMON_BASE_SIZE = 85f;
    private static final float ANIMATION_DURATION = 0.5f;
    private static final float DAMAGE_FLASH_DURATION = 0.1f;
    private static final float HP_UPDATE_DURATION = 0.5f;
    private static final int MAX_TURN_COUNT = 20;
    private static final ObjectMap<Pokemon.PokemonType, ObjectMap<Pokemon.PokemonType, Float>> typeEffectiveness;
    private static final float PLATFORM_SHAKE_DECAY = 0.9f;
    private static final float MIN_SHAKE_INTENSITY = 0.1f;
    private static final float RUN_SUCCESS_BASE = 0.5f;
    private static final float LEVEL_FACTOR = 0.1f;
    private static final HashMap<Pokemon.PokemonType, Color> TYPE_COLORS = new HashMap<Pokemon.PokemonType, Color>() {{
        put(Pokemon.PokemonType.FIRE, new Color(1, 0.3f, 0.3f, 1));
        put(Pokemon.PokemonType.WATER, new Color(0.2f, 0.6f, 1, 1));
        put(Pokemon.PokemonType.GRASS, new Color(0.2f, 0.8f, 0.2f, 1));
        put(Pokemon.PokemonType.NORMAL, new Color(0.8f, 0.8f, 0.8f, 1));
        put(Pokemon.PokemonType.ELECTRIC, new Color(1, 0.9f, 0.3f, 1));
        put(Pokemon.PokemonType.ICE, new Color(0.6f, 0.9f, 1, 1));
        put(Pokemon.PokemonType.FIGHTING, new Color(0.8f, 0.3f, 0.2f, 1));
        put(Pokemon.PokemonType.POISON, new Color(0.6f, 0.3f, 0.6f, 1));
        put(Pokemon.PokemonType.GROUND, new Color(0.9f, 0.7f, 0.3f, 1));
        put(Pokemon.PokemonType.FLYING, new Color(0.6f, 0.6f, 1, 1));
        put(Pokemon.PokemonType.PSYCHIC, new Color(1, 0.3f, 0.6f, 1));
        put(Pokemon.PokemonType.BUG, new Color(0.6f, 0.8f, 0.3f, 1));
        put(Pokemon.PokemonType.ROCK, new Color(0.7f, 0.6f, 0.3f, 1));
        put(Pokemon.PokemonType.GHOST, new Color(0.4f, 0.3f, 0.6f, 1));
        put(Pokemon.PokemonType.DRAGON, new Color(0.5f, 0.3f, 1, 1));
        put(Pokemon.PokemonType.DARK, new Color(0.4f, 0.3f, 0.3f, 1));
        put(Pokemon.PokemonType.STEEL, new Color(0.7f, 0.7f, 0.8f, 1));
        put(Pokemon.PokemonType.FAIRY, new Color(1, 0.6f, 0.8f, 1));
    }};// Fine-tuned positioning constants// Update these constants for better positioning

    static {
        typeEffectiveness = new ObjectMap<>();
        for (Pokemon.PokemonType type : Pokemon.PokemonType.values()) {
            typeEffectiveness.put(type, new ObjectMap<>());
            for (Pokemon.PokemonType defType : Pokemon.PokemonType.values()) {
                typeEffectiveness.get(type).put(defType, 1.0f); // Default effectiveness
            }
        }

        // Normal type
        initTypeEffectiveness(Pokemon.PokemonType.NORMAL, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.ROCK, 0.5f);
            put(Pokemon.PokemonType.GHOST, 0.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Fire type
        initTypeEffectiveness(Pokemon.PokemonType.FIRE, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.WATER, 0.5f);
            put(Pokemon.PokemonType.GRASS, 2.0f);
            put(Pokemon.PokemonType.ICE, 2.0f);
            put(Pokemon.PokemonType.BUG, 2.0f);
            put(Pokemon.PokemonType.ROCK, 0.5f);
            put(Pokemon.PokemonType.DRAGON, 0.5f);
            put(Pokemon.PokemonType.STEEL, 2.0f);
        }});

        // Water type
        initTypeEffectiveness(Pokemon.PokemonType.WATER, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 2.0f);
            put(Pokemon.PokemonType.WATER, 0.5f);
            put(Pokemon.PokemonType.GRASS, 0.5f);
            put(Pokemon.PokemonType.GROUND, 2.0f);
            put(Pokemon.PokemonType.ROCK, 2.0f);
            put(Pokemon.PokemonType.DRAGON, 0.5f);
        }});

        // Electric type
        initTypeEffectiveness(Pokemon.PokemonType.ELECTRIC, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.WATER, 2.0f);
            put(Pokemon.PokemonType.ELECTRIC, 0.5f);
            put(Pokemon.PokemonType.GRASS, 0.5f);
            put(Pokemon.PokemonType.GROUND, 0.0f);
            put(Pokemon.PokemonType.FLYING, 2.0f);
            put(Pokemon.PokemonType.DRAGON, 0.5f);
        }});

        // Grass type
        initTypeEffectiveness(Pokemon.PokemonType.GRASS, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.WATER, 2.0f);
            put(Pokemon.PokemonType.GRASS, 0.5f);
            put(Pokemon.PokemonType.POISON, 0.5f);
            put(Pokemon.PokemonType.GROUND, 2.0f);
            put(Pokemon.PokemonType.FLYING, 0.5f);
            put(Pokemon.PokemonType.BUG, 0.5f);
            put(Pokemon.PokemonType.ROCK, 2.0f);
            put(Pokemon.PokemonType.DRAGON, 0.5f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Ice type
        initTypeEffectiveness(Pokemon.PokemonType.ICE, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.WATER, 0.5f);
            put(Pokemon.PokemonType.GRASS, 2.0f);
            put(Pokemon.PokemonType.ICE, 0.5f);
            put(Pokemon.PokemonType.GROUND, 2.0f);
            put(Pokemon.PokemonType.FLYING, 2.0f);
            put(Pokemon.PokemonType.DRAGON, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Fighting type
        initTypeEffectiveness(Pokemon.PokemonType.FIGHTING, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.NORMAL, 2.0f);
            put(Pokemon.PokemonType.ICE, 2.0f);
            put(Pokemon.PokemonType.POISON, 0.5f);
            put(Pokemon.PokemonType.FLYING, 0.5f);
            put(Pokemon.PokemonType.PSYCHIC, 0.5f);
            put(Pokemon.PokemonType.BUG, 0.5f);
            put(Pokemon.PokemonType.ROCK, 2.0f);
            put(Pokemon.PokemonType.GHOST, 0.0f);
            put(Pokemon.PokemonType.DARK, 2.0f);
            put(Pokemon.PokemonType.STEEL, 2.0f);
            put(Pokemon.PokemonType.FAIRY, 0.5f);
        }});
        initTypeEffectiveness(Pokemon.PokemonType.POISON, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.GRASS, 2.0f);
            put(Pokemon.PokemonType.POISON, 0.5f);
            put(Pokemon.PokemonType.GROUND, 0.5f);
            put(Pokemon.PokemonType.ROCK, 0.5f);
            put(Pokemon.PokemonType.GHOST, 0.5f);
            put(Pokemon.PokemonType.STEEL, 0.0f);
            put(Pokemon.PokemonType.FAIRY, 2.0f);
        }});

        // Ground type
        initTypeEffectiveness(Pokemon.PokemonType.GROUND, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 2.0f);
            put(Pokemon.PokemonType.ELECTRIC, 2.0f);
            put(Pokemon.PokemonType.GRASS, 0.5f);
            put(Pokemon.PokemonType.POISON, 2.0f);
            put(Pokemon.PokemonType.FLYING, 0.0f);
            put(Pokemon.PokemonType.BUG, 0.5f);
            put(Pokemon.PokemonType.ROCK, 2.0f);
            put(Pokemon.PokemonType.STEEL, 2.0f);
        }});

        // Flying type
        initTypeEffectiveness(Pokemon.PokemonType.FLYING, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.ELECTRIC, 0.5f);
            put(Pokemon.PokemonType.GRASS, 2.0f);
            put(Pokemon.PokemonType.FIGHTING, 2.0f);
            put(Pokemon.PokemonType.BUG, 2.0f);
            put(Pokemon.PokemonType.ROCK, 0.5f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Psychic type
        initTypeEffectiveness(Pokemon.PokemonType.PSYCHIC, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIGHTING, 2.0f);
            put(Pokemon.PokemonType.POISON, 2.0f);
            put(Pokemon.PokemonType.PSYCHIC, 0.5f);
            put(Pokemon.PokemonType.DARK, 0.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Bug type
        initTypeEffectiveness(Pokemon.PokemonType.BUG, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.GRASS, 2.0f);
            put(Pokemon.PokemonType.FIGHTING, 0.5f);
            put(Pokemon.PokemonType.POISON, 0.5f);
            put(Pokemon.PokemonType.FLYING, 0.5f);
            put(Pokemon.PokemonType.PSYCHIC, 2.0f);
            put(Pokemon.PokemonType.GHOST, 0.5f);
            put(Pokemon.PokemonType.DARK, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
            put(Pokemon.PokemonType.FAIRY, 0.5f);
        }});

        // Rock type
        initTypeEffectiveness(Pokemon.PokemonType.ROCK, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 2.0f);
            put(Pokemon.PokemonType.ICE, 2.0f);
            put(Pokemon.PokemonType.FIGHTING, 0.5f);
            put(Pokemon.PokemonType.GROUND, 0.5f);
            put(Pokemon.PokemonType.FLYING, 2.0f);
            put(Pokemon.PokemonType.BUG, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});

        // Ghost type
        initTypeEffectiveness(Pokemon.PokemonType.GHOST, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.NORMAL, 0.0f);
            put(Pokemon.PokemonType.PSYCHIC, 2.0f);
            put(Pokemon.PokemonType.GHOST, 2.0f);
            put(Pokemon.PokemonType.DARK, 0.5f);
        }});

        // Dragon type
        initTypeEffectiveness(Pokemon.PokemonType.DRAGON, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.DRAGON, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
            put(Pokemon.PokemonType.FAIRY, 0.0f);
        }});

        // Dark type
        initTypeEffectiveness(Pokemon.PokemonType.DARK, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIGHTING, 0.5f);
            put(Pokemon.PokemonType.PSYCHIC, 2.0f);
            put(Pokemon.PokemonType.GHOST, 2.0f);
            put(Pokemon.PokemonType.DARK, 0.5f);
            put(Pokemon.PokemonType.FAIRY, 0.5f);
        }});

        // Steel type
        initTypeEffectiveness(Pokemon.PokemonType.STEEL, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.WATER, 0.5f);
            put(Pokemon.PokemonType.ELECTRIC, 0.5f);
            put(Pokemon.PokemonType.ICE, 2.0f);
            put(Pokemon.PokemonType.ROCK, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
            put(Pokemon.PokemonType.FAIRY, 2.0f);
        }});

        // Fairy type
        initTypeEffectiveness(Pokemon.PokemonType.FAIRY, new ObjectMap<Pokemon.PokemonType, Float>() {{
            put(Pokemon.PokemonType.FIRE, 0.5f);
            put(Pokemon.PokemonType.FIGHTING, 2.0f);
            put(Pokemon.PokemonType.POISON, 0.5f);
            put(Pokemon.PokemonType.DRAGON, 2.0f);
            put(Pokemon.PokemonType.DARK, 2.0f);
            put(Pokemon.PokemonType.STEEL, 0.5f);
        }});
    }

    private final Stage stage;
    private final Skin skin;
    private final Pokemon playerPokemon;
    private final Pokemon enemyPokemon;
    private final Array<Action> pendingActions = new Array<>();
    private final ShapeRenderer shapeRenderer;
    private TextureRegion platformTexture;
    private float playerPlatformX, playerPlatformY;
    private float enemyPlatformX, enemyPlatformY;
    private final Vector2 cameraShake;
    private float shakeDuration;
    private float shakeTimer;
    private Table battleScene;
    private Image playerPlatform;
    private Image enemyPlatform;
    private Image playerPokemonImage;
    private Image enemyPokemonImage;
    private Table actionMenu;
    private Table moveMenu;
    private ProgressBar playerHPBar;
    private ProgressBar enemyHPBar;
    private Label battleText;
    private TextButton fightButton;
    private TextButton bagButton;
    private TextButton pokemonButton;
    private TextButton runButton;
    private BattleState currentState;
    private BattleCallback callback;
    private float stateTimer = 0;
    private int turnCount = 0;
    private boolean isAnimating = false;
    private float currentShakeIntensity = 0;
    private PokemonHUD playerHUD;
    private PokemonHUD enemyHUD;
    private int selectedMoveIndex = 0;
    private Table moveSelectionMenu;
    private Label powerLabel;
    private Label accuracyLabel;
    private Label descriptionLabel;
    private Label moveTypeLabel;
    private boolean initialized = false;

    public BattleTable(Stage stage, Skin skin, Pokemon playerPokemon, Pokemon enemyPokemon) {
        super();
        this.stage = stage;
        this.skin = skin;
        this.playerPokemon = playerPokemon;
        this.enemyPokemon = enemyPokemon;
        this.shapeRenderer = new ShapeRenderer();
        this.cameraShake = new Vector2();
        this.currentState = BattleState.INTRO;
        this.isAnimating = true;
        setTouchable(Touchable.enabled);
        stage.addActor(this);

        stage.setViewport(new FitViewport(BASE_WIDTH, BASE_HEIGHT));
        stage.getViewport().update(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);

        try {
            initializeTextures();
            initializeUIComponents();
            initializePlatforms();
            initializePokemonSprites();
            setupHPBars();
            initializeHUDElements();
            initializeMoveMenu();
            initializeMoveLabels();
            setupContainer();

            initialized = true;
            startBattleAnimation();
        } catch (Exception e) {
            GameLogger.error("Error initializing battle table: " + e.getMessage());
        }
    }

    private static void initTypeEffectiveness(Pokemon.PokemonType attackType,
                                              ObjectMap<Pokemon.PokemonType, Float> effectiveness) {
        typeEffectiveness.get(attackType).putAll(effectiveness);

    }

    private static ProgressBar.ProgressBarStyle createHPBarStyle(float percentage) {
        ProgressBar.ProgressBarStyle style = new ProgressBar.ProgressBarStyle();

        // Background
        Pixmap bgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(0.2f, 0.2f, 0.2f, 0.8f);
        bgPixmap.fill();
        Texture bgTexture = new Texture(bgPixmap);
        style.background = new TextureRegionDrawable(new TextureRegion(bgTexture));
        bgPixmap.dispose();

        // Foreground
        Pixmap fgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        Color barColor;
        if (percentage > 0.5f) {
            barColor = new Color(0.2f, 0.8f, 0.2f, 1f); // Green
        } else if (percentage > 0.2f) {
            barColor = new Color(0.9f, 0.9f, 0.2f, 1f); // Yellow
        } else {
            barColor = new Color(0.8f, 0.2f, 0.2f, 1f); // Red
        }
        fgPixmap.setColor(barColor);
        fgPixmap.fill();
        Texture fgTexture = new Texture(fgPixmap);
        TextureRegionDrawable knob = new TextureRegionDrawable(new TextureRegion(fgTexture));
        style.knob = knob;
        style.knobBefore = knob;
        fgPixmap.dispose();

        return style;
    }

    private void setupContainer() {
        setFillParent(true);
        setTouchable(Touchable.childrenOnly);
        setZIndex(100);
    }


    @Override
    protected void sizeChanged() {
        super.sizeChanged();
        if (initialized) {
            updateSizes();
            updateLayout();
            updatePokemonPositions();
            if (currentState == BattleState.INTRO && isAnimating) {
                clearActions();
                resetPokemonPositions();
            }
        }
    }

    public BattleState getCurrentState() {
        return currentState;
    }

    public boolean isAnimating() {
        return isAnimating;
    }

    private void updateSizes() {
        float viewportWidth = stage.getViewport().getWorldWidth();
        float viewportHeight = stage.getViewport().getWorldHeight();

        // Calculate platform sizes
        float platformWidth = viewportWidth * PLATFORM_WIDTH_RATIO;
        float platformHeight = platformWidth * 0.3f; // Keep platforms relatively flat

        // Update platform sizes
        playerPlatform.setSize(platformWidth, platformHeight);
        enemyPlatform.setSize(platformWidth, platformHeight);

        // Calculate Pokemon sizes
        float pokemonSize = platformWidth * 0.8f;
        playerPokemonImage.setSize(pokemonSize, pokemonSize);
        enemyPokemonImage.setSize(pokemonSize, pokemonSize);
        updatePokemonPositions();
    }


    private void updateLayout() {
        if (!initialized) return;

        clear();
        setTouchable(Touchable.enabled);

        // Main container

        Table mainContainer = new Table();
        mainContainer.setName("MainContainer");
        mainContainer.setFillParent(true);
        mainContainer.top().padTop(10);
        mainContainer.setTouchable(Touchable.enabled);  // Changed from childrenOnly


        Table controlSection = new Table() {
            @Override
            public Actor hit(float x, float y, boolean touchable) {
                Actor hit = super.hit(x, y, touchable);
                GameLogger.info("Control section hit check at " + x + "," + y +
                    " result: " + (hit != null ? hit.getName() : "null"));
                return hit;
            }
        };
        controlSection.setName("ControlSection");
        controlSection.setBackground(createTranslucentBackground(0.7f));
        controlSection.setTransform(false);
        controlSection.setTouchable(Touchable.enabled);


        // Enemy section
        Table enemySection = new Table();
        enemySection.setTouchable(Touchable.disabled);
        enemySection.add(enemyHUD).expandX().right().pad(INFO_BOX_PADDING).row();

        Stack enemyStack = new Stack();
        enemyStack.setTouchable(Touchable.disabled);
        enemyStack.add(enemyPlatform);
        enemyStack.add(enemyPokemonImage);
        enemySection.add(enemyStack).expand().right().padRight(stage.getWidth() * 0.1f);

        // Player section
        Table playerSection = new Table();
        playerSection.setTouchable(Touchable.disabled);
        playerSection.add(playerHUD).expandX().left().pad(INFO_BOX_PADDING).row();

        Stack playerStack = new Stack();
        playerStack.setTouchable(Touchable.disabled);
        playerStack.add(playerPlatform);
        playerStack.add(playerPokemonImage);
        playerSection.add(playerStack).expand().left().padLeft(stage.getWidth() * 0.1f);

        Table buttonContainer = new Table();
        buttonContainer.setName("ButtonContainer");
        buttonContainer.setTouchable(Touchable.enabled);  // Changed from childrenOnly
        setupBattleButtons(buttonContainer);
        // Add components with explicit layout
        controlSection.add(battleText).expandX().fillX().pad(10).row();
        controlSection.add(buttonContainer).expandX().fillX().padBottom(5).padTop(5).height(BUTTON_HEIGHT * 2 + BUTTON_PADDING * 3);


        // Add sections to main container
        mainContainer.add(enemySection).expand().fill().row();
        mainContainer.add(playerSection).expand().fill().row();
        mainContainer.add(controlSection).expandX().fillX().bottom().padBottom(CONTROLS_BOTTOM_PADDING);
        add(mainContainer).expand().fill();

        boolean canInteract = currentState == BattleState.PLAYER_TURN && !isAnimating;
        enableBattleButtons(canInteract);

        GameLogger.info("Layout updated - Current state: " + currentState +
            ", Animating: " + isAnimating +
            ", Buttons touchable: " + (fightButton != null ? fightButton.getTouchable() : "null"));
    }

    private void updatePokemonPositions() {
        float viewportWidth = stage.getViewport().getWorldWidth();
        float viewportHeight = stage.getViewport().getWorldHeight();

        // Update platform positions
        playerPlatformX = viewportWidth * PLAYER_PLATFORM_X;
        playerPlatformY = viewportHeight * PLAYER_PLATFORM_Y;
        enemyPlatformX = viewportWidth * ENEMY_PLATFORM_X;
        enemyPlatformY = viewportHeight * ENEMY_PLATFORM_Y;

        playerPlatform.setPosition(playerPlatformX, playerPlatformY);
        enemyPlatform.setPosition(enemyPlatformX, enemyPlatformY);

        // Calculate Pokemon positions relative to platforms
        float playerPokemonOffsetX = (playerPlatform.getWidth() - (playerPokemonImage.getWidth() * POKEMON_SCALE)) / 2f;
        float playerPokemonOffsetY = (playerPlatform.getHeight() - (playerPokemonImage.getHeight() * POKEMON_SCALE)) / 2f;

        float enemyPokemonOffsetX = (enemyPlatform.getWidth() - (enemyPokemonImage.getWidth() * POKEMON_SCALE)) / 2f;
        float enemyPokemonOffsetY = (enemyPlatform.getHeight() - (enemyPokemonImage.getHeight() * POKEMON_SCALE)) / 2f;

        // Position Pokemon with proper centering and vertical offset
        playerPokemonImage.setPosition(
            playerPlatformX + playerPokemonOffsetX,
            playerPlatformY + playerPokemonOffsetY + PLATFORM_VERTICAL_OFFSET
        );

        enemyPokemonImage.setPosition(
            enemyPlatformX + enemyPokemonOffsetX,
            enemyPlatformY + enemyPokemonOffsetY + PLATFORM_VERTICAL_OFFSET
        );

        // Ensure proper scaling
        playerPokemonImage.setScale(POKEMON_SCALE);
        enemyPokemonImage.setScale(POKEMON_SCALE);
    }


    private TextureRegionDrawable createButtonBackground(Color color) {
        Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        pixmap.setColor(color);
        pixmap.fill();
        Texture texture = new Texture(pixmap);
        pixmap.dispose();
        return new TextureRegionDrawable(new TextureRegion(texture));
    }

    private void updateUI() {
        if (battleText == null || actionMenu == null || moveMenu == null) {
            GameLogger.error("UI components not properly initialized");
            return;
        }
        if (!initialized) {
            GameLogger.error("Battle table not properly initialized");
            return;
        }


        boolean isPlayerTurn = currentState == BattleState.PLAYER_TURN;
        boolean isBattleEnded = currentState == BattleState.ENDED;
        actionMenu.setVisible(isPlayerTurn && !isAnimating);
        moveMenu.setVisible(false);
        if (fightButton != null) fightButton.setDisabled(!isPlayerTurn || isBattleEnded);
        if (bagButton != null) bagButton.setDisabled(!isPlayerTurn || isBattleEnded);
        if (pokemonButton != null) pokemonButton.setDisabled(!isPlayerTurn || isBattleEnded);
        if (runButton != null) runButton.setDisabled(!isPlayerTurn || isBattleEnded);
        updateHPBars();
        updateStatusEffects();
        updateBattleText();
    }


    private TextureRegionDrawable createTranslucentBackground(float alpha) {
        Pixmap bgPixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(0, 0, 0, alpha);
        bgPixmap.fill();
        TextureRegion region = new TextureRegion(new Texture(bgPixmap));
        bgPixmap.dispose();
        return new TextureRegionDrawable(region);
    }

    @Override
    public Stage getStage() {
        return stage;
    }

    @Override
    public Skin getSkin() {
        return skin;
    }

    public void setCallback(BattleCallback callback) {
        this.callback = callback;
    }

    private void startShakeEffect() {
        currentShakeIntensity = (float) 5.0;
        shakeDuration = (float) 0.3;
        shakeTimer = 0;
    }

    private void updateShakeEffects(float delta) {
        if (shakeTimer < shakeDuration) {
            shakeTimer += delta;

            // Calculate shake offset
            float xOffset = MathUtils.random(-currentShakeIntensity, currentShakeIntensity);
            float yOffset = MathUtils.random(-currentShakeIntensity, currentShakeIntensity);
            cameraShake.set(xOffset, yOffset);

            // Apply shake to platforms and Pokemon
            playerPlatform.setPosition(
                playerPlatformX + xOffset,
                playerPlatformY + yOffset
            );
            playerPokemonImage.setPosition(
                playerPlatformX + platformTexture.getRegionWidth() / 2 - playerPokemonImage.getWidth() / 2 + xOffset,
                playerPlatformY + platformTexture.getRegionHeight() + yOffset
            );

            // Decay shake intensity
            currentShakeIntensity *= PLATFORM_SHAKE_DECAY;
            if (currentShakeIntensity < MIN_SHAKE_INTENSITY) {
                currentShakeIntensity = 0;
                resetPositions();
            }
        }
    }

    private void resetPositions() {
        playerPlatform.setPosition(playerPlatformX, playerPlatformY);
        enemyPlatform.setPosition(enemyPlatformX, enemyPlatformY);
        playerPokemonImage.setPosition(
            playerPlatformX + platformTexture.getRegionWidth() / 2f - playerPokemonImage.getWidth() / 2f,
            playerPlatformY + platformTexture.getRegionHeight()
        );
        enemyPokemonImage.setPosition(
            enemyPlatformX + platformTexture.getRegionWidth() / 2f - enemyPokemonImage.getWidth() / 2f,
            enemyPlatformY + platformTexture.getRegionHeight()
        );
    }


    @Override
    public void act(float delta) {
        super.act(delta);

        // Always increment stateTimer, regardless of isAnimating
        stateTimer += delta;

        if (Gdx.input.justTouched()) {
            Vector2 stageCoords = stage.screenToStageCoordinates(new Vector2(Gdx.input.getX(), Gdx.input.getY()));
            float x = stageCoords.x;
            float y = stageCoords.y;
            Actor hit = stage.hit(x, y, true);

            if (hit != null) {
                GameLogger.info("Touch detected on: " + hit.getClass().getSimpleName() +
                    " at " + x + "," + y +
                    " State: " + currentState +
                    " Animating: " + isAnimating +
                    " Button enabled: " + (hit instanceof TextButton ? !((TextButton) hit).isDisabled() : "N/A"));

                Actor current = hit;
                StringBuilder hierarchy = new StringBuilder();
                while (current != null) {
                    hierarchy.insert(0, current.getClass().getSimpleName() + " -> ");
                    current = current.getParent();
                }
                GameLogger.info("Touch hierarchy: " + hierarchy);
            }
        }

        if (playerHPBar == null || enemyHPBar == null) {
            return;
        }

        updateShakeEffects(delta);
        updateUI();

        switch (currentState) {
            case INTRO:
                updateIntroState();
                break;

            case PLAYER_TURN:
                if (!actionMenu.isVisible() && !moveMenu.isVisible()) {
                    showActionMenu(true);
                }
                break;

            case ENEMY_TURN:
                if (stateTimer >= 0.5f) {
                    executeEnemyMove();
                }
                break;

        }
    }



    @Override
    public void draw(Batch batch, float parentAlpha) {
        super.draw(batch, parentAlpha);
    }

    private void executeEnemyMove() {
        if (isAnimating || enemyPokemon.getCurrentHp() <= 0) return;

        // Simple AI - prioritize super effective moves
        Move selectedMove = null;
        float bestEffectiveness = 0f;

        for (Move move : enemyPokemon.getMoves()) {
            if (move.getPp() > 0) {
                float effectiveness = getTypeEffectiveness(
                    move.getType(),
                    playerPokemon.getPrimaryType()
                );

                if (playerPokemon.getSecondaryType() != null) {
                    effectiveness *= getTypeEffectiveness(
                        move.getType(),
                        playerPokemon.getSecondaryType()
                    );
                }

                if (effectiveness > bestEffectiveness) {
                    bestEffectiveness = effectiveness;
                    selectedMove = move;
                }
            }
        }
        if (selectedMove == null) {
            executeStruggle(enemyPokemon, playerPokemon);
            return;
        }

        executeMove(selectedMove, enemyPokemon, playerPokemon, false);
    }

    private void applyEndOfTurnEffects(Pokemon pokemon) {
        if (!pokemon.hasStatus()) return;

        switch (pokemon.getStatus()) {
            case BURNED:
                float burnDamage = pokemon.getStats().getHp() * 0.0625f;
                applyDamage(pokemon, burnDamage);
                showBattleText(pokemon.getName() + " was hurt by its burn!");
                break;

            case POISONED:
                float poisonDamage = pokemon.getStats().getHp() * 0.125f;
                applyDamage(pokemon, poisonDamage);
                showBattleText(pokemon.getName() + " was hurt by poison!");
                break;

            case BADLY_POISONED:
                float toxicDamage = pokemon.getStats().getHp() * (0.0625f * pokemon.getToxicCounter());
                applyDamage(pokemon, toxicDamage);
                pokemon.incrementToxicCounter();
                showBattleText(pokemon.getName() + " was hurt by toxic!");
                break;
        }

        updateHPBars();
    }

    private void attemptRun() {
        if (isAnimating) return;

        float runChance = calculateRunChance();
        if (MathUtils.random() < runChance) {
            showBattleText("Got away safely!");

            // Create fade out sequence without using battleScene
            SequenceAction escapeSequence = Actions.sequence(
                Actions.parallel(
                    Actions.run(() -> {
                        // Fade out Pokemon sprites
                        if (playerPokemonImage != null) {
                            playerPokemonImage.addAction(Actions.fadeOut(0.5f));
                        }
                        if (enemyPokemonImage != null) {
                            enemyPokemonImage.addAction(Actions.fadeOut(0.5f));
                        }
                    }),
                    Actions.delay(0.5f)
                ),
                Actions.parallel(
                    Actions.run(() -> {
                        // Fade out HUD elements
                        if (playerHUD != null) {
                            playerHUD.addAction(Actions.fadeOut(0.5f));
                        }
                        if (enemyHUD != null) {
                            enemyHUD.addAction(Actions.fadeOut(0.5f));
                        }
                        // Fade out action menu
                        if (actionMenu != null) {
                            actionMenu.addAction(Actions.fadeOut(0.5f));
                        }
                    }),
                    Actions.delay(0.5f)
                ),
                // Final cleanup
                Actions.run(() -> {
                    // Play sound effect
//                    AudioManager.getInstance().playSound(AudioManager.SoundEffect.BATTLE_RUN);

                    // Call callback
                    if (callback != null) {
                        callback.onBattleEnd(true);
                    }
                    // Clean up battle
                    cleanup();
                    remove();
                })
            );

            addAction(escapeSequence);
            isAnimating = true; // Set animating state
            currentState = BattleState.RUNNING;

        } else {
            showBattleText("Can't escape!");
//            AudioManager.getInstance().playSound(AudioManager.SoundEffect.MOVE_MISS);
            transitionToState(BattleState.ENEMY_TURN);
        }
    }

    // Helper method to clean up battle gracefully
    private void cleanup() {
        isAnimating = false;

        // Clear all menus
        if (actionMenu != null) actionMenu.remove();
        if (moveMenu != null) moveMenu.remove();
        if (moveSelectionMenu != null) moveSelectionMenu.remove();

        // Clear sprites
        if (playerPokemonImage != null) playerPokemonImage.remove();
        if (enemyPokemonImage != null) enemyPokemonImage.remove();

        // Clear HUD
        if (playerHUD != null) playerHUD.remove();
        if (enemyHUD != null) enemyHUD.remove();
    }

    public void dispose() {
        // Clean up resources
        if (playerPokemonImage != null) {
            playerPokemonImage.remove();
        }
        if (shapeRenderer != null) {
            shapeRenderer.dispose();
        }
        if (enemyPokemonImage != null) {
            enemyPokemonImage.remove();
        }
        if (battleScene != null) {
            battleScene.remove();
        }
        if (enemyHPBar != null && enemyHPBar.getStyle().knob instanceof TextureRegionDrawable) {
            ((TextureRegionDrawable) enemyHPBar.getStyle().knob).getRegion().getTexture().dispose();
        }
        if (playerHPBar != null && playerHPBar.getStyle().knob instanceof TextureRegionDrawable) {
            ((TextureRegionDrawable) playerHPBar.getStyle().knob).getRegion().getTexture().dispose();
        }
        // Dispose of any textures created for HP bars
        Array<Cell> cells = playerHUD.getCells();
        for (Cell cell : cells) {
            Actor actor = cell.getActor();
            if (actor instanceof ProgressBar) {
                ProgressBar bar = (ProgressBar) actor;
                Drawable knob = bar.getStyle().knob;
                if (knob instanceof TextureRegionDrawable) {
                    ((TextureRegionDrawable) knob).getRegion().getTexture().dispose();
                }
            }
        }
        clearActions();
        remove();
    }



    private float calculateRunChance() {
        // Make it very easy to run
        float baseChance = 0.9f; // 90% base chance

        // Small bonus based on level difference
        float levelBonus = Math.max(0, playerPokemon.getLevel() - enemyPokemon.getLevel()) * 0.02f;

        // Cap at 95% chance
        return Math.min(0.95f, baseChance + levelBonus);
    }

    private void initializeMoveMenu() {
        moveMenu = new Table(skin);
        moveMenu.setBackground(createTranslucentBackground(0.8f));
        moveMenu.defaults().pad(10).size(180, 45);

        // Create move buttons grid
        Table moveGrid = new Table();
        moveGrid.defaults().pad(5);

        // Add moves
        for (int i = 0; i < playerPokemon.getMoves().size(); i++) {
            final int moveIndex = i;
            Move move = playerPokemon.getMoves().get(i);

            Table moveButton = createMoveButton(move);
            moveButton.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    if (!isAnimating && currentState == BattleState.PLAYER_TURN) {
                        selectedMoveIndex = moveIndex;
                        executeMove(move, playerPokemon, enemyPokemon, true);
                    }
                }
            });

            if (i % 2 == 0) {
                moveGrid.add(moveButton).padRight(10);
            } else {
                moveGrid.add(moveButton).row();
            }
        }
        TextButton backButton = new TextButton("BACK", skin);
        backButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                showActionMenu(true);
            }
        });

        moveMenu.add(moveGrid).expand().fill().row();
        moveMenu.add(backButton).size(150, 40).pad(10);
        moveMenu.setVisible(false);  // Initially hidden
        addActor(moveMenu);
    }

    private void updateBattleText() {
        if (battleText == null) {
            GameLogger.error("Battle text not initialized");
            return;
        }

        String message = "";
        switch (currentState) {
            case INTRO:
                message = "Wild " + enemyPokemon.getName() + " appeared!";
                break;
            case PLAYER_TURN:
                message = "What will " + playerPokemon.getName() + " do?";
                break;
            case ENEMY_TURN:
                message = "Wild " + enemyPokemon.getName() + " is thinking...";
                break;
            case ENDED:
                message = playerPokemon.getCurrentHp() > 0 ? "Victory!" : "Defeat!";
                break;
            default:
                break;
        }
        battleText.setText(message);
    }


    private void initializePlatforms() {
        platformTexture = TextureManager.getBattlebacks().findRegion("battle_platform");
        if (platformTexture == null) {
            throw new RuntimeException("Failed to load battle platform texture");
        }

        playerPlatform = new Image(platformTexture);
        enemyPlatform = new Image(platformTexture);

        // Remove scaling
        playerPlatform.setScaling(Scaling.none);
        enemyPlatform.setScaling(Scaling.none);

        // Force visibility
        playerPlatform.setVisible(true);
        enemyPlatform.setVisible(true);

        // Do not add platforms directly to the stage
        // They will be added to the layout in updateLayout()
    }

    private void resetPokemonPositions() {
        if (playerPokemonImage != null && enemyPokemonImage != null) {
            float stageWidth = stage.getWidth();
            float stageHeight = stage.getHeight();

            // Position platforms
            playerPlatform.setScale(PLATFORM_SCALE);
            enemyPlatform.setScale(PLATFORM_SCALE);

            float platformWidth = platformTexture.getRegionWidth() * PLATFORM_SCALE;
            float platformHeight = platformTexture.getRegionHeight() * PLATFORM_SCALE;

            playerPlatform.setPosition(
                stageWidth * PLAYER_PLATFORM_X,
                stageHeight * PLAYER_PLATFORM_Y
            );

            enemyPlatform.setPosition(
                stageWidth * ENEMY_PLATFORM_X,
                stageHeight * ENEMY_PLATFORM_Y
            );

            // Position Pokemon with proper offset
            playerPokemonImage.setScale(POKEMON_SCALE);
            enemyPokemonImage.setScale(POKEMON_SCALE);

            playerPokemonImage.setPosition(
                playerPlatformX + (platformWidth - playerPokemonImage.getWidth()) / 2f,
                playerPlatformY + platformHeight * 0.5f + PLATFORM_VERTICAL_OFFSET
            );

            enemyPokemonImage.setPosition(
                enemyPlatformX + (platformWidth - enemyPokemonImage.getWidth()) / 2f,
                enemyPlatformY + platformHeight * 0.5f + PLATFORM_VERTICAL_OFFSET
            );
        }
    }


    private void initializePokemonSprites() {
        TextureRegion playerTexture = playerPokemon.getBackSprite();
        TextureRegion enemyTexture = enemyPokemon.getFrontSprite();

        if (playerTexture == null || enemyTexture == null) {
            throw new RuntimeException("Failed to load Pokemon sprites");
        }

        playerPokemonImage = new Image(playerTexture);
        enemyPokemonImage = new Image(enemyTexture);

        // Set base size while maintaining aspect ratio
        float playerAspect = playerTexture.getRegionWidth() / (float) playerTexture.getRegionHeight();
        float enemyAspect = enemyTexture.getRegionWidth() / (float) enemyTexture.getRegionHeight();

        playerPokemonImage.setSize(POKEMON_BASE_SIZE * playerAspect, POKEMON_BASE_SIZE);
        enemyPokemonImage.setSize(POKEMON_BASE_SIZE * enemyAspect, POKEMON_BASE_SIZE);

        // Remove scaling
        playerPokemonImage.setScaling(Scaling.none);
        enemyPokemonImage.setScaling(Scaling.none);
    }


    private void initializeHUDElements() {
        // Player HP bar
        playerHUD = new PokemonHUD(skin, playerPokemon, true);
        playerHUD.setHPBar(playerHPBar);

        // Enemy HP bar
        enemyHUD = new PokemonHUD(skin, enemyPokemon, false);
        enemyHUD.setHPBar(enemyHPBar);
    }

    private void initializeUIComponents() {
        // Initialize battle text
        battleText = new Label("", skin);
        battleText.setWrap(true);
        battleText.setAlignment(Align.center);
        battleText.setTouchable(Touchable.disabled);


        // Create button style with better visibility
        TextButton.TextButtonStyle buttonStyle = new TextButton.TextButtonStyle();
        buttonStyle.font = skin.getFont("default");
        buttonStyle.up = createButtonBackground(new Color(0.2f, 0.2f, 0.5f, 0.9f));
        buttonStyle.down = createButtonBackground(new Color(0.15f, 0.15f, 0.4f, 0.9f));
        buttonStyle.over = createButtonBackground(new Color(0.25f, 0.25f, 0.6f, 0.9f));
        buttonStyle.fontColor = Color.WHITE;

        // Initialize buttons with fixed size
        fightButton = new TextButton("FIGHT", buttonStyle);
        bagButton = new TextButton("BAG", buttonStyle);
        pokemonButton = new TextButton("POKEMON", buttonStyle);
        runButton = new TextButton("RUN", buttonStyle);

        // Enable button interaction and make text bigger
        TextButton[] buttons = {fightButton, bagButton, pokemonButton, runButton};
        for (TextButton button : buttons) {
            button.setTouchable(Touchable.enabled);
            button.getLabel().setFontScale(1.2f);
            button.setSize(BUTTON_WIDTH, BUTTON_HEIGHT);
        }

        fightButton.setTouchable(Touchable.enabled);
        bagButton.setTouchable(Touchable.enabled);
        pokemonButton.setTouchable(Touchable.enabled);
        runButton.setTouchable(Touchable.enabled);
        // Create action menu
        actionMenu = new Table();
        actionMenu.setTouchable(Touchable.childrenOnly); // Important: allow touch events to reach buttons
        actionMenu.defaults().size(BUTTON_WIDTH, BUTTON_HEIGHT).pad(BUTTON_PADDING);
        actionMenu.setBackground(createTranslucentBackground(0.5f));

        // Add buttons to actionMenu with proper spacing
        actionMenu.add(fightButton).size(BUTTON_WIDTH, BUTTON_HEIGHT);
        actionMenu.add(bagButton).size(BUTTON_WIDTH, BUTTON_HEIGHT);
        actionMenu.add(pokemonButton).size(BUTTON_WIDTH, BUTTON_HEIGHT);
        actionMenu.add(runButton).size(BUTTON_WIDTH, BUTTON_HEIGHT);

        // Set up container properties
        actionMenu.pack(); // Important: properly size the container
        actionMenu.setTransform(false); // Better touch handling
        actionMenu.setTouchable(Touchable.enabled);
    }

    private void showActionMenu(boolean show) {
        if (actionMenu != null) {
            actionMenu.setVisible(show);
            actionMenu.setTouchable(show ? Touchable.enabled : Touchable.disabled);

            // Make sure buttons are properly enabled/disabled
            if (show) {
                fightButton.setDisabled(false);
                bagButton.setDisabled(false);
                pokemonButton.setDisabled(playerPokemon.getCurrentHp() <= 0);
                runButton.setDisabled(false);

                // Refresh touchable states
                fightButton.setTouchable(Touchable.enabled);
                bagButton.setTouchable(Touchable.enabled);
                pokemonButton.setTouchable(Touchable.enabled);
                runButton.setTouchable(Touchable.enabled);
            }
        }

        if (moveMenu != null) {
            moveMenu.setVisible(!show);
            moveMenu.setTouchable(!show ? Touchable.enabled : Touchable.disabled);
        }
        GameLogger.info("Action menu " + (show ? "shown" : "hidden") + " - State: " + currentState);
    }

    private void setBattleInterfaceEnabled(boolean enabled) {
        GameLogger.info("Setting battle interface enabled: " + enabled);

        // Update control section
        if (actionMenu != null) {
            actionMenu.setTouchable(enabled ? Touchable.enabled : Touchable.disabled);
            actionMenu.setVisible(enabled);
        }

        // Update button container
        if (fightButton != null) {
            TextButton[] buttons = {fightButton, bagButton, pokemonButton, runButton};
            for (TextButton button : buttons) {
                button.setDisabled(!enabled);
                button.setTouchable(enabled ? Touchable.enabled : Touchable.disabled);
                GameLogger.info(button.getName() + " enabled: " + enabled);
            }
        }
    }

    private void startBattleAnimation() {
        GameLogger.info("Starting battle animation");
        isAnimating = true;
        currentState = BattleState.INTRO;
        setBattleInterfaceEnabled(false);  // Disable interface during intro

        SequenceAction introSequence = Actions.sequence(
            Actions.run(() -> {
                battleText.setText("Wild " + enemyPokemon.getName() + " appeared!");
                GameLogger.info("Battle intro started");
            }),
            Actions.delay(1.0f),
            Actions.run(() -> {
                GameLogger.info("Battle intro complete - transitioning to player turn");
                isAnimating = false;
                currentState = BattleState.PLAYER_TURN;
                battleText.setText("What will " + playerPokemon.getName() + " do?");
                setBattleInterfaceEnabled(true);  // Enable interface after intro
                updateUI();
            })
        );

        addAction(introSequence);
    }

    private Table createTypeIcon(Pokemon.PokemonType type) {
        Table iconContainer = new Table();
        Color typeColor = TYPE_COLORS.get(type);

        // Create circular background
        Pixmap iconPixmap = new Pixmap(30, 30, Pixmap.Format.RGBA8888);
        iconPixmap.setColor(typeColor);
        iconPixmap.fillCircle(15, 15, 15);

        TextureRegionDrawable iconBg = new TextureRegionDrawable(
            new TextureRegion(new Texture(iconPixmap)));
        iconPixmap.dispose();

        iconContainer.setBackground(iconBg);
        return iconContainer;
    }

    private void updateHPBarColor(ProgressBar bar, float percentage) {
        String styleKey;
        if (percentage > 0.5f) {
            styleKey = "hp-bar-green";
        } else if (percentage > 0.2f) {
            styleKey = "hp-bar-yellow";
        } else {
            styleKey = "hp-bar-red";
        }

        bar.setStyle(skin.get(styleKey, ProgressBar.ProgressBarStyle.class));
    }

    private void initializeTextures() {
        // Load platform texture
        platformTexture = TextureManager.battlebacks.findRegion("battle_platform");
        if (platformTexture == null) {
            throw new RuntimeException("Failed to load battle platform texture");
        }

        // Load background texture
        TextureRegion battleBackground = TextureManager.battlebacks.findRegion("battle_bg_plains");
        if (battleBackground == null) {
            throw new RuntimeException("Failed to load battle background texture");
        }
    }

    private void setupHPBars() {
        // Player HP bar
        playerHPBar = new ProgressBar(0, playerPokemon.getStats().getHp(), 1, false,
            createHPBarStyle(playerPokemon.getCurrentHp() / (float) playerPokemon.getStats().getHp()));
        playerHPBar.setSize(HP_BAR_WIDTH, 8); // Reduce height
        playerHPBar.setValue(playerPokemon.getCurrentHp());

        // Enemy HP bar
        enemyHPBar = new ProgressBar(0, enemyPokemon.getStats().getHp(), 1, false,
            createHPBarStyle(enemyPokemon.getCurrentHp() / (float) enemyPokemon.getStats().getHp()));
        enemyHPBar.setSize(HP_BAR_WIDTH, 8); // Reduce height
        enemyHPBar.setValue(enemyPokemon.getCurrentHp());
    }

    private void handleBagButton() {
        // Implement bag functionality
        showNotImplementedMessage("Bag feature coming soon!");
    }

    private void handlePokemonButton() {
        // Implement Pokemon switch functionality
        showNotImplementedMessage("Pokemon switch feature coming soon!");
    }

    private void showNotImplementedMessage(String message) {
        // Show a message for unimplemented features
        battleText.setText(message);
    }

    private void createMoveMenu() {
        moveMenu = new Table();
        moveMenu.setFillParent(true);
        moveMenu.center();
        moveMenu.defaults().pad(5).size(200, 50);

        // Add moves from player's Pokemon
        for (Move move : playerPokemon.getMoves()) {
            TextButton moveButton = new TextButton(move.getName(), skin, "battle");
            moveButton.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    GameLogger.info("Move selected: " + move.getName());
                    executeMove(move, playerPokemon, enemyPokemon, true);
                }
            });
            moveMenu.add(moveButton).row();
        }

        // Add back button
        TextButton backButton = new TextButton("BACK", skin, "battle");
        backButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                showMoveMenu(false);
            }
        });
        moveMenu.add(backButton).row();

        // Initially hide move menu
        moveMenu.setVisible(false);
        stage.addActor(moveMenu);
    }

    public void showMoveMenu(boolean show) {
        GameLogger.info("Showing move menu: " + show);
        if (moveMenu == null) {
            createMoveMenu();
        }
        moveMenu.setVisible(show);
        actionMenu.setVisible(!show);
    }

    private void showMoveSelection() {
        if (isAnimating || currentState != BattleState.PLAYER_TURN) return;

        GameLogger.info("Showing move selection menu");

        // Hide main action menu
        showActionMenu(false);

        if (moveSelectionMenu != null) {
            moveSelectionMenu.remove();
        }

        // Initialize move menu
        moveSelectionMenu = new Table();
        moveSelectionMenu.setBackground(createTranslucentBackground(0.8f));
        moveSelectionMenu.defaults().pad(10).size(200, 50);
        moveSelectionMenu.setTouchable(Touchable.enabled);

        // Create move grid
        Table moveGrid = new Table();
        moveGrid.defaults().pad(5).size(180, 45);
        moveGrid.setTouchable(Touchable.enabled);

        // Add moves
        for (Move move : playerPokemon.getMoves()) {
            Table moveButton = createMoveButton(move);
            moveButton.setTouchable(Touchable.enabled);

            moveButton.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    if (!isAnimating && currentState == BattleState.PLAYER_TURN) {
                        executeMove(move, playerPokemon, enemyPokemon, true);
                        hideMoveSelection();
                    }
                }
            });

            moveGrid.add(moveButton).pad(5);
            if (moveGrid.getCells().size % 2 == 0) {
                moveGrid.row();
            }
        }

        // Add back button
        TextButton backButton = new TextButton("BACK", skin);
        backButton.setTouchable(Touchable.enabled);
        backButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                hideMoveSelection();
                showActionMenu(true);
            }
        });

        moveSelectionMenu.add(moveGrid).expand().fill().pad(10).row();
        moveSelectionMenu.add(backButton).size(150, 40).pad(10);

        // Position the menu
        moveSelectionMenu.setPosition(
            (stage.getWidth() - moveSelectionMenu.getPrefWidth()) / 2,
            (stage.getHeight() - moveSelectionMenu.getPrefHeight()) / 2
        );

        stage.addActor(moveSelectionMenu);
    }

    private void updateMoveInfo(Move move) {
        if (powerLabel == null || accuracyLabel == null ||
            descriptionLabel == null || moveTypeLabel == null) {
            GameLogger.error("Move info labels not initialized");
            return;
        }

        // Update power
        String powerText = move.getPower() > 0 ? String.valueOf(move.getPower()) : "-";
        powerLabel.setText(powerText);

        // Update accuracy
        String accuracyText = move.getAccuracy() > 0 ? move.getAccuracy() + "%" : "-";
        accuracyLabel.setText(accuracyText);

        // Update type
        moveTypeLabel.setText(move.getType().toString());
        moveTypeLabel.setColor(TextureManager.getTypeColor(move.getType()));

        // Update description
        descriptionLabel.setText(move.getDescription());
    }

    private void hideMoveSelection() {
        if (moveSelectionMenu != null) {
            moveSelectionMenu.addAction(Actions.sequence(
                Actions.fadeOut(0.2f),
                Actions.removeActor()
            ));
        }
    }

    private void initializeMoveLabels() {
        // Create labels with default style
        powerLabel = new Label("", skin);
        accuracyLabel = new Label("", skin);
        descriptionLabel = new Label("", skin);
        moveTypeLabel = new Label("", skin);

        // Configure label properties
        powerLabel.setFontScale(0.9f);
        accuracyLabel.setFontScale(0.9f);
        descriptionLabel.setFontScale(0.8f);
        moveTypeLabel.setFontScale(0.9f);

        // Enable text wrapping for description
        descriptionLabel.setWrap(true);
    }

    private Table createMoveButton(final Move move) {
        Table button = new Table();

        // Get type-based style
        Color typeColor = TYPE_COLORS.getOrDefault(move.getType(), TYPE_COLORS.get(Pokemon.PokemonType.NORMAL));
        button.setBackground(createGradientBackground(typeColor));

        // Move name
        Label nameLabel = new Label(move.getName(), new Label.LabelStyle(skin.getFont("default"), Color.WHITE));
        nameLabel.setFontScale(1.2f);

        // PP counter
        Label ppLabel = new Label(move.getPp() + "/" + move.getMaxPp(),
            new Label.LabelStyle(skin.getFont("default"), Color.WHITE));

        // Type icon
        Table typeIcon = createTypeIcon(move.getType());

        // Layout
        Table content = new Table();
        content.add(nameLabel).left().expandX().row();
        content.add(ppLabel).left().padTop(5);

        button.add(content).expand().fill().pad(10);
        button.add(typeIcon).size(30).right().pad(10);

        // Click handling
        button.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                executeMove(move, playerPokemon, enemyPokemon, true);
            }

            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                button.setColor(button.getColor().mul(1.2f));
                updateMoveInfo(move);
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                button.setColor(typeColor);
            }
        });
        setTouchable(Touchable.enabled);
        return button;
    }

    private TextureRegionDrawable createGradientBackground(Color baseColor) {
        Pixmap pixmap = new Pixmap(300, 80, Pixmap.Format.RGBA8888);

        // Create gradient effect
        for (int x = 0; x < 300; x++) {
            float alpha = 0.9f;
            float factor = x / 300f;
            Color gradientColor = new Color(
                baseColor.r + (factor * 0.2f),
                baseColor.g + (factor * 0.2f),
                baseColor.b + (factor * 0.2f),
                alpha
            );
            pixmap.setColor(gradientColor);
            for (int y = 0; y < 80; y++) {
                pixmap.drawPixel(x, y);
            }
        }

        Texture texture = new Texture(pixmap);
        pixmap.dispose();
        return new TextureRegionDrawable(new TextureRegion(texture));
    }

    public void update(float delta) {
        stateTimer += delta;

        // Process any pending animations
        if (!pendingActions.isEmpty() && !isAnimating) {
            Action nextAction = pendingActions.removeIndex(0);
            addAction(nextAction);
        }

        // Update battle state
        switch (currentState) {
            case INTRO:
                updateIntroState();
                break;
            case PLAYER_TURN:
                updatePlayerTurn();
                break;
            case ENEMY_TURN:
                updateEnemyTurn();
                break;
            case ANIMATING:
                updateAnimations(delta);
                break;
            case ENDED:
                updateEndState();
                break;
        }

        // Update UI elements
        updateHPBars();
        updateStatusEffects();
    }

    private void finishMoveExecution(boolean isPlayerMove) {
        Move usedMove;
        if (isPlayerMove) {
            usedMove = playerPokemon.getMoves().get(selectedMoveIndex);
        } else {
            usedMove = enemyPokemon.getMoves().get(0);
        }
        applyEndOfTurnEffects(isPlayerMove ? playerPokemon : enemyPokemon);

        if (checkBattleEnd()) {
            return;
        }
        if (callback != null) {
            callback.onMoveUsed(
                isPlayerMove ? playerPokemon : enemyPokemon,
                usedMove,
                isPlayerMove ? enemyPokemon : playerPokemon
            );
            callback.onTurnEnd(isPlayerMove ? playerPokemon : enemyPokemon);
        }
        isAnimating = false;
        transitionToState(isPlayerMove ? BattleState.ENEMY_TURN : BattleState.PLAYER_TURN);

        playerHUD.update();
        enemyHUD.update();
    }

    private void updateEndState() {
        if (!isAnimating) {
            boolean playerWon = playerPokemon.getCurrentHp() > 0;

            SequenceAction endSequence = Actions.sequence(
                Actions.run(() -> showBattleText(
                    playerWon ? "Victory!" :
                        playerPokemon.getName() + " fainted!"
                )),
                Actions.delay(2.0f),
                Actions.parallel(
                    Actions.run(() -> {
                        playerPokemonImage.addAction(Actions.fadeOut(1.0f));
                        enemyPokemonImage.addAction(Actions.fadeOut(1.0f));
                    })
                ),
                Actions.delay(1.0f),
                Actions.run(() -> {
                    if (callback != null) {
                        callback.onBattleEnd(playerWon);
                    }
                })
            );

            addAction(endSequence);
            isAnimating = true;
        }
    }

    private void updateIntroState() {
        if (stateTimer >= ANIMATION_DURATION) {
            transitionToState(BattleState.PLAYER_TURN);
            showBattleText(generateBattleStartText());
        }
    }

    private void updatePlayerTurn() {
        if (!actionMenu.isVisible() && !isAnimating) {
            showActionMenu(true);
        }
    }

    private void updateEnemyTurn() {
        if (!isAnimating && stateTimer >= 0.5f) { // Small delay before enemy action
            executeEnemyMove();
        }
    }

    private void updateAnimations(float delta) {
        if (!isAnimating) {
            if (currentState == BattleState.PLAYER_TURN) {
                checkBattleEnd();
            } else if (currentState == BattleState.ENEMY_TURN) {
                transitionToState(BattleState.PLAYER_TURN);
            }
        }
    }

    private void executeMove(Move move, Pokemon attacker, Pokemon defender, boolean isPlayerMove) {
        if (isAnimating) return;

        isAnimating = true;
        showActionMenu(false); // Hide action menu when move starts
        if (moveSelectionMenu != null) {
            moveSelectionMenu.remove(); // Remove the move selection menu
        }


        SequenceAction moveSequence = Actions.sequence(
            // Hide all menus first
            Actions.run(() -> {
                if (actionMenu != null) actionMenu.setVisible(false);
                if (moveMenu != null) moveMenu.setVisible(false);
            }),
            Actions.delay(0.5f),

            Actions.run(() -> {
                showBattleText(attacker.getName() + " used " + move.getName() + "!");
            }),
            Actions.delay(0.5f),

            // 3. Show damage effect
            Actions.run(() -> {
                float damage = calculateDamage(move, attacker, defender);
                applyDamage(defender, damage);

                // Flash the defender sprite
                Image defenderSprite = (defender == playerPokemon) ? playerPokemonImage : enemyPokemonImage;
                defenderSprite.addAction(Actions.sequence(
                    Actions.color(Color.RED),
                    Actions.delay(0.1f),
                    Actions.color(Color.WHITE)
                ));

                // Shake effect for powerful moves
                if (move.getPower() > 80) {
                    startShakeEffect();
                }
            }),
            Actions.delay(0.5f),

            // 4. Show effectiveness message
            Actions.run(() -> {
                showEffectivenessMessage(move, defender);
            }),
            Actions.delay(0.5f),

            // 5. End move execution
            Actions.run(() -> {
                finishMoveExecution(isPlayerMove);
            })
        );

        // Add the sequence to the stage
        stage.addAction(moveSequence);
    }

    private void showEffectivenessMessage(Move move, Pokemon defender) {
        float effectiveness = calculateTypeEffectiveness(move.getType(), defender);

        if (effectiveness > 1.5f) {
            showBattleText("It's super effective!");
        } else if (effectiveness < 0.5f) {
            showBattleText("It's not very effective...");
        } else if (effectiveness == 0) {
            showBattleText("It had no effect...");
        }
    }

    private float calculateTypeEffectiveness(Pokemon.PokemonType moveType, Pokemon defender) {
        float effectiveness = getTypeEffectiveness(moveType, defender.getPrimaryType());

        if (defender.getSecondaryType() != null) {
            effectiveness *= getTypeEffectiveness(moveType, defender.getSecondaryType());
        }

        return effectiveness;
    }

    private float calculateDamage(Move move, Pokemon attacker, Pokemon defender) {
        float baseDamage = move.getPower() * (move.isSpecial() ?
            (float) attacker.getStats().getSpecialAttack() / defender.getStats().getSpecialDefense() :
            (float) attacker.getStats().getAttack() / defender.getStats().getDefense());

        float typeMultiplier = getTypeEffectiveness(move.getType(), defender.getPrimaryType());
        if (defender.getSecondaryType() != null) {
            typeMultiplier *= getTypeEffectiveness(move.getType(), defender.getSecondaryType());
        }

        float variation = MathUtils.random(0.85f, 1.0f);

        float statusMultiplier = attacker.getStatusModifier(move);

        return baseDamage * typeMultiplier * variation * statusMultiplier;
    }

    private void applyDamage(Pokemon target, float damage) {
        // Flash the Pokemon sprite
        Image targetSprite = target == playerPokemon ? playerPokemonImage : enemyPokemonImage;
        targetSprite.addAction(Actions.sequence(
            Actions.color(Color.RED),
            Actions.delay(DAMAGE_FLASH_DURATION),
            Actions.color(Color.WHITE)
        ));

        float newHP = Math.max(0, target.getCurrentHp() - damage);
        animateHPBar(target, newHP);
        target.setCurrentHp(newHP);
    }

    private void animateHPBar(Pokemon pokemon, float newHP) {
        ProgressBar hpBar = pokemon == playerPokemon ? playerHPBar : enemyHPBar;
        float startHP = hpBar.getValue();

        hpBar.addAction(Actions.sequence(
            Actions.run(() -> updateHPBarColor(hpBar, newHP / pokemon.getStats().getHp())),
            Actions.moveTo(startHP, newHP, HP_UPDATE_DURATION, Interpolation.smooth)
        ));
    }

    private void setupBattleButtons(Table buttonContainer) {
        GameLogger.info("Setting up battle buttons");

        // Create button style with proper states
        TextButton.TextButtonStyle style = new TextButton.TextButtonStyle();
        style.font = skin.getFont("default");
        style.up = createButtonBackground(new Color(0.2f, 0.2f, 0.5f, 0.9f));
        style.down = createButtonBackground(new Color(0.15f, 0.15f, 0.4f, 1f));
        style.over = createButtonBackground(new Color(0.25f, 0.25f, 0.6f, 0.9f));
        style.fontColor = Color.WHITE;
        style.disabledFontColor = new Color(0.7f, 0.7f, 0.7f, 1f);

        // Initialize buttons
        fightButton = new TextButton("FIGHT", style);
        fightButton.setName("FightButton");
        fightButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                GameLogger.info("Fight button clicked - State: " + currentState + " Animating: " + isAnimating);
                if (!isAnimating && currentState == BattleState.PLAYER_TURN) {
                    showMoveSelection();
                    event.stop();
                }
            }
        });

        bagButton = new TextButton("BAG", style);
        bagButton.setName("BagButton");
        bagButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                GameLogger.info("Bag button clicked - State: " + currentState + " Animating: " + isAnimating);
                if (!isAnimating && currentState == BattleState.PLAYER_TURN) {
                    handleBagButton();
                    event.stop();
                }
            }
        });

        pokemonButton = new TextButton("POKEMON", style);
        pokemonButton.setName("PokemonButton");
        pokemonButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                GameLogger.info("Pokemon button clicked - State: " + currentState + " Animating: " + isAnimating);
                if (!isAnimating && currentState == BattleState.PLAYER_TURN) {
                    handlePokemonButton();
                    event.stop();
                }
            }
        });

        runButton = new TextButton("RUN", style);
        runButton.setName("RunButton");
        runButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                GameLogger.info("Run button clicked - State: " + currentState + " Animating: " + isAnimating);
                if (!isAnimating && currentState == BattleState.PLAYER_TURN) {
                    attemptRun();
                    event.stop();
                }
            }
        });

        // Set up button grid
        Table buttonGrid = new Table();
        buttonGrid.setName("ButtonGrid");
        buttonGrid.setTouchable(Touchable.enabled);
        buttonGrid.defaults().size(BUTTON_WIDTH, BUTTON_HEIGHT).pad(BUTTON_PADDING);

        // Add buttons to grid with proper layout
        buttonGrid.add(fightButton).expand().fill().pad(BUTTON_PADDING);
        buttonGrid.add(bagButton).expand().fill().pad(BUTTON_PADDING).row();
        buttonGrid.add(pokemonButton).expand().fill().pad(BUTTON_PADDING);
        buttonGrid.add(runButton).expand().fill().pad(BUTTON_PADDING);

        // Set up button container
        buttonContainer.setName("ButtonContainer");
        buttonContainer.setTouchable(Touchable.enabled);
        buttonContainer.setTransform(false);
        buttonContainer.add(buttonGrid).expand().fill().pad(5);

        // Ensure buttons are touchable and enabled
        TextButton[] buttons = {fightButton, bagButton, pokemonButton, runButton};
        for (TextButton btn : buttons) {
            btn.setTouchable(Touchable.enabled);
        }

        enableBattleButtons(currentState == BattleState.PLAYER_TURN && !isAnimating);
        GameLogger.info("Battle buttons setup complete - Current state: " + currentState +
            " Animating: " + isAnimating);
    }


    private float calculateTypeEffectiveness(Move move, Pokemon defender) {
        if (move == null || defender == null) {
            return 1.0f;
        }

        float effectiveness = getTypeEffectiveness(move.getType(), defender.getPrimaryType());

        // Consider secondary type if present
        if (defender.getSecondaryType() != null) {
            effectiveness *= getTypeEffectiveness(move.getType(), defender.getSecondaryType());
        }

        return effectiveness;
    }

    private void showEffectivenessMessage(float effectiveness) {
        if (effectiveness > 1.5f) {
            showBattleText("It's super effective!");
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.SUPER_EFFECTIVE);
        } else if (effectiveness < 0.5f) {
            showBattleText("It's not very effective...");
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.NOT_EFFECTIVE);
        } else if (effectiveness == 0) {
            showBattleText("It had no effect...");
        }
    }
    private void enableBattleButtons(boolean enable) {
        if (fightButton == null) return;

        TextButton[] buttons = {fightButton, bagButton, pokemonButton, runButton};
        for (TextButton button : buttons) {
            button.setDisabled(!enable);
            button.setTouchable(enable ? Touchable.enabled : Touchable.childrenOnly);
            GameLogger.info(button.getName() + " enabled: " + enable +
                " touchable: " + button.getTouchable());
        }
    }

    private boolean checkBattleEnd() {
        if (playerPokemon.getCurrentHp() <= 0 || enemyPokemon.getCurrentHp() <= 0 ||
            turnCount >= MAX_TURN_COUNT) {

            boolean playerWon = playerPokemon.getCurrentHp() > 0 && enemyPokemon.getCurrentHp() <= 0;
            currentState = BattleState.ENDED;
            isAnimating = true;

            // Create ending sequence
            SequenceAction endSequence = Actions.sequence(
                Actions.run(() -> {
                    if (turnCount >= MAX_TURN_COUNT) {
                        showBattleText("Battle ended in a draw!");
                    } else {
                        showBattleText(playerWon ? "Victory!" : playerPokemon.getName() + " fainted!");
                    }
                }),
                Actions.delay(2.0f),
                Actions.parallel(
                    Actions.run(() -> {
                        if (playerPokemonImage != null) {
                            playerPokemonImage.addAction(Actions.fadeOut(1.0f));
                        }
                        if (enemyPokemonImage != null) {
                            enemyPokemonImage.addAction(Actions.fadeOut(1.0f));
                        }
                    })
                ),
                Actions.delay(1.0f),
                Actions.run(() -> {
                    if (callback != null) {
                        callback.onBattleEnd(playerWon);
                    }
                    dispose();
                })
            );

            addAction(endSequence); // Add to BattleTable instead of battleScene
            return true;
        }
        return false;
    }

    private void showBattleText(String text) {
        battleText.setText(text);
        battleText.addAction(Actions.sequence(
            Actions.alpha(0),
            Actions.fadeIn(0.2f)
        ));
    }

    private void transitionToState(BattleState newState) {
        GameLogger.info("Transitioning from " + currentState + " to " + newState);

        boolean wasAnimating = isAnimating;
        currentState = newState;
        stateTimer = 0;

        switch (newState) {
            case INTRO:
                isAnimating = true;
                enableBattleButtons(false);
                break;

            case PLAYER_TURN:
                isAnimating = false;
                enableBattleButtons(true);
                showActionMenu(true);
                break;

            case ENEMY_TURN:
                isAnimating = false;
                enableBattleButtons(false);
                showActionMenu(false);
                break;

            case ENDED:
                isAnimating = false;
                enableBattleButtons(false);
                showActionMenu(false);
                break;
        }

        // Update UI if animation state changed
        if (wasAnimating != isAnimating) {
            updateUI();
        }

        GameLogger.info("State transition complete - " +
            "State: " + currentState +
            " Animating: " + isAnimating +
            " Buttons enabled: " + (currentState == BattleState.PLAYER_TURN && !isAnimating));
    }

    private String generateBattleStartText() {
        return "Wild " + enemyPokemon.getName() + " appeared!";
    }

    private void updateHPBars() {
        // Update player HP bar
        float playerHPPercent = playerPokemon.getCurrentHp() / playerPokemon.getStats().getHp();
        playerHPBar.setValue(playerPokemon.getCurrentHp());
        updateHPBarColor(playerHPBar, playerHPPercent);

        // Update enemy HP bar
        float enemyHPPercent = enemyPokemon.getCurrentHp() / enemyPokemon.getStats().getHp();
        enemyHPBar.setValue(enemyPokemon.getCurrentHp());
        updateHPBarColor(enemyHPBar, enemyHPPercent);
    }

    private void updateStatusEffects() {
        // Update player Pokemon status
        if (playerPokemon.hasStatus()) {
            playerHUD.updateStatusIcon(TextureManager.getStatusIcon(
                TextureManager.StatusCondition.valueOf(playerPokemon.getStatus().name())));
        }

        // Update enemy Pokemon status
        if (enemyPokemon.hasStatus()) {
            enemyHUD.updateStatusIcon(TextureManager.getStatusIcon(
                TextureManager.StatusCondition.valueOf(enemyPokemon.getStatus().name())));
        }
    }

    private void executeStruggle(Pokemon attacker, Pokemon defender) {
        // Struggle implementation - damages both Pokemon
        float damage = attacker.getStats().getAttack() * 0.5f;
        float recoil = damage * 0.25f;

        applyDamage(defender, damage);
        applyDamage(attacker, recoil);

        showBattleText(attacker.getName() + " used Struggle!");
    }

    private float getTypeEffectiveness(Pokemon.PokemonType attackType, Pokemon.PokemonType defendType) {
        if (attackType == null || defendType == null) {
            GameLogger.error("Null type detected in getTypeEffectiveness: attackType=" + attackType + ", defendType=" + defendType);
            return 1.0f; // Neutral effectiveness when types are unknown
        }
        ObjectMap<Pokemon.PokemonType, Float> effectivenessMap = typeEffectiveness.get(attackType);
        if (effectivenessMap == null) {
            GameLogger.error("No effectiveness data for attackType: " + attackType);
            return 1.0f; // Default to neutral effectiveness
        }
        return effectivenessMap.get(defendType, 1.0f);
    }

    private enum BattleState {
        INTRO,        // Initial battle animation
        PLAYER_TURN,  // Player selecting action
        ENEMY_TURN,   // Enemy AI selecting action
        ANIMATING,    // Move animations playing
        ENDED,        // Battle complete
        RUNNING,      // Attempting to flee
        CATCHING      // Pokeball throw animation
    }


    public interface BattleCallback {
        void onBattleEnd(boolean playerWon);

        void onTurnEnd(Pokemon activePokemon);

        void onStatusChange(Pokemon pokemon, Pokemon.Status newStatus);

        void onMoveUsed(Pokemon user, Move move, Pokemon target);
    }

    private static class PokemonHUD extends Table {
        private final Table statusContainer;
        private final Pokemon pokemon;
        private Label hpLabel;
        private ProgressBar hpBar;
        private Label nameLabel;
        private Label levelLabel;
        private Skin skin;

        public PokemonHUD(Skin skin, Pokemon pokemon, boolean isPlayer) {
            this.pokemon = pokemon;
            this.skin = skin;


            // Name and Level
            nameLabel = new Label(pokemon.getName(), skin);
            levelLabel = new Label("Lv." + pokemon.getLevel(), skin);

            // Top row
            Table topRow = new Table();
            topRow.add(nameLabel).left().expandX();
            topRow.add(levelLabel).right();

            // HP Label
            hpLabel = new Label((int) pokemon.getCurrentHp() + "/" + (int) pokemon.getStats().getHp(), skin);
            hpLabel.setFontScale(0.7f);

            statusContainer = new Table();
            statusContainer.setName("statusContainer");

            // Layout without backgrounds
            add(topRow).expandX().fillX().pad(2).row();
            add(hpLabel).expandX().pad(2);

            setVisible(true);
        }

        private Drawable createHUDBackground() {
            Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
            pixmap.setColor(0, 0, 0, 0.5f);
            pixmap.fill();
            TextureRegion region = new TextureRegion(new Texture(pixmap));
            pixmap.dispose();
            return new TextureRegionDrawable(region);
        }

        private String getHPStyleKey(float percentage) {
            if (percentage > 0.5f) {
                return "hp-bar-green";
            } else if (percentage > 0.2f) {
                return "hp-bar-yellow";
            } else {
                return "hp-bar-red";
            }
        }

        public void update() {
            levelLabel.setText("Lv." + pokemon.getLevel());

            float currentPercentage = pokemon.getCurrentHp() / (float) pokemon.getStats().getHp();
            String newStyleKey = getHPStyleKey(currentPercentage);

            hpBar.setStyle(skin.get(newStyleKey, ProgressBar.ProgressBarStyle.class));
            hpBar.setValue(pokemon.getCurrentHp());

            hpLabel.setText((int) pokemon.getCurrentHp() + "/" + (int) pokemon.getStats().getHp());
        }


        public void setHPBar(ProgressBar hpBar) {
            this.hpBar = hpBar;

            // Remove existing HP bar if present
            for (Cell<?> cell : getCells()) {
                if (cell.getActor() == hpBar) {
                    cell.setActor(null);
                }
            }

            // Add HP bar directly without any container
            add(hpBar).expandX().fillX().height(8).pad(4).row();
        }

        @Override
        public void layout() {
            super.layout();
            // Ensure proper scaling of the HUD components
            setScale(1.0f);
            invalidateHierarchy();
        }

        public void updateStatusIcon(TextureRegion statusIcon) {
            statusContainer.clear();
            if (statusIcon != null) {
                Image statusImage = new Image(statusIcon);
                statusContainer.add(statusImage).size(32).pad(2);
            }
        }
    }

    public class ActionButton extends TextButton {
        private final Runnable action;
        private final BattleTable battleTable;

        public ActionButton(String text, TextButtonStyle style, Runnable action, BattleTable battleTable) {
            super(text, style);
            this.action = action;
            this.battleTable = battleTable;

            addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    GameLogger.info(text + " button clicked - State: " + battleTable.getCurrentState() +
                        " Animating: " + battleTable.isAnimating() +
                        " Disabled: " + isDisabled());

                    if (!isDisabled() && !battleTable.isAnimating() &&
                        battleTable.getCurrentState() == BattleState.PLAYER_TURN) {
                        action.run();
                    }
                }
            });
        }

        @Override
        public void act(float delta) {
            super.act(delta);
            boolean enabled = battleTable.getCurrentState() == BattleState.PLAYER_TURN &&
                !battleTable.isAnimating();
            setDisabled(!enabled);
        }
    }
}

================
File: main/java/io/github/pokemeetup/screens/otherui/BuildingHotbar.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.FrameBuffer;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.utils.Scaling;
import io.github.pokemeetup.blocks.BuildingData;
import io.github.pokemeetup.blocks.BuildingTemplate;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.textures.BlockTextureManager;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.List;

public class BuildingHotbar extends Table {
    private static final int VISIBLE_SLOTS = 9;
    private static final float SLOT_SIZE = 50f;
    private static final float PADDING = 5f;
    private static final float PREVIEW_SIZE = 40f;
    private final List<BuildingData> buildingSlots = new ArrayList<>();
    private final ScrollPane scrollPane;
    private final Table slotsTable;
    private int selectedIndex = 0;

    public BuildingHotbar(Skin skin) {
        // Set background similar to the regular hotbar
        this.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("hotbar_bg")));
        this.pad(PADDING);

        // Create the slots table (horizontal layout)
        slotsTable = new Table();

        // Scroll pane for horizontal scrolling if needed
        ScrollPane.ScrollPaneStyle scrollStyle = new ScrollPane.ScrollPaneStyle(
            skin.get(ScrollPane.ScrollPaneStyle.class));
        scrollStyle.hScrollKnob = new TextureRegionDrawable(TextureManager.ui.findRegion("scrollbar_knob"));
        scrollPane = new ScrollPane(slotsTable, scrollStyle);
        scrollPane.setScrollingDisabled(false, true);
        scrollPane.setFadeScrollBars(false);

        // Fit the hotbar width to screen width
        float totalWidth = Gdx.graphics.getWidth() - 20f;  // a margin from screen edges
        float totalHeight = SLOT_SIZE + PADDING * 2;

        this.add(scrollPane).width(totalWidth).height(totalHeight);

        // Initialize with a default building
        initializeBuildings();
        refreshSlots();

        GameLogger.info("BuildingHotbar initialized horizontally: " + totalWidth + "x" + totalHeight);
    }

    private void initializeBuildings() {
        // Example: Wooden House
        BuildingData woodenHouse = new BuildingData(
            "wooden_house",
            "Wooden House",
            BuildingTemplate.createWoodenHouse()
        );
        woodenHouse.addRequirement("wooden_planks", 128);
        buildingSlots.add(woodenHouse);

        GameLogger.info("Added wooden house template to building hotbar");
    }

    private void refreshSlots() {
        slotsTable.clear();

        for (int i = 0; i < buildingSlots.size(); i++) {
            final int index = i;
            BuildingData building = buildingSlots.get(i);

            // Create slot table
            Table slot = new Table();
            slot.setBackground(new TextureRegionDrawable(
                TextureManager.ui.findRegion(index == selectedIndex ? "slot_selected" : "slot_normal")));

            // Create preview image
            Table previewContainer = createBuildingPreview(building);
            slot.add(previewContainer).size(SLOT_SIZE).pad(PADDING);

            // Add click listener
            slot.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    selectSlot(index);
                }
            });

            slotsTable.add(slot).size(SLOT_SIZE).pad(PADDING);
        }
    }

    private Table createBuildingPreview(BuildingData building) {
        Table container = new Table();
        if (building != null) {
            // Use a predefined preview image from the buildings atlas
            // Adjust the region name if needed to match your actual texture name
            TextureRegion finalHouseTexture = TextureManager.buildings.findRegion(building.getId());
            if (finalHouseTexture != null) {
                Image previewImage = new Image(finalHouseTexture);
                previewImage.setScaling(Scaling.fit);
                container.add(previewImage).size(SLOT_SIZE, SLOT_SIZE).center();
            } else {
                // If no preview image is found, show a placeholder
                // Make sure to have a fallback in case the preview image doesn't exist
                Label label = new Label("No Preview", getSkin());
                container.add(label).center();
            }
        }
        return container;
    }



    @Override
    public void act(float delta) {
        super.act(delta);
        // If you want to handle keyboard scrolling:
        if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) {
            scroll(-5);
        } else if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) {
            scroll(5);
        }
    }

    public void selectSlot(int index) {
        if (index >= 0 && index < buildingSlots.size()) {
            selectedIndex = index;
            refreshSlots();
            GameLogger.info("Selected building slot: " + index);
        }
    }

    public BuildingData getSelectedBuilding() {
        if (selectedIndex >= 0 && selectedIndex < buildingSlots.size()) {
            return buildingSlots.get(selectedIndex);
        }
        return null;
    }

    public void scroll(int amount) {
        // Scroll horizontally by amount
        float currentX = scrollPane.getScrollX();
        scrollPane.setScrollX(currentX + amount);
    }
}

================
File: main/java/io/github/pokemeetup/screens/otherui/BuildModeUI.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Scaling;
import io.github.pokemeetup.blocks.BuildingData;
import io.github.pokemeetup.blocks.BuildingTemplate;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.blocks.SmartBuildingManager;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.UITransitionManager;
import io.github.pokemeetup.system.data.BlockSaveData;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.BlockTextureManager;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

public class BuildModeUI extends Group {
    private static final float PADDING = 10f;
    private static final float PARTY_UI_HEIGHT = 50f;
    private static final float SLOT_SIZE = 40f;
    private static final int HOTBAR_SLOTS = 9;
    private static final Color VALID_PREVIEW_COLOR = new Color(0, 1, 0, 0.3f);
    private static final Color INVALID_PREVIEW_COLOR = new Color(1, 0, 0, 0.3f);
    private final Skin skin;
    private final BuildingHotbar buildingHotbar;
    private boolean inBuildingMode = false;

    private final Table mainTable;
    private final Table hotbarTable;
    private final SmartBuildingManager smartBuildingManager;
    private final ShapeRenderer shapeRenderer;
    private final BlockTextureManager blockTextureManager;
    private final boolean disposed = false;
    private final Vector2 previewPosition;
    private final UITransitionManager transitionManager = new UITransitionManager();
    private int selectedSlot = 0;
    private boolean canPlaceAtPreview;
    private float stateTime = 0;
    private final BitmapFont font;

    public BuildModeUI(Skin skin) {
        this.skin = skin;
        this.font = new BitmapFont(Gdx.files.internal("Skins/default.fnt"));

        this.buildingHotbar = new BuildingHotbar(skin);
        buildingHotbar.setVisible(false);

        float hotbarY = PARTY_UI_HEIGHT + PADDING;
        buildingHotbar.setPosition(PADDING, hotbarY);
        this.addActor(buildingHotbar);

        this.blockTextureManager = new BlockTextureManager();
        this.shapeRenderer = new ShapeRenderer();
        this.previewPosition = new Vector2();

        this.mainTable = new Table();
        this.mainTable.setFillParent(true);
        this.mainTable.bottom().center();
        this.mainTable.padBottom(PARTY_UI_HEIGHT + PADDING);

        this.hotbarTable = new Table();
        this.hotbarTable.setTouchable(Touchable.enabled);

        // Initialize and populate the build inventory with all placeable blocks.
        refreshBuildInventory();

        this.smartBuildingManager = new SmartBuildingManager(GameContext.get().getWorld());
        this.mainTable.add(hotbarTable).expandX().center().bottom();

        this.mainTable.setTouchable(Touchable.disabled);
        this.addActor(mainTable);

        float hotbarHeight = SLOT_SIZE + PADDING * 2;
        setSize(Gdx.graphics.getWidth(), hotbarHeight);
        setPosition(0, PARTY_UI_HEIGHT + PADDING);

        GameContext.get().getPlayer().getInventory().addObserver(() -> {
            refreshBuildInventory();
        });
    }

    public boolean isInBuildingMode() {
        return inBuildingMode;
    }

    public void resize(int width) {
        setSize(width, SLOT_SIZE + PADDING * 2);
        setPosition(0, PARTY_UI_HEIGHT + PADDING);
        mainTable.invalidateHierarchy();
    }

    @Override
    public void draw(Batch batch, float parentAlpha) {
        super.draw(batch, parentAlpha);
    }

    public void renderPlacementPreview(SpriteBatch batch, OrthographicCamera camera) {
        if (!GameContext.get().getPlayer().isBuildMode() || !this.isVisible()) return;

        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();

        switch (GameContext.get().getPlayer().getDirection()) {
            case "up": targetY++; break;
            case "down": targetY--; break;
            case "left": targetX--; break;
            case "right": targetX++; break;
        }

        previewPosition.set(targetX, targetY);
        canPlaceAtPreview = canPlaceBlockAt(targetX, targetY);

        renderPlacementIndicator(camera, targetX, targetY);

        // If placement is valid, render block preview
        if (canPlaceAtPreview) {
            renderBlockPreview(batch, targetX, targetY);
        }
    }

    private void renderPlacementIndicator(OrthographicCamera camera, int targetX, int targetY) {
        Gdx.gl.glEnable(GL20.GL_BLEND);
        shapeRenderer.setProjectionMatrix(camera.combined);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);

        Color previewColor = canPlaceAtPreview ? VALID_PREVIEW_COLOR : INVALID_PREVIEW_COLOR;
        shapeRenderer.setColor(previewColor);

        float previewX = targetX * World.TILE_SIZE;
        float previewY = targetY * World.TILE_SIZE;
        shapeRenderer.rect(previewX, previewY, World.TILE_SIZE, World.TILE_SIZE);

        shapeRenderer.end();
        Gdx.gl.glDisable(GL20.GL_BLEND);
    }

    private void renderBlockPreview(SpriteBatch batch, int targetX, int targetY) {
        ItemData selectedItem = GameContext.get().getPlayer().getBuildInventory().getItemAt(selectedSlot);
        if (selectedItem == null) return;

        PlaceableBlock.BlockType baseType = PlaceableBlock.BlockType.fromItemId(selectedItem.getItemId());
        if (baseType == null) return;

        String groupId = smartBuildingManager.getGroupIdForBlockType(baseType);
        PlaceableBlock.BlockType previewType = groupId != null ?
            smartBuildingManager.getSmartBlockType(groupId, targetX, targetY) : baseType;

        if (previewType != null) {
            Vector2 blockPosition = new Vector2(targetX, targetY);
            PlaceableBlock previewBlock = new PlaceableBlock(previewType, blockPosition, null, false);
            TextureRegion blockTexture = BlockTextureManager.getBlockFrame(previewBlock, stateTime);

            if (blockTexture != null) {
                batch.begin();
                float previewX = targetX * World.TILE_SIZE;
                float previewY = targetY * World.TILE_SIZE;

                batch.setColor(1, 1, 1, 0.7f);
                batch.draw(blockTexture, previewX, previewY);
                batch.setColor(Color.WHITE);
                batch.end();
            }
        }
    }

    public void toggleBuildingMode() {
        inBuildingMode = !inBuildingMode;

        if (inBuildingMode) {
            // Hide regular hotbar
            hotbarTable.setVisible(false);
            // Show building hotbar
            buildingHotbar.setVisible(true);
            mainTable.clear();
            mainTable.add(buildingHotbar).expandX().center().bottom();
            buildingHotbar.selectSlot(0);
        } else {
            // Hide building hotbar
            buildingHotbar.setVisible(false);
            mainTable.clear();
            mainTable.add(hotbarTable).expandX().center().bottom();
            hotbarTable.setVisible(true);
            selectSlot(0);
        }
    }


    public boolean tryPlaceBuilding(int tileX, int tileY) {
        if (!inBuildingMode) return false;

        BuildingData building = buildingHotbar.getSelectedBuilding();
        if (building == null) {
            GameLogger.info("No building selected");
            return false;
        }

        for (Map.Entry<String, Integer> req : building.getRequirements().entrySet()) {
            if (!hasEnoughMaterials(req.getKey(), req.getValue())) {
                GameLogger.info("Not enough materials: " + req.getKey() +
                    " (Need: " + req.getValue() +
                    ", Have: " + countPlayerItems(req.getKey()) + ")");
                return false;
            }
        }

        BuildingTemplate template = building.getTemplate();
        if (template == null) {
            GameLogger.error("Building template is null");
            return false;
        }

        if (!canPlaceBuilding(template, tileX, tileY)) {
            GameLogger.info("Cannot place building at " + tileX + "," + tileY);
            return false;
        }

        boolean placed = template.placeBuilding(GameContext.get().getWorld(), tileX, tileY);
        if (placed) {
            consumeMaterials(building.getRequirements());
            GameLogger.info("Successfully placed building: " + building.getName());
            return true;
        }

        GameLogger.info("Failed to place building");
        return false;
    }

    private boolean hasEnoughMaterials(String itemId, int required) {
        int count = 0;
        for (int i = 0; i < GameContext.get().getPlayer().getInventory().getSize(); i++) {
            ItemData item = GameContext.get().getPlayer().getInventory().getItemAt(i);
            if (item != null && item.getItemId().equals(itemId)) {
                count += item.getCount();
            }
        }
        return count >= required;
    }

    private void consumeMaterials(Map<String, Integer> requirements) {
        for (Map.Entry<String, Integer> req : requirements.entrySet()) {
            int remaining = req.getValue();
            for (int i = 0; i < GameContext.get().getPlayer().getInventory().getSize() && remaining > 0; i++) {
                ItemData item = GameContext.get().getPlayer().getInventory().getItemAt(i);
                if (item != null && item.getItemId().equals(req.getKey())) {
                    if (item.getCount() <= remaining) {
                        remaining -= item.getCount();
                        GameContext.get().getPlayer().getInventory().removeItemAt(i);
                        i--;
                    } else {
                        item.setCount(item.getCount() - remaining);
                        remaining = 0;
                    }
                }
            }
        }
        refreshBuildInventory();
    }

    public void show() {
        if (!disposed) {
            this.setVisible(true);
            this.setTouchable(Touchable.enabled);
            mainTable.setVisible(true);
            refreshBuildInventory();
        }
    }

    public void startHideTransition(float duration) {
        transitionManager.startHideTransition(duration, () -> {
            mainTable.setVisible(false);
            this.setVisible(false);
            this.setTouchable(Touchable.disabled);
        });
    }

    public void hide() {
        startHideTransition(UITransitionManager.DEFAULT_TRANSITION_TIME);
    }

    public void updateHotbarContent() {
        hotbarTable.clear();
        hotbarTable.setBackground(new TextureRegionDrawable(
            TextureManager.ui.findRegion("hotbar_bg")
        ));
        hotbarTable.pad(4);

        for (int i = 0; i < HOTBAR_SLOTS; i++) {
            final int slotIndex = i;
            Table slotCell = createSlotCell(i);

            slotCell.addListener(new ClickListener() {
                @Override
                public void clicked(InputEvent event, float x, float y) {
                    selectSlot(slotIndex);
                    event.stop();
                }
            });

            hotbarTable.add(slotCell).size(SLOT_SIZE).pad(2);
        }
    }

    private boolean isBlockItem(String itemId) {
        // Normalize item ID
        String normalizedId = itemId.toLowerCase().replace("_item", "");
        try {
            PlaceableBlock.BlockType.valueOf(normalizedId.toUpperCase());
            return true;
        } catch (IllegalArgumentException e) {
            return false;
        }
    }

    private Table createSlotCell(int index) {
        Table slotCell = new Table();
        slotCell.setBackground(new TextureRegionDrawable(
            TextureManager.ui.findRegion(index == selectedSlot ? "slot_selected" : "slot_normal")
        ));

        ItemData item = GameContext.get().getPlayer().getBuildInventory().getItemAt(index);
        if (item != null) {
            TextureRegion itemIcon = blockTextureManager.getItemIcon(item.getItemId());
            if (itemIcon != null) {
                Image itemImage = new Image(itemIcon);
                itemImage.setScaling(Scaling.fit);
                slotCell.add(itemImage).width(SLOT_SIZE - 8).center().expand();

                if (item.getCount() > 1) {
                    Label countLabel = new Label(String.valueOf(item.getCount()), skin);
                    countLabel.setColor(Color.WHITE);
                    countLabel.setPosition(
                        slotCell.getWidth() - countLabel.getWidth() - 2,
                        2
                    );
                    slotCell.addActor(countLabel);
                }
            }
        }

        return slotCell;
    }

    public void dispose() {
        if (shapeRenderer != null) {
            shapeRenderer.dispose();
        }
    }

    public void selectSlot(int index) {
        if (index >= 0 && index < HOTBAR_SLOTS) {
            selectedSlot = index;
            ItemData selectedItem = GameContext.get().getPlayer().getBuildInventory().getItemAt(index);

            if (selectedItem != null) {
                GameContext.get().getPlayer().selectBlockItem(index);
                PlaceableBlock.BlockType blockType = PlaceableBlock.BlockType.fromItemId(selectedItem.getItemId());
                if (blockType != null) {
                    GameLogger.info("Selected block: " + blockType.id);
                }
            }

            updateHotbarContent();
        }
    }

    public void update(float deltaTime) {
        stateTime += deltaTime;
        ItemData selectedItem = GameContext.get().getPlayer().getBuildInventory().getItemAt(selectedSlot);
        if (selectedItem != null) {
            GameLogger.info("Selected: " + selectedItem.getItemId() +
                " at pos: " + previewPosition +
                " canPlace: " + canPlaceAtPreview);
        }
    }

    public void render(SpriteBatch batch, OrthographicCamera camera) {
        GameLogger.info("BuildModeUI rendering - BuildingMode: " + inBuildingMode +
            ", Hotbar visible: " + buildingHotbar.isVisible());
        if (!this.isVisible() || !GameContext.get().getPlayer().isBuildMode() || !mainTable.isVisible()) return;

        stateTime += Gdx.graphics.getDeltaTime();

        if (inBuildingMode) {
            renderBuildingPreview(batch, camera);
        } else {
            renderPlacementPreview(batch, camera);
        }
    }

    private void renderBuildingPreview(SpriteBatch batch, OrthographicCamera camera) {
        if (!GameContext.get().getPlayer().isBuildMode() || !this.isVisible()) return;

        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();

        switch (GameContext.get().getPlayer().getDirection()) {
            case "up": targetY++; break;
            case "down": targetY--; break;
            case "left": targetX--; break;
            case "right": targetX++; break;
        }

        BuildingData buildingData = buildingHotbar.getSelectedBuilding();
        if (buildingData == null) return;

        BuildingTemplate template = buildingData.getTemplate();
        boolean canPlace = canPlaceBuilding(template, targetX, targetY);

        renderBuildingPlacementArea(camera, targetX, targetY, template, canPlace);

        if (canPlace) {
            renderBuildingBlocks(batch, targetX, targetY, template);
        }

        renderBuildingRequirements(batch, camera, buildingData, canPlace);
    }

    private boolean canPlaceBuilding(BuildingTemplate template, int startX, int startY) {
        int width = template.getWidth();
        int height = template.getHeight();

        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                BuildingTemplate.BlockData blockData = template.getBlockAt(x, y);
                if (blockData != null) {
                    int worldX = startX + x;
                    int worldY = startY + y;

                    if (!GameContext.get().getWorld().isPassable(worldX, worldY)) {
                        return false;
                    }

                    if (GameContext.get().getWorld().getBlockManager().getBlockAt(worldX, worldY) != null) {
                        return false;
                    }

                    PlaceableBlock.BlockType blockType = blockData.type;
                    if (blockType.hasCollision && !isSpaceClear(worldX, worldY)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    private boolean isSpaceClear(int x, int y) {
        List<WorldObject> objects = GameContext.get().getWorld().getObjectManager()
            .getObjectsNearPosition(x * World.TILE_SIZE, y * World.TILE_SIZE);

        for (WorldObject obj : objects) {
            Rectangle objBounds = obj.getCollisionBox();
            if (objBounds != null) {
                Rectangle blockBounds = new Rectangle(
                    x * World.TILE_SIZE,
                    y * World.TILE_SIZE,
                    World.TILE_SIZE,
                    World.TILE_SIZE
                );
                if (objBounds.overlaps(blockBounds)) {
                    return false;
                }
            }
        }

        Chunk chunk = GameContext.get().getWorld().getChunkAtPosition(x, y);
        if (chunk != null) {
            int localX = Math.floorMod(x, Chunk.CHUNK_SIZE);
            int localY = Math.floorMod(y, Chunk.CHUNK_SIZE);
            return chunk.isPassable(localX, localY);
        }

        return false;
    }

    private void renderBuildingPlacementArea(OrthographicCamera camera, int startX, int startY,
                                             BuildingTemplate template, boolean canPlace) {
        Gdx.gl.glEnable(GL20.GL_BLEND);
        shapeRenderer.setProjectionMatrix(camera.combined);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);

        Color areaColor = canPlace ? VALID_PREVIEW_COLOR : INVALID_PREVIEW_COLOR;
        shapeRenderer.setColor(areaColor);

        float previewX = startX * World.TILE_SIZE;
        float previewY = startY * World.TILE_SIZE;
        shapeRenderer.rect(
            previewX,
            previewY,
            template.getWidth() * World.TILE_SIZE,
            template.getHeight() * World.TILE_SIZE
        );

        shapeRenderer.end();
        Gdx.gl.glDisable(GL20.GL_BLEND);
    }

    private void renderBuildingBlocks(SpriteBatch batch, int startX, int startY,
                                      BuildingTemplate template) {
        batch.begin();
        batch.setColor(1, 1, 1, 0.7f);

        for (int x = 0; x < template.getWidth(); x++) {
            for (int y = 0; y < template.getHeight(); y++) {
                BuildingTemplate.BlockData blockData = template.getBlockAt(x, y);
                if (blockData != null) {
                    PlaceableBlock previewBlock = new PlaceableBlock(
                        blockData.type,
                        new Vector2(startX + x, startY + y),
                        null,
                        blockData.isFlipped
                    );

                    TextureRegion blockTexture = BlockTextureManager.getBlockFrame(previewBlock, stateTime);
                    if (blockTexture != null) {
                        float blockX = (startX + x) * World.TILE_SIZE;
                        float blockY = (startY + y) * World.TILE_SIZE;

                        if (blockData.isFlipped) {
                            batch.draw(
                                blockTexture,
                                blockX + blockTexture.getRegionWidth(),
                                blockY,
                                -blockTexture.getRegionWidth(),
                                blockTexture.getRegionHeight()
                            );
                        } else {
                            batch.draw(blockTexture, blockX, blockY);
                        }
                    }
                }
            }
        }

        batch.setColor(Color.WHITE);
        batch.end();
    }

    private void renderBuildingRequirements(SpriteBatch batch, OrthographicCamera camera,
                                            BuildingData building, boolean canPlace) {
        batch.begin();
        String title = building.getName();

        // Calculate starting Y from top of screen, and center X
        float startY = Gdx.graphics.getHeight() - 60;
        float centerX = Gdx.graphics.getWidth() / 2f;

        BitmapFont.BitmapFontData fontData = font.getData();
        fontData.setScale(1f);
        font.getData().markupEnabled = true;

        // Draw building name centered
        float titleWidth = font.getRegion().getTexture().getWidth(); // Approximation, better use GlyphLayout
        // Use GlyphLayout for precise width calculation
        com.badlogic.gdx.graphics.g2d.GlyphLayout layout = new com.badlogic.gdx.graphics.g2d.GlyphLayout();

        layout.setText(font, title);
        float textWidth = layout.width;
        font.setColor(canPlace ? Color.WHITE : Color.RED);
        font.draw(batch, title, centerX - textWidth / 2, startY);

        float requirementY = startY - 20;
        for (Map.Entry<String, Integer> req : building.getRequirements().entrySet()) {
            String itemId = req.getKey();
            int required = req.getValue();
            int available = countPlayerItems(itemId);

            Color textColor = available >= required ? Color.GREEN : Color.RED;
            font.setColor(textColor);

            String text = String.format("%s: %d/%d", getItemDisplayName(itemId), available, required);
            layout.setText(font, text);
            textWidth = layout.width;

            font.draw(batch, text, centerX - textWidth / 2, requirementY);
            requirementY -= 20;
        }

        font.setColor(Color.WHITE);
        batch.end();
    }


    private int countPlayerItems(String itemId) {
        int count = 0;
        for (int i = 0; i < GameContext.get().getPlayer().getInventory().getSize(); i++) {
            ItemData item = GameContext.get().getPlayer().getInventory().getItemAt(i);
            if (item != null && item.getItemId().equals(itemId)) {
                count += item.getCount();
            }
        }
        return count;
    }

    private String getItemDisplayName(String itemId) {
        return itemId.substring(0, 1).toUpperCase() +
            itemId.substring(1).toLowerCase().replace('_', ' ');
    }

    private boolean canPlaceBlockAt(int tileX, int tileY) {
        int playerTileX = GameContext.get().getPlayer().getTileX();
        int playerTileY = GameContext.get().getPlayer().getTileY();

        boolean isAdjacent = false;
        switch (GameContext.get().getPlayer().getDirection()) {
            case "up":
                isAdjacent = (tileX == playerTileX && tileY == playerTileY + 1);
                break;
            case "down":
                isAdjacent = (tileX == playerTileX && tileY == playerTileY - 1);
                break;
            case "left":
                isAdjacent = (tileX == playerTileX - 1 && tileY == playerTileY);
                break;
            case "right":
                isAdjacent = (tileX == playerTileX + 1 && tileY == playerTileY);
                break;
        }

        if (!isAdjacent) {
            GameLogger.info("Position not adjacent to player in facing direction");
            return false;
        }

        PlaceableBlock existingBlock = GameContext.get().getWorld().getBlockManager().getBlockAt(tileX, tileY);
        if (existingBlock != null) {
            GameLogger.info("Block already exists at target position");
            return false;
        }

        return GameContext.get().getWorld().isPassable(tileX, tileY);
    }

    public boolean tryPlaceBlock(int tileX, int tileY) {
        if (!GameContext.get().getPlayer().isBuildMode()) return false;
        if (!canPlaceBlockAt(tileX, tileY)) return false;
        if (inBuildingMode) {
            return tryPlaceBuilding(tileX, tileY);
        }

        synchronized (GameContext.get().getPlayer().getInventory().getInventoryLock()) {
            ItemData selectedItem = GameContext.get().getPlayer().getBuildInventory().getItemAt(selectedSlot);
            if (selectedItem == null) {
                GameLogger.info("No item selected in build inventory");
                return false;
            }

            try {
                UUID selectedItemUUID = selectedItem.getUuid();
                ItemData inventoryItem = findInventoryItem(selectedItemUUID);
                if (inventoryItem == null) {
                    GameLogger.info("Item not found in main inventory: " + selectedItem.getItemId());
                    updateHotbarContent();
                    return false;
                }

                PlaceableBlock.BlockType blockType = PlaceableBlock.BlockType.fromItemId(inventoryItem.getItemId());
                if (blockType == null) {
                    GameLogger.error("Invalid block type for item: " + inventoryItem.getItemId());
                    return false;
                }

                String groupId = smartBuildingManager.getGroupIdForBlockType(blockType);
                if (groupId != null) {
                    PlaceableBlock.BlockType smartType = smartBuildingManager.getSmartBlockType(groupId, tileX, tileY);
                    if (smartType != null) {
                        blockType = smartType;
                    }
                }

                boolean placed = GameContext.get().getWorld().getBlockManager()
                    .placeBlockFromPlayer(blockType, GameContext.get().getPlayer(), GameContext.get().getWorld());

                if (placed) {
                    if (inventoryItem.getCount() > 1) {
                        inventoryItem.setCount(inventoryItem.getCount() - 1);
                    } else {
                        removeInventoryItem(selectedItemUUID);
                    }

                    if (groupId != null) {
                        smartBuildingManager.updateSurroundingBlocks(tileX, tileY, groupId);
                    }

                    saveBlockData(blockType, tileX, tileY);
                    updateHotbarContent();

                    GameLogger.info("Successfully placed block: " + blockType.getId());
                    return true;
                }
            } catch (Exception e) {
                GameLogger.error("Error placing block: " + e.getMessage());
            }
            return false;
        }
    }

    /**
     * Refreshes the build inventory by clearing all slots and repopulating them
     * from the player's main inventory. It includes all placeable blocks the player has,
     * up to the hotbar slot limit.
     */
    public void refreshBuildInventory() {
        // First, clear all build inventory slots
        for (int i = 0; i < HOTBAR_SLOTS; i++) {
            GameContext.get().getPlayer().getBuildInventory().removeItemAt(i);
        }

        int buildSlot = 0;
        // Fill slots with placeable blocks from player's main inventory
        for (int i = 0; i < GameContext.get().getPlayer().getInventory().getSize() && buildSlot < HOTBAR_SLOTS; i++) {
            ItemData item = GameContext.get().getPlayer().getInventory().getItemAt(i);
            if (item != null && isBlockItem(item.getItemId())) {
                GameContext.get().getPlayer().getBuildInventory().setItemAt(buildSlot++, item);
            }
        }

        updateHotbarContent();
    }

    private ItemData findInventoryItem(UUID itemUUID) {
        for (int i = 0; i < GameContext.get().getPlayer().getInventory().getSize(); i++) {
            ItemData item = GameContext.get().getPlayer().getInventory().getItemAt(i);
            if (item != null && item.getUuid().equals(itemUUID)) {
                return item;
            }
        }
        return null;
    }

    private void removeInventoryItem(UUID itemUUID) {
        for (int i = 0; i < GameContext.get().getPlayer().getInventory().getSize(); i++) {
            ItemData item = GameContext.get().getPlayer().getInventory().getItemAt(i);
            if (item != null && item.getUuid().equals(itemUUID)) {
                GameContext.get().getPlayer().getInventory().removeItemAt(i);
                break;
            }
        }
    }

    private void saveBlockData(PlaceableBlock.BlockType blockType, int tileX, int tileY) {
        if (GameContext.get().getWorld().getWorldData() != null) {
            BlockSaveData blockData = GameContext.get().getWorld().getWorldData().getBlockData();
            if (blockData == null) {
                blockData = new BlockSaveData();
                GameContext.get().getWorld().getWorldData().setBlockData(blockData);
            }

            String chunkKey = getChunkKeyForPosition(tileX, tileY);
            BlockSaveData.BlockData data = new BlockSaveData.BlockData(blockType.getId(), tileX, tileY);
            blockData.addBlock(chunkKey, data);
            GameContext.get().getWorld().getWorldData().setDirty(true);
            GameContext.get().getWorld().save();
        }
    }

    private String getChunkKeyForPosition(int tileX, int tileY) {
        int chunkX = Math.floorDiv(tileX, World.CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, World.CHUNK_SIZE);
        return chunkX + "," + chunkY;
    }
}

================
File: main/java/io/github/pokemeetup/screens/otherui/GameMenu.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Preferences;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.client.GameClientSingleton;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.screens.ModeSelectionScreen;
import io.github.pokemeetup.system.InputManager;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.utils.GameLogger;

import java.util.concurrent.atomic.AtomicBoolean;

public class GameMenu extends Actor {
    private static final float BUTTON_WIDTH = 200f;
    private static final float BUTTON_HEIGHT = 50f;
    private static final float MENU_PADDING = 20f;

    private final CreatureCaptureGame game;
    private final InputManager inputManager;
    private Stage stage;
    private Skin skin;
    private Window menuWindow;
    private Table menuTable;
    private boolean isVisible;
    private Window optionsWindow;
    private Slider musicSlider;
    private Slider soundSlider;
    private CheckBox musicEnabled;
    private CheckBox soundEnabled;
    private volatile boolean disposalRequested = false;
    private volatile boolean isDisposing = false;

    public GameMenu(CreatureCaptureGame game, Skin skin, InputManager inputManager) {
        this.game = game;
        this.skin = skin;
        this.inputManager = inputManager;
        this.stage = new Stage(new ScreenViewport());
        createMenu();
        menuWindow.setVisible(false);
        hide();
    }

    private void handleExit() {
        if (GameContext.get().getGameClient() != null && !GameContext.get().getGameClient().isSinglePlayer()) {
            Dialog confirmDialog = new Dialog("Confirm Exit", skin) {
                @Override
                protected void result(Object object) {
                    if ((Boolean) object) {
                        performMultiplayerExit();
                    }
                }
            };
            confirmDialog.text("Are you sure you want to exit to title?\nYour progress will be saved.");
            confirmDialog.button("Yes", true);
            confirmDialog.button("No", false);
            confirmDialog.show(stage);
        } else {
            performSaveAndExit();
        }
    }

    private void performMultiplayerExit() {
        Dialog loadingDialog = new Dialog("", skin);
        loadingDialog.text("Saving and exiting...");
        loadingDialog.show(stage);

        new Thread(() -> {
            try {
                GameClient oldClient = GameContext.get().getGameClient();

                // 2) Dispose the old client
                if (oldClient != null) {
                    oldClient.dispose();
                }

                // 3) Reset the singleton
                GameClientSingleton.resetInstance();
                GameContext.get().setGameClient(null);
                GameContext.get().setInventoryScreen(null);
                GameContext.get().setBuildModeUI(null);
                GameContext.get().setCraftingScreen(null);


                // 4) Now schedule UI thread action
                Gdx.app.postRunnable(() -> safeDisposeAndTransition(loadingDialog, false));

            } catch (Exception e) {
                GameLogger.error("Exit failed: " + e.getMessage());
                Gdx.app.postRunnable(() -> {
                    loadingDialog.hide();
                    showErrorDialog("Failed to exit: " + e.getMessage());
                });
            }
        }).start();
    }

    private void safeDisposeAndTransition(Dialog loadingDialog, boolean isSinglePlayer) {
        try {
            isDisposing = true;

            // Clean up menu resources
            if (menuWindow != null) menuWindow.setVisible(false);
            if (optionsWindow != null) optionsWindow.setVisible(false);
            if (stage != null) {
                stage.clear();
                stage.dispose();
            }

            if (loadingDialog != null) {
                loadingDialog.hide();
            }
            if (isSinglePlayer) {
                game.saveAndDispose();
                game.reinitializeGame();
            }


            // Create new screen
            game.setScreen(new ModeSelectionScreen(game));
            isDisposing = false;
        } catch (Exception e) {
            GameLogger.error("Cleanup error: " + e.getMessage());
            isDisposing = false;
            if (loadingDialog != null) loadingDialog.hide();
            showErrorDialog("Error during cleanup: " + e.getMessage());
        }
    }

    private void createMenu() {
        menuWindow = new Window("Menu", skin);
        menuWindow.setMovable(false);
        menuWindow.addListener(new InputListener() {
            @Override
            public boolean keyDown(InputEvent event, int keycode) {
                GameLogger.info("GameMenu keyDown: keycode=" + keycode);
                return false; // Allow event to propagate
            }

            @Override
            public boolean keyUp(InputEvent event, int keycode) {
                GameLogger.info("GameMenu keyUp: keycode=" + keycode);
                return false; // Allow event to propagate
            }
        });

        menuTable = new Table();
        menuTable.defaults().pad(10).width(BUTTON_WIDTH).height(BUTTON_HEIGHT);

        TextButton saveButton = new TextButton("Save Game", skin);
        TextButton bagButton = new TextButton("Bag", skin);
        TextButton pokemonButton = new TextButton("Pokemon", skin);
        TextButton optionsButton = new TextButton("Options", skin);
        TextButton exitButton = new TextButton("Quit and Save to Title", skin);


        saveButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (GameContext.get().getGameClient().isSinglePlayer()) {
                    saveGame();
                }
            }
        });

        ClickListener notImplementedListener = new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                showNotImplementedMessage();
            }
        };

        bagButton.addListener(notImplementedListener);
        pokemonButton.addListener(notImplementedListener);
        exitButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                handleExit();
            }
        });


        menuTable.add(saveButton).row();
        menuTable.add(bagButton).row();
        menuTable.add(pokemonButton).row();
        menuTable.add(optionsButton).row();
        menuTable.add(exitButton).row();

        menuWindow.add(menuTable).pad(MENU_PADDING);
        menuWindow.pack();
        menuWindow.setPosition(
            (Gdx.graphics.getWidth() - menuWindow.getWidth()) / 2,
            (Gdx.graphics.getHeight() - menuWindow.getHeight()) / 2
        );

        optionsButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                showOptions();
            }
        });

        createOptionsMenu();
        stage.addActor(menuWindow);
    }

    private void performSaveAndExit() {
        if (disposalRequested) return;
        disposalRequested = true;

        Dialog loadingDialog = new Dialog("", skin);
        loadingDialog.text("Saving game...");
        loadingDialog.show(stage);

        new Thread(() -> {
            try {
                // Save game state
                if (GameContext.get().getGameClient() != null) {
                    if (!GameContext.get().getGameClient().isSinglePlayer()) {
                        if (GameContext.get().getPlayer().getWorld() != null) {
                            GameContext.get().getGameClient().saveState(GameContext.get().getPlayer().getPlayerData());
                        }
                    } else {
                        GameContext.get().setInventoryScreen(null);
                        GameContext.get().setCraftingScreen(null);
                        GameContext.get().setBuildModeUI(null);
                        game.saveAndDispose();
                    }
                }

                // Schedule GL disposal on main thread
                Gdx.app.postRunnable(() -> safeDisposeAndTransition(loadingDialog,true));

            } catch (Exception e) {
                GameLogger.error("Save failed: " + e.getMessage());
                Gdx.app.postRunnable(() -> {
                    loadingDialog.hide();
                    showErrorDialog("Failed to save: " + e.getMessage());
                });
            }
        }).start();
    }

    private void showErrorDialog(String message) {
        try {
            Dialog errorDialog = new Dialog("Error", skin);
            errorDialog.text(message);
            errorDialog.button("OK");
            errorDialog.show(stage);
        } catch (Exception e) {
            GameLogger.error("Failed to show error dialog: " + e.getMessage());
        }
    }

    public Stage getStage() {
        if (isDisposing || stage == null) {
            return null;
        }
        return stage;
    }

    public void show() {
        if (isVisible) return;
        isVisible = true;
        menuWindow.setVisible(true);
        stage.setKeyboardFocus(menuWindow);
        inputManager.setUIState(InputManager.UIState.MENU);
    }

    public void hide() {
        if (!isVisible) return;
        isVisible = false;
        menuWindow.setVisible(false);
        stage.unfocus(menuWindow); // Remove focus
        inputManager.setUIState(InputManager.UIState.NORMAL); // Update UI state
    }

    public boolean isVisible() {
        return isVisible;
    }

    private void saveGame() {
        GameLogger.info("Attempting to save game");

        try {
            if (GameContext.get().getGameClient() != null && GameContext.get().getPlayer().getWorld() != null) {
                World currentWorld = GameContext.get().getPlayer().getWorld();

                if (GameContext.get().getPlayer().getUsername() == null) {
                    throw new Exception("Invalid player state");
                }

                PlayerData playerData = new PlayerData(GameContext.get().getPlayer().getUsername());
                playerData.updateFromPlayer(GameContext.get().getPlayer());

                if (GameContext.get().getGameClient().isSinglePlayer()) {
                    WorldData worldData = currentWorld.getWorldData();
                    worldData.savePlayerData(GameContext.get().getPlayer().getUsername(), playerData, false);
                    game.getWorldManager().saveWorld(worldData);
                    GameLogger.info("Game saved successfully");

                } else {
                    GameContext.get().getGameClient().savePlayerState(playerData);
                }

                showSaveSuccessDialog();
            } else {
                throw new Exception("Game state is invalid");
            }
        } catch (Exception e) {
            showSaveErrorDialog(e.getMessage());
        }
    }

    private void showSaveSuccessDialog() {
        Dialog dialog = new Dialog("Success", skin) {
            public void result(Object obj) {
                hide();
            }
        };
        dialog.text("Game saved successfully!");
        dialog.button("OK");
        dialog.show(stage);
    }

    private void showSaveErrorDialog(String errorMessage) {
        GameLogger.info("Save error: " + errorMessage);
        Dialog dialog = new Dialog("Error", skin) {
            public void result(Object obj) {
                hide();
            }
        };
        dialog.text("Failed to save game: " + errorMessage);
        dialog.button("OK");
        dialog.show(stage);
    }

    private void showNotImplementedMessage() {
        Dialog dialog = new Dialog("Notice", skin) {
            public void result(Object obj) {
                hide();
            }
        };
        dialog.text("This feature is not yet implemented.");
        dialog.button("OK");
        dialog.show(stage);
    }

    private void createOptionsMenu() {
        optionsWindow = new Window("Options", skin);
        optionsWindow.setMovable(false);

        Table optionsTable = new Table();
        optionsTable.pad(MENU_PADDING);

        Label musicLabel = new Label("Music Volume", skin);
        musicSlider = new Slider(0f, 1f, 0.1f, false, skin);
        musicSlider.setValue(AudioManager.getInstance().getMusicVolume());

        musicEnabled = new CheckBox(" Music Enabled", skin);
        musicEnabled.setChecked(AudioManager.getInstance().isMusicEnabled());

        Label soundLabel = new Label("Sound Volume", skin);
        soundSlider = new Slider(0f, 1f, 0.1f, false, skin);
        soundSlider.setValue(AudioManager.getInstance().getSoundVolume());

        soundEnabled = new CheckBox(" Sound Enabled", skin);
        soundEnabled.setChecked(AudioManager.getInstance().isSoundEnabled());

        setupAudioListeners();
        setupSaveButton(optionsTable); // Pass optionsTable to add the Save button
        setupCancelButton(optionsTable); // Optionally add a Cancel button

        optionsTable.add(musicLabel).left().padBottom(10).row();
        optionsTable.add(musicSlider).width(200).padBottom(5).row();
        optionsTable.add(musicEnabled).left().padBottom(20).row();
        optionsTable.add(soundLabel).left().padBottom(10).row();
        optionsTable.add(soundSlider).width(200).padBottom(5).row();
        optionsTable.add(soundEnabled).left().padBottom(20).row();

        optionsWindow.add(optionsTable);
        optionsWindow.pack();
        optionsWindow.setPosition(
            (Gdx.graphics.getWidth() - optionsWindow.getWidth()) / 2,
            (Gdx.graphics.getHeight() - optionsWindow.getHeight()) / 2
        );

        optionsWindow.setVisible(false);
        stage.addActor(optionsWindow);
    }

    private void setupAudioListeners() {
        musicSlider.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                AudioManager.getInstance().setMusicVolume(musicSlider.getValue());
            }
        });

        musicEnabled.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                AudioManager.getInstance().setMusicEnabled(musicEnabled.isChecked());
            }
        });

        soundSlider.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                AudioManager.getInstance().setSoundVolume(soundSlider.getValue());
                if (soundEnabled.isChecked()) {
                    AudioManager.getInstance().playSound(AudioManager.SoundEffect.MENU_SELECT);
                }
            }
        });

        soundEnabled.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                AudioManager.getInstance().setSoundEnabled(soundEnabled.isChecked());
            }
        });
    }

    private void setupSaveButton(Table optionsTable) {
        TextButton saveButton = new TextButton("Save", skin);
        saveButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                saveAudioSettings();
                hideOptions();
            }
        });
        optionsTable.add(saveButton).width(BUTTON_WIDTH).height(BUTTON_HEIGHT).padTop(10).row();
    }

    private void setupCancelButton(Table optionsTable) {
        TextButton cancelButton = new TextButton("Cancel", skin);
        cancelButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                hideOptions();
            }
        });
        optionsTable.add(cancelButton).width(BUTTON_WIDTH).height(BUTTON_HEIGHT).padTop(10).row();
    }

    private void saveAudioSettings() {
        Preferences prefs = Gdx.app.getPreferences("audio_settings");
        prefs.putFloat("music_volume", musicSlider.getValue());
        prefs.putFloat("sound_volume", soundSlider.getValue());
        prefs.putBoolean("music_enabled", musicEnabled.isChecked());
        prefs.putBoolean("sound_enabled", soundEnabled.isChecked());
        prefs.flush();

        Dialog dialog = new Dialog("Settings Saved", skin) {
            public void result(Object obj) {
                hide();
            }
        };
        dialog.text("Audio settings have been saved.");
        dialog.button("OK");
        dialog.show(stage);
    }

    private void showOptions() {
        menuWindow.setVisible(false);
        optionsWindow.setVisible(true);
        musicSlider.setValue(AudioManager.getInstance().getMusicVolume());
        soundSlider.setValue(AudioManager.getInstance().getSoundVolume());
        musicEnabled.setChecked(AudioManager.getInstance().isMusicEnabled());
        soundEnabled.setChecked(AudioManager.getInstance().isSoundEnabled());
    }

    private void hideOptions() {
        optionsWindow.setVisible(false);
        menuWindow.setVisible(true);
    }

    public void render() {
        if (!isDisposing && isVisible && stage != null) {
            try {
                stage.act();
                stage.draw();
            } catch (Exception e) {
                GameLogger.error("Error rendering menu: " + e.getMessage());
            }
        }
    }

    public void dispose() {
        if (isDisposing) {
            return;
        }

        isDisposing = true;
        if (stage != null) {
            Gdx.app.postRunnable(() -> {
                try {
                    if (stage != null) {
                        stage.clear();
                        stage.dispose();
                        stage = null;
                    }
                    skin = null;
                    menuWindow = null;
                    optionsWindow = null;
                    menuTable = null;
                    GameLogger.info("GameMenu disposed successfully");
                } catch (Exception e) {
                    GameLogger.error("Error disposing GameMenu: " + e.getMessage());
                }
            });
        }
    }
}

================
File: main/java/io/github/pokemeetup/screens/otherui/HotbarUI.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Image;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.PokemonParty;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;

public class HotbarUI {
    private static final int HOTBAR_SLOTS = 9;
    private final Table mainTable;
    private final Stage stage;
    private final Skin skin;
    private final Player player;
    private final TextureAtlas atlas;

    private Table hotbarTable;
    private boolean buildMode = false;

    public HotbarUI(Stage stage, Skin skin, Player player, TextureAtlas atlas) {
        this.stage = stage;
        this.skin = skin;
        this.player = player;
        this.atlas = atlas;
        this.mainTable = new Table();

        createUI();
    }

    private void createUI() {
        mainTable.setFillParent(true);
        mainTable.bottom();
        mainTable.pad(20);

        hotbarTable = new Table();
        updateHotbarContent();

        mainTable.add(hotbarTable).expandX().bottom();
        stage.addActor(mainTable);
    }

    public void toggleBuildMode() {
        buildMode = !buildMode;
        updateHotbarContent();
    }

    public void updateHotbarContent() {
        hotbarTable.clear();
        hotbarTable.setBackground(new TextureRegionDrawable(
            atlas.findRegion("hotbar_bg")
        ));
        hotbarTable.pad(4);

        if (buildMode) {
            createBuildModeSlots();
        } else {
            createPokemonSlots();
        }
    }

    private void createBuildModeSlots() {
        Inventory buildInventory = player.getBuildInventory();

        for (int i = 0; i < HOTBAR_SLOTS; i++) {
            Table slotCell = new Table();
            slotCell.setBackground(new TextureRegionDrawable(
                atlas.findRegion("slot_normal")
            ));

            ItemData item = buildInventory.getItemAt(i);
            if (item != null) {
                // Add item icon
                Image itemIcon = new Image(ItemManager.getItem(item.getItemId()).getIcon());
                slotCell.add(itemIcon).size(32).center();

                // Add count label if more than 1
                if (item.getCount() > 1) {
                    Label countLabel = new Label(String.valueOf(item.getCount()), skin);
                    countLabel.setPosition(
                        slotCell.getWidth() - 10,
                        10
                    );
                    slotCell.addActor(countLabel);
                }
            }

            hotbarTable.add(slotCell).size(40).pad(2);
        }
    }

    private void createPokemonSlots() {
        PokemonParty party = player.getPokemonParty();

        for (int i = 0; i < HOTBAR_SLOTS; i++) {
            Table slotCell = new Table();
            slotCell.setBackground(new TextureRegionDrawable(
                atlas.findRegion(i == 0 ? "slot_selected" : "slot_normal")
            ));

            if (i < party.getSize()) {
                Pokemon pokemon = party.getPokemon(i);
                if (pokemon != null) {
                    // Add Pokemon icon
                    Image pokemonIcon = new Image(pokemon.getCurrentIconFrame(0));
                    slotCell.add(pokemonIcon).size(32).center();

                    // Add level label
                    Label levelLabel = new Label("Lv." + pokemon.getLevel(), skin);
                    levelLabel.setPosition(
                        slotCell.getWidth() - 10,
                        10
                    );
                    slotCell.addActor(levelLabel);
                }
            }

            hotbarTable.add(slotCell).size(40).pad(2);
        }
    }

    public void update(float delta) {
        // Update selected slot highlighting and animations
        if (buildMode != player.isBuildMode()) {
            toggleBuildMode();
        }
    }
}

================
File: main/java/io/github/pokemeetup/screens/otherui/InventorySlotUI.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.*;
import com.badlogic.gdx.utils.Align;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.screens.InventoryScreenInterface;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.inventory.crafting.CraftingSystem;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventoryLock;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotDataObserver;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.UUID;

public class InventorySlotUI extends Table implements InventorySlotDataObserver {
    public static final int ITEM_SIZE = 32;
    private static final int SLOT_SIZE = 40;
    private static final float DURABILITY_BAR_HEIGHT = 4f;
    private static final float DURABILITY_BAR_PADDING = 2f;
    private final InventorySlotData slotData;
    private final Skin skin;
    private final InventoryScreenInterface screenInterface;
    private Image itemImage;
    private Label countLabel;
    private Label itemNameLabel;
    private Label durabilityLabel;
    private Image durabilityBar;
    public InventorySlotUI(InventorySlotData slotData, Skin skin, InventoryScreenInterface screenInterface) {
        this.slotData = slotData;
        this.skin = skin;
        this.screenInterface = screenInterface;

        setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_normal")));
        setSize(SLOT_SIZE, SLOT_SIZE);
        setTouchable(Touchable.enabled);

        // Order of calls adjusted:
        setupContents();
        setupTooltip();           // Setup tooltip labels before updateSlot()
        slotData.addObserver(this);
        updateSlot();             // Now we can safely call updateSlot()
        setupInput();
    }

    public void forceUpdate() {
        updateSlot();
    }

    private void setupTooltip() {
        Table tooltipTable = new Table();
        tooltipTable.setBackground(skin.newDrawable("white", new Color(0, 0, 0, 0.7f)));
        tooltipTable.pad(5);

        Label.LabelStyle tooltipStyle = new Label.LabelStyle(skin.getFont("default-font"), Color.WHITE);

        // Initialize labels here
        itemNameLabel = new Label("", tooltipStyle);
        durabilityLabel = new Label("", tooltipStyle);

        tooltipTable.add(itemNameLabel).left().row();
        tooltipTable.add(durabilityLabel).left();

        Tooltip<Table> tooltip = new Tooltip<>(tooltipTable);
        TooltipManager tooltipManager = TooltipManager.getInstance();
        tooltipManager.initialTime = 0f;
        tooltipManager.subsequentTime = 0f;
        addListener(tooltip);
    }

    public void updateSlot() {
        ItemData itemData = getSlotItemData();
        if (slotData.getSlotType() == InventorySlotData.SlotType.CRAFTING_RESULT) {
            CraftingSystem cs = screenInterface.getCraftingSystem();
            itemData = cs != null ? cs.getCraftingResult() : null;
        }

        if (itemData != null && itemData.getCount() > 0) {
            TextureRegion itemTexture = getItemTexture(itemData.getItemId());
            if (itemTexture != null) {
                itemImage.setDrawable(new TextureRegionDrawable(itemTexture));
                itemImage.setVisible(true);

                countLabel.setVisible(itemData.getCount() > 1);
                if (itemData.getCount() > 1) {
                    countLabel.setText(String.valueOf(itemData.getCount()));
                }

                if (itemData.getMaxDurability() > 0) {
                    float percentage = itemData.getDurabilityPercentage();
                    percentage = Math.max(0f, Math.min(1f, percentage));
                    durabilityBar.setColor(getDurabilityColor(percentage));
                    float barWidth = (SLOT_SIZE - DURABILITY_BAR_PADDING * 2) * percentage;
                    durabilityBar.setSize(barWidth, DURABILITY_BAR_HEIGHT);
                    durabilityBar.setPosition(DURABILITY_BAR_PADDING, DURABILITY_BAR_PADDING);
                    durabilityBar.setVisible(true);
                } else {
                    durabilityBar.setVisible(false);
                }
            } else {
                // Texture missing fallback
                itemImage.setVisible(false);
                countLabel.setVisible(false);
                durabilityBar.setVisible(false);
            }
        } else {
            itemImage.setVisible(false);
            countLabel.setVisible(false);
            durabilityBar.setVisible(false);
        }

        updateTooltip();
    }

    private void setupContents() {
        itemImage = new Image();
        itemImage.setSize(ITEM_SIZE, ITEM_SIZE);
        itemImage.setVisible(false);

        countLabel = new Label("", skin);
        countLabel.setAlignment(Align.bottomRight);
        countLabel.setVisible(false);

        durabilityBar = new Image(skin.newDrawable("white"));
        durabilityBar.setVisible(false);
        durabilityBar.setSize(0, DURABILITY_BAR_HEIGHT);

        Container<Image> durabilityContainer = new Container<>(durabilityBar);
        durabilityContainer.align(Align.bottomLeft);
        durabilityContainer.pad(DURABILITY_BAR_PADDING);
        durabilityContainer.setTouchable(Touchable.disabled);
        durabilityContainer.setFillParent(false);

        Stack stack = new Stack();
        stack.setSize(SLOT_SIZE, SLOT_SIZE);
        stack.add(itemImage);
        stack.add(durabilityContainer);
        stack.add(countLabel);

        add(stack).expand().fill().size(SLOT_SIZE, SLOT_SIZE);
    }

    @Override
    public void onSlotDataChanged() {
        updateSlot();
    }

    private void updateTooltip() {
        ItemData itemData = getSlotItemData();
        if (itemData != null) {
            itemNameLabel.setText(itemData.getItemId());
            if (itemData.getMaxDurability() > 0) {
                durabilityLabel.setText("Durability: " +
                    itemData.getDurability() + "/" +
                    itemData.getMaxDurability());
                durabilityLabel.setVisible(true);
            } else {
                durabilityLabel.setVisible(false);
            }
        } else {
            itemNameLabel.setText("");
            durabilityLabel.setVisible(false);
        }
    }

    private TextureRegion getItemTexture(String itemId) {
        TextureRegion texture = TextureManager.items.findRegion(itemId.toLowerCase() + "_item");
        if (texture == null) {
            texture = TextureManager.items.findRegion(itemId.toLowerCase());
        }
        return texture;
    }

    private void setupInput() {
        addListener(new InputListener() {
            private boolean isHovered = false;
            private Vector2 touchDownPos = new Vector2();
            private long touchDownTime;

            @Override
            public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {
                touchDownPos.set(x, y);
                touchDownTime = System.currentTimeMillis();
                setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_selected")));
                return true;
            }

            @Override
            public void touchUp(InputEvent event, float x, float y, int pointer, int button) {
                float moveDistance = touchDownPos.dst(x, y);
                long clickDuration = System.currentTimeMillis() - touchDownTime;

                // Simple click check
                if (moveDistance < 5 && clickDuration < 200) {
                    boolean shiftHeld = isShiftDown();
                    if (button == Input.Buttons.LEFT) {
                        handleLeftClick(shiftHeld);
                    } else if (button == Input.Buttons.RIGHT) {
                        handleRightClick();
                    }
                }
                updateSlotBackground();
            }

            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                isHovered = true;
                updateSlotBackground();
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                isHovered = false;
                updateSlotBackground();
            }

            private void updateSlotBackground() {
                if (isHovered) {
                    setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_selected")));
                } else {
                    setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_normal")));
                }
            }
        });
    }

    private boolean isShiftDown() {
        return Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT);
    }

    private void handleLeftClick(boolean shiftHeld) {
        InventoryLock.writeLock();
        try {
            Item heldItem = screenInterface.getHeldItemObject();
            ItemData currentSlotItem = getSlotItemData();
            InventorySlotData.SlotType slotType = slotData.getSlotType();

            if (slotType == InventorySlotData.SlotType.CRAFTING_RESULT) {
                handleCraftingResultClick(shiftHeld);
                return;
            }

            if (shiftHeld && currentSlotItem != null) {
                handleShiftClickMove(currentSlotItem);
                return;
            }

            if (currentSlotItem == null && heldItem != null) {
                // Place entire held stack into empty slot
                placeStackIntoEmptySlot(heldItem, slotType, heldItem.getCount());
            } else if (currentSlotItem != null && heldItem == null) {
                pickUpEntireStack(currentSlotItem, slotType);
            } else if (currentSlotItem != null && heldItem != null) {
                if (canStackTogether(currentSlotItem, heldItem)) {
                    mergeStacks(currentSlotItem, heldItem, slotType);
                } else {
                    swapItems(currentSlotItem, heldItem, slotType);
                }
            }
        } catch (Exception e) {
            GameLogger.error("Error in handleLeftClick: " + e.getMessage());
            e.printStackTrace();
        } finally {
            InventoryLock.writeUnlock();
            updateSlot();
            screenInterface.updateHeldItemDisplay(); // Ensure UI updates after logic
        }
    }

    private void handleRightClick() {
        InventoryLock.writeLock();
        try {
            Item heldItem = screenInterface.getHeldItemObject();
            ItemData currentSlotItem = getSlotItemData();
            InventorySlotData.SlotType slotType = slotData.getSlotType();

            if (slotType == InventorySlotData.SlotType.CRAFTING_RESULT) {
                pickUpOneCraftedItem();
            } else if (currentSlotItem == null && heldItem != null) {
                // Place one item from held stack into empty slot
                placeStackIntoEmptySlot(heldItem, slotType, 1);
            } else if (currentSlotItem != null && heldItem == null) {
                // Pick up half the stack
                pickUpHalfStack(currentSlotItem, slotType);
            } else if (currentSlotItem != null && heldItem != null && canStackTogether(currentSlotItem, heldItem)) {
                addOneItemToSlot(currentSlotItem, heldItem, slotType);
            }
        } catch (Exception e) {
            GameLogger.error("Error in handleRightClick: " + e.getMessage());
            e.printStackTrace();
        } finally {
            InventoryLock.writeUnlock();
            updateSlot();
            screenInterface.updateHeldItemDisplay();
        }
    }

    private void pickUpOneCraftedItem() {
        CraftingSystem cs = screenInterface.getCraftingSystem();
        if (cs == null) return;
        ItemData result = cs.getCraftingResult();
        if (result == null) return;
        Item heldItem = screenInterface.getHeldItemObject();
        if (heldItem != null) return; // Hand not empty

        if (cs.craftOneItem()) {
            Item crafted = new Item(result.getItemId());
            crafted.setCount(1);
            crafted.setUuid(UUID.randomUUID());
            crafted.setDurability(result.getDurability());
            crafted.setMaxDurability(result.getMaxDurability());
            screenInterface.setHeldItem(crafted);
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.CRAFT);
        }
    }

    private void handleShiftClickMove(ItemData currentSlotItem) {
        InventorySlotData.SlotType slotType = slotData.getSlotType();
        if (currentSlotItem == null) return;

        if (slotType == InventorySlotData.SlotType.CHEST) {
            // Move from chest to player inventory
            int remainder = fullyTryAddItem(screenInterface.getInventory(), currentSlotItem);
            if (remainder <= 0) {
                // Everything moved to inventory
                slotData.setItemData(null);
            } else {
                // Some items couldn't fit
                currentSlotItem.setCount(remainder);
                slotData.setItemData(currentSlotItem);
            }
        } else if (slotType == InventorySlotData.SlotType.INVENTORY) {
            // Move from inventory to chest
            ItemContainer chest = screenInterface.getChestData();
            if (chest == null) return;

            int remainder = fullyTryAddItem(chest, currentSlotItem);
            if (remainder <= 0) {
                // Everything moved to chest
                slotData.setItemData(null);
            } else {
                // Some items remain
                currentSlotItem.setCount(remainder);
                slotData.setItemData(currentSlotItem);
            }
        } else if (slotType == InventorySlotData.SlotType.CRAFTING_RESULT) {
            // Mass craft all possible items into inventory
            handleMassCraftToInventory();
        }

        // Update UI after shift-click
        updateSlot();
        screenInterface.updateHeldItemDisplay();
    }


    private void handleMassCraftToInventory() {
        CraftingSystem cs = screenInterface.getCraftingSystem();
        if (cs == null) return;
        ItemData result = cs.getCraftingResult();
        if (result == null) return;

        while (cs.craftOneItem()) {
            ItemData single = result.copy();
            single.setCount(1);
            single.setUuid(UUID.randomUUID());
            int remainder = fullyTryAddItem(screenInterface.getInventory(), single);
            if (remainder > 0) {
                // Can't fit this crafted item entirely, so break
                // Return it to the crafting table or discard depending on logic
                break;
            }
        }
    }


    private void moveAllToInventory(ItemData itemData) {
        if (itemData == null) return;
        int remaining = addItemToContainer(screenInterface.getInventory(), itemData);
        if (remaining <= 0) {
            slotData.setItemData(null);
        } else {
            itemData.setCount(remaining);
            slotData.setItemData(itemData);
        }
    }

    private void moveAllToChest(ItemData itemData) {
        ItemContainer chest = screenInterface.getChestData();
        if (chest == null || itemData == null) return;
        int remaining = addItemToContainer(chest, itemData);
        if (remaining <= 0) {
            slotData.setItemData(null);
        } else {
            itemData.setCount(remaining);
            slotData.setItemData(itemData);
        }
    }

    private int addItemToContainer(ItemContainer container, ItemData itemData) {
        if (container instanceof Inventory) {
            Inventory inv = (Inventory) container;
            int originalCount = itemData.getCount();
            ItemData copy = itemData.copy();
            if (inv.addItem(copy)) {
                return 0;
            } else {
                return originalCount;
            }
        }
        return itemData.getCount();
    }

    private boolean canStackTogether(ItemData slotItem, Item heldItem) {
        if (!slotItem.getItemId().equals(heldItem.getName())) return false;
        Item template = ItemManager.getItemTemplate(heldItem.getName());
        return template != null && template.isStackable();
    }

    private void placeStackIntoEmptySlot(Item heldItem, InventorySlotData.SlotType slotType, int amount) {
        if (heldItem == null || heldItem.getCount() < amount) {
            return;
        }

        ItemData currentItem = slotData.getItemData();
        if (currentItem != null && currentItem.getCount() > 0) {
            return;
        }

        ItemData newItem = new ItemData(heldItem.getName(), amount, UUID.randomUUID());
        newItem.setDurability(heldItem.getDurability());
        newItem.setMaxDurability(heldItem.getMaxDurability());

        slotData.setItemData(newItem);

        int newCount = heldItem.getCount() - amount;
        if (newCount <= 0) {
            screenInterface.setHeldItem(null);
        } else {
            heldItem.setCount(newCount);
            screenInterface.setHeldItem(heldItem);
        }

        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }

    private void pickUpEntireStack(ItemData currentSlotItem, InventorySlotData.SlotType slotType) {
        if (currentSlotItem == null) return;
        slotData.setItemData(null);

        Item newHeld = new Item(currentSlotItem.getItemId());
        newHeld.setCount(currentSlotItem.getCount());
        newHeld.setDurability(currentSlotItem.getDurability());
        newHeld.setMaxDurability(currentSlotItem.getMaxDurability());
        newHeld.setUuid(UUID.randomUUID());

        screenInterface.setHeldItem(newHeld);
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }private int tryMergeItemData(ItemContainer container, ItemData itemToMove) {
        int remainder = itemToMove.getCount();

        for (int i = 0; i < container.getSize(); i++) {
            InventorySlotData slotData = container.getSlotData(i);
            ItemData slotItem = slotData.getItemData();
            if (slotItem != null
                && slotItem.getItemId().equals(itemToMove.getItemId())
                && slotItem.getCount() < Item.MAX_STACK_SIZE) {

                int space = Item.MAX_STACK_SIZE - slotItem.getCount();
                int toMove = Math.min(remainder, space);
                slotItem.setCount(slotItem.getCount() + toMove);
                slotData.setItemData(slotItem);
                remainder -= toMove;
                if (remainder <= 0) break;
            }
        }

        return remainder;
    }

    private int tryPlaceInEmptySlot(ItemContainer container, ItemData itemToMove) {
        int remainder = itemToMove.getCount();

        for (int i = 0; i < container.getSize(); i++) {
            InventorySlotData slotData = container.getSlotData(i);
            if (slotData.getItemData() == null) {
                // Place as many as we can into this empty slot
                int toPlace = Math.min(remainder, Item.MAX_STACK_SIZE);
                ItemData newData = itemToMove.copy();
                newData.setCount(toPlace);
                slotData.setItemData(newData);
                remainder -= toPlace;
                if (remainder <= 0) break;
            }
        }

        return remainder;
    }

    private int fullyTryAddItem(ItemContainer container, ItemData itemData) {
        // First try merging into existing stacks
        int remainder = tryMergeItemData(container, itemData);

        // If still have remainder, try placing into empty slots
        if (remainder > 0) {
            ItemData remainderData = itemData.copy();
            remainderData.setCount(remainder);
            remainder = tryPlaceInEmptySlot(container, remainderData);
        }
        return remainder;
    }


    private void mergeStacks(ItemData currentSlotItem, Item heldItem, InventorySlotData.SlotType slotType) {
        int maxStack = Item.MAX_STACK_SIZE;
        int total = currentSlotItem.getCount() + heldItem.getCount();
        int newSlotCount = Math.min(total, maxStack);
        int remainder = total - newSlotCount;

        ItemData updated = currentSlotItem.copy();
        updated.setCount(newSlotCount);
        slotData.setItemData(updated);

        if (remainder <= 0) {
            screenInterface.setHeldItem(null);
        } else {
            heldItem.setCount(remainder);
            screenInterface.setHeldItem(heldItem);
        }

        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }

    private void swapItems(ItemData currentSlotItem, Item heldItem, InventorySlotData.SlotType slotType) {
        ItemData slotNew = new ItemData(heldItem.getName(), heldItem.getCount(), UUID.randomUUID());
        slotNew.setDurability(heldItem.getDurability());
        slotNew.setMaxDurability(heldItem.getMaxDurability());
        slotData.setItemData(slotNew);

        Item newHeld = new Item(currentSlotItem.getItemId());
        newHeld.setCount(currentSlotItem.getCount());
        newHeld.setUuid(UUID.randomUUID());
        newHeld.setDurability(currentSlotItem.getDurability());
        newHeld.setMaxDurability(currentSlotItem.getMaxDurability());
        screenInterface.setHeldItem(newHeld);

        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }

    private void pickUpHalfStack(ItemData currentSlotItem, InventorySlotData.SlotType slotType) {
        if (currentSlotItem == null) return;
        int half = (currentSlotItem.getCount() + 1) / 2;
        int remain = currentSlotItem.getCount() - half;

        ItemData updated = currentSlotItem.copy();
        updated.setCount(remain <= 0 ? 0 : remain);
        slotData.setItemData(remain <= 0 ? null : updated);

        Item newHeld = new Item(currentSlotItem.getItemId());
        newHeld.setCount(half);
        newHeld.setDurability(currentSlotItem.getDurability());
        newHeld.setMaxDurability(currentSlotItem.getMaxDurability());
        newHeld.setUuid(UUID.randomUUID());
        screenInterface.setHeldItem(newHeld);

        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }

    private void addOneItemToSlot(ItemData currentSlotItem, Item heldItem, InventorySlotData.SlotType slotType) {
        if (currentSlotItem.getCount() >= Item.MAX_STACK_SIZE) return;

        ItemData updated = currentSlotItem.copy();
        updated.setCount(currentSlotItem.getCount() + 1);
        slotData.setItemData(updated);

        int newHeldCount = heldItem.getCount() - 1;
        if (newHeldCount <= 0) {
            screenInterface.setHeldItem(null);
        } else {
            heldItem.setCount(newHeldCount);
            screenInterface.setHeldItem(heldItem);
        }

        AudioManager.getInstance().playSound(AudioManager.SoundEffect.ITEM_PICKUP);
    }

    private void handleCraftingResultClick(boolean shiftHeld) {
        CraftingSystem cs = screenInterface.getCraftingSystem();
        if (cs == null) return;

        if (shiftHeld) {
            handleMassCraftToInventory();
        } else {
            pickUpOneCraftedItem();
        }
    }

    private ItemData getSlotItemData() {
        InventorySlotData.SlotType type = slotData.getSlotType();
        if (type == InventorySlotData.SlotType.CRAFTING ||
            type == InventorySlotData.SlotType.EXPANDED_CRAFTING) {
            CraftingSystem cs = screenInterface.getCraftingSystem();
            return cs != null ? cs.getItemInGrid(slotData.getSlotIndex()) : null;
        } else if (type == InventorySlotData.SlotType.CRAFTING_RESULT) {
            return null;
        } else {
            return slotData.getItemData();
        }
    }

    private Color getDurabilityColor(float percentage) {
        if (percentage > 0.6f) {
            return new Color(0.2f, 0.8f, 0.2f, 1f);
        } else if (percentage > 0.3f) {
            return new Color(0.8f, 0.8f, 0.2f, 1f);
        } else {
            return new Color(0.8f, 0.2f, 0.2f, 1f);
        }
    }

    @Override
    public void draw(Batch batch, float parentAlpha) {
        super.draw(batch, parentAlpha);
    }
}

================
File: main/java/io/github/pokemeetup/screens/otherui/PokemonPartyUI.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.PokemonParty;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.ArrayList;
import java.util.List;

public class PokemonPartyUI extends Table {
    private static final float PARTY_WIDTH = 300f;
    private static final float PARTY_HEIGHT = 400f;
    private static final float SLOT_SIZE = 80f;
    private static final float PADDING = 10f;

    private final PokemonParty party;
    private final Skin skin;
    private final List<PokemonSlot> slots;
    private int selectedIndex;

    public PokemonPartyUI(PokemonParty party, Skin skin) {
        this.party = party;
        this.skin = skin;
        this.slots = new ArrayList<>();
        this.selectedIndex = 0;

        setBackground(createBackground());
        pad(PADDING);
        setupUI();

        // Center the party UI
        setPosition(
            (Gdx.graphics.getWidth() - PARTY_WIDTH) / 2,
            (Gdx.graphics.getHeight() - PARTY_HEIGHT) / 2
        );
        setSize(PARTY_WIDTH, PARTY_HEIGHT);
    }

    private void setupUI() {
        for (int i = 0; i < PokemonParty.MAX_PARTY_SIZE; i++) {
            PokemonSlot slot = new PokemonSlot(i, skin);
            slots.add(slot);
            add(slot).size(SLOT_SIZE).pad(PADDING);
            row();
        }
        updateUI();
    }

    public void updateUI() {
        for (int i = 0; i < slots.size(); i++) {
            Pokemon pokemon = party.getPokemon(i);
            PokemonSlot slot = slots.get(i);
            slot.update(pokemon);
            slot.setSelected(i == selectedIndex);
        }
    }

    public void selectPokemon(int index) {
        if (index >= 0 && index < party.getSize()) {
            selectedIndex = index;
            updateUI();
        }
    }

    public int getSelectedIndex() {
        return selectedIndex;
    }

    public Pokemon getSelectedPokemon() {
        return party.getPokemon(selectedIndex);
    }

    private Drawable createBackground() {
        return new TextureRegionDrawable(TextureManager.ui
            .findRegion("hotbar_bg"))
            .tint(new Color(0.2f, 0.2f, 0.2f, 0.9f));
    }

    private class PokemonSlot extends Table {
        private final int index;
        private final Image pokemonIcon;
        private final Label nameLabel;
        private final Label levelLabel;
        private final ProgressBar hpBar;

        public PokemonSlot(int index, Skin skin) {
            this.index = index;
            setBackground(createSlotBackground());
            pad(5);

            pokemonIcon = new Image();
            nameLabel = new Label("", skin);
            levelLabel = new Label("", skin);
            hpBar = new ProgressBar(0, 100, 1, false, skin);

            add(pokemonIcon).size(50).padRight(10);
            Table infoTable = new Table();
            infoTable.add(nameLabel).left().row();
            infoTable.add(levelLabel).left().row();
            infoTable.add(hpBar).width(100).padTop(5);
            add(infoTable).expandX().left();
        }

        public void update(Pokemon pokemon) {
            if (pokemon != null) {
                pokemonIcon.setDrawable(new TextureRegionDrawable(pokemon.getIconSprite()));
                nameLabel.setText(pokemon.getName());
                levelLabel.setText("Lv. " + pokemon.getLevel());
                hpBar.setValue(((float) pokemon.getCurrentHp() / pokemon.getStats().getHp()) * 100);
                setVisible(true);
            } else {
                setVisible(index < party.getSize());
            }
        }

        public void setSelected(boolean selected) {
            setBackground(createSlotBackground(selected));
        }

        private Drawable createSlotBackground(boolean selected) {
            return new TextureRegionDrawable(TextureManager.ui
                .findRegion(selected ? "slot_selected" : "slot_normal"))
                .tint(new Color(0.3f, 0.3f, 0.3f, 0.9f));
        }

        private Drawable createSlotBackground() {
            return createSlotBackground(false);
        }
    }
}

================
File: main/java/io/github/pokemeetup/screens/otherui/ServerListEntry.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.ui.Image;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.TimeUtils;
import com.esotericsoftware.kryonet.Client;
import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.Listener;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.Base64;

public class ServerListEntry extends Table {
    private final Texture defaultIcon;
    private Image serverIcon;
    private Label nameLabel;
    private Label motdLabel;
    private Label playerCountLabel;
    private Label pingLabel;
    private ServerConnectionConfig config;
    private NetworkProtocol.ServerInfo serverInfo;
    private final Skin skin;
    private float lastUpdateTime = 0;
    private static final float UPDATE_INTERVAL = 5f; // Update every 5 seconds

    public ServerListEntry(ServerConnectionConfig config, Skin skin) {
        super(skin);
        this.skin = skin;
        this.config = config;
        this.defaultIcon = new Texture(Gdx.files.internal("ui/default-server-icon.png"));

        setup();
        updateServerInfo();
    }

    private void setup() {
        setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_background"))); // Use your skin's button background
        pad(10);

        // Server icon (64x64 recommended size)
        serverIcon = new Image(defaultIcon);
        serverIcon.setSize(64, 64);

        // Labels with custom styles
        nameLabel = new Label(config.getServerName(), skin);
        motdLabel = new Label("Connecting...", skin);
        motdLabel.setWrap(true);
        playerCountLabel = new Label("???/???", skin);
        pingLabel = new Label("???ms", skin);

        // Layout
        Table leftSide = new Table();
        leftSide.add(serverIcon).size(64).pad(5);

        Table serverInfo = new Table();
        serverInfo.add(nameLabel).left().expandX().row();
        serverInfo.add(motdLabel).left().expandX().width(300).row();

        Table rightSide = new Table();
        rightSide.add(playerCountLabel).right().padRight(10);
        rightSide.add(pingLabel).right();

        add(leftSide).padRight(10);
        add(serverInfo).expandX().fill();
        add(rightSide).right();

        // Hover effect
        addListener(new InputListener() {
            @Override
            public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {
                setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_background")));
            }

            @Override
            public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {
                setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_background")));
            }
        });
    }


    public void updateServerInfo() {
        float currentTime = TimeUtils.millis() / 1000f;
        if (currentTime - lastUpdateTime < UPDATE_INTERVAL) {
            return;
        }
        lastUpdateTime = currentTime;

        Thread infoThread = new Thread(() -> {
            Client tempClient = null;
            try {
                tempClient = new Client(16384, 2048);
                NetworkProtocol.registerClasses(tempClient.getKryo());
                tempClient.start();

                final long startTime = System.currentTimeMillis();
                final Client finalClient = tempClient;

                tempClient.addListener(new Listener() {
                    @Override
                    public void received(Connection connection, Object object) {
                        if (object instanceof NetworkProtocol.ServerInfoResponse) {
                            NetworkProtocol.ServerInfoResponse response =
                                (NetworkProtocol.ServerInfoResponse) object;
                            long ping = System.currentTimeMillis() - startTime;

                            Gdx.app.postRunnable(() -> {
                                updateUI(response.serverInfo, ping);
                            });

                            closeClientSafely(finalClient);
                        }
                    }
                });

                tempClient.connect(5000, config.getServerIP(),
                    config.getTcpPort(), config.getUdpPort());

                NetworkProtocol.ServerInfoRequest request = new NetworkProtocol.ServerInfoRequest();
                request.timestamp = System.currentTimeMillis();
                tempClient.sendTCP(request);

            } catch (Exception e) {
                final Client finalClient = tempClient;
                Gdx.app.postRunnable(() -> {
                    updateUIError();
                    closeClientSafely(finalClient);
                });
            }
        });
        infoThread.start();
    }private void closeClientSafely(Client client) {
        if (client != null) {
            try {
                client.close();
            } catch (Exception e) {
                GameLogger.error("Error closing temporary client: " + e.getMessage());
            }
        }
    }
    private void updateUI(NetworkProtocol.ServerInfo info, long ping) {
        this.serverInfo = info;

        nameLabel.setText(info.name);
        motdLabel.setText(info.motd);
        playerCountLabel.setText(info.playerCount + "/" + info.maxPlayers);
        pingLabel.setText(ping + "ms");

        // Update server icon if provided
        if (info.iconBase64 != null && !info.iconBase64.isEmpty()) {
            try {
                byte[] iconData = Base64.getDecoder().decode(info.iconBase64);
                Pixmap pixmap = new Pixmap(iconData, 0, iconData.length);
                Texture iconTexture = new Texture(pixmap);
                serverIcon.setDrawable(new TextureRegionDrawable(new TextureRegion(iconTexture)));
                pixmap.dispose();
            } catch (Exception e) {
                GameLogger.error("Error loading server icon: " + e.getMessage());
            }
        }
    }

    private void updateUIError() {
        nameLabel.setText(config.getServerName() + " (Offline)");
        motdLabel.setText("Cannot connect to server");
        playerCountLabel.setText("0/0");
        pingLabel.setText("---");
    }

    public void dispose() {
        defaultIcon.dispose();
        // Dispose of any custom icon textures
        if (serverIcon.getDrawable() instanceof TextureRegionDrawable) {
            TextureRegionDrawable drawable = (TextureRegionDrawable) serverIcon.getDrawable();
            drawable.getRegion().getTexture().dispose();
        }
    }
}

================
File: main/java/io/github/pokemeetup/screens/otherui/StarterSelectionTable.java
================
package io.github.pokemeetup.screens.otherui;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Touchable;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Scaling;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.data.PokemonDatabase;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.ResponsiveLayout;
import io.github.pokemeetup.utils.textures.TextureManager;

public class StarterSelectionTable extends Table {
    private static final float BASE_TITLE_SCALE = 2.0f;
    private final Label pokemonInfoLabel;
    private final TextButton confirmButton;
    private Pokemon selectedStarter;
    private Table selectedCell = null;
    private SelectionListener selectionListener;
    private boolean selectionMade = false;


    private final Skin skin;
    private final Label titleLabel;
    public StarterSelectionTable(Skin skin) {
        this.skin = skin;
        GameLogger.info("Creating StarterSelectionTable");
        Gdx.graphics.setWindowedMode(
            Math.max(800, Gdx.graphics.getWidth()),
            Math.max(600, Gdx.graphics.getHeight())
        );
        // Setup main table properties
        setFillParent(true);
        setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("starter-bg")));
        setTouchable(Touchable.enabled);
        Table mainContainer = new Table();
        mainContainer.center();
        mainContainer.defaults().center().pad(20);

        // Add top spacing for vertical centering
        mainContainer.add().expandY().row();

        // Title
        titleLabel = new Label("Choose Your First Partner!", skin);
        titleLabel.setFontScale(BASE_TITLE_SCALE);
        titleLabel.setAlignment(Align.center);
        mainContainer.add(titleLabel).expandX().center().padBottom(40).row();

        // Pokemon selection area
        starters = new Table();
        starters.defaults().pad(BASE_PADDING).space(40);
        starters.center();

        // Add starter options
        addStarterOption(starters, "BULBASAUR", "A reliable grass-type partner with a mysterious bulb.");
        addStarterOption(starters, "CHARMANDER", "A fierce fire-type partner with a burning tail.");
        addStarterOption(starters, "SQUIRTLE", "A sturdy water-type partner with a protective shell.");

        mainContainer.add(starters).expandX().center().padBottom(40).row();

        // Info label
        pokemonInfoLabel = new Label("Click on a Pokemon to learn more!", skin);
        pokemonInfoLabel.setWrap(true);
        pokemonInfoLabel.setAlignment(Align.center);
        pokemonInfoLabel.setFontScale(1.3f);

        Table infoContainer = new Table();
        infoContainer.add(pokemonInfoLabel).width(Gdx.graphics.getWidth() * 0.6f).pad(30);
        mainContainer.add(infoContainer).expandX().center().padBottom(30).row();

        // Confirm button
        confirmButton = new TextButton("Choose Pokemon!", skin);
        confirmButton.setDisabled(true);
        confirmButton.getLabel().setFontScale(1.5f);
        confirmButton.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                if (!confirmButton.isDisabled() && selectedStarter != null) {
                    confirmSelection();
                }
            }
        });

        mainContainer.add(confirmButton).size(BASE_BUTTON_WIDTH, BASE_BUTTON_HEIGHT).padBottom(40).row();

        // Add bottom spacing for vertical centering
        mainContainer.add().expandY().row();

        // Add main container to this table
        add(mainContainer).expand().fill();

        GameLogger.info("StarterSelectionTable setup complete");
    }


private void addStarterOption(Table container, String pokemonName, String description) {
        Table cell = new Table();
        cell.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_normal")));
        cell.center(); // Center contents of the cell

        // Pokemon sprite
        TextureRegion sprite = TextureManager.getPokemonfront().findRegion(pokemonName + "_front");
        if (sprite != null) {
            Image image = new Image(sprite);
            image.setScaling(Scaling.fit);
            Vector2 imageSize = ResponsiveLayout.getElementSize(120, 120);
            cell.add(image).size(imageSize.x, imageSize.y)
                .center() // Center the image
                .pad(ResponsiveLayout.getPadding())
                .row();
        }

        // Pokemon name
        Label nameLabel = new Label(pokemonName, skin);
        nameLabel.setFontScale(ResponsiveLayout.getFontScale());
        cell.add(nameLabel).center().pad(ResponsiveLayout.getPadding());

        // Click listener
        cell.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                selectStarter(pokemonName, description, cell);
            }
        });

        // Add cell to container with proper sizing
        Vector2 cellSize = ResponsiveLayout.getElementSize(180, 200);
        container.add(cell).size(cellSize.x, cellSize.y).center();
    }

    private void setupStarterPokemon(Pokemon starter) {
        switch (starter.getName()) {
            case "BULBASAUR":
                starter.setPrimaryType(Pokemon.PokemonType.GRASS);
                starter.getMoves().add(PokemonDatabase.getMoveByName("Tackle"));
                starter.getMoves().add(PokemonDatabase.getMoveByName("Growl"));
                starter.setSecondaryType(Pokemon.PokemonType.POISON);
                starter.setLevel(5);
                starter.setCurrentHp(starter.getStats().getHp());
                break;

            case "CHARMANDER":
                starter.setPrimaryType(Pokemon.PokemonType.FIRE);
                starter.getMoves().add(PokemonDatabase.getMoveByName("Tackle"));
                starter.getMoves().add(PokemonDatabase.getMoveByName("Growl"));
                starter.setLevel(5);
                starter.setCurrentHp(starter.getStats().getHp());
                break;

            case "SQUIRTLE":
                starter.setPrimaryType(Pokemon.PokemonType.WATER);
                starter.getMoves().add(PokemonDatabase.getMoveByName("Tackle"));
                starter.getMoves().add(PokemonDatabase.getMoveByName("Withdraw"));
                starter.setCurrentHp(starter.getStats().getHp());
                starter.setLevel(5);
                break;
        }

        // Set base stats for all starters
        Pokemon.Stats stats = starter.getStats();
        stats.setHp(20);
        stats.setAttack(12);
        stats.setDefense(12);
        stats.setSpecialAttack(12);
        stats.setSpecialDefense(12);
        stats.setSpeed(12);
        starter.setCurrentHp(stats.getHp());
    }
    private void selectStarter(String pokemonName, String description, Table pokemonCell) {
        if (selectionMade) return;

        GameLogger.info("Selecting starter: " + pokemonName);
        selectedStarter = new Pokemon(pokemonName, 5);
        setupStarterPokemon(selectedStarter);

        if (selectedCell != null) {
            selectedCell.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_normal")));
            selectedCell.setColor(1, 1, 1, 1);
        }

        pokemonCell.setBackground(new TextureRegionDrawable(TextureManager.ui.findRegion("slot_selected")));
        selectedCell = pokemonCell;

        confirmButton.setDisabled(false);
        pokemonInfoLabel.setText(description);

        if (selectionListener != null) {
            selectionListener.onSelectionStart();
        }
    }

    private void confirmSelection() {
        if (selectedStarter != null && selectionListener != null && !selectionMade) {
            GameLogger.info("Confirming starter selection: " + selectedStarter.getName());
            selectionMade = true;
            selectionListener.onStarterSelected(selectedStarter);
        }
    }
    private final Table starters;  // Table containing Pokemon options

    private static final float BASE_POKEMON_SIZE = 160f;
    private static final float BASE_PADDING = 20f;
    private static final float BASE_BUTTON_WIDTH = 300f;
    private static final float BASE_BUTTON_HEIGHT = 80f;

    public void setSelectionListener(SelectionListener listener) {
        this.selectionListener = listener;
    }

    public void resize(int width, int height) {
        GameLogger.info("Resizing StarterSelectionTable to: " + width + "x" + height);

        // Calculate scale based on screen size
        float scaleFactor = Math.min(width / 1920f, height / 1080f);
        scaleFactor = Math.max(scaleFactor, 0.3f);
        float buttonWidth = BASE_BUTTON_WIDTH * scaleFactor;
        float buttonHeight = BASE_BUTTON_HEIGHT * scaleFactor;
        float padding = BASE_PADDING * scaleFactor;

        // Update font scales
        titleLabel.setFontScale(BASE_TITLE_SCALE * scaleFactor);
        pokemonInfoLabel.setFontScale(1.3f * scaleFactor);
        confirmButton.getLabel().setFontScale(1.5f * scaleFactor);

        // Update Pokemon container
        starters.clear();
        starters.defaults().pad(padding).space(padding * 2);

        // Recreate Pokemon options with new sizes
        addStarterOption(starters, "BULBASAUR", "A reliable grass-type partner with a mysterious bulb.");
        addStarterOption(starters, "CHARMANDER", "A fierce fire-type partner with a burning tail.");
        addStarterOption(starters, "SQUIRTLE", "A sturdy water-type partner with a protective shell.");

        // Update info label width
        pokemonInfoLabel.setWidth(width * 0.6f);

        // Update button size
        confirmButton.setSize(buttonWidth, buttonHeight);

        // Force layout update
        invalidateHierarchy();
        validate();

        // Center the table
        setPosition((width - getWidth()) / 2, (height - getHeight()) / 2);

        GameLogger.info("StarterSelectionTable resize complete - Scale factor: " + scaleFactor);
    }





    public interface SelectionListener {
        void onStarterSelected(Pokemon starter);

        void onSelectionStart();
    }

}

================
File: main/java/io/github/pokemeetup/screens/WorldSelectionScreen.java
================
package io.github.pokemeetup.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.*;
import com.badlogic.gdx.graphics.g2d.*;
import com.badlogic.gdx.graphics.glutils.FrameBuffer;
import com.badlogic.gdx.math.*;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.*;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.client.GameClientSingleton;
import io.github.pokemeetup.multiplayer.server.config.ServerConfigManager;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import static io.github.pokemeetup.system.gameplay.overworld.World.INITIAL_LOAD_RADIUS;

/**
 * A screen that shows all available worlds, allows creation/deletion,
 * and loads either single- or multi-player.
 */
public class WorldSelectionScreen implements Screen {
    private static final String DEFAULT_PLAYER_NAME = "Player";
    private static final float MIN_BUTTON_WIDTH = 150f;
    private static final float MIN_BUTTON_HEIGHT = 40f;
    private static final float MIN_WORLD_LIST_WIDTH = 300f;
    private static final float MIN_INFO_PANEL_WIDTH = 200f;
    private final CreatureCaptureGame game;
    private final Stage stage;
    private final Skin skin;
    private final Map<String, Texture> worldThumbnails = new HashMap<>();
    private Table mainTable;
    private ScrollPane worldListScroll;
    private Table worldListTable;
    private Table infoPanel;
    private WorldData selectedWorld;
    // Buttons
    private TextButton playButton;
    private TextButton createButton;
    private TextButton deleteButton;
    private TextButton backButton;
    private ButtonGroup<TextButton> tabGroup;
    private String currentTab = "All";
    private ButtonGroup<TextButton> sortGroup;
    private String currentSort = "Name";
    private float screenWidth;
    private float screenHeight;
    private Table contentTable;
    private TextureRegion placeholderRegion;

    public WorldSelectionScreen(CreatureCaptureGame game) {
        this.game = game;
        this.stage = new Stage(new ScreenViewport());

        TextureAtlas atlas;
        try {
            atlas = new TextureAtlas(Gdx.files.internal("Skins/uiskin.atlas"));
        } catch (Exception e) {
            GameLogger.error("Failed to load TextureAtlas 'uiskin.atlas': " + e.getMessage());
            throw new RuntimeException("TextureAtlas loading failed.", e);
        }

        skin = new Skin(atlas);
        try {
            skin.load(Gdx.files.internal("Skins/uiskin.json"));
        } catch (Exception e) {
            GameLogger.error("Failed to load skin JSON 'uiskin.json': " + e.getMessage());
            throw new RuntimeException("Skin JSON loading failed.", e);
        }
        List<String> requiredDrawables = Arrays.asList(
            "default-round", "default-round-down", "default-rect",
            "default-window", "default-scroll", "default-round-large",
            "check-on", "check-off", "tree-minus", "tree-plus",
            "default-select", "default-select-selection",
            "default-splitpane-vertical", "default-splitpane",
            "default-slider", "default-slider-knob"
        );

        for (String drawableName : requiredDrawables) {
            if (!skin.has(drawableName, Drawable.class)) {
                GameLogger.error("Missing drawable in skin: " + drawableName);
            }
        }

        Gdx.input.setInputProcessor(stage);

        createUI();
        updateScreenSizes();
        refreshWorldList();
    }

    // Adjust layout on resizing
    private void updateScreenSizes() {
        screenWidth = Gdx.graphics.getWidth();
        screenHeight = Gdx.graphics.getHeight();

        // Calculate relative sizes
        float buttonWidth = Math.max(MIN_BUTTON_WIDTH, screenWidth * 0.2f);
        float buttonHeight = Math.max(MIN_BUTTON_HEIGHT, screenHeight * 0.08f);
        float worldListWidth = Math.max(MIN_WORLD_LIST_WIDTH, screenWidth * 0.55f);
        float infoPanelWidth = Math.max(MIN_INFO_PANEL_WIDTH, screenWidth * 0.35f);

        // Update UI elements with new sizes
        updateUIElements(buttonWidth, buttonHeight, worldListWidth, infoPanelWidth);
    }

    private void updateUIElements(float buttonWidth, float buttonHeight,
                                  float worldListWidth, float infoPanelWidth) {
        // Calculate font scale based on screen size
        float fontScale = Math.max(0.8f, Math.min(screenWidth, screenHeight) / 1000f);

        // Update main table padding
        if (mainTable != null) {
            mainTable.pad(screenWidth * 0.02f); // 2% of screen width

            // Update title scaling
            Label titleLabel = mainTable.findActor("titleLabel");
            if (titleLabel != null) {
                titleLabel.setFontScale(fontScale * 1.5f);
            }
        }

        // Update button sizes and font scales
        updateButton(createButton, buttonWidth, buttonHeight, fontScale);
        updateButton(playButton, buttonWidth, buttonHeight, fontScale);
        updateButton(deleteButton, buttonWidth, buttonHeight, fontScale);
        updateButton(backButton, buttonWidth, buttonHeight, fontScale);

        // Update scroll pane and info panel sizes
        if (worldListScroll != null && contentTable != null) {
            worldListTable.padRight(screenWidth * 0.02f);
            Cell<?> scrollCell = contentTable.getCell(worldListScroll);
            if (scrollCell != null) {
                scrollCell.width(worldListWidth);
            }

            Cell<?> infoPanelCell = contentTable.getCell(infoPanel);
            if (infoPanelCell != null) {
                infoPanelCell.width(infoPanelWidth);
            }
        }

        // Update world entry sizes
        if (worldListTable != null) {
            for (Actor actor : worldListTable.getChildren()) {
                if (actor instanceof Table) {
                    Table entry = (Table) actor;
                    float entryPadding = screenWidth * 0.01f;
                    entry.pad(entryPadding);

                    // Update thumbnail size
                    Image thumbnail = entry.findActor("thumbnail");
                    if (thumbnail != null) {
                        float thumbnailSize = Math.max(60f, screenWidth * 0.08f);
                        Cell<?> thumbnailCell = entry.getCell(thumbnail);
                        if (thumbnailCell != null) {
                            thumbnailCell.size(thumbnailSize);
                        }
                    }

                    // Update labels in the entry
                    for (Actor child : entry.getChildren()) {
                        if (child instanceof Label) {
                            ((Label) child).setFontScale(fontScale);
                        }
                    }
                }
            }
        }
    }

    private void updateButton(TextButton button, float width, float height, float fontScale) {
        if (button != null) {
            button.getLabel().setFontScale(fontScale);
            Table parent = button.getParent() instanceof Table ? (Table) button.getParent() : null;
            if (parent != null) {
                Cell<?> cell = parent.getCell(button);
                if (cell != null) {
                    cell.width(width)
                        .height(height)
                        .pad(screenWidth * 0.01f);
                }
            }
        }
    }

    @Override
    public void resize(int width, int height) {
        stage.getViewport().update(width, height, true);
        updateScreenSizes();
    }

    private void createUI() {
        mainTable = new Table();
        mainTable.setFillParent(true);
        mainTable.pad(20);

        Label titleLabel = new Label("Select World", skin);
        titleLabel.setName("titleLabel");
        titleLabel.setFontScale(2.0f);
        mainTable.add(titleLabel).colspan(4).pad(20);
        mainTable.row();

        // Tab buttons
        Table tabTable = new Table();
        tabGroup = new ButtonGroup<>();

        String[] tabs = {"All", "Recent", "Multiplayer"};
        for (String tab : tabs) {
            TextButton tabButton = new TextButton(tab, skin);
            tabGroup.add(tabButton);
            tabTable.add(tabButton).pad(5);
        }
        mainTable.add(tabTable).colspan(4).pad(10);
        mainTable.row();

        // Sorting buttons
        Table sortTable = new Table();
        TextButton sortByNameButton = new TextButton("Sort by Name", skin);
        TextButton sortByDateButton = new TextButton("Sort by Date", skin);
        sortGroup = new ButtonGroup<>(sortByNameButton, sortByDateButton);
        sortGroup.setMaxCheckCount(1);
        sortGroup.setMinCheckCount(1);
        sortGroup.setUncheckLast(true);

        sortTable.add(sortByNameButton).pad(5);
        sortTable.add(sortByDateButton).pad(5);

        mainTable.add(sortTable).colspan(4).pad(10);
        mainTable.row();

        // World list setup
        worldListTable = new Table();
        worldListTable.top();
        worldListTable.defaults().expandX().fillX().pad(5f);

        ScrollPane.ScrollPaneStyle scrollPaneStyle = new ScrollPane.ScrollPaneStyle();
        scrollPaneStyle.background = skin.newDrawable("default-pane", new Color(0.15f, 0.15f, 0.15f, 0.8f));
        scrollPaneStyle.vScroll = skin.newDrawable("default-scroll");
        scrollPaneStyle.vScrollKnob = skin.newDrawable("default-round-large");

        worldListScroll = new ScrollPane(worldListTable, scrollPaneStyle);
        worldListScroll.setFadeScrollBars(false);
        worldListScroll.setScrollingDisabled(true, false);

        // Info panel
        infoPanel = new Table(skin);
        infoPanel.background("default-pane");
        infoPanel.pad(10);

        contentTable = new Table();
        contentTable.defaults().pad(10);
        contentTable.add(worldListScroll)
            .width(Gdx.graphics.getWidth() * 0.6f)
            .expandY()
            .fillY()
            .padRight(20);
        contentTable.add(infoPanel)
            .width(Gdx.graphics.getWidth() * 0.35f)
            .expandY()
            .fillY();

        mainTable.add(contentTable).colspan(4).expand().fill();
        mainTable.row();

        Table buttonTable = new Table();

        createButton = new TextButton("Create New World", skin);
        playButton = new TextButton("Play Selected World", skin);
        deleteButton = new TextButton("Delete World", skin);
        backButton = new TextButton("Back", skin);

        playButton.setDisabled(true);
        deleteButton.setDisabled(true);

        float fontScale = 1.2f;
        createButton.getLabel().setFontScale(fontScale);
        playButton.getLabel().setFontScale(fontScale);
        deleteButton.getLabel().setFontScale(fontScale);
        backButton.getLabel().setFontScale(fontScale);

        buttonTable.add(createButton).pad(10).width(250).height(70);
        buttonTable.add(playButton).pad(10).width(250).height(70);
        buttonTable.add(deleteButton).pad(10).width(250).height(70);
        buttonTable.row();
        buttonTable.add(backButton).colspan(3).width(250).height(70).pad(10);

        mainTable.add(buttonTable).colspan(4).pad(10);

        stage.addActor(mainTable);

        placeholderRegion = TextureManager.ui.findRegion("placeholder-image");
        addTabListeners();
        addSortListeners();
        addButtonListeners();

        tabGroup.getButtons().get(0).setChecked(true);
        sortGroup.getButtons().get(0).setChecked(true);
    }

    private void addTabListeners() {
        for (TextButton tabButton : tabGroup.getButtons()) {
            tabButton.addListener(new ChangeListener() {
                @Override
                public void changed(ChangeEvent event, Actor actor) {
                    if (tabButton.isChecked()) {
                        currentTab = tabButton.getText().toString();
                        refreshWorldList();
                    }
                }
            });
        }
    }

    private void addSortListeners() {
        for (TextButton sortButton : sortGroup.getButtons()) {
            sortButton.addListener(new ChangeListener() {
                @Override
                public void changed(ChangeEvent event, Actor actor) {
                    if (sortButton.isChecked()) {
                        currentSort = sortButton.getText().toString().replace("Sort by ", "");
                        refreshWorldList();
                    }
                }
            });
        }
    }

    private void addButtonListeners() {
        createButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                showCreateWorldDialog();
            }
        });

        playButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                if (selectedWorld != null) {
                    String username = selectedWorld.getPlayers().isEmpty()
                        ? DEFAULT_PLAYER_NAME
                        : selectedWorld.getPlayers().keySet().iterator().next();
                    loadSelectedWorld(username);
                }
            }
        });

        deleteButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                if (selectedWorld != null) {
                    showDeleteConfirmDialog();
                }
            }
        });

        backButton.addListener(new ChangeListener() {
            @Override
            public void changed(ChangeEvent event, Actor actor) {
                game.setScreen(new ModeSelectionScreen(game));
                dispose();
            }
        });
    }

    private Table createWorldEntry(WorldData world) {
        Table entry = new Table(skin);
        entry.setName("worldEntry");
        entry.setBackground(skin.newDrawable("default-pane", new Color(0.2f, 0.2f, 0.2f, 0.8f)));

        // Entry contents
        Table contentTable = new Table();
        float padding = 10f;
        contentTable.pad(padding);

        // Thumbnail container
        Table thumbnailContainer = new Table();
        thumbnailContainer.setBackground(skin.newDrawable("default-pane", new Color(0.15f, 0.15f, 0.15f, 1f)));

        // Load thumbnail image
        Image thumbnailImage;
        FileHandle thumbnailFile = Gdx.files.local("thumbnails/" + world.getName() + ".png");
        if (thumbnailFile.exists()) {
            Texture thumbnailTexture = new Texture(thumbnailFile);
            worldThumbnails.put(world.getName(), thumbnailTexture);
            thumbnailImage = new Image(new TextureRegionDrawable(new TextureRegion(thumbnailTexture)));
            thumbnailImage.setScaling(Scaling.fit);
        } else {
            // Use placeholder image
            thumbnailImage = new Image(placeholderRegion);
            thumbnailImage.setScaling(Scaling.fit);
        }
        thumbnailImage.setName("thumbnail");

        float thumbnailSize = 180f;
        thumbnailContainer.add(thumbnailImage).size(thumbnailSize).pad(2f);

        // Set up the infoTable
        Table infoTable = new Table();
        infoTable.defaults().left().pad(5f);

        // World name label
        Label nameLabel = new Label(world.getName(), skin);
        nameLabel.setFontScale(1.2f);

        // Last played date
        Label timeLabel = new Label("Last played: " + formatDate(world.getLastPlayed()), skin);
        timeLabel.setFontScale(0.9f);

        // Seed
        Label seedLabel = new Label("Seed: " + getSeedFromWorld(world), skin);
        seedLabel.setFontScale(0.9f);

        // Played time (optional)
        String playedTimeStr = formatPlayedTime(world.getPlayedTime());
        Label playedTimeLabel = new Label("Played time: " + playedTimeStr, skin);
        playedTimeLabel.setFontScale(0.9f);

        // Add labels to infoTable
        infoTable.add(nameLabel).expandX().fillX().padBottom(5f);
        infoTable.row();
        infoTable.add(timeLabel).expandX().fillX().padBottom(5f);
        infoTable.row();
        infoTable.add(seedLabel).expandX().fillX().padBottom(5f);
        infoTable.row();
        infoTable.add(playedTimeLabel).expandX().fillX();

        // Add thumbnail and infoTable to contentTable
        contentTable.add(thumbnailContainer).size(thumbnailSize + padding * 2).padRight(padding * 2);
        contentTable.add(infoTable).expand().fill();

        // Add content table to main entry
        entry.add(contentTable).expand().fill();

        // Selection listener
        entry.addListener(new ClickListener() {
            @Override
            public void clicked(InputEvent event, float x, float y) {
                resetWorldEntryStyles();
                entry.setBackground(skin.newDrawable("default-pane", new Color(0.3f, 0.6f, 1f, 0.8f)));
                selectWorld(world);
            }
        });

        return entry;
    }

    private void resetWorldEntryStyles() {
        for (Actor actor : worldListTable.getChildren()) {
            if (actor instanceof Table) {
                ((Table) actor).setBackground(skin.newDrawable("default-pane", new Color(0.2f, 0.2f, 0.2f, 0.8f)));
            }
        }
    }

    private void refreshWorldList() {
        worldListTable.clear();
        WorldData previousSelection = selectedWorld;

        List<WorldData> worldList = new ArrayList<>(GameContext.get().getWorldManager().getWorlds().values());
        worldList.removeIf(world -> !shouldShowWorld(world));

        // Sort
        if (currentSort.equals("Name")) {
            worldList.sort(Comparator.comparing(WorldData::getName));
        } else if (currentSort.equals("Date")) {
            worldList.sort(Comparator.comparingLong(WorldData::getLastPlayed).reversed());
        }

        worldListTable.defaults().expandX().fillX().pad(5f);

        for (WorldData world : worldList) {
            Table worldEntry = createWorldEntry(world);

            if (world.equals(previousSelection)) {
                worldEntry.setBackground(skin.newDrawable("default-pane", new Color(0.3f, 0.6f, 1f, 0.8f)));
                selectedWorld = world;
            }

            worldListTable.add(worldEntry).expandX().fillX();
            worldListTable.row();
        }

        playButton.setDisabled(selectedWorld == null);
        deleteButton.setDisabled(selectedWorld == null);

        updateInfoPanel();
    }

    private boolean shouldShowWorld(WorldData world) {
        switch (currentTab) {
            case "Recent":
                return (System.currentTimeMillis() - world.getLastPlayed()) < (7L * 24 * 60 * 60 * 1000);
            case "Multiplayer":
                return world.getName().equals(CreatureCaptureGame.MULTIPLAYER_WORLD_NAME);
            default:
                return true;
        }
    }

    private void selectWorld(WorldData world) {
        if (world == null) return;

        selectedWorld = world;
        updateInfoPanel();
        playButton.setDisabled(false);
        deleteButton.setDisabled(false);

        GameLogger.info("Selected world '" + world.getName() +
            "' - Commands " + (world.commandsAllowed() ? "enabled" : "disabled"));
    }

    private void updateInfoPanel() {
        infoPanel.clear();

        if (selectedWorld == null) {
            infoPanel.add(new Label("Select a world to view details", skin)).expand();
            return;
        }

        infoPanel.defaults().left().pad(5);

        // World name
        Label nameLabel = new Label(selectedWorld.getName(), skin);
        nameLabel.setFontScale(1.5f);
        infoPanel.add(nameLabel).expandX();
        infoPanel.row();

        // Last played
        Label lastPlayedLabel = new Label("Last played: " + formatDate(selectedWorld.getLastPlayed()), skin);
        lastPlayedLabel.setFontScale(1.0f);
        infoPanel.add(lastPlayedLabel);
        infoPanel.row();

        // World size
        infoPanel.add(new Label("World size: " + World.WORLD_SIZE + " x " + World.WORLD_SIZE, skin));
        infoPanel.row();

        // Seed
        long seed = getSeedFromWorld(selectedWorld);
        infoPanel.add(new Label("Seed: " + seed, skin));
        infoPanel.row();

        // Played time
        long playedTimeMillis = selectedWorld.getPlayedTime();
        String playedTimeStr = formatPlayedTime(playedTimeMillis);
        Label playedTimeLabel = new Label("Played time: " + playedTimeStr, skin);
        infoPanel.add(playedTimeLabel);
        infoPanel.row();

        // Username
        String username = selectedWorld.getPlayers() != null && !selectedWorld.getPlayers().isEmpty()
            ? selectedWorld.getPlayers().keySet().iterator().next()
            : "Player";
        Label usernameLabel = new Label("Username: " + username, skin);
        infoPanel.add(usernameLabel).row();
    }

    private String formatPlayedTime(long millis) {
        long seconds = millis / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;

        seconds = seconds % 60;
        minutes = minutes % 60;

        return String.format("%02dh %02dm %02ds", hours, minutes, seconds);
    }

    private String formatDate(long timestamp) {
        if (timestamp == 0) return "Never";
        return new SimpleDateFormat("MMM d, yyyy HH:mm").format(new Date(timestamp));
    }

    private long getSeedFromWorld(WorldData world) {
        if (world == null) return System.currentTimeMillis();
        WorldData.WorldConfig config = world.getConfig();
        if (config == null) {
            config = new WorldData.WorldConfig(System.currentTimeMillis());
            world.setConfig(config);
            GameLogger.error("Created new config for null config world");
        }
        return config.getSeed();
    }

    private void showCreateWorldDialog() {
        Dialog dialog = new Dialog("Create New World", skin) {
            @Override
            protected void result(Object object) {
                if ((Boolean) object) {
                    TextField nameField = findActor("nameField");
                    CheckBox cheatsAllowed = findActor("cheatsAllowed");
                    TextField seedField = findActor("seedField");
                    TextField dialogUsernameField = findActor("usernameField");

                    boolean commandsEnabled = cheatsAllowed != null && cheatsAllowed.isChecked();
                    GameLogger.info("Create world dialog - Commands enabled checkbox: " + commandsEnabled);

                    String worldName = nameField.getText().trim();
                    String seedText = seedField.getText().trim();
                    String username = dialogUsernameField.getText().trim();

                    if (worldName.isEmpty()) {
                        showError("World name cannot be empty");
                        return;
                    }

                    if (username.isEmpty()) {
                        username = DEFAULT_PLAYER_NAME;
                    }

                    long seed;
                    if (seedText.isEmpty()) {
                        seed = System.currentTimeMillis();
                    } else {
                        try {
                            seed = Long.parseLong(seedText);
                        } catch (NumberFormatException e) {
                            showError("Seed must be a valid number");
                            return;
                        }
                    }

                    createNewWorld(worldName, seed, username, commandsEnabled);
                }
            }
        };

        // Create fields
        TextField nameField = new TextField("", skin);
        nameField.setName("nameField");
        nameField.setMessageText("World name");

        CheckBox cheatsAllowed = new CheckBox(" Enable Commands", skin);
        cheatsAllowed.setName("cheatsAllowed");
        cheatsAllowed.setChecked(false);

        TextField seedField = new TextField("", skin);
        seedField.setName("seedField");
        seedField.setMessageText("Optional seed (number)");

        TextField dialogUsernameField = new TextField("", skin);
        dialogUsernameField.setName("usernameField");
        dialogUsernameField.setMessageText("Your username (optional)");

        // Add fields to dialog
        dialog.getContentTable().add(new Label("World Name:", skin)).left().padBottom(5);
        dialog.getContentTable().row();
        dialog.getContentTable().add(nameField).width(300).padBottom(15);
        dialog.getContentTable().row();
        dialog.getContentTable().add(new Label("Seed (optional):", skin)).left().padBottom(5);
        dialog.getContentTable().row();
        dialog.getContentTable().add(seedField).width(300).padBottom(15);
        dialog.getContentTable().row();
        dialog.getContentTable().add(new Label("Username:", skin)).left().padBottom(5);
        dialog.getContentTable().row();
        dialog.getContentTable().add(dialogUsernameField).width(300).padBottom(15);
        dialog.getContentTable().row();
        dialog.getContentTable().add(cheatsAllowed).left().padBottom(15);

        dialog.button("Create", true);
        dialog.button("Cancel", false);
        dialog.show(stage);
    }

    private void showDeleteConfirmDialog() {
        Dialog dialog = new Dialog("Delete World", skin) {
            @Override
            protected void result(Object object) {
                if ((Boolean) object) {
                    deleteSelectedWorld();
                }
            }
        };

        dialog.text("Are you sure you want to delete '" + selectedWorld.getName() + "'?\nThis cannot be undone!");
        dialog.button("Delete", true);
        dialog.button("Cancel", false);
        dialog.show(stage);
    }

    private void deleteSelectedWorld() {
        try {
            GameContext.get().getWorldManager().deleteWorld(selectedWorld.getName());
            selectedWorld = null;
            refreshWorldList();
            updateInfoPanel();
            playButton.setDisabled(true);
            deleteButton.setDisabled(true);
        } catch (Exception e) {
            showError("Failed to delete world: " + e.getMessage());
            GameLogger.error("Failed to delete world: " + e.getMessage());
        }
    }

    private void createNewWorld(String name, long seed, String username, boolean cheatsAllowed) {
        try {
            GameLogger.info("Creating new world '" + name + "' with commands " +
                (cheatsAllowed ? "enabled" : "disabled"));

            // Create world
            WorldData world = GameContext.get().getWorldManager().createWorld(name, seed, 0.15f, 0.05f);
            if (world == null) {
                showError("Failed to create world");
                return;
            }

            // Immediately set and save commands flag
            world.setCommandsAllowed(cheatsAllowed);
            GameLogger.info("Set initial commands state: " + world.commandsAllowed());

            // Create config
            WorldData.WorldConfig config = new WorldData.WorldConfig(seed);
            config.setTreeSpawnRate(0.15f);
            config.setPokemonSpawnRate(0.05f);
            world.setConfig(config);

            // Create player data
            PlayerData playerData = new PlayerData(username);
            world.savePlayerData(username, playerData, false);

            // Force an immediate save
            GameContext.get().getWorldManager().saveWorld(world);

            GameLogger.info("World creation complete - Commands enabled: " + world.commandsAllowed());

            // Generate thumbnail and update UI
            generateWorldThumbnail(world);
            refreshWorldList();
            selectWorld(world);

        } catch (Exception e) {
            GameLogger.error("Failed to create world: " + e.getMessage());
            showError("Failed to create world: " + e.getMessage());
        }
    }

    public void loadSelectedWorld(String username) {
        try {
            GameLogger.info("Starting world load: " + selectedWorld.getName());

            // 1. Save current world state if needed
            if (GameContext.get().getWorld() != null && GameContext.get().getPlayer() != null) {
                // Only save if current world matches type we're coming from
                boolean currentIsMultiplayer = GameContext.get().getGameClient() != null &&
                    !GameContext.get().getGameClient().isSinglePlayer();
                boolean targetIsMultiplayer = selectedWorld.getName().equals(CreatureCaptureGame.MULTIPLAYER_WORLD_NAME);

                if (currentIsMultiplayer == targetIsMultiplayer) {
                    PlayerData currentState = GameContext.get().getPlayer().getPlayerData();
                    GameContext.get().getWorld().getWorldData().savePlayerData(
                        GameContext.get().getPlayer().getUsername(),
                        currentState,
                        currentIsMultiplayer
                    );
                }
            }

            // 2. Clean up old state
            if (GameContext.get().getGameClient() != null) {
                GameContext.get().getGameClient().dispose();
                GameContext.get().setGameClient(null);
            }
            GameClientSingleton.resetInstance();

            // 3. Load correct world data
            boolean isMultiplayerWorld = selectedWorld.getName().equals(CreatureCaptureGame.MULTIPLAYER_WORLD_NAME);

            WorldData worldDataCopy = new WorldData(selectedWorld.getName());
            worldDataCopy.setConfig(selectedWorld.getConfig());
            worldDataCopy.setWorldTimeInMinutes(selectedWorld.getWorldTimeInMinutes());
            worldDataCopy.setPlayedTime(selectedWorld.getPlayedTime());
            worldDataCopy.setLastPlayed(System.currentTimeMillis());
            worldDataCopy.setCommandsAllowed(selectedWorld.commandsAllowed());

            // 4. Get correct player data for this world
            PlayerData worldSpecificPlayerData = selectedWorld.getPlayerData(username, isMultiplayerWorld);
            if (worldSpecificPlayerData == null) {
                worldSpecificPlayerData = new PlayerData(username);
            }

            // 5. Initialize world
            game.initializeWorld(worldDataCopy.getName(), isMultiplayerWorld);

            // 6. Set up appropriate client and connection
            if (isMultiplayerWorld) {
                // Connect to server
                ServerConnectionConfig config = ServerConfigManager.getDefaultServerConfig();
                GameContext.get().setGameClient(GameClientSingleton.getSinglePlayerInstance(GameContext.get().getPlayer()));
            } else {
                // Create singleplayer client
                GameContext.get().setGameClient(GameClientSingleton.getSinglePlayerInstance(GameContext.get().getPlayer()));
                GameContext.get().getGameClient().setSinglePlayer(true);
            }

            // 7. Apply the correct world-specific player data
            if (GameContext.get().getPlayer() != null) {
                GameContext.get().getPlayer().updateFromPlayerData(worldSpecificPlayerData);
            }

            // 8. Switch to game screen
            GameScreen newScreen = new GameScreen(game, username,
                GameContext.get().getGameClient(), selectedWorld.commandsAllowed());
            GameContext.get().setGameScreen(newScreen);

            game.setScreen(newScreen);
            dispose();

        } catch (Exception e) {
            GameLogger.error("Failed to load world: " + e.getMessage());
            showError("Failed to load world: " + e.getMessage());
        }
    }
    /**
     * Generates a thumbnail for a newly-created or existing world.
     * <p>
     * We create a temporary World instance and render it to an FBO.
     */
    private void generateWorldThumbnail(WorldData worldData) {
        final int THUMBNAIL_SIZE = 256;
        FrameBuffer fbo = null;
        SpriteBatch batch = null;
        World tempWorld = null;

        try {
            GameLogger.info("Starting thumbnail generation for: " + worldData.getName());

            // Create new FBO
            fbo = new FrameBuffer(Pixmap.Format.RGBA8888, THUMBNAIL_SIZE, THUMBNAIL_SIZE, false);
            batch = new SpriteBatch();

            // Create minimal world just for a screenshot
            tempWorld = initializeWorldDirectly(worldData);

            // Setup camera
            OrthographicCamera camera = new OrthographicCamera();
            camera.setToOrtho(false, 16 * World.TILE_SIZE, 16 * World.TILE_SIZE);
            camera.position.set(World.DEFAULT_X_POSITION, World.DEFAULT_Y_POSITION, 0);
            camera.update();

            // Render into FBO
            fbo.begin();
            Gdx.gl.glViewport(0, 0, THUMBNAIL_SIZE, THUMBNAIL_SIZE);
            Gdx.gl.glClearColor(0.529f, 0.808f, 0.922f, 1);
            Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

            batch.setProjectionMatrix(camera.combined);
            batch.begin();

            Rectangle viewBounds = new Rectangle(
                camera.position.x - camera.viewportWidth / 2,
                camera.position.y - camera.viewportHeight / 2,
                camera.viewportWidth,
                camera.viewportHeight
            );
            tempWorld.render(batch, viewBounds, tempWorld.getPlayer());

            batch.end();
            Pixmap pixmap = Pixmap.createFromFrameBuffer(0, 0, THUMBNAIL_SIZE, THUMBNAIL_SIZE);
            fbo.end();
            Gdx.gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());

            // Flip the pixmap
            Pixmap flippedPixmap = flipPixmap(pixmap);
            pixmap.dispose();

            // Save thumbnail to file
            FileHandle thumbnailDir = Gdx.files.local("thumbnails");
            if (!thumbnailDir.exists()) {
                thumbnailDir.mkdirs();
            }

            FileHandle thumbnailFile = thumbnailDir.child(worldData.getName() + ".png");
            PixmapIO.writePNG(thumbnailFile, flippedPixmap);

            flippedPixmap.dispose();

        } catch (Exception e) {
            GameLogger.error("Failed to generate thumbnail: " + e.getMessage());
        } finally {
            if (batch != null) batch.dispose();
            if (fbo != null) fbo.dispose();
            if (tempWorld != null) tempWorld.dispose();
        }
    }

    private Pixmap flipPixmap(Pixmap src) {
        int width = src.getWidth();
        int height = src.getHeight();
        Pixmap flipped = new Pixmap(width, height, src.getFormat());

        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                int pixel = src.getPixel(x, y);
                flipped.drawPixel(x, height - y - 1, pixel);
            }
        }
        return flipped;
    }

    /**
     * Creates a temporary local World to generate the thumbnail image.
     */
    private World initializeWorldDirectly(WorldData worldData) throws IOException {
        if (worldData == null) {
            throw new IOException("WorldData cannot be null");
        }
        long seed = worldData.getConfig() != null ? worldData.getConfig().getSeed() : System.currentTimeMillis();
        BiomeManager biomeManager = new BiomeManager(seed);
        World world = new World(worldData.getName(), seed, biomeManager);
        world.loadChunksAroundPositionSynchronously(
            new Vector2(World.DEFAULT_X_POSITION, World.DEFAULT_Y_POSITION),
            INITIAL_LOAD_RADIUS
        );
        // minimal dummy player
        Player tempPlayer = new Player(
            World.DEFAULT_X_POSITION,
            World.DEFAULT_Y_POSITION,
            world,
            "ThumbnailGen"
        );
        world.setPlayer(tempPlayer);
        return world;
    }

    private void showError(String message) {
        Dialog dialog = new Dialog("Error", skin);
        dialog.text(message);
        dialog.button("OK");
        dialog.show(stage);
    }

    @Override
    public void show() {
        AudioManager.getInstance().playMenuMusic();
        Gdx.app.postRunnable(this::refreshWorldList);
    }

    @Override
    public void render(float delta) {
        AudioManager.getInstance().update(delta);

        // Handle back/escape key
        if (Gdx.input.isKeyJustPressed(Input.Keys.BACK) || Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            game.setScreen(new ModeSelectionScreen(game));
            dispose();
            return;
        }

        Gdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        stage.act(delta);
        stage.draw();
    }

    @Override
    public void pause() {
    }

    @Override
    public void resume() {
    }

    @Override
    public void hide() {
    }

    @Override
    public void dispose() {
        stage.dispose();
        skin.dispose();
        for (Texture texture : worldThumbnails.values()) {
            texture.dispose();
        }
    }
}

================
File: main/java/io/github/pokemeetup/system/AndroidMovementController.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.MathUtils;

public class AndroidMovementController {
    private static final float DEADZONE = 0.2f;
    private static final float MAX_JOYSTICK_RADIUS = 100f;
    private static final float DIRECTION_THRESHOLD = 0.5f;

    private final Player player;
    private final Vector2 joystickCenter;
    private final Vector2 joystickCurrent;
    private final Vector2 movementVector;
    private boolean isActive;
    private String currentDirection;
    private float magnitude;

    public AndroidMovementController(Player player, InputHandler inputHandler) {
        this.player = player;
        this.joystickCenter = new Vector2();
        this.inputHandler = inputHandler;
        this.joystickCurrent = new Vector2();
        this.movementVector = new Vector2();
        this.isActive = false;
    }

    public void handleTouchDown(float x, float y) {
        joystickCenter.set(x, y);
        joystickCurrent.set(x, y);
        isActive = true;
        updateJoystick();
    }

    public void handleTouchDragged(float x, float y) {
        if (!isActive) return;

        joystickCurrent.set(x, y);
        updateJoystick();
    }



    private final InputHandler inputHandler;
    private void updateJoystick() {
        movementVector.set(joystickCurrent).sub(joystickCenter);

        // Calculate magnitude (0 to 1)
        magnitude = movementVector.len() / MAX_JOYSTICK_RADIUS;
        magnitude = MathUtils.clamp(magnitude, 0, 1);

        // Apply deadzone
        if (magnitude < DEADZONE) {
            magnitude = 0;
            movementVector.setZero();
            currentDirection = null;
            // Reset movement flags
            resetMovementFlags();
            return;
        }

        // Normalize vector
        movementVector.nor();

        updateDirection();

        // Set running based on magnitude
        if (inputHandler != null) {
            inputHandler.setRunning(magnitude > 0.8f);
        }
    } private void resetMovementFlags() {
        inputHandler.moveUp(false);
        inputHandler.moveDown(false);
        inputHandler.moveLeft(false);
        inputHandler.moveRight(false);
    }
    private void updateDirection() {
        float x = movementVector.x;
        float y = movementVector.y;

        // Reset movement flags
        resetMovementFlags();

        // Determine direction and set flags
        if (Math.abs(x) > DIRECTION_THRESHOLD) {
            if (x > 0) {
                inputHandler.moveRight(true);
            } else {
                inputHandler.moveLeft(true);
            }
        }
        if (Math.abs(y) > DIRECTION_THRESHOLD) {
            if (y > 0) {
                inputHandler.moveUp(true);
            } else {
                inputHandler.moveDown(true);
            }
        }
    }
    public void handleTouchUp() {
        isActive = false;
        movementVector.setZero();
        magnitude = 0;
        currentDirection = null;
        resetMovementFlags();
        if (player != null) {
            player.setMoving(false);
        }
    }

    public void update() {
        if (!isActive || magnitude < DEADZONE || currentDirection == null) {
            return;
        }
        if (!player.isMoving() && currentDirection != null) {
            player.move(currentDirection);
        } else if (player.isMoving()) {
            player.setDirection(currentDirection);
        }
    }

    public Vector2 getJoystickCenter() {
        return joystickCenter;
    }

    public Vector2 getJoystickCurrent() {
        return joystickCurrent;
    }

    public float getMaxRadius() {
        return MAX_JOYSTICK_RADIUS;
    }

    public boolean isActive() {
        return isActive;
    }

    public float getMagnitude() {
        return magnitude;
    }
}

================
File: main/java/io/github/pokemeetup/system/battle/BattleCompletionHandler.java
================
package io.github.pokemeetup.system.battle;

public interface BattleCompletionHandler {
    void onBattleComplete(BattleResult result);
}

================
File: main/java/io/github/pokemeetup/system/battle/BattleInitiationHandler.java
================
package io.github.pokemeetup.system.battle;

public interface BattleInitiationHandler {
    void handleBattleInitiation();
}

================
File: main/java/io/github/pokemeetup/system/battle/BattleResult.java
================
package io.github.pokemeetup.system.battle;

import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.WildPokemon;

public class BattleResult {
    private final boolean victory;
    private final int experienceGained;
    private final Pokemon playerPokemon;
    private final WildPokemon wildPokemon;

    public BattleResult(boolean victory, Pokemon playerPokemon, WildPokemon wildPokemon) {
        this.victory = victory;
        this.playerPokemon = playerPokemon;
        this.wildPokemon = wildPokemon;
        this.experienceGained = calculateExperience();
    }

    private int calculateExperience() {
        if (!victory) return 0;
        // Basic experience formula based on defeated Pokemon's level
        return (wildPokemon.getLevel() * 3) + 20;
    }

    public boolean isVictory() { return victory; }
    public int getExperienceGained() { return experienceGained; }
    public Pokemon getPlayerPokemon() { return playerPokemon; }
    public WildPokemon getWildPokemon() { return wildPokemon; }
}

================
File: main/java/io/github/pokemeetup/system/battle/BattleSystemHandler.java
================
package io.github.pokemeetup.system.battle;

import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.PokemonParty;
import io.github.pokemeetup.pokemon.WildPokemon;

public class BattleSystemHandler {
    private boolean isInBattle = false;   private boolean attemptingBattle = false;

    public void setAttemptingBattle(boolean attempting) {
        this.attemptingBattle = attempting;
    }

    public boolean isAttemptingBattle() {
        return this.attemptingBattle;
    }
    private WildPokemon lockedPokemon = null;

    // Check if player can battle (should only be called for battle initiation)
    public boolean canStartBattle(PokemonParty playerParty) {
        if (playerParty == null) return false;

        // Only check for valid battle Pokemon when actually trying to battle
        if (isInBattle) {
            for (Pokemon pokemon : playerParty.getParty()) {
                if (pokemon != null && pokemon.getCurrentHp() > 0) {
                    return true;
                }
            }
            return false;
        }
        return true; // Allow other actions when not in battle
    }



    // Lock/unlock Pokemon during battle
    public void lockPokemonForBattle(WildPokemon pokemon) {
        if (pokemon != null) {
            pokemon.setMoving(false);
            if (pokemon.getAi() != null) {
                pokemon.getAi().setPaused(true);
            }
            pokemon.setX(pokemon.getX()); // Force position update
            pokemon.setY(pokemon.getY());
            lockedPokemon = pokemon;
        }
    }

    public void unlockPokemon() {
        if (lockedPokemon != null) {
            if (lockedPokemon.getAi() != null) {
                lockedPokemon.getAi().setPaused(false);
            }
            lockedPokemon = null;
        }
    }

    // Battle state management
    public void startBattle() {
        isInBattle = true;
    }

    public void endBattle() {
        isInBattle = false;
        unlockPokemon();
    }

    public boolean isInBattle() {
        return isInBattle;
    }
}

================
File: main/java/io/github/pokemeetup/system/data/BlockSaveData.java
================
package io.github.pokemeetup.system.data;

import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonValue;
import io.github.pokemeetup.utils.GameLogger;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BlockSaveData {
    private Map<String, List<BlockData>> placedBlocks;

    public BlockSaveData() {
        this.placedBlocks = new HashMap<>();
    }

    public void addBlock(String chunkKey, BlockData block) {
        if (block == null) {
            GameLogger.error("Attempted to add invalid block data");
            return;
        }

        placedBlocks.computeIfAbsent(chunkKey, k -> new ArrayList<>()).add(block);
        GameLogger.info("Added block " + block.type + " to chunk " + chunkKey);
    }

    public Map<String, List<BlockData>> getPlacedBlocks() {
        if (placedBlocks == null) {
            placedBlocks = new HashMap<>();
        }
        return placedBlocks;
    }

    public void setPlacedBlocks(Map<String, List<BlockData>> placedBlocks) {
        this.placedBlocks = placedBlocks;
    }

    public BlockSaveData copy() {
        BlockSaveData copy = new BlockSaveData();

        if (this.placedBlocks != null) {
            Map<String, List<BlockData>> placedBlocksCopy = new HashMap<>();
            for (Map.Entry<String, List<BlockData>> entry : this.placedBlocks.entrySet()) {
                String chunkKey = entry.getKey();
                List<BlockData> originalList = entry.getValue();
                List<BlockData> copiedList = new ArrayList<>();

                if (originalList != null) {
                    for (BlockData blockData : originalList) {
                        if (blockData != null) {
                            copiedList.add(blockData.copy());
                        } else {
                            copiedList.add(null);
                        }
                    }
                }

                placedBlocksCopy.put(chunkKey, copiedList);
            }
            copy.setPlacedBlocks(placedBlocksCopy);
        }

        return copy;
    }

    public static class BlockData implements Serializable, Json.Serializable {
        public String type;
        public int x;
        public int y;
        public boolean isFlipped;     // Ensure this field is present
        public boolean isChestOpen;
        public ChestData chestData;
        public HashMap<String, Object> extraData;

        public BlockData() {
            this.extraData = new HashMap<>();
        }

        public BlockData(String type, int x, int y) {
            this.type = type;
            this.x = x;
            this.y = y;
            this.extraData = new HashMap<>();
            this.isFlipped = false;
            this.isChestOpen = false;
        }

        @Override
        public void write(Json json) {
            json.writeValue("type", type);
            json.writeValue("x", x);
            json.writeValue("y", y);
            json.writeValue("isFlipped", isFlipped);   // Make sure we're writing this
            json.writeValue("isChestOpen", isChestOpen);
            json.writeValue("extraData", extraData, HashMap.class);

            if (chestData != null) {
                json.writeValue("chestData", chestData);
            }
        }

        @Override
        public void read(Json json, JsonValue jsonData) {
            type = jsonData.getString("type");
            x = jsonData.getInt("x");
            y = jsonData.getInt("y");
            isFlipped = jsonData.getBoolean("isFlipped", false); // Reading flipped state
            isChestOpen = jsonData.getBoolean("isChestOpen", false);
            extraData = json.readValue(HashMap.class, jsonData.get("extraData"));
            chestData = json.readValue(ChestData.class, jsonData.get("chestData"));
        }

        public BlockData copy() {
            BlockData copy = new BlockData();
            copy.type = this.type;
            copy.x = this.x;
            copy.y = this.y;
            copy.isFlipped = this.isFlipped;
            copy.isChestOpen = this.isChestOpen;
            copy.extraData = new HashMap<>(this.extraData);
            if (this.chestData != null) {
                copy.chestData = this.chestData.copy();
            }
            return copy;
        }
    }
}

================
File: main/java/io/github/pokemeetup/system/data/ChestData.java
================
package io.github.pokemeetup.system.data;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonValue;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;
import io.github.pokemeetup.utils.GameLogger;

import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.UUID;

public class ChestData implements Serializable, Json.Serializable,ItemContainer {
    public static final int CHEST_SIZE = 27;
    private static final long serialVersionUID = 1L; // Add serialVersionUID
    public UUID chestId;
    public ArrayList<ItemData> items;
    public Vector2 position;
    public boolean isDirty;
    public transient InventorySlotData[] slotDataArray;

    public ChestData() {
        this.chestId = UUID.randomUUID();
        this.items = new ArrayList<>(CHEST_SIZE);
        this.position = new Vector2(0, 0);
        initializeSlots();
    }

    public ChestData(int x, int y) {
        this.chestId = UUID.randomUUID();
        this.items = new ArrayList<>(CHEST_SIZE);
        this.position = new Vector2(x, y);
        this.isDirty = false;
        initializeSlots();
    }

    private void initializeSlots() {
        // Clear and initialize items list
        if (items == null) {
            items = new ArrayList<>(CHEST_SIZE);
        }
        items.clear();
        for (int i = 0; i < CHEST_SIZE; i++) {
            items.add(null);
        }

        // Initialize slot data array
        initializeSlotDataArray();
    }

    public InventorySlotData getSlotData(int index) {
        if (slotDataArray == null) {
            initializeSlotDataArray();
        }

        if (index >= 0 && index < CHEST_SIZE) {
            return slotDataArray[index];
        }
        return null;
    }

    @Override
    public ItemData getItemAt(int index) {
        if (items == null) {
            initializeSlots();
        }

        if (index >= 0 && index < items.size()) {
            return items.get(index);
        }
        return null;
    }

    @Override
    public void setItemAt(int index, ItemData item) {
        if (items == null) {
            initializeSlots();
        }

        if (index >= 0 && index < items.size()) {
            if (item != null) {
                items.set(index, item.copy());
            } else {
                items.set(index, null);
            }
            isDirty = true;
        }
    }

    @Override
    public int getSize() {
        return CHEST_SIZE;
    }



    @Override
    public void write(Json json) {
        json.writeValue("chestId", chestId.toString());
        json.writeValue("position", position);
        json.writeValue("isDirty", isDirty);
        json.writeValue("items", items, ArrayList.class, ItemData.class);
    }

    @Override
    public void read(Json json, JsonValue jsonData) {
        chestId = UUID.fromString(jsonData.getString("chestId"));
        position = json.readValue(Vector2.class, jsonData.get("position"));
        isDirty = jsonData.getBoolean("isDirty", false);
        items = json.readValue(ArrayList.class, ItemData.class, jsonData.get("items"));
        initializeSlotDataArray();
    }

    public void initializeSlotDataArray() {
        if (slotDataArray == null) {
            slotDataArray = new InventorySlotData[CHEST_SIZE];
            for (int i = 0; i < CHEST_SIZE; i++) {
                slotDataArray[i] = new InventorySlotData(i, InventorySlotData.SlotType.CHEST, this);
            }
        }
    }


    public ChestData copy() {
        ChestData copy = new ChestData((int)position.x, (int)position.y);
        copy.chestId = UUID.fromString(this.chestId.toString()); // Deep copy UUID
        copy.isDirty = this.isDirty;

        // Deep copy items
        if (this.items != null) {
            for (int i = 0; i < this.items.size(); i++) {
                ItemData item = this.items.get(i);
                if (item != null) {
                    copy.items.set(i, item.copy());
                }
            }
        }

        return copy;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("ChestData{id=").append(chestId)
            .append(", position=").append(position)
            .append(", items=[");

        if (items != null) {
            for (int i = 0; i < items.size(); i++) {
                ItemData item = items.get(i);
                if (item != null) {
                    sb.append("\n  ").append(i).append(": ").append(item);
                }
            }
        }

        sb.append("\n]}");
        return sb.toString();
    }

    public synchronized void validateAndRepair() {
        try {
            GameLogger.info("Starting chest validation for chest " + chestId);

            // Ensure items list exists and has correct size
            if (items == null) {
                items = new ArrayList<>(CHEST_SIZE);
                GameLogger.error("Items list was null, recreating");
            }

            // Ensure list has correct size
            while (items.size() < CHEST_SIZE) {
                items.add(null);
                GameLogger.error("Added missing slot to chest");
            }
            while (items.size() > CHEST_SIZE) {
                items.remove(items.size() - 1);
                GameLogger.error("Removed excess slot from chest");
            }

            // Validate each item
            for (int i = 0; i < items.size(); i++) {
                ItemData item = items.get(i);
                if (item != null) {
                    boolean needsRepair = false;

                    // Validate UUID
                    if (item.getUuid() == null) {
                        item.setUuid(UUID.randomUUID());
                        needsRepair = true;
                        GameLogger.error("Repaired null UUID for item in slot " + i);
                    }

                    // Validate item count
                    if (item.getCount() <= 0) {
                        items.set(i, null);
                        GameLogger.error("Removed item with invalid count from slot " + i);
                        continue;
                    }

                    // Validate durability
                    if (item.getMaxDurability() > 0) {
                        if (item.getDurability() <= 0) {
                            items.set(i, null);
                            GameLogger.error("Removed broken item from slot " + i);
                            continue;
                        }
                        if (item.getDurability() > item.getMaxDurability()) {
                            item.setDurability(item.getMaxDurability());
                            needsRepair = true;
                            GameLogger.error("Fixed excessive durability for item in slot " + i);
                        }
                    }

                    // If item needed repairs, create a clean copy
                    if (needsRepair) {
                        items.set(i, item.copy());
                    }
                }
            }

            // Ensure slot data array is initialized
            if (slotDataArray == null || slotDataArray.length != CHEST_SIZE) {
                initializeSlotDataArray();
                GameLogger.error("Reinitialized slot data array");
            }

            // Mark as needing save
            isDirty = true;
            GameLogger.info("Chest validation complete for chest " + chestId);

        } catch (Exception e) {
            GameLogger.error("Error during chest validation: " + e.getMessage());
            e.printStackTrace();

            // Try to recover to a safe state
            initializeSlots();
        }
    }
}

================
File: main/java/io/github/pokemeetup/system/data/ItemData.java
================
package io.github.pokemeetup.system.data;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemDataObserver;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class ItemData {
    private final transient List<ItemDataObserver> observers = new ArrayList<>();
    public String itemId;   // Changed to public
    public int count;       // Changed to public
    public UUID uuid;       // Changed to public
    public int durability = -1;     // Changed to public
    public int maxDurability = -1;  // Changed to public

    public ItemData() {
        this.uuid = UUID.randomUUID();
    }

    public ItemData(String itemId, int count, UUID uuid) {
        this.itemId = itemId;
        this.count = count;
        this.uuid = uuid != null ? uuid : UUID.randomUUID();

        // Initialize durability from item template
        Item itemTemplate = ItemManager.getItemTemplate(itemId);
        if (itemTemplate != null) {
            this.durability = itemTemplate.getMaxDurability();
            this.maxDurability = itemTemplate.getMaxDurability();
        } else {
            this.durability = -1;
            this.maxDurability = -1;
        }
    }

    public ItemData(String itemId, int count) {
        this.itemId = itemId;
        this.count = count;
        this.uuid = UUID.randomUUID();
    }


    public ItemData(String itemId) {
        this.itemId = itemId;
        this.count = 1;
        this.uuid = UUID.randomUUID();
    }

    public ItemData(ItemData other) {
        this.itemId = other.itemId;
        this.count = other.count;
        this.uuid = other.uuid != null ? other.uuid : UUID.randomUUID();
        this.durability = other.durability;
        this.maxDurability = other.maxDurability;
    }

    public boolean isBroken() {
        return maxDurability > 0 && durability <= 0;
    }


    public void updateDurability(int amount) {
        if (maxDurability > 0) {
            int oldDurability = durability;
            durability = Math.max(0, Math.min(maxDurability, durability + amount));

            if (oldDurability != durability) {
                notifyObservers();
            }
        }
    }public void addObserver(ItemDataObserver observer) {
        if (observer != null && !observers.contains(observer)) {
            observers.add(observer);
        }
    }

    public void removeObserver(ItemDataObserver observer) {
        observers.remove(observer);
    }


    private void notifyObservers() {
        for (ItemDataObserver observer : observers) {
            observer.onItemDataChanged(this);
        }
    }


    public int getDurability() {
        return durability;
    }

    public void setDurability(int durability) {
        this.durability = durability;
        if (this.maxDurability > 0 && this.durability > this.maxDurability) {
            this.durability = this.maxDurability;
        }
        notifyObservers();
    }

    public boolean hasDurability() {
        return maxDurability > 0;
    }

    private String normalizeItemId(String itemId) {
        String normalized = itemId.toLowerCase();
        if (!normalized.endsWith("_item")) {
            normalized += "_item";
        }
        return normalized;
    }

    public String getItemId() {
        return itemId;
    }

    public void setItemId(String itemId) {
        this.itemId = itemId.toLowerCase(); // Normalize to lowercase

        // When retrieving the texture, add "_item" suffix
        TextureRegion texture = TextureManager.items.findRegion(this.itemId + "_item");
        if (texture == null) {
            GameLogger.error("No texture found for item: " + this.itemId + "_item");
        }

        // Retrieve item template using the consistent itemId
        Item itemTemplate = ItemManager.getItemTemplate(this.itemId);
        if (itemTemplate != null) {
            if (this.maxDurability == -1) {
                this.maxDurability = itemTemplate.getMaxDurability();
            }

            if (this.durability == -1) {
                this.durability = this.maxDurability;
            }

            if (this.maxDurability > 0 && this.durability > this.maxDurability) {
                this.durability = this.maxDurability;
            }
        }
    }



    public int getMaxDurability() {
        return maxDurability;
    }

    public void setMaxDurability(int maxDurability) {
        this.maxDurability = maxDurability;
    }

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        if (count < 0) {
            GameLogger.error("Attempted to set negative count: " + count);
            this.count = 0;
            return;
        }

        Item template = ItemManager.getItemTemplate(itemId);
        if (template != null && !template.isStackable()) {
            this.count = Math.min(1, count);
            GameLogger.info("Set count=1 for unstackable item: " + itemId);
        } else {
            this.count = Math.min(count, Item.MAX_STACK_SIZE);
            GameLogger.info("Set count=" + this.count + " for " + itemId);
        }
        notifyObservers(); // Notify when count changes
    }

    public UUID getUuid() {
        if (uuid == null) {
            uuid = UUID.randomUUID();
        }
        return uuid;
    }


    public void setUuid(UUID uuid) {
        this.uuid = uuid;
    }


    public boolean isEmpty() {
        return this.count <= 0;
    }

    public ItemData copyWithUUID() {
        return new ItemData(this.itemId, this.count, UUID.randomUUID());
    }


    @Override
    public String toString() {
        return "ItemData{" +
            "itemId='" + itemId + '\'' +
            ", count=" + count +
            ", uuid=" + uuid +
            '}';
    }
    public float getDurabilityPercentage() {
        if (maxDurability > 0) {
            return (float) durability / (float) maxDurability;
        } else {
            return 0f;
        }
    }

    public ItemData copy() {
        ItemData copy = new ItemData(this.itemId, this.count, this.uuid);
        copy.setDurability(this.durability);
        copy.setMaxDurability(this.maxDurability);
        return copy;
    }


    public boolean isValid() {
        if (itemId == null || itemId.trim().isEmpty()) {
            return false;
        }
        if (count <= 0) {
            return false;
        }
        if (uuid == null) {
            uuid = UUID.randomUUID(); // Auto-generate UUID if missing
        }
        return ItemManager.getItem(itemId) != null; // Verify item exists in manager
    }

}

================
File: main/java/io/github/pokemeetup/system/data/PlayerData.java
================
package io.github.pokemeetup.system.data;

import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.PokemonParty;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;


public class PlayerData {
    private String username;
    private float x;
    private float y;
    private String direction;
    private boolean isMoving;
    private boolean wantsToRun;
    private List<ItemData> inventoryItems;
    private List<PokemonData> partyPokemon;

    public PlayerData() {
        this.direction = "down";
        this.inventoryItems = new ArrayList<>();
        this.partyPokemon = new ArrayList<>();
    }

    public PlayerData(String username) {
        this();
        this.username = username;
    }


    public void updateFromPlayer(Player player) {
        if (player == null) {
            GameLogger.error("Cannot update from null player");
            return;
        }

        try {
            this.x = player.getTileX();
            this.y = player.getTileY();
            this.direction = player.getDirection();
            this.isMoving = player.isMoving();
            this.wantsToRun = player.isRunning();

            this.inventoryItems = new ArrayList<>(Collections.nCopies(Inventory.INVENTORY_SIZE, null));
            this.partyPokemon = new ArrayList<>(Collections.nCopies(PokemonParty.MAX_PARTY_SIZE, null));

            if (player.getInventory() != null) {
                List<ItemData> items = player.getInventory().getAllItems();
                for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                    if (i < items.size() && items.get(i) != null) {
                        ItemData itemData = items.get(i);
                        if (validateItemData(itemData)) {
                            this.inventoryItems.set(i, itemData.copy());
                        }
                    }
                }
            }

            if (player.getPokemonParty() != null) {
                List<Pokemon> currentParty = player.getPokemonParty().getParty();
                for (int i = 0; i < PokemonParty.MAX_PARTY_SIZE; i++) {
                    if (i < currentParty.size() && currentParty.get(i) != null) {
                        Pokemon pokemon = currentParty.get(i);
                        try {
                            PokemonData pokemonData = PokemonData.fromPokemon(pokemon);
                            if (pokemonData.verifyIntegrity()) {
                                this.partyPokemon.set(i, pokemonData);
                            }
                        } catch (Exception e) {
                            GameLogger.error("Failed to convert Pokemon at slot " + i + ": " + e.getMessage());
                        }
                    }
                }
            }
        } catch (Exception ignored) {
        }
    }

    public int getValidItemCount() {
        if (inventoryItems == null) return 0;
        return (int) inventoryItems.stream()
            .filter(item -> item != null && item.isValid())
            .count();
    }

    public boolean validateAndRepairState() {
        boolean wasRepaired = false;

        // Validate username
        if (username == null || username.trim().isEmpty()) {
            return false; // Critical failure - can't repair without username
        }

        // Initialize collections if null
        if (inventoryItems == null) {
            inventoryItems = new ArrayList<>();
            wasRepaired = true;
        }

        if (partyPokemon == null) {
            partyPokemon = new ArrayList<>();
            wasRepaired = true;
        }

        // Ensure direction has valid value
        if (direction == null) {
            direction = "down";
            wasRepaired = true;
        }

        // Validate position
        if (Float.isNaN(x) || Float.isInfinite(x)) {
            x = 0;
            wasRepaired = true;
        }
        if (Float.isNaN(y) || Float.isInfinite(y)) {
            y = 0;
            wasRepaired = true;
        }


        return true; // Return true if validation passed, even if repairs were made
    }

    public int getValidPokemonCount() {
        if (partyPokemon == null) return 0;
        return (int) partyPokemon.stream()
            .filter(pokemon -> pokemon != null && pokemon.verifyIntegrity())
            .count();
    }

    public void applyToPlayer(Player player) {
        if (player == null) return;

        GameLogger.info("Applying PlayerData to player: " + this.username);
        int validItems = getValidItemCount();
        int validPokemon = getValidPokemonCount();
        GameLogger.info("Initial PlayerData state - Valid Items: " + validItems +
            " Valid Pokemon: " + validPokemon);

        try {
            if (validateAndRepairState()) {
                GameLogger.info("Data was repaired during validation");
            }

            player.setX(x * World.TILE_SIZE);
            player.setY(y * World.TILE_SIZE);
            player.setDirection(direction);
            player.setMoving(isMoving);
            player.setRunning(wantsToRun);

            if (validItems > 0) {
                player.getInventory().clear();
                for (ItemData item : inventoryItems) {
                    if (item != null && item.isValid()) {
                        player.getInventory().addItem(item.copy());
                        GameLogger.info("Restored item: " + item.getItemId() + " x" + item.getCount());
                    }
                }
            }

            // Only clear if we're actually going to add Pokemon
            if (validPokemon > 0) {
                player.getPokemonParty().clearParty();
                for (PokemonData pokemonData : partyPokemon) {
                    if (pokemonData != null && pokemonData.verifyIntegrity()) {
                        Pokemon pokemon = pokemonData.toPokemon();
                        player.getPokemonParty().addPokemon(pokemon);
                        GameLogger.info("Restored Pokemon: " + pokemon.getName());
                    }
                }
            }

            // Log final valid counts
            GameLogger.info("Final player state - Items: " + player.getInventory().getAllItems().size() +
                " Pokemon: " + player.getPokemonParty().getSize());

        } catch (Exception e) {
            GameLogger.error("Error applying PlayerData: " + e.getMessage());
        }
    }


    private boolean validateItemData(ItemData item) {
        return item != null &&
            item.getItemId() != null &&
            !item.getItemId().isEmpty() &&
            item.getCount() > 0 &&
            item.getCount() <= Item.MAX_STACK_SIZE &&
            ItemManager.getItem(item.getItemId()) != null &&
            item.getUuid() != null;
    }


    public PlayerData copy() {
        PlayerData copy = new PlayerData(this.username);

        copy.setX(this.x);
        copy.setY(this.y);
        copy.setDirection(this.direction);
        copy.setMoving(this.isMoving);
        copy.setWantsToRun(this.wantsToRun);

        // Deep copy inventory items
        if (this.inventoryItems != null) {
            List<ItemData> inventoryCopy = new ArrayList<>();
            for (ItemData item : this.inventoryItems) {
                if (item != null) {
                    inventoryCopy.add(item.copy());
                } else {
                    inventoryCopy.add(null);
                }
            }
            copy.setInventoryItems(inventoryCopy);
        }

        // Deep copy Pokemon party
        if (this.partyPokemon != null) {
            List<PokemonData> partyCopy = new ArrayList<>();
            for (PokemonData pokemon : this.partyPokemon) {
                if (pokemon != null) {
                    partyCopy.add(pokemon.copy());
                } else {
                    partyCopy.add(null);
                }
            }
            copy.setPartyPokemon(partyCopy);
        }

        return copy;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public float getX() {
        return x;
    }

    public void setX(float x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    public String getDirection() {
        return direction;
    }

    public void setDirection(String direction) {
        this.direction = direction;
    }

    public boolean isMoving() {
        return isMoving;
    }

    public void setMoving(boolean moving) {
        isMoving = moving;
    }

    public boolean isWantsToRun() {
        return wantsToRun;
    }

    public void setWantsToRun(boolean wantsToRun) {
        this.wantsToRun = wantsToRun;
    }

    public List<ItemData> getInventoryItems() {
        return inventoryItems;
    }

    public void setInventoryItems(List<ItemData> items) {
        this.inventoryItems = new ArrayList<>(items);
    }

    public List<PokemonData> getPartyPokemon() {
        return partyPokemon;
    }

    public void setPartyPokemon(List<PokemonData> partyPokemon) {
        this.partyPokemon = partyPokemon;
    }

    @Override
    public String toString() {
        return "io.github.pokemeetup.system.data.PlayerData{" +
            "username='" + username + '\'' +
            ", position=(" + x + "," + y + ")" +
            ", direction='" + direction + '\'' +
            ", inventory=" + (inventoryItems != null ? inventoryItems.size() : "null") + " items" +
            ", party=" + (partyPokemon != null ? partyPokemon.size() : "null") + " pokemon" +
            '}';
    }
}

================
File: main/java/io/github/pokemeetup/system/data/PokemonData.java
================
package io.github.pokemeetup.system.data;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.attacks.LearnableMove;
import io.github.pokemeetup.pokemon.attacks.Move;
import io.github.pokemeetup.utils.GameLogger;

import java.io.Serializable;
import java.util.*;
import java.util.stream.Collectors;

public class PokemonData {
    private final Vector2 position = new Vector2();
    // Basic Info
    public String name;
    public UUID uuid = UUID.randomUUID();
    public int level;
    public String nature;
    public Pokemon.PokemonType primaryType;
    public Pokemon.PokemonType secondaryType; // Can be null
    // Stats
    public Stats stats;
    // Moves
    public List<MoveData> moves;
    // Base Stats
    private int baseHp;
    private int currentExperience = 0;
    private int experienceToNextLevel = 0;

    // Add getters and setters
    public int getCurrentExperience() {
        return currentExperience;
    }

    public void setCurrentExperience(int experience) {
        this.currentExperience = Math.max(0, experience);
    }

    public int getExperienceToNextLevel() {
        return experienceToNextLevel;
    }

    public void setExperienceToNextLevel(int exp) {
        this.experienceToNextLevel = Math.max(0, exp);
    }
    private int baseAttack;
    private int baseDefense;
    private int baseSpAtk;
    private Map<UUID, WildPokemonData> wildPokemonMap = new HashMap<>();
    private int baseSpDef;
    private int baseSpeed;
    // Physical Dimensions
    private float width;
    private float height;
    private List<LearnableMove> learnableMoves;
    private List<String> tmMoves;
    private HashMap<String, Move> moveDatabase;
    private HashMap<UUID, WildPokemonData> wildPokemon;
    public PokemonData() {
        this.uuid = UUID.randomUUID();
        this.learnableMoves = new ArrayList<>();
        this.moves = new ArrayList<>();
        this.tmMoves = new ArrayList<>();
        this.moveDatabase = new HashMap<>();
        wildPokemon = new HashMap<>();
        this.stats = new Stats();
        this.currentHp = stats.getHp();
    }    public int getCurrentHp() {
        return currentHp;
    }

    public void setCurrentHp(int hp) {
        this.currentHp = Math.min(Math.max(0, hp), stats != null ? stats.getHp() : hp);
    }


    public static PokemonData fromPokemon(Pokemon pokemon) {
        if (pokemon == null) {
            throw new IllegalArgumentException("Cannot create PokemonData from null Pokemon.");
        }
        PokemonData data = new PokemonData();
        data.setName(pokemon.getName());
        data.setLevel(pokemon.getLevel());
        data.setNature(pokemon.getNature());
        data.setUuid(pokemon.getUuid());
        data.setPrimaryType(pokemon.getPrimaryType());
        data.setSecondaryType(pokemon.getSecondaryType());
        data.setCurrentHp(pokemon.getCurrentHp()); // Add this line

        data.setBaseHp(pokemon.getStats().getHp());
        data.setBaseAttack(pokemon.getStats().getAttack());
        data.setBaseDefense(pokemon.getStats().getDefense());
        data.setBaseSpAtk(pokemon.getStats().getSpecialAttack());
        data.setBaseSpDef(pokemon.getStats().getSpecialDefense());
        data.setBaseSpeed(pokemon.getStats().getSpeed());

        data.setCurrentExperience(pokemon.getCurrentExperience());
        data.setExperienceToNextLevel(pokemon.getExperienceForNextLevel());
        if (pokemon.getMoves() != null) {
            List<MoveData> moveDataList = pokemon.getMoves().stream().map(MoveData::fromMove).filter(Objects::nonNull).collect(Collectors.toList());
            data.setMoves(moveDataList);
        }

        return data;
    }
    public boolean verifyIntegrity() {
        if (this.name == null || this.name.isEmpty()) {
            GameLogger.error("PokemonData integrity check failed: name is null or empty");
            return false;
        }

        if (this.level <= 0) {
            GameLogger.error("PokemonData integrity check failed: level is non-positive");
            return false;
        }

        return true;
    }



    public void removeWildPokemon(UUID id) {
        wildPokemon.remove(id);
    }

    public Vector2 getPosition() {
        return position.cpy();
    }

    public void setPosition(float x, float y) {
        this.position.set(x, y);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public UUID getUuid() {
        if (uuid == null) {
            uuid = UUID.randomUUID();
        }
        return uuid;
    }

    public void setUuid(UUID uuid) {
        this.uuid = uuid != null ? uuid : UUID.randomUUID();
    }

    public int getLevel() {
        return level;
    }

    public void setLevel(int level) {
        this.level = level;
    }

    public String getNature() {
        return nature;
    }

    public void setNature(String nature) {
        this.nature = nature;
    }

    public Pokemon.PokemonType getPrimaryType() {
        return primaryType;
    }

    public void setPrimaryType(Pokemon.PokemonType primaryType) {
        this.primaryType = primaryType != null ? primaryType : Pokemon.PokemonType.NORMAL; // Default to NORMAL
    }

    public Pokemon.PokemonType getSecondaryType() {
        return secondaryType;
    }

    public void setSecondaryType(Pokemon.PokemonType secondaryType) {
        this.secondaryType = secondaryType;
    }

    public Stats getStats() {
        // Ensure stats are never null
        if (this.stats == null) {
            this.stats = new Stats();
        }
        return stats;
    }

    public void setStats(Stats stats) {
        // Never allow null stats
        this.stats = stats != null ? stats.copy() : new Stats();
    }


    public int getBaseHp() {
        return baseHp;
    }

    public void setBaseHp(int baseHp) {
        this.baseHp = baseHp;
    }

    public int getBaseAttack() {
        return baseAttack;
    }

    public void setBaseAttack(int baseAttack) {
        this.baseAttack = baseAttack;
    }

    public int getBaseDefense() {
        return baseDefense;
    }

    public void setBaseDefense(int baseDefense) {
        this.baseDefense = baseDefense;
    }

    public int getBaseSpAtk() {
        return baseSpAtk;
    }

    public void setBaseSpAtk(int baseSpAtk) {
        this.baseSpAtk = baseSpAtk;
    }

    public int getBaseSpDef() {
        return baseSpDef;
    }

    public void setBaseSpDef(int baseSpDef) {
        this.baseSpDef = baseSpDef;
    }

    public int getBaseSpeed() {
        return baseSpeed;
    }

    public void setBaseSpeed(int baseSpeed) {
        this.baseSpeed = baseSpeed;
    }

    public float getWidth() {
        return width;
    }

    public void setWidth(float width) {
        this.width = width;
    }

    public float getHeight() {
        return height;
    }

    public void setHeight(float height) {
        this.height = height;
    }

    public List<MoveData> getMoves() {
        return moves;
    }

    public void setMoves(List<MoveData> moves) {
        this.moves = moves != null ? new ArrayList<>(moves) : new ArrayList<>();
    }


    public PokemonData copy() {
        PokemonData copy = new PokemonData();
        copy.baseHp = this.baseHp;
        copy.baseAttack = this.baseAttack;
        copy.baseDefense = this.baseDefense;
        copy.baseSpAtk = this.baseSpAtk;
        copy.baseSpDef = this.baseSpDef;
        copy.baseSpeed = this.baseSpeed;

        if (this.tmMoves != null) {
            copy.tmMoves = new ArrayList<>(this.tmMoves);
        }

        copy.name = this.name;
        copy.currentHp = this.currentHp;
        copy.level = this.level;
        copy.nature = this.nature;
        copy.uuid = this.uuid;
        copy.primaryType = this.primaryType;
        copy.secondaryType = this.secondaryType;
        // Ensure stats are never null in copies
        copy.stats = this.stats != null ? this.stats.copy() : new Stats();


        copy.currentExperience = this.currentExperience;
        copy.experienceToNextLevel = this.experienceToNextLevel;
        if (this.moves != null) {
            copy.moves = new ArrayList<>();

            for (MoveData move : this.moves) {
                copy.moves.add(move.copy());
            }
        }

        if (this.learnableMoves != null) {
            copy.learnableMoves = new ArrayList<>(this.learnableMoves);
        }

        return copy;
    }
    public void heal(int amount) {
        if (this.stats != null) {
            this.currentHp = Math.min(this.stats.getHp(), this.currentHp + amount);
        }
    }
    private int currentHp;

    public Pokemon toPokemon() {
        if (name == null || name.isEmpty()) {
            throw new IllegalStateException("Pokemon name is missing.");
        }

        if (primaryType == null) {
            // This should never happen if setters are correctly implemented
            primaryType = Pokemon.PokemonType.NORMAL;
        }

        Pokemon pokemon = new Pokemon(name, level);
        pokemon.setUuid(uuid);
        pokemon.setNature(nature);
        pokemon.setPrimaryType(primaryType);
        pokemon.setSecondaryType(secondaryType);
        pokemon.setCurrentHp(this.currentHp);

        // Apply base stats
        pokemon.getStats().setHp(baseHp);
        pokemon.getStats().setAttack(baseAttack);
        pokemon.getStats().setDefense(baseDefense);
        pokemon.getStats().setSpecialAttack(baseSpAtk);
        pokemon.getStats().setSpecialDefense(baseSpDef);
        pokemon.getStats().setSpeed(baseSpeed);

        // Apply moves
        for (MoveData moveData : moves) {
            Move move = moveData.toMove();
            if (move != null) {
                pokemon.getMoves().add(move);
            }
        }

        return pokemon;
    }

    // Nested Stats class
    public static class Stats {
        public int hp;
        public int attack;
        public int defense;
        public int specialAttack;
        public int specialDefense;
        public int speed;
        public int[] ivs = new int[6];
        public int[] evs = new int[6];

        public Stats() {
            // Initialize with default values
            this.hp = 1;
            this.attack = 1;
            this.defense = 1;
            this.specialAttack = 1;
            this.specialDefense = 1;
            this.speed = 1;
            // Initialize IVs and EVs with zeros
            this.ivs = new int[6];
            this.evs = new int[6];
        }


        public Stats(Pokemon.Stats stats) {
            if (stats != null) {
                this.hp = stats.getHp();
                this.attack = stats.getAttack();
                this.defense = stats.getDefense();
                this.specialAttack = stats.getSpecialAttack();
                this.specialDefense = stats.getSpecialDefense();
                this.speed = stats.getSpeed();
                System.arraycopy(stats.ivs, 0, this.ivs, 0, 6);
                System.arraycopy(stats.evs, 0, this.evs, 0, 6);
            }
        }

        public int getHp() {
            return hp;
        }

        public void setHp(int hp) {
            this.hp = hp;
        }

        public int getAttack() {
            return attack;
        }

        public void setAttack(int attack) {
            this.attack = attack;
        }

        public int getDefense() {
            return defense;
        }

        public void setDefense(int defense) {
            this.defense = defense;
        }

        public int getSpecialAttack() {
            return specialAttack;
        }

        public void setSpecialAttack(int specialAttack) {
            this.specialAttack = specialAttack;
        }

        public int getSpecialDefense() {
            return specialDefense;
        }

        public void setSpecialDefense(int specialDefense) {
            this.specialDefense = specialDefense;
        }

        public int getSpeed() {
            return speed;
        }

        public void setSpeed(int speed) {
            this.speed = speed;
        }

        public Stats copy() {
            Stats copy = new Stats();
            copy.hp = this.hp;
            copy.attack = this.attack;
            copy.defense = this.defense;
            copy.specialAttack = this.specialAttack;
            copy.specialDefense = this.specialDefense;
            copy.speed = this.speed;
            copy.ivs = this.ivs.clone();
            copy.evs = this.evs.clone();
            return copy;
        }
    }

    // Nested MoveData class
    public static class MoveData {
        public String name;
        public Pokemon.PokemonType type;
        public int power;
        public int accuracy;
        public int pp;
        public int maxPp;
        public boolean isSpecial;
        public String description; // Add description field
        public MoveEffectData effect; // Add effect field
        public boolean canFlinch;

        public MoveData() {
        }

        public int getAccuracy() {
            return accuracy;
        }

        public MoveEffectData getEffect() {
            return effect;
        }

        public boolean isCanFlinch() {
            return canFlinch;
        }

        public void setAccuracy(int accuracy) {
            this.accuracy = accuracy;
        }

        public void setEffect(MoveEffectData effect) {
            this.effect = effect;
        }

        public void setCanFlinch(boolean canFlinch) {
            this.canFlinch = canFlinch;
        }

        public MoveData(String name, Pokemon.PokemonType type, int power, int accuracy, int pp, int maxPp, boolean isSpecial, String description, MoveEffectData effect, boolean canFlinch) {
            this.name = name;
            this.type = type;
            this.power = power;
            this.accuracy = accuracy;
            this.pp = pp;
            this.maxPp = maxPp;
            this.isSpecial = isSpecial;
            this.description = description;
            this.effect = effect;
            this.canFlinch = canFlinch;
        }

        public static MoveData fromMove(Move move) {
            if (move == null) return null;
            MoveData moveData = new MoveData();
            moveData.name = move.getName();
            moveData.type = move.getType();
            moveData.power = move.getPower();
            moveData.accuracy = move.getAccuracy();
            moveData.pp = move.getPp();
            moveData.maxPp = move.getMaxPp();
            moveData.isSpecial = move.isSpecial();
            moveData.description = move.getDescription();
            moveData.canFlinch = move.canFlinch();


            return moveData;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Pokemon.PokemonType getType() {
            return type;
        }

        public void setType(Pokemon.PokemonType type) {
            this.type = type;
        }

        private int currentExperience = 0;
        private int experienceToNextLevel = 0;

        // Add getters and setters
        public int getCurrentExperience() {
            return currentExperience;
        }

        public void setCurrentExperience(int experience) {
            this.currentExperience = Math.max(0, experience);
        }

        public int getExperienceToNextLevel() {
            return experienceToNextLevel;
        }

        public void setExperienceToNextLevel(int exp) {
            this.experienceToNextLevel = Math.max(0, exp);
        }

        public int getPower() {
            return power;
        }

        public void setPower(int power) {
            this.power = power;
        }

        public int getPp() {
            return pp;
        }

        public void setPp(int pp) {
            this.pp = pp;
        }

        public int getMaxPp() {
            return maxPp;
        }

        public void setMaxPp(int maxPp) {
            this.maxPp = maxPp;
        }

        public boolean isSpecial() {
            return isSpecial;
        }

        public void setSpecial(boolean special) {
            isSpecial = special;
        }

        public String getDescription() {
            return description;
        }

        public void setDescription(String description) {
            this.description = description;
        }

        public Move toMove() {
            if (name == null || name.isEmpty()) {
                GameLogger.error("Move name is missing.");
                return null;
            }

            if (type == null) {
                GameLogger.error("Move type is null for move " + name + ", setting to NORMAL.");
                type = Pokemon.PokemonType.NORMAL;
            }

            Move.Builder builder = new Move.Builder(name, type)
                .power(power)
                .accuracy(accuracy)
                .pp(pp)
                .special(isSpecial)
                .description(description)
                .canFlinch(canFlinch);

            return builder.build();
        }


        public MoveData copy() {
            return new MoveData(name, type, power, accuracy, pp, maxPp, isSpecial, description, effect, canFlinch);
        }

        public static class MoveEffectData {
            public Pokemon.Status statusEffect;
            public Map<String, Integer> statModifiers;
            public String effectType;
            public float chance;
            public String animation;
            public String sound;
            public int duration;

            public MoveEffectData(Pokemon.Status statusEffect, Map<String, Integer> statModifiers, String effectType, float chance, String animation, String sound, int duration) {
                this.statusEffect = statusEffect;
                this.statModifiers = statModifiers;
                this.effectType = effectType;
                this.chance = chance;
                this.animation = animation;
                this.sound = sound;
                this.duration = duration;
            }

            public MoveEffectData() {
            }

            public static MoveEffectData fromMoveEffect(Move.MoveEffect moveEffect) {
                if (moveEffect == null) return null;
                MoveEffectData effectData = new MoveEffectData();
                effectData.statusEffect = moveEffect.getStatusEffect();
                effectData.statModifiers = new HashMap<>(moveEffect.getStatModifiers());
                effectData.effectType = moveEffect.getEffectType();
                effectData.chance = moveEffect.getChance();
                effectData.animation = moveEffect.getAnimation();
                effectData.sound = moveEffect.getSound();
                effectData.duration = moveEffect.getDuration();
                return effectData;
            }

            public Pokemon.Status getStatusEffect() {
                return statusEffect;
            }

            public void setStatusEffect(Pokemon.Status statusEffect) {
                this.statusEffect = statusEffect;
            }

            public Map<String, Integer> getStatModifiers() {
                return statModifiers;
            }

            public void setStatModifiers(Map<String, Integer> statModifiers) {
                this.statModifiers = statModifiers;
            }

            public String getEffectType() {
                return effectType;
            }

            public void setEffectType(String effectType) {
                this.effectType = effectType;
            }

            public float getChance() {
                return chance;
            }

            public void setChance(float chance) {
                this.chance = chance;
            }

            public String getAnimation() {
                return animation;
            }

            public void setAnimation(String animation) {
                this.animation = animation;
            }

            public String getSound() {
                return sound;
            }

            public void setSound(String sound) {
                this.sound = sound;
            }

            public int getDuration() {
                return duration;
            }

            public void setDuration(int duration) {
                this.duration = duration;
            }

            public Move.MoveEffect toMoveEffect() {
                Move.MoveEffect moveEffect = new Move.MoveEffect();
                moveEffect.setStatusEffect(statusEffect);
                moveEffect.setStatModifiers(statModifiers != null ? new HashMap<>(statModifiers) : new HashMap<>());
                moveEffect.setEffectType(effectType);
                moveEffect.setChance(chance);
                moveEffect.setAnimation(animation);
                moveEffect.setSound(sound);
                moveEffect.setDuration(duration);
                return moveEffect;
            }
        }
    }

    public static class WildPokemonData implements Serializable {
        private String name;
        private int level;
        private Vector2 position;
        private String direction;
        private boolean isMoving;
        private long spawnTime;
        private Pokemon.PokemonType primaryType;
        private Pokemon.PokemonType secondaryType;
        private float currentHp;
        private Stats stats;
        private List<MoveData> moves;
        private UUID uuid;

        public WildPokemonData() {
            this.position = new Vector2();
            this.stats = new Stats();
            this.moves = new ArrayList<>();
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getLevel() {
            return level;
        }

        public void setLevel(int level) {
            this.level = level;
        }

        public Vector2 getPosition() {
            return position;
        }

        public void setPosition(Vector2 position) {
            this.position = position;
        }

        public String getDirection() {
            return direction;
        }

        public void setDirection(String direction) {
            this.direction = direction;
        }

        public boolean isMoving() {
            return isMoving;
        }

        public void setMoving(boolean moving) {
            isMoving = moving;
        }

        public long getSpawnTime() {
            return spawnTime;
        }

        public void setSpawnTime(long spawnTime) {
            this.spawnTime = spawnTime;
        }

        public Pokemon.PokemonType getPrimaryType() {
            return primaryType;
        }

        public void setPrimaryType(Pokemon.PokemonType type) {
            this.primaryType = type;
        }

        public Pokemon.PokemonType getSecondaryType() {
            return secondaryType;
        }

        public void setSecondaryType(Pokemon.PokemonType type) {
            this.secondaryType = type;
        }

        public float getCurrentHp() {
            return currentHp;
        }

        public void setCurrentHp(float hp) {
            this.currentHp = hp;
        }

        public Stats getStats() {
            return stats;
        }

        public void setStats(Stats stats) {
            this.stats = stats;
        }

        public List<MoveData> getMoves() {
            return moves;
        }

        public void setMoves(List<MoveData> moves) {
            this.moves = moves;
        }

        public UUID getUuid() {
            return uuid;
        }

        public void setUuid(UUID uuid) {
            this.uuid = uuid;
        }
    }

    public static class MoveEffectData {
        private String type;
        private float chance;
        private Pokemon.Status status;
        private Map<String, Integer> statChanges = new HashMap<>();

        public MoveEffectData(String type, float chance) {
            this.type = type;
            this.chance = chance;
        }

        public String getType() {
            return type;
        }


        public Pokemon.Status getStatus() {
            return status;
        }

        public void setStatus(Pokemon.Status status) {
            this.status = status;
        }

        public void setStatChanges(Map<String, Integer> changes) {
            this.statChanges = changes;
        }
    }
}

================
File: main/java/io/github/pokemeetup/system/data/WorldData.java
================
package io.github.pokemeetup.system.data;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Json;
import io.github.pokemeetup.multiplayer.server.ServerStorageSystem;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.JsonConfig;

import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class WorldData {

    private final Object timeLock = new Object();
    private final Object saveLock = new Object();
    private final Map<UUID, WildPokemon> wildPokemonMap = new ConcurrentHashMap<>();
    private final Map<Vector2, List<WorldObject>> chunkObjects;
    private double worldTimeInMinutes = 480.0;
    private long playedTime = 0L;
    private float dayLength = 10.0f;
    private PokemonData pokemonData;
    private String name;
    private Set<UUID> playerUUIDs;
    private long lastPlayed;
    private WorldConfig config;
    private boolean isDirty;
    private BlockSaveData blockData;
    private Map<Vector2, Chunk> chunks;
    private HashMap<String, PlayerData> players;
    private String username;
    private Map<Vector2, List<WorldObject>> dynamicObjects;
    private boolean commandsAllowed = false;

    public WorldData(String name) {
        this();
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("World name cannot be null or empty");
        }
        this.name = name.trim();
    }

    public WorldData() {
        this.playerUUIDs = new HashSet<>();
        this.players = new HashMap<>();
        this.pokemonData = new PokemonData();
        this.lastPlayed = System.currentTimeMillis();
        this.chunks = new HashMap<>();
        this.chunkObjects = new HashMap<>();
        this.commandsAllowed = false;
    }

    public WorldData(String name, long lastPlayed, WorldConfig config) {
        this();
        this.name = name;
        this.pokemonData = new PokemonData();
        this.lastPlayed = lastPlayed;
        this.config = config;
        this.commandsAllowed = false;
    }

    public WorldData(String name, long lastPlayed, WorldConfig config, String username) {
        this(name, lastPlayed, config);
        this.username = username;
        this.commandsAllowed = false;
    }


    public static WorldData fromJson(String jsonStr) {
        try {
            Json json = JsonConfig.getInstance();
            return json.fromJson(WorldData.class, jsonStr);
        } catch (Exception e) {
            GameLogger.error("Failed to parse WorldData from JSON: " + e.getMessage());
            return null;
        }
    }

    public WorldData copy() {
        WorldData copy = new WorldData(this.name);
        synchronized (saveLock) {
            // Copy core settings
            copy.commandsAllowed = this.commandsAllowed;
            copy.worldTimeInMinutes = this.worldTimeInMinutes;
            copy.playedTime = this.playedTime;
            copy.dayLength = this.dayLength;
            copy.lastPlayed = this.lastPlayed;
            copy.isDirty = this.isDirty;
            copy.username = this.username;

            // Copy config
            if (this.config != null) {
                WorldConfig configCopy = new WorldConfig(this.config.getSeed());
                configCopy.setTreeSpawnRate(this.config.getTreeSpawnRate());
                configCopy.setPokemonSpawnRate(this.config.getPokemonSpawnRate());
                configCopy.setTileSpawnX(this.config.getTileSpawnX());
                configCopy.setTileSpawnY(this.config.getTileSpawnY());
                copy.config = configCopy;
            }
            if (this.players != null) {
                HashMap<String, PlayerData> playersCopy = new HashMap<>();
                for (Map.Entry<String, PlayerData> entry : this.players.entrySet()) {
                    playersCopy.put(entry.getKey(), entry.getValue().copy());
                }
                copy.setPlayers(playersCopy);
            } else {
                copy.setPlayers(new HashMap<>());
            }
            // Copy player UUIDs
            if (this.playerUUIDs != null) {
                copy.playerUUIDs = new HashSet<>(this.playerUUIDs);
            }

            // Copy Pokemon data
            if (this.pokemonData != null) {
                copy.pokemonData = this.pokemonData.copy();
            }

            // Copy block data if exists
            if (this.blockData != null) {
                copy.blockData = this.blockData.copy();
            }

            // Copy chunk references (chunks themselves are managed separately)
            if (this.chunks != null) {
                copy.chunks = new HashMap<>(this.chunks);
            }

            // Deep copy chunk objects
            if (this.chunkObjects != null) {
                copy.dynamicObjects = new HashMap<>();
                for (Map.Entry<Vector2, List<WorldObject>> entry : this.chunkObjects.entrySet()) {
                    List<WorldObject> objectsCopy = new ArrayList<>();
                    for (WorldObject obj : entry.getValue()) {
                        objectsCopy.add(obj.copy());
                    }
                    copy.dynamicObjects.put(entry.getKey().cpy(), objectsCopy);
                }
            }


            return copy;
        }
    }

    public Map<Vector2, Chunk> getChunks() {
        return chunks;
    }


    public Map<Vector2, List<WorldObject>> getChunkObjects() {
        return chunkObjects;
    }

    public double getWorldTimeInMinutes() {
        synchronized (timeLock) {
            return worldTimeInMinutes;
        }
    }

    public void setWorldTimeInMinutes(double time) {
        synchronized (timeLock) {
            this.worldTimeInMinutes = time;
            GameLogger.info("Set world time to: " + time);
        }
    }

    public long getPlayedTime() {
        synchronized (timeLock) {
            return playedTime;
        }
    }

    public void setPlayedTime(long time) {
        synchronized (timeLock) {
            this.playedTime = time;
            GameLogger.info("Set played time to: " + time);
        }
    }

    public void validateAndRepairWorld() {
        if (this.players == null) {
            this.players = new HashMap<>();
            isDirty = true;
        }
        if (this.pokemonData == null) {
            this.pokemonData = new PokemonData();
            setDirty(true);
        }

        // Validate Pokemon in player data
        if (players != null) {
            for (PlayerData player : players.values()) {
                if (player.getPartyPokemon() != null) {
                    List<PokemonData> validPokemon = new ArrayList<>();
                    for (PokemonData pokemon : player.getPartyPokemon()) {
                        if (pokemon != null) {
                            validPokemon.add(pokemon);
                            setDirty(true);
                        }
                    }
                    if (!validPokemon.isEmpty()) {
                        player.setPartyPokemon(validPokemon);
                    }
                }
            }
        }
    }

    public void validateAndRepair() {
        synchronized (timeLock) {
            if (worldTimeInMinutes < 0 || worldTimeInMinutes >= 24 * 60) {
                GameLogger.error("Repairing invalid world time: " + worldTimeInMinutes);
                worldTimeInMinutes = 480.0;
            }

            if (dayLength <= 0) {
                GameLogger.error("Repairing invalid day length: " + dayLength);
                dayLength = 10.0f;
            }

            if (playedTime < 0) {
                GameLogger.error("Repairing invalid played time: " + playedTime);
                playedTime = 0;
            }
        }

        if (blockData == null) {
            GameLogger.error("blockData is null during validation. Blocks may not be loaded correctly.");
        }

        // Validate players data
        if (players != null) {
            for (Map.Entry<String, PlayerData> entry : players.entrySet()) {
                PlayerData playerData = entry.getValue();
                if (playerData.getInventoryItems() == null) {
                    playerData.setInventoryItems(new ArrayList<>());
                }

                // Validate each inventory item
                for (int i = 0; i < playerData.getInventoryItems().size(); i++) {
                    ItemData item = playerData.getInventoryItems().get(i);
                    if (item != null && item.getUuid() == null) {
                        item.setUuid(UUID.randomUUID());
                        GameLogger.info("Generated new UUID for item: " + item.getItemId());
                    }
                }
            }
        }
    }

    public void save() {
        synchronized (saveLock) {
            try {
                GameLogger.info("Saving world data - Time: " + worldTimeInMinutes +
                    " Played Time: " + playedTime +
                    " Day Length: " + dayLength);

                setDirty(true);
                WorldManager worldManager = WorldManager.getInstance();
                worldManager.saveWorld(this);

                GameLogger.info("Successfully saved world: " + name);

            } catch (Exception e) {
                GameLogger.error("Failed to save world: " + name + " - " + e.getMessage());
            }
        }
    }

    public void save(boolean createBackup) {
        synchronized (saveLock) {
            try {
                validateAndRepairWorld();
                if (createBackup) {
                    String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
                    String backupName = name + "_backup_" + timestamp;

                    WorldData backup = new WorldData(backupName);
                    backup.setConfig(this.config);
                    backup.setWorldTimeInMinutes(this.worldTimeInMinutes);
                    backup.setPlayedTime(this.playedTime);
                    backup.setDayLength(this.dayLength);
                    backup.setPlayers(new HashMap<>(this.players));
                    backup.setBlockData(this.blockData);
                    // Save backup
                    WorldManager.getInstance().saveWorld(backup);
                    GameLogger.info("Created backup of world: " + name);
                }
                save();

            } catch (Exception e) {
                GameLogger.error("Failed to save world with backup: " + name + " - " + e.getMessage());
            }
        }
    }

    public boolean commandsAllowed() {
        return commandsAllowed;
    }

    public void setCommandsAllowed(boolean commandsAllowed) {
        synchronized (saveLock) {
            this.commandsAllowed = commandsAllowed;
            isDirty = true;
            GameLogger.info("Commands " + (commandsAllowed ? "enabled" : "disabled") +
                " for world: " + name);
        }
    }

    public void save(boolean createBackup, ServerStorageSystem storage) {
        synchronized (saveLock) {
            try {
                validateAndRepairWorld();
                if (createBackup) {
                    String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
                    String backupName = name + "_backup_" + timestamp;

                    WorldData backup = new WorldData(backupName);
                    backup.setConfig(this.config);
                    backup.setWorldTimeInMinutes(this.worldTimeInMinutes);
                    backup.setPlayedTime(this.playedTime);
                    backup.setDayLength(this.dayLength);
                    backup.setPlayers(new HashMap<>(this.players));
                    backup.setBlockData(this.blockData);

                    WorldManager.getInstance().saveWorld(backup);
                    GameLogger.info("Created backup of world: " + name);
                }
                save();

            } catch (Exception e) {
                GameLogger.error("Failed to save world with backup: " + name + " - " + e.getMessage());
            }
        }
    }

    public void addChunkObjects(Vector2 position, List<WorldObject> objects) {
        chunkObjects.put(position, new ArrayList<>(objects));
    }

    public Object getTimeLock() {
        return timeLock;
    }


    public void updateTime(float deltaTime) {
        synchronized (timeLock) {
            long deltaMillis = (long) (deltaTime * 1000);
            playedTime += deltaMillis;
            double gameMinutesPerSecond = (24 * 60.0) / (dayLength * 60.0);
            double timeToAdd = deltaTime * gameMinutesPerSecond;

            worldTimeInMinutes = (worldTimeInMinutes + timeToAdd) % (24 * 60);


        }
    }

    public float getDayLength() {
        return dayLength;
    }

    public void setDayLength(float dayLength) {
        this.dayLength = dayLength;
    }


    public PokemonData getPokemonData() {
        return pokemonData;
    }

    public void setPokemonData(PokemonData pokemonData) {
        this.pokemonData = pokemonData;
    }

    public BlockSaveData getBlockData() {
        return blockData;
    }

    public void setBlockData(BlockSaveData blockData) {
        this.blockData = blockData;
    }



    public PlayerData getLegacyPlayerData(String username) {
        synchronized (saveLock) {
            PlayerData data = players.get(username);
            if (data != null) {
                return data.copy();
            }
            return null;
        }
    }

    public void savePlayerData(String username, PlayerData data, boolean isMultiplayer) {
        if (isMultiplayer) {
            // Multiplayer mode logic (just store UUID reference)
        } else {
            // Singleplayer mode: store actual data
            if (data != null && username != null) {
                this.players.put(username, data.copy());
                this.isDirty = true;
            }
        }
    }


    public PlayerData getPlayerData(String username, boolean isMultiplayer) {
        if (isMultiplayer) {
            // In multiplayer mode, this should not be used directly
            // Instead, use ServerStorageSystem to get player data
            GameLogger.error("Attempted to get player data directly in multiplayer mode");
            return null;
        } else {
            return getLegacyPlayerData(username);
        }
    }

    public WorldConfig getConfig() {
        return config;
    }

    public void setConfig(WorldConfig config) {
        synchronized (saveLock) {
            this.config = config;
            isDirty = true;
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        synchronized (saveLock) {
            if (name == null || name.trim().isEmpty()) {
                throw new IllegalArgumentException("World name cannot be null or empty");
            }
            this.name = name.trim();
            setDirty(true);
        }
    }

    public long getLastPlayed() {
        return lastPlayed;
    }

    public void setLastPlayed(long lastPlayed) {
        synchronized (saveLock) {
            this.lastPlayed = lastPlayed;
            isDirty = true;
        }
    }

    public Map<String, PlayerData> getPlayers() {
        if (players != null) {
            return Collections.unmodifiableMap(players);
        }
        return null;
    }

    public void setPlayers(HashMap<String, PlayerData> players) {
        this.players = players;
    }


    public void removeWildPokemon(UUID uuid) {
        wildPokemonMap.remove(uuid);
        if (pokemonData != null) {
            pokemonData.removeWildPokemon(uuid);
        }
    }

    // Now, update the Ga
    public boolean isDirty() {
        return isDirty;
    }

    public void setDirty(boolean dirty) {
        isDirty = dirty;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        synchronized (saveLock) {
            this.username = username;
            isDirty = true;
        }
    }


    @Override
    public String toString() {
        return "WorldData{" +
            "name='" + name + '\'' +
            ", players=" + players.size() +
            ", lastPlayed=" + lastPlayed +
            ", username='" + username + '\'' +
            '}';
    }

    public static class WorldConfig {
        private long seed;
        private float treeSpawnRate = 0.15f;
        private float pokemonSpawnRate = 0.05f;
        ;
        private int tileSpawnX;
        ;
        private int tileSpawnY;

        public WorldConfig() {
        }

        public WorldConfig(long seed) {
            this.seed = seed;
        }

        // Getters and Setters
        public long getSeed() {
            return seed;
        }

        public void setSeed(long seed) {
            this.seed = seed;
        }

        public int getTileSpawnX() {
            return tileSpawnX;
        }

        public void setTileSpawnX(int tileSpawnX) {
            this.tileSpawnX = tileSpawnX;
        }

        public int getTileSpawnY() {
            return tileSpawnY;
        }

        public void setTileSpawnY(int tileSpawnY) {
            this.tileSpawnY = tileSpawnY;
        }

        public float getTreeSpawnRate() {
            return treeSpawnRate;
        }

        public void setTreeSpawnRate(float rate) {
            this.treeSpawnRate = rate;
        }

        public float getPokemonSpawnRate() {
            return pokemonSpawnRate;
        }

        public void setPokemonSpawnRate(float rate) {
            this.pokemonSpawnRate = rate;
        }
    }

    public static class WorldObjectData implements Serializable {
        public String type;
        public float x, y;
        public String id;
        // Add other object properties
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/CharacterAnimations.java
================
package io.github.pokemeetup.system.gameplay;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.*;

public class CharacterAnimations {  private static final int SOURCE_SPRITE_SIZE = 32;
    private static final int FRAMES_PER_SKIN = 8; // 8 columns per skin tone
    private static final int DIRECTIONS_PER_ROW = 4; // 4 directions (DOWN, LEFT, RIGHT, UP)


    private static final float DEFAULT_FRAME_DURATION = 0.15f;

    // Animation durations
    private static final float WALK_DURATION = 0.125f;  // 8 frames per tile
    private static final float RUN_DURATION = 0.1f;
    private static final float EMOTE_DURATION = 0.25f;
    private static final float ACTION_DURATION = 0.15f;

    private final Map<String, Animation<TextureRegion>> animations;
    private final Map<String, Map<String, Animation<TextureRegion>>> clothingAnimations;

    private final Map<String, Animation<TextureRegion>> hairAnimations;
    private int currentSkinTone = 0;


    public enum HairStyle {
        BOB("bob"),
        BRAIDS("braids"),
        EXTRA_LONG("extra_long"),
        EXTRA_LONG_SKIRT("extra_long_skirt"),
        FRENCH_CURL("french_curl"),
        GENTLEMAN("gentleman"),
        LONG_STRAIGHT("long_straight"),
        PONYTAIL("ponytail"),
        SPACEBUNS("spacebuns"),
        WAVY("wavy"),
        BUZZCUT("buzzcut"),
        CURLY("curly"),
        EMO("emo"),
        LONG_STRAIGHT_SKIRT("long_straight_skirt"),
        MIDIWAVE("midiwave");

        final String atlasKey;

        HairStyle(String atlasKey) {
            this.atlasKey = atlasKey;
        }
    }

    private final TextureAtlas hairAtlas;
    private static final float LONG_EMOTE_DURATION = 0.2f;
    private static final int IDLE_ROW = 0;
    private static final int WALK_ROW = 1;
    private static final int RUN_ROW = 2;
    private static final int SPRITE_SIZE = 32;
    private final TextureAtlas characterAtlas;
    private final Map<String, TextureRegion> directionalFrames;
    private final Map<String, Animation<TextureRegion>> walkAnimations;
    private final Map<String, Animation<TextureRegion>> runAnimations;
    private List<OutfitLayer> activeOutfitLayers = new ArrayList<>();
    public CharacterAnimations(TextureAtlas atlas) {
        this.characterAtlas = atlas;
        this.hairAtlas = TextureManager.hairstyles;
        this.walkAnimations = new HashMap<>();
        this.runAnimations = new HashMap<>();
        this.directionalFrames = new HashMap<>();
        this.clothingAnimations = new HashMap<>();
        this.hairAnimations = new HashMap<>();
        this.animations = new HashMap<>();
        initializeFrames();
        initializeAnimations();
        initializeDirectionalFrames();
    }
    public void render(SpriteBatch batch, float x, float y, float width, float height,
                       CharacterAction action, Direction dir, float stateTime) {
        // Base character
        TextureRegion baseFrame = getFrame(action, dir, stateTime);
        if (baseFrame != null) {
            batch.draw(baseFrame, x, y, width, height);
        }

        // Clothing layers (sorted by z-index)
        for (OutfitLayer layer : activeOutfitLayers) {
            TextureRegion clothing = getClothingOverlayForType(
                layer.type, action, dir, stateTime);
            if (clothing != null) {
                batch.draw(clothing, x, y, width, height);
            }
        }

        // Hair on top
        TextureRegion hair = getHairFrame(action, dir, stateTime);
        if (hair != null) {
            batch.draw(hair, x, y, width, height);
        }
    }


    private void initializeAnimations() {
        TextureRegion fullSheet = characterAtlas.findRegion("char_all");
        if (fullSheet == null) {
            GameLogger.error("Failed to load character sprite sheet!");
            return;
        }

        // Clear existing animations
        animations.clear();
        clothingAnimations.clear();
        hairAnimations.clear();

        // Initialize for each action and direction
        for (CharacterAction action : CharacterAction.values()) {
            for (Direction dir : Direction.values()) {
                String key = getAnimationKey(action, dir);
                Animation<TextureRegion> anim = createAnimation(fullSheet, action, dir);
                animations.put(key, anim);
            }
        }

        // Initialize hair animations if hair style is set
        if (currentHairStyle != null) {
            initializeHairAnimations();
        }
    }

    public TextureRegion getFrame(CharacterAction action, Direction dir, float stateTime) {
        // Special handling for IDLE
        if (action == CharacterAction.IDLE) {
            return getDirectionalFrame(dir);
        }

        String key = getAnimationKey(action, dir);
        Animation<TextureRegion> animation = animations.get(key);

        if (animation == null) {
            return getDefaultFrame();
        }

        return animation.getKeyFrame(stateTime,
            action == CharacterAction.WALK || action == CharacterAction.RUN);
    }
    private Animation<TextureRegion> createAnimation(TextureRegion sheet,
                                                     CharacterAction action,
                                                     Direction dir) {
        TextureRegion[] frames = new TextureRegion[action.frameCount];

        for (int i = 0; i < action.frameCount; i++) {
            int frameIndex = action.startFrame + i;
            frames[i] = getFrameFromSheet(sheet, currentSkinTone, frameIndex, dir);
        }

        Animation<TextureRegion> animation = new Animation<>(action.frameDuration, frames);

        // Loop only walking and running
        if (action == CharacterAction.WALK || action == CharacterAction.RUN) {
            animation.setPlayMode(Animation.PlayMode.LOOP);
        } else {
            animation.setPlayMode(Animation.PlayMode.NORMAL);
        }

        return animation;
    }


    private TextureRegion getClothingOverlayForType(String clothingType,
                                                    CharacterAction action,
                                                    Direction dir,
                                                    float stateTime) {
        TextureRegion clothingSheet = TextureManager.clothing.findRegion(clothingType);
        if (clothingSheet == null) return null;

        // For IDLE, use the first frame of the walking animation
        if (action == CharacterAction.IDLE) {
            return new TextureRegion(
                clothingSheet,
                currentSkinTone * (SOURCE_SPRITE_SIZE * 8),  // Use first frame
                dir.rowOffset * SOURCE_SPRITE_SIZE,
                SOURCE_SPRITE_SIZE,
                SOURCE_SPRITE_SIZE
            );
        }

        // For running animations, ensure we're using the correct offset
        int frameIndex = getFrameIndexForAction(action, stateTime);
        int frameX = (currentSkinTone * (SOURCE_SPRITE_SIZE * 8)) +
            ((action.startFrame + frameIndex) * SOURCE_SPRITE_SIZE);

        return new TextureRegion(
            clothingSheet,
            frameX,
            dir.rowOffset * SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE
        );
    }


    private int getFrameIndexForAction(CharacterAction action, float stateTime) {
        if (action == CharacterAction.IDLE) {
            return 0;
        }

        float animationTime = stateTime % (action.frameCount * action.frameDuration);
        int frameIndex = (int) (animationTime / action.frameDuration);
        return frameIndex % action.frameCount;
    }
    private TextureRegion getHairFrame(CharacterAction action, Direction dir, float stateTime) {
        if (currentHairStyle == null) return null;

        TextureRegion hairSheet = TextureManager.hairstyles.findRegion(currentHairStyle.atlasKey);
        if (hairSheet == null) return null;

        // For IDLE, use the first frame
        if (action == CharacterAction.IDLE) {
            return new TextureRegion(
                hairSheet,
                currentSkinTone * (SOURCE_SPRITE_SIZE * 8),
                dir.rowOffset * SOURCE_SPRITE_SIZE,
                SOURCE_SPRITE_SIZE,
                SOURCE_SPRITE_SIZE
            );
        }

        int frameIndex = getFrameIndexForAction(action, stateTime);
        int frameX = (currentSkinTone * (SOURCE_SPRITE_SIZE * 8)) +
            ((action.startFrame + frameIndex) * SOURCE_SPRITE_SIZE);

        return new TextureRegion(
            hairSheet,
            frameX,
            dir.rowOffset * SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE
        );
    }

    private void initializeHairAnimations() {
        TextureRegion hairSheet = hairAtlas.findRegion(currentHairStyle.atlasKey);
        if (hairSheet == null) {
            GameLogger.error("Failed to load hair style: " + currentHairStyle.atlasKey);
            return;
        }

        for (CharacterAction action : CharacterAction.values()) {
            for (Direction dir : Direction.values()) {
                String key = getAnimationKey(action, dir);
                Animation<TextureRegion> anim = createHairAnimation(hairSheet, action, dir);
                hairAnimations.put(key, anim);
            }
        }
    }
    public TextureRegion getClothingOverlay(String clothingType, CharacterAction action,
                                            Direction dir, float stateTime) {
        if (clothingType == null) return null;

        TextureRegion clothingSheet = TextureManager.clothing.findRegion(clothingType);
        if (clothingSheet == null) return null;

        // Match the same frame as the character animation
        Animation<TextureRegion> baseAnim = animations.get(getAnimationKey(action, dir));
        if (baseAnim == null) return null;

        int frameIndex = baseAnim.getKeyFrameIndex(stateTime);

        return new TextureRegion(
            clothingSheet,
            currentSkinTone * (SOURCE_SPRITE_SIZE * 8) + (frameIndex * SOURCE_SPRITE_SIZE),
            dir.rowOffset * SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE
        );
    }


    private Animation<TextureRegion> createHairAnimation(TextureRegion sheet,
                                                         CharacterAction action,
                                                         Direction dir) {
        TextureRegion[] frames = new TextureRegion[action.frameCount];

        int startX = currentSkinTone * (SOURCE_SPRITE_SIZE * 8);
        int startY = dir.rowOffset * SOURCE_SPRITE_SIZE;

        for (int i = 0; i < action.frameCount; i++) {
            int frameX = startX + ((action.startFrame + i) * SOURCE_SPRITE_SIZE);
            frames[i] = new TextureRegion(sheet,
                frameX,
                startY,
                SOURCE_SPRITE_SIZE,
                SOURCE_SPRITE_SIZE);
        }

        Animation<TextureRegion> animation = new Animation<>(action.frameDuration, frames);
        if (action == CharacterAction.WALK || action == CharacterAction.RUN) {
            animation.setPlayMode(Animation.PlayMode.LOOP);
        }

        return animation;
    }

    public void setHairStyle(HairStyle style) {
        if (style != currentHairStyle) {
            currentHairStyle = style;
            initializeHairAnimations();
            GameLogger.info("Changed hair style to: " + style.name());
        }
    }

    private HairStyle currentHairStyle;


    private void initializeDirectionalFrames() {
        TextureRegion fullSheet = characterAtlas.findRegion("char_all");
        if (fullSheet == null) {
            GameLogger.error("Failed to load character sprite sheet!");
            return;
        }

        // For each direction, get the standing frame
        for (Direction dir : Direction.values()) {
            // Calculate base position in sprite sheet
            int x = currentSkinTone * (SPRITE_SIZE * 8); // 8 frames per skin tone
            int y = dir.rowOffset * SPRITE_SIZE;

            // Create frame for this direction
            TextureRegion frame = new TextureRegion(
                fullSheet,
                x,
                y,
                SPRITE_SIZE,
                SPRITE_SIZE
            );

            directionalFrames.put(dir.name(), frame);
        }
    }

    // Helper method to get clothing overlay for a direction
    public TextureRegion getClothingOverlay(Direction dir, String clothingType, TextureAtlas clothingAtlas) {
        if (clothingType == null || clothingAtlas == null) return null;

        TextureRegion clothingSheet = clothingAtlas.findRegion(clothingType);
        if (clothingSheet == null) return null;

        // Match clothing coordinates to character coordinates
        return new TextureRegion(
            clothingSheet,
            currentSkinTone * (SPRITE_SIZE * 8),
            dir.rowOffset * SPRITE_SIZE,
            SPRITE_SIZE,
            SPRITE_SIZE
        );
    }


    private float getFrameDuration(CharacterAction action) {
        switch (action) {
            case WALK:
                return WALK_DURATION;
            case RUN:
                return RUN_DURATION;
            default:
                return ACTION_DURATION;
        }
    }

    public TextureRegion getFrame(Direction dir, boolean isMoving, boolean isRunning, float stateTime) {
        if (isMoving) {
            Animation<TextureRegion> animation = isRunning ?
                runAnimations.get(dir.name()) :
                walkAnimations.get(dir.name());
            return animation != null ? animation.getKeyFrame(stateTime, true) : getDirectionalFrame(dir);
        }
        return getDirectionalFrame(dir);
    }




    public List<TextureRegion> getClothingOverlays(CharacterAction action, Direction dir, float stateTime) {
        List<TextureRegion> overlays = new ArrayList<>();

        for (OutfitLayer layer : activeOutfitLayers) {
            TextureRegion overlay = getClothingOverlayForType(layer.type, action, dir, stateTime);
            if (overlay != null) {
                overlays.add(overlay);
            }
        }

        return overlays;
    }




    public static class OutfitLayer {
        public final String type;
        public final int zIndex;

        public OutfitLayer(String type, int zIndex) {
            this.type = type;
            this.zIndex = zIndex;
        }
    }


    public void addOutfitLayer(String outfitType, int zIndex) {
        activeOutfitLayers.add(new OutfitLayer(outfitType, zIndex));
        // Sort layers by z-index (lower numbers render first)
        activeOutfitLayers.sort(Comparator.comparingInt(layer -> layer.zIndex));
    }

    public void removeOutfitLayer(String outfitType) {
        activeOutfitLayers.removeIf(layer -> layer.type.equals(outfitType));
    }

    public void clearOutfitLayers() {
        activeOutfitLayers.clear();
    }

    private TextureRegion getClothingOverlayForType(Direction dir, String clothingType,
                                                    TextureAtlas clothingAtlas, boolean isMoving,
                                                    boolean isRunning, float stateTime) {
        if (clothingType == null || clothingAtlas == null) return null;

        TextureRegion clothingSheet = clothingAtlas.findRegion(clothingType);
        if (clothingSheet == null) return null;

        int rowOffset = dir.rowOffset;
        if (isMoving) {
            rowOffset += isRunning ? (RUN_ROW * 4) : (WALK_ROW * 4);
        }

        int frameIndex = 0;
        if (isMoving) {
            float duration = isRunning ? RUN_DURATION : WALK_DURATION;
            frameIndex = (int) ((stateTime % (duration * 4)) / duration);
        }

        return new TextureRegion(
            clothingSheet,
            currentSkinTone * (SOURCE_SPRITE_SIZE * 8) + (frameIndex * SOURCE_SPRITE_SIZE),
            rowOffset * SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE
        );
    }

    private TextureRegion getDirectionalFrame(Direction dir) {
        return directionalFrames.getOrDefault(dir.name(), directionalFrames.get(Direction.DOWN.name()));
    }



    private void initializeFrames() {
        TextureRegion fullSheet = characterAtlas.findRegion("char_all");
        if (fullSheet == null) {
            GameLogger.error("Failed to load character sprite sheet!");
            return;
        }

        for (Direction dir : Direction.values()) {
            initializeDirectionFrames(fullSheet, dir);
        }
    }

    public TextureRegion getFrame(Direction dir, boolean isMoving, float stateTime) {
        if (isMoving) {
            Animation<TextureRegion> walkAnim = walkAnimations.get(dir.name());
            return walkAnim != null ? walkAnim.getKeyFrame(stateTime, true) : getDirectionalFrame(dir);
        }
        return getDirectionalFrame(dir);
    }
    public void dispose() {
        animations.clear();
        clothingAnimations.clear();
        directionalFrames.clear();
        walkAnimations.clear();
        runAnimations.clear();
        activeOutfitLayers.clear();
    }

    private void initializeDirectionFrames(TextureRegion fullSheet, Direction dir) {
        int baseX = currentSkinTone * (SOURCE_SPRITE_SIZE * 8);

        // Standing frame (first frame of idle row)
        TextureRegion standingFrame = new TextureRegion(
            fullSheet,
            baseX,
            (dir.rowOffset + IDLE_ROW * 4) * SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE
        );
        directionalFrames.put(dir.name(), standingFrame);

        // Walking animation
        TextureRegion[] walkFrames = createAnimationFrames(
            fullSheet,
            baseX,
            (dir.rowOffset + WALK_ROW * 4) * SOURCE_SPRITE_SIZE,
            4
        );
        walkAnimations.put(dir.name(), new Animation<>(WALK_DURATION, walkFrames));

        // Running animation
        TextureRegion[] runFrames = createAnimationFrames(
            fullSheet,
            baseX,
            (dir.rowOffset + RUN_ROW * 4) * SOURCE_SPRITE_SIZE,
            4
        );
        runAnimations.put(dir.name(), new Animation<>(RUN_DURATION, runFrames));
    }

    private TextureRegion[] createAnimationFrames(TextureRegion sheet, int baseX, int baseY, int frameCount) {
        TextureRegion[] frames = new TextureRegion[frameCount];
        for (int i = 0; i < frameCount; i++) {
            frames[i] = new TextureRegion(
                sheet,
                baseX + (i * SOURCE_SPRITE_SIZE),
                baseY,
                SOURCE_SPRITE_SIZE,
                SOURCE_SPRITE_SIZE
            );
        }
        return frames;
    }
    private String getAnimationKey(CharacterAction action, Direction dir) {
        return action.name() + "_" + dir.name();
    }

    public TextureRegion getClothingOverlay(Direction dir, String clothingType, TextureAtlas clothingAtlas, boolean isMoving, float stateTime) {
        if (clothingType == null || clothingAtlas == null) return null;

        TextureRegion clothingSheet = clothingAtlas.findRegion(clothingType);
        if (clothingSheet == null) return null;

        int frameIndex = isMoving ?
            (int) ((stateTime % (WALK_DURATION * 4)) / WALK_DURATION) : 0;

        return new TextureRegion(
            clothingSheet,
            currentSkinTone * (SOURCE_SPRITE_SIZE * 8) + (frameIndex * SOURCE_SPRITE_SIZE),
            dir.rowOffset * SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE,
            SOURCE_SPRITE_SIZE
        );
    }

    private TextureRegion getDefaultFrame() {
        return getFrame(CharacterAction.WALK, Direction.DOWN, 0);
    }

    public enum Direction {
        DOWN(0), UP(1), RIGHT(2), LEFT(3);

        final int rowOffset;

        Direction(int rowOffset) {
            this.rowOffset = rowOffset;
        }
    }   private TextureRegion getFrameFromSheet(TextureRegion sheet, int skinIndex,
                                                int frameIndex, Direction dir) {
        // Calculate position in sprite sheet
        int x = (skinIndex * FRAMES_PER_SKIN + frameIndex) * SOURCE_SPRITE_SIZE;
        int y = dir.rowOffset * SOURCE_SPRITE_SIZE;

        return new TextureRegion(sheet, x, y, SOURCE_SPRITE_SIZE, SOURCE_SPRITE_SIZE);
    }

    public void setSkinTone(int toneIndex) {
        if (toneIndex >= 0 && toneIndex < 8) {
            this.currentSkinTone = toneIndex;
            initializeAnimations();
        }
    }    public enum CharacterAction {
        IDLE(0, 1, 0f),              // Single frame, first frame of walk animation
        WALK(0, 8, 0.125f),          // Walking animation starts at same position
        RUN(8, 5, 0.1f),
        EMOTE(13, 4, 0.25f),
        LONG_EMOTE(17, 8, 0.2f),
        SWORD(25, 5, 0.15f),
        SHIELD(30, 4, 0.15f),
        SIT(34, 2, 0.25f),
        SLEEP(36, 2, 0.5f),
        PICKAXE(38, 5, 0.15f),
        AXE(43, 5, 0.15f),
        WATER(48, 2, 0.25f),
        FARM(50, 5, 0.15f),
        TORCH(55, 5, 0.15f);

        final int startFrame;
        final int frameCount;
        final float frameDuration;

        CharacterAction(int startFrame, int frameCount, float frameDuration) {
            this.startFrame = startFrame;
            this.frameCount = frameCount;
            this.frameDuration = frameDuration;
        }
    }

}

================
File: main/java/io/github/pokemeetup/system/gameplay/CharacterCustomization.java
================
package io.github.pokemeetup.system.gameplay;

import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.FrameBuffer;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

public class CharacterCustomization {
    public enum ClothingType {
        NONE(""),
        BASIC("basic"),
        DRESS("dress"),
        FLORAL("floral"),
        OVERALLS("overalls"),
        PANTS("pants"),
        PANTS_SUIT("pants_suit"),
        SAILOR("sailor"),
        SAILOR_BOW("sailor_bow"),
        SKIRT("skirt"),
        SKULL("skull"),
        SPAGHETTI("spaghetti"),
        SPORTY("sporty"),
        STRIPE("stripe"),
        SUIT("suit"),
        WITCH("witch"),
        CLOWN("clown"),
        PUMPKIN("pumpkin");

        private final String atlasKey;

        ClothingType(String atlasKey) {
            this.atlasKey = atlasKey;
        }

        public String getAtlasKey() {
            return atlasKey;
        }
    }

    private final TextureAtlas characterAtlas = TextureManager.characters;
    private final int SKIN_COLUMN_WIDTH = 256; // 4 frames per row
    private final TextureAtlas clothingAtlas = TextureManager.clothing;
    private ClothingType currentOutfit = ClothingType.NONE;
    private int currentSkinTone = 0;
        // Add frame dimensions
        private static final int SPRITE_WIDTH = 32;
        private static final int SPRITE_HEIGHT = 32;

        // Method to combine character and clothing frames
        private TextureRegion[] combineFrames(TextureRegion[] baseFrames, TextureRegion[] clothingFrames) {
            if (clothingFrames == null) return baseFrames;

            TextureRegion[] combinedFrames = new TextureRegion[baseFrames.length];

            for (int i = 0; i < baseFrames.length; i++) {
                // Create a new FrameBuffer to combine textures
                FrameBuffer frameBuffer = new FrameBuffer(Pixmap.Format.RGBA8888, SPRITE_WIDTH, SPRITE_HEIGHT, false);
                SpriteBatch batch = new SpriteBatch();

                frameBuffer.begin();
                batch.begin();

                // Draw base character
                batch.draw(baseFrames[i], 0, 0, SPRITE_WIDTH, SPRITE_HEIGHT);

                // Draw clothing on top
                if (clothingFrames[i] != null) {
                    batch.draw(clothingFrames[i], 0, 0, SPRITE_WIDTH, SPRITE_HEIGHT);
                }

                batch.end();
                frameBuffer.end();

                // Convert to TextureRegion
                combinedFrames[i] = new TextureRegion(frameBuffer.getColorBufferTexture());
                combinedFrames[i].flip(false, true); // Correct texture orientation

                // Cleanup
                frameBuffer.dispose();
                batch.dispose();
            }

            return combinedFrames;
        }

    public void setOutfit(ClothingType outfit) {
        if (outfit != null) {
            this.currentOutfit = outfit;
            GameLogger.info("Changed outfit to: " + outfit.name());
        }
    }

    public ClothingType getCurrentOutfit() {
        return currentOutfit;
    }

    public void setSkinTone(int toneIndex) {
        if (toneIndex >= 0 && toneIndex < 8) {
            this.currentSkinTone = toneIndex;
            GameLogger.info("Changed skin tone to: " + toneIndex);
        }
    }


    private static final int SOURCE_SPRITE_SIZE = 32;
    private static final int DISPLAY_WIDTH = 32;
    private static final int DISPLAY_HEIGHT = 48;

    public TextureRegion[] getCharacterFrames(String action, int frameCount) {
        TextureRegion[] frames = new TextureRegion[frameCount];
        TextureRegion[] clothingFrames = new TextureRegion[frameCount];

        TextureRegion fullSheet = characterAtlas.findRegion("char_all");
        TextureRegion clothingSheet = currentOutfit != ClothingType.NONE ?
            clothingAtlas.findRegion(currentOutfit.getAtlasKey()) : null;

        for (int i = 0; i < frameCount; i++) {
            int frameX = (currentSkinTone * 256) + (i * SOURCE_SPRITE_SIZE);
            int frameY = getActionOffset(action);

            frames[i] = new TextureRegion(fullSheet,
                frameX, frameY,
                SOURCE_SPRITE_SIZE, SOURCE_SPRITE_SIZE);

            if (clothingSheet != null) {
                clothingFrames[i] = new TextureRegion(clothingSheet,
                    frameX, frameY,
                    SOURCE_SPRITE_SIZE, SOURCE_SPRITE_SIZE);
            }
        }

        return combineFrames(frames, clothingFrames);
    }
    private int getActionOffset(String action) {
        // Map actions to Y positions in spritesheet
        switch (action.toLowerCase()) {
            case "idle": return 0;
            case "walk": return 64;
            case "run": return 128;
            case "punch": return 192;
            case "sword": return 256;
            case "pickaxe": return 320;
            case "axe": return 384;
            case "water": return 448;
            case "emote_happy": return 512;
            case "emote_sad": return 576;
            default: return 0;
        }
    }

}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/ChestInteractionHandler.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

public class ChestInteractionHandler {
    private static final float INTERACTION_RANGE = World.TILE_SIZE * 1.5f;
    private boolean isChestOpen = false;
    private Vector2 currentChestPosition = null;

    public void resetChestBlockOpenState(World world) {
        if (currentChestPosition != null && world != null) {
            PlaceableBlock chestBlock = world.getBlockManager()
                .getBlockAt((int) currentChestPosition.x, (int) currentChestPosition.y);
            if (chestBlock != null && chestBlock.getType() == PlaceableBlock.BlockType.CHEST) {
                chestBlock.setChestOpen(false);
            }
        }
    }

    public boolean canInteractWithChest(Player player) {
        if (player == null || player.getWorld() == null) {
            return false;
        }    if (isChestOpen) {
            return false;
        }

        int targetX = player.getTileX();
        int targetY = player.getTileY();

        // Get tile in front of player based on direction
        switch (player.getDirection()) {
            case "up":
                targetY++;
                break;
            case "down":
                targetY--;
                break;
            case "left":
                targetX--;
                break;
            case "right":
                targetX++;
                break;
        }

        PlaceableBlock block = player.getWorld().getBlockManager().getBlockAt(targetX, targetY);
        if (block != null && block.getType() == PlaceableBlock.BlockType.CHEST) {
            // Cache the chest position when found
            currentChestPosition = new Vector2(targetX, targetY);
            return true;
        }

        return false;
    }

    public Vector2 getCurrentChestPosition() {
        return currentChestPosition;
    }

    public boolean isChestOpen() {
        return isChestOpen;
    }

    public void setChestOpen(boolean isOpen) {
        this.isChestOpen = isOpen;
    }

    public void reset() {
        isChestOpen = false;
        currentChestPosition = null;
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/CraftingGrid.java
================
package io.github.pokemeetup.system.gameplay.inventory.crafting;

import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;

import java.util.ArrayList;
import java.util.List;

public class CraftingGrid implements ItemContainer {
    private final int size;
    private final ItemData[] gridItems;

    // Observer list
    private final List<CraftingGridObserver> observers = new ArrayList<>();

    public CraftingGrid(int size) {
        this.size = size;
        this.gridItems = new ItemData[size];
    }

    @Override
    public ItemData getItemAt(int index) {
        if (index >= 0 && index < size) {
            return gridItems[index];
        }
        return null;
    }

    public List<ItemData> getAllItems() {
        List<ItemData> items = new ArrayList<>();
        for (ItemData item : gridItems) {
            items.add(item); // Include nulls to maintain grid structure
        }
        return items;
    }

    @Override
    public void setItemAt(int index, ItemData item) {
        if (index >= 0 && index < size) {
            gridItems[index] = item;
            notifyObservers();
        }
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public InventorySlotData getSlotData(int index) {
        return null;
    }

    public void clear() {
        for (int i = 0; i < size; i++) {
            gridItems[i] = null;
        }
        notifyObservers();
    }

    // Observer pattern implementation
    public void addObserver(CraftingGridObserver observer) {
        if (!observers.contains(observer)) {
            observers.add(observer);
        }
    }

    public void removeObserver(CraftingGridObserver observer) {
        observers.remove(observer);
    }

    private void notifyObservers() {
        for (CraftingGridObserver observer : observers) {
            observer.onCraftingGridChanged();
        }
    }

    // Observer interface
    public interface CraftingGridObserver {
        void onCraftingGridChanged();
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/CraftingResult.java
================
package io.github.pokemeetup.system.gameplay.inventory.crafting;

public class CraftingResult {
    private final String itemId;
    private final int count;

    public CraftingResult(String itemId, int count) {
        this.itemId = itemId;
        this.count = count;
    }

    public String getItemId() {
        return itemId;
    }

    public int getCount() {
        return count;
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/crafting/CraftingSystem.java
================
package io.github.pokemeetup.system.gameplay.inventory.crafting;

import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotDataObserver;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

public class CraftingSystem implements CraftingGrid.CraftingGridObserver {
    private final CraftingGrid craftingGrid;
    private final Object craftingLock = new Object();
    private final List<InventorySlotDataObserver>[] slotObservers;
    private final List<CraftingSystemObserver> observers = new ArrayList<>();
    private final Inventory inventory;
    private final int gridSize;
    private ItemData resultSlot;

    public CraftingSystem(Inventory inventory, int gridSize, CraftingGrid craftingGrid) {
        this.inventory = inventory;
        this.gridSize = gridSize;
        this.craftingGrid = craftingGrid;
        this.craftingGrid.addObserver(this); // Register as observer
        this.slotObservers = new List[gridSize * gridSize];
        for (int i = 0; i < gridSize * gridSize; i++) {
            slotObservers[i] = new ArrayList<>();
        }
    }

    public void returnItemsToInventory() {
        synchronized (craftingLock) {
            for (int i = 0; i < craftingGrid.getSize(); i++) {
                ItemData item = craftingGrid.getItemAt(i);
                if (item != null) {
                    boolean added = inventory.addItem(item.copy());
                    if (added) {
                        craftingGrid.setItemAt(i, null);
                        notifySlotObservers(i);
                    } else {
                        GameLogger.error("Inventory full, cannot return item: " + item.getItemId());
                    }
                }
            }
            updateCraftingResult();
        }
    }

    public void addObserver(CraftingSystemObserver observer) {
        observers.add(observer);
    }

    public void addSlotObserver(int index, InventorySlotDataObserver observer) {
        if (index >= 0 && index < craftingGrid.getSize()) {
            slotObservers[index].add(observer);
        }
    }

    public void updateCraftingResult() {
        synchronized (craftingLock) {
            resultSlot = checkRecipes();
            notifyCraftingResultChanged();
        }
    }


    private void notifySlotObservers(int index) {
        if (index >= 0 && index < slotObservers.length) {
            List<InventorySlotDataObserver> observers = slotObservers[index];
            if (observers != null) {
                for (InventorySlotDataObserver observer : observers) {
                    if (observer != null) {
                        observer.onSlotDataChanged();
                    }
                }
            }
        }
    }

    public boolean craftOneItem() {
        synchronized (craftingLock) {
            if (resultSlot == null) return false;

            // Consume ingredients
            Map<String, Integer> requiredItems = getRequiredItemsForCurrentRecipe();
            if (requiredItems == null) return false; // No recipe found

            // Check if the grid has sufficient items for one craft
            for (Map.Entry<String, Integer> entry : requiredItems.entrySet()) {
                String itemId = entry.getKey();
                int requiredCount = entry.getValue();
                int availableCount = getTotalItemCountInGrid(itemId);

                if (availableCount < requiredCount) {
                    GameLogger.error("Not enough " + itemId + " to craft one " + resultSlot.getItemId());
                    return false;
                }
            }

            // Consume the required items for one craft
            for (Map.Entry<String, Integer> entry : requiredItems.entrySet()) {
                String itemId = entry.getKey();
                int requiredCount = entry.getValue();
                consumeItemsFromGrid(itemId, requiredCount);
            }

            // Update crafting result based on the new grid state
            updateCraftingResult();

            AudioManager.getInstance().playSound(AudioManager.SoundEffect.CRAFT);

            return true;
        }
    }


    private int getTotalItemCountInGrid(String itemId) {
        int totalCount = 0;
        for (ItemData item : craftingGrid.getAllItems()) {
            if (item != null && item.getItemId().equalsIgnoreCase(itemId)) {
                totalCount += item.getCount();
            }
        }
        return totalCount;
    }

    public void setItemInGrid(int index, ItemData item) {
        synchronized (craftingLock) {
            if (index < 0 || index >= craftingGrid.getSize()) {
                GameLogger.error("Invalid grid index: " + index);
                return;
            }

            GameLogger.info("Setting item in grid index " + index + ": " +
                (item != null ? item.getItemId() + " x" + item.getCount() : "null"));

            // Only copy if we're actually placing the item, not when removing
            if (item != null) {
                // Get the current item in the slot
                ItemData currentItem = craftingGrid.getItemAt(index);

                // If the slot already has the same type of item, update its count instead of creating new
                if (currentItem != null && currentItem.getItemId().equals(item.getItemId())) {
                    currentItem.setCount(item.getCount());
                    GameLogger.info("Updated existing item count to: " + currentItem.getCount());
                } else {
                    // If it's a different item or empty slot, place a copy
                    ItemData itemCopy = item.copy();
                    craftingGrid.setItemAt(index, itemCopy);
                    GameLogger.info("Placed new item in grid: " + itemCopy.getItemId() + " x" + itemCopy.getCount());
                }
            } else {
                // If we're removing the item (item is null), just set it directly
                craftingGrid.setItemAt(index, null);
                GameLogger.info("Removed item from grid index: " + index);
            }

            notifySlotObservers(index);
            updateCraftingResult();
        }
    }



    private boolean isCraftingTableRecipe3x3() {
        // We'll assume the crafting table is crafted by placing 4 sticks in a 2x2 pattern anywhere in the grid
        for (int row = 0; row <= gridSize - 2; row++) {
            for (int col = 0; col <= gridSize - 2; col++) {
                if (check2x2PatternAt(row, col)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean itemMatches(ItemData itemData, String itemId) {
        return itemData != null && itemData.getItemId().equalsIgnoreCase(itemId);
    }


    private ItemData checkRecipes() {
        ItemData result;

        if (gridSize >= 2) {
            result = check2x2Recipes();
            if (result != null) return result;
        }

        if (gridSize >= 3) {
            result = check3x3Recipes();
            return result;
        }

        return null;
    }


    private boolean isWoodenAxeRecipe() {
        // Ensure grid size is at least 3x3
        if (gridSize < 3) return false;

        for (int row = 0; row <= gridSize - 3; row++) {
            for (int col = 0; col <= gridSize - 2; col++) {
                if (checkWoodenAxePatternAt(row, col, false) || checkWoodenAxePatternAt(row, col, true)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean checkWoodenAxePatternAt(int row, int col, boolean mirrored) {
        // Define the pattern for the axe
        String[][] pattern = mirrored ? new String[][]{
            {ItemManager.ItemIDs.WOODEN_PLANKS, ItemManager.ItemIDs.WOODEN_PLANKS, null},
            {ItemManager.ItemIDs.STICK, ItemManager.ItemIDs.WOODEN_PLANKS, null},
            {ItemManager.ItemIDs.STICK, null, null}
        } : new String[][]{
            {null, ItemManager.ItemIDs.WOODEN_PLANKS, ItemManager.ItemIDs.WOODEN_PLANKS},
            {null, ItemManager.ItemIDs.STICK, ItemManager.ItemIDs.WOODEN_PLANKS},
            {null, ItemManager.ItemIDs.STICK, null}
        };

        Set<Integer> usedIndices = new HashSet<>();

        for (int r = 0; r < pattern.length; r++) {
            for (int c = 0; c < pattern[r].length; c++) {
                int gridRow = row + r;
                int gridCol = col + c;
                if (gridRow >= gridSize || gridCol >= gridSize) {
                    return false;
                }

                int index = gridRow * gridSize + gridCol;
                usedIndices.add(index);

                String expectedItem = pattern[r][c];
                ItemData actualItem = craftingGrid.getItemAt(index);

                if (expectedItem == null) {
                    if (actualItem != null) return false;
                } else {
                    if (!itemMatches(actualItem, expectedItem)) return false;
                }
            }
        }

        // Ensure all other slots are empty
        return otherSlotsEmpty(usedIndices);
    }

    private boolean check2x2PatternAt(int row, int col) {
        int index1 = row * gridSize + col;
        int index2 = row * gridSize + (col + 1);
        int index3 = (row + 1) * gridSize + col;
        int index4 = (row + 1) * gridSize + (col + 1);

        // Ensure indices are within bounds
        if (index1 >= craftingGrid.getSize() || index2 >= craftingGrid.getSize() ||
            index3 >= craftingGrid.getSize() || index4 >= craftingGrid.getSize()) {
            return false;
        }

        return itemMatches(craftingGrid.getItemAt(index1), "Stick") &&
            itemMatches(craftingGrid.getItemAt(index2), "Stick") &&
            itemMatches(craftingGrid.getItemAt(index3), "Stick") &&
            itemMatches(craftingGrid.getItemAt(index4), "Stick") &&
            otherSlotsEmpty(Set.of(index1, index2, index3, index4));
    }

    private ItemData check3x3Recipes() {
        if (isWoodenAxeRecipe()) {
            return new ItemData(ItemManager.ItemIDs.WOODEN_AXE, 1, UUID.randomUUID());
        }
        if (isCraftingTableRecipe3x3()) {
            return new ItemData(ItemManager.ItemIDs.CRAFTING_TABLE, 1, UUID.randomUUID());
        }
        // Add more recipes here as needed
        return null;
    }


    private Map<String, Integer> getRequiredItemsForCurrentRecipe() {
        if (resultSlot == null) return null;

        Map<String, Integer> requiredItems = new HashMap<>();

        if (resultSlot.getItemId().equalsIgnoreCase(ItemManager.ItemIDs.WOODEN_AXE)) {
            requiredItems.put(ItemManager.ItemIDs.WOODEN_PLANKS, 3);
            requiredItems.put(ItemManager.ItemIDs.STICK, 2);
        } else if (resultSlot.getItemId().equalsIgnoreCase(ItemManager.ItemIDs.CRAFTING_TABLE)) {
            requiredItems.put(ItemManager.ItemIDs.WOODEN_PLANKS, 4);
        } else if (resultSlot.getItemId().equalsIgnoreCase(ItemManager.ItemIDs.STICK)) {
            requiredItems.put(ItemManager.ItemIDs.WOODEN_PLANKS, 2);
        }

        return requiredItems;
    }

    private boolean otherSlotsEmpty(Set<Integer> usedIndices) {
        for (int i = 0; i < craftingGrid.getSize(); i++) {
            if (!usedIndices.contains(i) && craftingGrid.getItemAt(i) != null) {
                return false;
            }
        }
        return true;
    }

    public ItemData getItemInGrid(int index) {
        synchronized (craftingLock) {
            if (index < 0 || index >= craftingGrid.getSize()) {
                return null;
            }
            return craftingGrid.getItemAt(index);
        }
    }

    private ItemData check2x2Recipes() {
        int patternHeight = 2;
        int patternWidth = 1; // For the stick recipe

        for (int row = 0; row <= gridSize - patternHeight; row++) {
            for (int col = 0; col <= gridSize - patternWidth; col++) {
                if (isStickRecipeAt(row, col)) {
                    GameLogger.info("Stick recipe matched at position (" + row + ", " + col + ").");
                    return new ItemData(ItemManager.ItemIDs.STICK, 4, UUID.randomUUID()); // 4 sticks
                }

                if (isCraftingTableRecipe2x2At(row, col)) {
                    GameLogger.info("Crafting table recipe matched at position (" + row + ", " + col + ").");
                    return new ItemData(ItemManager.ItemIDs.CRAFTING_TABLE, 1, UUID.randomUUID()); // 1 table
                }
            }
        }
        return null;
    }

    private boolean isStickRecipeAt(int row, int col) {
        int patternHeight = 2;
        int patternWidth = 1;

        // Check if the pattern fits in the grid
        if (row + patternHeight > gridSize || col + patternWidth > gridSize) {
            return false;
        }

        Set<Integer> usedIndices = new HashSet<>();

        for (int r = 0; r < patternHeight; r++) {
            int gridRow = row + r;

            int index = gridRow * gridSize + col;
            usedIndices.add(index);

            ItemData actualItem = craftingGrid.getItemAt(index);
            if (!itemMatches(actualItem, ItemManager.ItemIDs.WOODEN_PLANKS)) {
                return false;
            }
        }

        // Ensure all other slots are empty
        return otherSlotsEmpty(usedIndices);
    }

    private boolean isCraftingTableRecipe2x2At(int row, int col) {
        int patternHeight = 2;
        int patternWidth = 2;

        // Check if the pattern fits in the grid
        if (row + patternHeight > gridSize || col + patternWidth > gridSize) {
            return false;
        }

        Set<Integer> usedIndices = new HashSet<>();

        for (int r = 0; r < patternHeight; r++) {
            for (int c = 0; c < patternWidth; c++) {
                int gridRow = row + r;
                int gridCol = col + c;

                int index = gridRow * gridSize + gridCol;
                usedIndices.add(index);

                ItemData actualItem = craftingGrid.getItemAt(index);
                if (!itemMatches(actualItem, ItemManager.ItemIDs.WOODEN_PLANKS)) {
                    return false;
                }
            }
        }

        // Ensure all other slots are empty
        return otherSlotsEmpty(usedIndices);
    }


    public ItemData getCraftingResult() {
        synchronized (craftingLock) {
            if (resultSlot == null) return null;

            int maxCraftable = calculateMaxCraftableAmount();
            if (maxCraftable <= 0) return null;

            ItemData result = resultSlot.copy();
            result.setCount(maxCraftable);
            return result;
        }
    }

    private int calculateMaxCraftableAmount() {
        Map<String, Integer> requiredItems = getRequiredItemsForCurrentRecipe();
        if (requiredItems == null) return 0;

        Map<String, Integer> itemsInGrid = new HashMap<>();
        for (ItemData item : craftingGrid.getAllItems()) {
            if (item != null) {
                itemsInGrid.put(item.getItemId(),
                    itemsInGrid.getOrDefault(item.getItemId(), 0) + item.getCount());
            }
        }

        int maxCraftable = Integer.MAX_VALUE;
        for (Map.Entry<String, Integer> entry : requiredItems.entrySet()) {
            String itemId = entry.getKey();
            int requiredCount = entry.getValue();
            int availableCount = itemsInGrid.getOrDefault(itemId, 0);

            int craftableWithItem = availableCount / requiredCount;
            if (craftableWithItem < maxCraftable) {
                maxCraftable = craftableWithItem;
            }
        }
        return maxCraftable;
    }


    private void consumeItemsFromGrid(String itemId, int requiredCount) {
        int countToConsume = requiredCount;

        for (int i = 0; i < craftingGrid.getSize(); i++) {
            ItemData item = craftingGrid.getItemAt(i);
            if (item != null && item.getItemId().equalsIgnoreCase(itemId)) {
                int itemCount = item.getCount();
                if (itemCount <= countToConsume) {
                    // Consume the whole stack
                    countToConsume -= itemCount;
                    craftingGrid.setItemAt(i, null); // Clear the slot
                } else {
                    // Consume part of the stack
                    item.setCount(itemCount - countToConsume);
                    countToConsume = 0;
                }
                notifySlotObservers(i);

                if (countToConsume <= 0) {
                    break;
                }
            }
        }

        if (countToConsume > 0) {
            GameLogger.error("consumeItemsFromGrid: Insufficient items in grid for item: " + itemId);
        }
    }


    private void notifyCraftingResultChanged() {
        for (CraftingSystemObserver observer : observers) {
            observer.onCraftingResultChanged(resultSlot);
        }
    }

    @Override
    public void onCraftingGridChanged() {
        updateCraftingResult();
    }

    public interface CraftingSystemObserver {
        void onCraftingResultChanged(ItemData newResult);
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/Inventory.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventoryObserver;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.ItemContainer;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Inventory implements ItemContainer {
    public static final int INVENTORY_SIZE = 27;
    private final List<Slot> slots;
    private final Map<UUID, ItemData> itemTracker;
    private final Object inventoryLock = new Object();
    private final List<InventoryObserver> observers = new ArrayList<>();
    private InventorySlotData[] slotDataArray;

    public Inventory() {
        this.slots = new ArrayList<>(INVENTORY_SIZE);
        for (int i = 0; i < INVENTORY_SIZE; i++) {
            slots.add(new Slot());
        }
        this.itemTracker = new ConcurrentHashMap<>();
        validateSlots();
        slotDataArray = new InventorySlotData[INVENTORY_SIZE];
        for (int i = 0; i < INVENTORY_SIZE; i++) {
            slotDataArray[i] = new InventorySlotData(i, InventorySlotData.SlotType.INVENTORY, this);
        }
    }

    public ItemData getItemAt(int index) {
        synchronized (inventoryLock) {
            if (index < 0 || index >= INVENTORY_SIZE) {
                GameLogger.error("Invalid inventory slot index: " + index);
                return null;
            }

            Slot slot = slots.get(index);
            if (slot == null) {
                return null;
            }

            ItemData item = slot.getItemData(); // Now returns actual reference
            if (item != null) {
                GameLogger.info("Got item at slot " + index + ": " +
                    item.getItemId() + " x" + item.getCount());
            }
            return item;
        }
    }

    public void update() {
        synchronized (inventoryLock) {
            // Remove items with invalid counts or UUIDs
            for (Slot slot : slots) {
                ItemData item = slot.getItemData();
                if (item != null && (item.getCount() <= 0 || item.getUuid() == null)) {
                    itemTracker.remove(item.getUuid());
                    slot.setItemData(null);
                }
            }

            // Rebuild itemTracker
            itemTracker.clear();
            for (Slot slot : slots) {
                ItemData item = slot.getItemData();
                if (item != null && item.getUuid() != null) {
                    itemTracker.put(item.getUuid(), item);
                }
            }

            // Handle items with zero durability
            for (Slot slot : slots) {
                ItemData item = slot.getItemData();
                if (item != null && item.getDurability() == 0) {
                    GameLogger.info("Item broken due to zero durability: " + item.getItemId());
                    itemTracker.remove(item.getUuid());
                    slot.setItemData(null);
                    notifyObservers();
                }
            }
        }
    }

    public void setItemAt(int index, ItemData itemData) {
        synchronized (inventoryLock) {
            if (index < 0 || index >= slots.size()) {
                GameLogger.error("Invalid slot index: " + index);
                return;
            }

            Slot slot = slots.get(index);
            if (slot == null) {
                slot = new Slot();
                slots.set(index, slot);
            }

            ItemData oldItem = slot.getItemData();
            if (oldItem != null && oldItem.getUuid() != null) {
                itemTracker.remove(oldItem.getUuid());
            }

            if (itemData != null) {
                if (itemData.getUuid() == null) {
                    itemData.setUuid(UUID.randomUUID());
                }

                // Ensure unstackable items have count of 1
                Item itemTemplate = ItemManager.getItemTemplate(itemData.getItemId());
                if (itemTemplate != null && !itemTemplate.isStackable()) {
                    if (itemData.getCount() > 1) {
                        GameLogger.error("Attempted to set unstackable item with count > 1: " + itemData.getItemId());
                        itemData.setCount(1);
                    }
                }

                slot.setItemData(itemData);
                itemTracker.put(itemData.getUuid(), itemData);
            } else {
                slot.setItemData(null);
            }
            notifyObservers();
        }
    }

    @Override
    public int getSize() {
        return INVENTORY_SIZE;
    }

    public List<ItemData> getAllItems() {
        synchronized (inventoryLock) {
            List<ItemData> items = new ArrayList<>(INVENTORY_SIZE);

            GameLogger.info("Getting all items...");
            int nonNullCount = 0;

            for (Slot slot : slots) {
                if (slot == null) {
                    items.add(null);
                    continue;
                }

                ItemData item = slot.getItemData();
                if (item != null) {
                    // Create defensive copy
                    ItemData copy = item.copy();
                    items.add(copy);
                    nonNullCount++;

                } else {
                    items.add(null);
                }
            }

            return items;
        }
    }

    public void setAllItems(List<ItemData> items) {
        if (items == null) {
            return;
        }
        synchronized (inventoryLock) {
            GameLogger.info("Setting all items - Received " +
                items.stream().filter(Objects::nonNull).count() + " items");
            for (int i = 0; i < INVENTORY_SIZE; i++) {
                if (i < items.size() && items.get(i) != null) {
                    ItemData item = items.get(i).copy(); // Make defensive copy
                    setItemAt(i, item);
                    GameLogger.info("Set item at " + i + ": " + item.getItemId() + " x" + item.getCount());
                } else {
                    setItemAt(i, null);
                }
            }

            notifyObservers();
            validateAndRepair();
        }
    }

    public boolean addItem(ItemData itemData) {
        if (itemData == null) return false;

        synchronized (inventoryLock) {
            try {
                Item itemTemplate = ItemManager.getItemTemplate(itemData.getItemId());
                if (itemTemplate == null) {
                    return false;
                }
                if (itemTemplate.isStackable()) {
                    int remainingCount = itemData.getCount();
                    GameLogger.info("Processing stackable item, count=" + remainingCount);

                    // First pass: Stack with existing items
                    for (int i = 0; i < slots.size() && remainingCount > 0; i++) {
                        Slot slot = slots.get(i);
                        if (slot == null) {
                            slots.set(i, new Slot());
                            continue;
                        }

                        ItemData existingItem = slot.getItemData();
                        if (existingItem != null &&
                            existingItem.getItemId().equals(itemData.getItemId()) &&
                            existingItem.getCount() < Item.MAX_STACK_SIZE) {

                            int spaceInStack = Item.MAX_STACK_SIZE - existingItem.getCount();
                            int amountToAdd = Math.min(spaceInStack, remainingCount);

                            // Create new item data with updated count
                            ItemData updatedItem = existingItem.copy();
                            updatedItem.setCount(existingItem.getCount() + amountToAdd);
                            slot.setItemData(updatedItem);

                            remainingCount -= amountToAdd;
                            GameLogger.info("Stacked " + amountToAdd + " in slot " + i +
                                ", remaining: " + remainingCount);
                        }
                    }

                    // If we still have items, find empty slots
                    while (remainingCount > 0) {
                        Slot emptySlot = findEmptySlot();
                        if (emptySlot == null) {
                            GameLogger.info("No empty slots for remaining " + remainingCount + " items");
                            return remainingCount < itemData.getCount(); // Return true if we stacked anything
                        }

                        int stackSize = Math.min(remainingCount, Item.MAX_STACK_SIZE);
                        ItemData newStack = new ItemData(itemData.getItemId(), stackSize, UUID.randomUUID());
                        emptySlot.setItemData(newStack);

                        remainingCount -= stackSize;
                        GameLogger.info("Created new stack of " + stackSize + " in empty slot");
                    }

                    validateAndRepair();
                    notifyObservers();
                    return true;
                } else {
                    // Non-stackable items
                    for (int i = 0; i < itemData.getCount(); i++) {
                        Slot emptySlot = findEmptySlot();
                        if (emptySlot == null) {
                            GameLogger.info("No empty slots for non-stackable item");
                            return i > 0; // Return true if we placed any items
                        }

                        ItemData singleItem = new ItemData(itemData.getItemId(), 1, UUID.randomUUID());
                        emptySlot.setItemData(singleItem);
                        GameLogger.info("Placed non-stackable item in empty slot");
                    }

                    validateAndRepair();
                    notifyObservers();
                    return true;
                }

            } catch (Exception e) {
                GameLogger.error("Error in addItem: " + e.getMessage());
                validateAndRepair();
                return false;
            }
        }
    }

    public InventorySlotData getSlotData(int index) {
        if (index >= 0 && index < slotDataArray.length) {
            return slotDataArray[index];
        }
        return null;
    }

    private Slot findEmptySlot() {
        for (Slot slot : slots) {
            if (slot == null) continue;
            if (slot.isEmpty()) return slot;
        }
        return null;
    }

    public void notifyObservers() {
        for (InventoryObserver observer : observers) {
            observer.onInventoryChanged();
        }
    }

    public void addObserver(InventoryObserver observer) {
        observers.add(observer);
    }


    public void validateAndRepair() {
        synchronized (inventoryLock) {
            try {
                GameLogger.info("Starting inventory validation");

                // Validate slots array
                if (slots.size() != INVENTORY_SIZE) {
                    GameLogger.error("Invalid slots size: " + slots.size());
                    while (slots.size() < INVENTORY_SIZE) {
                        slots.add(new Slot());
                    }
                }

                // Rebuild item tracker
                itemTracker.clear();
                int itemCount = 0;

                for (int i = 0; i < slots.size(); i++) {
                    Slot slot = slots.get(i);
                    if (slot == null) {
                        slots.set(i, new Slot());
                        continue;
                    }

                    ItemData item = slot.getItemData();
                    if (item != null) {
                        itemCount++;
                        // Ensure valid UUID
                        if (item.getUuid() == null) {
                            item.setUuid(UUID.randomUUID());
                        }
                        itemTracker.put(item.getUuid(), item);

                        // Validate stack size and unstackable items
                        Item itemTemplate = ItemManager.getItemTemplate(item.getItemId());
                        if (itemTemplate != null) {
                            if (!itemTemplate.isStackable() && item.getCount() > 1) {
                                GameLogger.error("Unstackable item with count > 1 in slot " + i + ": " + item.getCount());
                                item.setCount(1);
                            } else if (item.getCount() <= 0 || item.getCount() > Item.MAX_STACK_SIZE) {
                                GameLogger.error("Invalid stack size in slot " + i + ": " + item.getCount());
                                if (item.getCount() <= 0) {
                                    slot.setItemData(null);
                                    itemCount--;
                                } else {
                                    item.setCount(Item.MAX_STACK_SIZE);
                                }
                            }
                        }
                    }
                }

            } catch (Exception e) {
                GameLogger.error("Error during inventory validation: " + e.getMessage());
            }
        }
    }

    public void clear() {
        synchronized (inventoryLock) {
            GameLogger.info("Clearing inventory");
            for (Slot slot : slots) {
                if (slot != null) {
                    slot.setItemData(null);
                }
            }
            itemTracker.clear();
        }
    }


    public Object getInventoryLock() {
        return inventoryLock;
    }

    public void load() {
        synchronized (inventoryLock) {
            validateSlots(); // Ensure slots are valid before loading
            validateAndRepair(); // Validate after loading
        }
    }

    private void validateSlots() {
        synchronized (inventoryLock) {
            boolean needsRepair = false;
            for (int i = 0; i < INVENTORY_SIZE; i++) {
                if (slots.get(i) == null) {
                    slots.set(i, new Slot());
                    needsRepair = true;
                    GameLogger.error("Repaired null slot at index " + i);
                }
            }

            if (needsRepair) {
                validateAndRepair(); // Run full validation after slot repair
            }
        }
    }


    public void removeItemAt(int index) {
        synchronized (inventoryLock) {
            if (index < 0 || index >= slots.size()) {
                return;
            }

            Slot slot = slots.get(index);
            ItemData removedItem = slot.getItemData();
            if (removedItem != null) {
                itemTracker.remove(removedItem.getUuid());
                slot.setItemData(null);
                notifyObservers();
                GameLogger.info("Removed item from slot " + index + ": " + removedItem.getItemId());
            }
        }
    }

    public boolean isEmpty() {
        synchronized (inventoryLock) {
            return slots.stream().allMatch(Slot::isEmpty);
        }
    }


}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/Item.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.UUID;

public class Item {
    public static final int MAX_STACK_SIZE = 64;
    private boolean stackable = true;  // Default to stackable
    private int maxDurability = -1;    // -1 means no durability
    private int durability = -1;       // Current durability

    private UUID uuid; // Unique identifier for each Item instance
    private String name;
    private String iconName; // Name of the texture region
    private transient TextureRegion icon; // Marked transient to avoid serialization
    private int count = 1;
    private boolean isCraftingResult = false;

    public Item(String name) {
        this.name = name;
        this.uuid = UUID.randomUUID();
        Item template = ItemManager.getItemTemplate(name);
        if (template != null) {
            this.iconName = template.getIconName();
            this.icon = template.getIcon();
            this.stackable = template.isStackable();
            this.maxDurability = template.getMaxDurability();
            this.durability = template.getMaxDurability();
        } else {
            // Log error but don't crash
            GameLogger.error("Failed to find template for item: " + name);
            this.iconName = "missing";
            this.icon = TextureManager.items.findRegion("stick_item");
        }
        this.count = 1;
    }

    public Item(String name, String iconName, TextureRegion icon) {
        this.name = name;
        this.iconName = iconName;
        this.icon = icon;
        this.uuid = UUID.randomUUID();
        if (name.toLowerCase().contains("axe")) {
            this.stackable = false;
            this.maxDurability = 100;  // Example durability for tools
            this.durability = 100;
        }
    }

    public Item(String name, String iconName, TextureRegion icon, int count) {
        this.name = name;
        this.iconName = iconName;
        this.icon = icon;
        this.count = count;
        this.uuid = UUID.randomUUID();
        if (name.toLowerCase().contains("axe")) {
            this.stackable = false;
            this.maxDurability = 100;  // Example durability for tools
            this.durability = 100;
        }
    }

    public Item() {
        this.uuid = UUID.randomUUID();
    }

    public Item(Item other) {
        this.name = other.name;
        this.count = other.count;
        this.icon = other.icon;
        this.uuid = other.uuid;
        this.stackable = other.stackable;
        this.maxDurability = other.maxDurability;
        this.durability = other.durability;
    }
    public int getDurability() {
        return durability;
    }

    public void setDurability(int durability) {
        this.durability = durability;
    }

    public boolean isStackable() {
        return stackable;
    }

    public void setStackable(boolean stackable) {
        this.stackable = stackable;
    }

    public int getMaxDurability() {
        return maxDurability;
    }

    public void setMaxDurability(int maxDurability) {
        this.maxDurability = maxDurability;
    }

    public boolean isCraftingResult() {
        return isCraftingResult;
    }

    public void setCraftingResult(boolean craftingResult) {
        isCraftingResult = craftingResult;
    }

    public boolean isBlock() {
        for (PlaceableBlock.BlockType type : PlaceableBlock.BlockType.values()) {
            if (getName().equalsIgnoreCase(type.getId())) {
                return true;
            }
        }
        return false;
    }



    public UUID getUuid() {
        return uuid;
    }

    public void setUuid(UUID uuid) {
        this.uuid = uuid;
    }

    public int getCount() {
        GameLogger.info("Item '" + name + "' getCount() returning: " + this.count);
        return this.count;
    }
    public void setCount(int count) {
        if (count < 0) {
            GameLogger.error("Attempted to set negative count for item '" + name + "': " + count);
            this.count = 0;
        } else {
            this.count = Math.min(count, MAX_STACK_SIZE);
        }
        GameLogger.info("Item '" + name + "' count set to: " + this.count);
    }


    public boolean isEmpty() {
        return this.count <= 0;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getIconName() {
        return iconName;
    }

    public void setIconName(String iconName) {
        this.iconName = iconName;
    }

    public TextureRegion getIcon() {
        if (icon == null) {
            // Try to load from TextureManager
            icon = TextureManager.items.findRegion(name.toLowerCase() + "_item");
            if (icon != null) {
                GameLogger.info("Loaded icon for " + name + " from TextureManager");
            } else {
                GameLogger.error("Could not find icon for " + name);
            }
        }
        return icon;
    }

    public void setIcon(TextureRegion icon) {
        if (icon == null) {
            GameLogger.error("Attempted to set null icon for item: " + name);
            return;
        }
        this.icon = icon;
        GameLogger.info("Set icon for item: " + name);
    }

    public Item copy() {
        return new Item(this);
    }

    @Override
    public String toString() {
        return "Item{" +
            "name='" + name + '\'' +
            ", count=" + count +
            ", uuid=" + uuid +
            '}';
    }

}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/ItemManager.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

public class ItemManager {
    private static final Map<String, Item> items = new HashMap<>();
    private static final String DEFAULT_TEXTURE = "missing_texture";
    private static boolean initialized = false;
    private static boolean isServerMode = false;

    public static void setServerMode(boolean serverMode) {
        isServerMode = serverMode;
        initialized = false; // Reset initialization to allow server-specific init
    }

    public static void initialize(TextureAtlas atlas) {
        if (initialized) {
            return;
        }
        if (isServerMode && atlas == null) {
            initializeServerItems();
            return;
        }

        if (atlas == null) {
            GameLogger.error("Cannot initialize ItemManager - atlas is null");
            return;
        }

        GameLogger.info("Initializing ItemManager with atlas...");
        logAvailableRegions(atlas);

        // Register standard items...
        Map<String, String> standardItems = new HashMap<>();
        standardItems.put(ItemIDs.POTION, "potion_item");
        standardItems.put(ItemIDs.ELIXIR, "elixir_item");
        standardItems.put(ItemIDs.POKEBALL, "pokeball_item");
        standardItems.put(ItemIDs.WOODEN_AXE, "wooden_axe_item");
        standardItems.put(ItemIDs.STICK, "stick_item");

        // Register block items
        for (PlaceableBlock.BlockType blockType : PlaceableBlock.BlockType.values()) {
            String itemId = blockType.getId().toLowerCase();
            String textureKey = itemId + "_item";
            standardItems.put(itemId, textureKey);
            GameLogger.info("Registered block item: " + itemId);
        }

        for (Map.Entry<String, String> entry : standardItems.entrySet()) {
            String itemId = entry.getKey().toLowerCase();
            String textureKey = entry.getValue();

            TextureRegion texture = getTextureWithFallbacks(atlas, textureKey, itemId);
            if (texture != null) {
                Item item = new Item(itemId, textureKey, texture);


                if (itemId.equals(ItemIDs.WOODEN_AXE)) {
                    item.setStackable(false);
                    item.setMaxDurability(100);
                    item.setDurability(100);
                } else {
                    item.setStackable(true);
                    item.setMaxDurability(-1);
                }

                items.put(itemId, item); // Use normalized itemId without "_item"
                GameLogger.info(String.format("Initialized item: %s with texture %s", itemId, textureKey));
            }
        }

        initialized = true;
        validateItems();
        logInitializationSummary();
    }

    private static void initializeServerItems() {
        GameLogger.info("Initializing ItemManager in server mode...");

        // Register standard items
        Map<String, String> standardItems = new HashMap<>();
        standardItems.put(ItemIDs.POTION, "potion");
        standardItems.put(ItemIDs.ELIXIR, "elixir");
        standardItems.put(ItemIDs.POKEBALL, "pokeball");
        standardItems.put(ItemIDs.WOODEN_AXE, "wooden_axe");
        standardItems.put(ItemIDs.STICK, "stick");

        // Register block items
        for (PlaceableBlock.BlockType blockType : PlaceableBlock.BlockType.values()) {
            String itemId = blockType.getId().toLowerCase();
            standardItems.put(itemId, itemId);
        }

        for (Map.Entry<String, String> entry : standardItems.entrySet()) {
            String itemId = entry.getKey().toLowerCase();
            // Create items without textures in server mode
            Item item = new Item(itemId, entry.getValue(), null);

            if (itemId.equals(ItemIDs.WOODEN_AXE)) {
                item.setStackable(false);
                item.setMaxDurability(100);
                item.setDurability(100);
            } else {
                item.setStackable(true);
                item.setMaxDurability(-1);
            }

            items.put(itemId, item);
            GameLogger.info("Initialized server item: " + itemId);
        }

        initialized = true;
        GameLogger.info("Server mode ItemManager initialization complete: " + items.size() + " items");
    }

    private static TextureRegion getTextureWithFallbacks(TextureAtlas atlas, String primaryKey, String itemId) {
        TextureRegion texture;
        String[] attempts = new String[]{
            primaryKey,
            itemId + "_item",
            itemId.toLowerCase() + "_item",
            itemId,
            itemId.toLowerCase(),
            DEFAULT_TEXTURE
        };

        for (String key : attempts) {
            texture = atlas.findRegion(key);
            if (texture != null) {
                GameLogger.info(String.format("Found texture for %s using key: %s", itemId, key));
                return texture;
            }
        }

        GameLogger.error(String.format("Failed to find any texture for item: %s", itemId));
        return null;
    }

    public static Item getItemTemplate(String itemId) {
        if (!initialized) {
            GameLogger.error("Attempting to get item before ItemManager initialization");
            return null;
        }
        return items.get(itemId);
    }

    public static Item getItem(String itemId) {
        if (!initialized) {
            if (isServerMode) {
                initialize(null); // Auto-initialize for server
            } else {
                GameLogger.error("Attempting to get item before ItemManager initialization");
                return null;
            }
        }

        if (itemId == null) {
            GameLogger.error("Null itemId provided to getItem");
            return null;
        }

        String normalizedId = itemId.toLowerCase().replace("_item", "");
        Item baseItem = items.get(normalizedId);

        if (baseItem == null) {
            GameLogger.error("No item found with ID: " + normalizedId);
            return null;
        }

        if (!isServerMode && baseItem.getIcon() == null) {
            GameLogger.error("Item found but missing texture: " + itemId);
            return null;
        }

        return baseItem.copy();
    }


    public static void validateItems() {
        GameLogger.info("Validating initialized items...");
        if (isServerMode) {
            // Simple validation for server mode
            GameLogger.info("Validating server items...");
            for (Map.Entry<String, Item> entry : items.entrySet()) {
                GameLogger.info("Validated server item: " + entry.getKey());
            }
            return;
        }
        for (Map.Entry<String, Item> entry : items.entrySet()) {
            Item item = entry.getValue();
            if (item.getIcon() == null) {
                GameLogger.error(String.format("Item %s is missing texture", entry.getKey()));
                continue;
            }

            if (!item.getIcon().getTexture().isManaged()) {
                GameLogger.error(String.format("Item %s has invalid texture state", entry.getKey()));
            }

            GameLogger.info(String.format("Validated item: %s (texture: %dx%d)",
                entry.getKey(),
                item.getIcon().getRegionWidth(),
                item.getIcon().getRegionHeight()));
        }
    }

    public static Collection<String> getAllItemNames() {
        if (!initialized) {
            GameLogger.error("Attempting to get item names before initialization");
            return Collections.emptyList();
        }
        return new ArrayList<>(items.keySet());
    }

    public static List<String> getAllFindableItemNames() {
        List<String> itemsFindable = new ArrayList<>();
        if (!initialized) {
            GameLogger.error("Attempting to get item names before initialization");
            return Collections.emptyList();
        }
        itemsFindable.add("pokeball");
        itemsFindable.add("stick");
        itemsFindable.add("potion");
        itemsFindable.add("elixir");

        return itemsFindable;
    }

    public static boolean isInitialized() {
        return initialized;
    }

    // Helper methods
    private static void logAvailableRegions(TextureAtlas atlas) {
        GameLogger.info("Available regions in atlas:");
        for (TextureAtlas.AtlasRegion region : atlas.getRegions()) {
            GameLogger.info(String.format("- %s (%dx%d)",
                region.name, region.getRegionWidth(), region.getRegionHeight()));
        }
    }

    private static void logInitializationSummary() {
        GameLogger.info(String.format("ItemManager initialization complete: %d items loaded",
            items.size()));
        GameLogger.info("Loaded items: " + String.join(", ", items.keySet()));
    }

    public static final class ItemIDs {
        public static final String POTION = "potion";
        public static final String HOUSE_PLANKS = "house_planks";
        public static final String ELIXIR = "elixir";
        public static final String POKEBALL = "pokeball";
        public static final String STICK = "stick";
        public static final String CRAFTING_TABLE = "craftingtable";
        public static final String FURNACE = "furnace";
        public static final String WOODEN_PLANKS = "wooden_planks";
        public static final String WOODEN_DOOR = "wooden_door";
        public static final String ROOF_CORNER = "roof_corner";
        public static final String HOUSE_PART = "house_part";
        public static final String HOUSE_MIDDLE_PART = "house_middlesection_part";
        public static final String HOUSE_MIDDLE_PART_0 = "house_midsection_part";
        public static final String HOUSE_MIDDLE_PART_1 = "house_middlesection";
        public static final String ROOF_CORNER_1 = "roof_middle_part";
        public static final String ROOF_MIDDLE = "roof_middle";
        public static final String ROOFINNER = "roofinner";
        public static final String ROOF_INSIDE = "roof_middle_outside";
        public static final String CHEST = "chest";
        public static final String WOODEN_AXE = "wooden_axe";
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventoryLock.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

import java.util.concurrent.locks.ReentrantReadWriteLock;

public class InventoryLock {
    private static final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true);

    public static void readLock() {
        lock.readLock().lock();
    }

    public static void readUnlock() {
        lock.readLock().unlock();
    }

    public static void writeLock() {
        lock.writeLock().lock();
    }

    public static void writeUnlock() {
        lock.writeLock().unlock();
    }

    public static ReentrantReadWriteLock getLock() {
        return lock;
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventoryObserver.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

public interface InventoryObserver {
    void onInventoryChanged();
}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventorySlotData.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.utils.GameLogger;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class InventorySlotData implements ItemDataObserver {
    private final int slotIndex;
    private final List<InventorySlotDataObserver> observers = new ArrayList<>();
    private final transient ItemContainer itemContainer;
    private SlotType slotType;
    private int position;
    private String slotId;

    public InventorySlotData(int slotIndex, SlotType slotType, ItemContainer itemContainer) {
        this.slotIndex = slotIndex;
        this.slotType = slotType;
        this.itemContainer = itemContainer;
        this.position = 0;
        this.slotId = "";
    }

    public SlotType getSlotType() {
        return slotType;
    }

    public void setSlotType(SlotType slotType) {
        this.slotType = slotType;
    }

    public InventorySlotData copy() {
        InventorySlotData copy = new InventorySlotData(this.slotIndex, this.slotType, this.itemContainer);
        copy.position = this.position;
        copy.slotId = this.slotId;
        return copy;
    }

    public void setItem(String itemId, int count, UUID uuid) {
        if (itemId == null || count <= 0) {
            this.itemContainer.setItemAt(slotIndex, null);
        } else {
            ItemData newItemData = new ItemData(itemId, count, uuid != null ? uuid : UUID.randomUUID());
            this.itemContainer.setItemAt(slotIndex, newItemData);

            if (slotType == SlotType.CRAFTING || slotType == SlotType.CRAFTING_RESULT) {
                notifyObservers();
            }
        }
        notifyObservers();
    }


    public void clear() {
        ItemData currentItem = getItemData();
        if (currentItem != null) {
            currentItem.removeObserver(this);
        }
        this.itemContainer.setItemAt(slotIndex, null);
        notifyObservers();
    }

    @Override
    public void onItemDataChanged(ItemData itemData) {
        GameLogger.error("Item data changed in slot " + slotIndex + ": " +
            (itemData != null ? itemData.getItemId() + " x" + itemData.getCount() : "null"));
        notifyObservers();
    }

    public void addObserver(InventorySlotDataObserver observer) {
        if (!observers.contains(observer)) {
            observers.add(observer);
        }
    }

    public void notifyObservers() {
        for (InventorySlotDataObserver observer : observers) {
            observer.onSlotDataChanged();
        }
    }

    public boolean isEmpty() {
        ItemData itemData = getItemData();
        return itemData == null || itemData.getCount() <= 0;
    }

    public String getItemId() {
        ItemData itemData = getItemData();
        return itemData != null ? itemData.getItemId() : null;
    }

    public int getCount() {
        ItemData itemData = getItemData();
        return itemData != null ? itemData.getCount() : 0;
    }

    public void setCount(int count) {
        ItemData itemData = getItemData();
        if (itemData != null) {
            itemData.setCount(count);
            if (count <= 0) {
                this.itemContainer.setItemAt(slotIndex, null);
            }
        }
        notifyObservers();
    }

    public ItemData getItemData() {
        // Removed the logging inside this getter to avoid confusion
        return itemContainer.getItemAt(slotIndex);
    }

    public void setItemData(ItemData itemData) {
        try {
            // Only log important changes, not every trivial action
            if (itemData != null) {
                ItemData copyData = itemData.copy();
                copyData.addObserver(this);
                this.itemContainer.setItemAt(slotIndex, copyData);
            } else {
                this.itemContainer.setItemAt(slotIndex, null);
            }

            notifyObservers();
        } catch (Exception e) {
            GameLogger.error("Error in setItemData: " + e.getMessage() + " for slot " + slotIndex);
        }
    }


    public int getSlotIndex() {
        return slotIndex;
    }

    public int getPosition() {
        return position;
    }

    public void setPosition(int position) {
        this.position = position;
    }

    public UUID getUuid() {
        ItemData itemData = getItemData();
        return itemData != null ? itemData.getUuid() : null;
    }

    public Item getItem() {
        ItemData itemData = getItemData();
        if (itemData == null) return null;

        Item baseItem = ItemManager.getItem(itemData.getItemId());
        if (baseItem == null) {
            GameLogger.error("Could not find base item for: " + itemData.getItemId());
            return null;
        }

        Item item = baseItem.copy();
        item.setCount(itemData.getCount());
        item.setUuid(itemData.getUuid());
        return item;
    }


    public ItemContainer getItemContainer() {
        return itemContainer;
    }

    public enum SlotType {
        INVENTORY,
        HOTBAR,
        CRAFTING,
        CRAFTING_RESULT,
        EXPANDED_CRAFTING,
        CHEST
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/InventorySlotDataObserver.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

public interface InventorySlotDataObserver {
    void onSlotDataChanged();

}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/ItemContainer.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

import io.github.pokemeetup.system.data.ItemData;

public interface ItemContainer {
    ItemData getItemAt(int index);
    void setItemAt(int index, ItemData item);
    int getSize();
    InventorySlotData getSlotData(int index);
}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/secureinventories/ItemDataObserver.java
================
package io.github.pokemeetup.system.gameplay.inventory.secureinventories;

import io.github.pokemeetup.system.data.ItemData;

public interface ItemDataObserver {
    void onItemDataChanged(ItemData itemData);
}

================
File: main/java/io/github/pokemeetup/system/gameplay/inventory/Slot.java
================
package io.github.pokemeetup.system.gameplay.inventory;

import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.utils.GameLogger;

import java.util.UUID;

public class Slot {
    private final Object slotLock = new Object();
    private ItemData itemData;

    public Slot() {

    }


    public ItemData getItemData() {
        synchronized (slotLock) {
            return itemData;
        }
    }


    public void setItemData(ItemData newItemData) {
        synchronized (slotLock) {
            this.itemData = newItemData;
            validateItemData();
        }
    }

    private void validateItemData() {
        if (itemData != null) {
            Item template = ItemManager.getItemTemplate(itemData.getItemId());
            if (template != null) {
                if (!template.isStackable() && itemData.getCount() > 1) {
                    GameLogger.info("Fixing unstackable item count for: " + itemData.getItemId());
                    itemData.setCount(1);
                }
                if (itemData.getCount() <= 0) {
                    GameLogger.info("Removing item with invalid count: " + itemData.getItemId());
                    itemData = null;
                }
            }
        }
    }

    public boolean isEmpty() {
        synchronized (slotLock) {
            return itemData == null || itemData.getCount() <= 0;
        }
    }

    public void clear() {
        synchronized (slotLock) {
            this.itemData = null;
        }
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/AddOperation.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.math.Vector2;

public class AddOperation extends WorldObjectOperation {
    public Vector2 chunkPos;
    public WorldObject object;

    public AddOperation(Vector2 chunkPos, WorldObject object) {
        super(OperationType.ADD);
        this.type = OperationType.ADD;
        this.chunkPos = chunkPos;
        this.object = object;
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/biomes/Biome.java
================
package io.github.pokemeetup.system.gameplay.overworld.biomes;

import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

public class Biome {
    private final BiomeType type;
    private HashMap<Integer, Integer> tileDistribution;
    private String name;
    private List<Integer> allowedTileTypes;
    private List<WorldObject.ObjectType> spawnableObjects;
    private Map<WorldObject.ObjectType, Double> spawnChances;

    public Biome(String name, BiomeType type) {
        this.name = name;
        this.type = type;
        this.allowedTileTypes = new ArrayList<>();
        this.spawnableObjects = new ArrayList<>();
        this.spawnChances = new HashMap<>();
        this.tileDistribution = new HashMap<>();
    }

    public List<WorldObject.ObjectType> getSpawnableObjects() {
        return spawnableObjects != null ? spawnableObjects : new ArrayList<>();
    }


    public Map<WorldObject.ObjectType, Double> getSpawnChances() {
        return spawnChances;
    }

    public void loadSpawnableObjects(List<String> objectStrings) {
        this.spawnableObjects = new ArrayList<>();
        for (String objStr : objectStrings) {
            try {
                WorldObject.ObjectType type = WorldObject.ObjectType.valueOf(objStr);
                this.spawnableObjects.add(type);
            } catch (IllegalArgumentException e) {
                GameLogger.error(name + ": Invalid object type: " + objStr);
            }
        }
    }
    public void loadSpawnChances(Map<String, Double> chanceMap) {
        this.spawnChances = new HashMap<>();
        for (Map.Entry<String, Double> entry : chanceMap.entrySet()) {
            try {
                WorldObject.ObjectType type = WorldObject.ObjectType.valueOf(entry.getKey());
                this.spawnChances.put(type, entry.getValue());
            } catch (IllegalArgumentException e) {
                GameLogger.error(name + ": Invalid object type in spawn chances: " + entry.getKey());
            }
        }
    }

    public double getSpawnChanceForObject(WorldObject.ObjectType objectType) {
        return spawnChances != null ? spawnChances.getOrDefault(objectType, 0.0) : 0.0;
    }

    public void setTileDistribution(Map<Integer, Integer> distribution) {
        if (distribution == null || distribution.isEmpty()) {
            throw new IllegalArgumentException("Tile distribution cannot be null or empty");
        }

        // If allowed types is empty, initialize it from the distribution
        if (allowedTileTypes.isEmpty()) {
            allowedTileTypes = new ArrayList<>(distribution.keySet());
        }

        // Add any missing tile types to allowed types
        for (Integer tileType : distribution.keySet()) {
            if (!allowedTileTypes.contains(tileType)) {
                allowedTileTypes.add(tileType);
            }
        }



        double totalWeight = distribution.values().stream()
            .mapToDouble(Integer::doubleValue)
            .sum();

        // Normalize weights if needed
        if (Math.abs(totalWeight - 100.0) > 0.001) {
            Map<Integer, Integer> normalizedDist = new HashMap<>();

            for (Map.Entry<Integer, Integer> entry : distribution.entrySet()) {
                double normalizedValue = (entry.getValue() / totalWeight) * 100.0;
                normalizedDist.put(entry.getKey(), (int) Math.round(normalizedValue));
            }

            // Adjust for rounding errors
            int finalTotal = normalizedDist.values().stream()
                .mapToInt(Integer::intValue)
                .sum();

            if (finalTotal != 100) {
                int diff = 100 - finalTotal;
                int highestKey = normalizedDist.entrySet().stream()
                    .max(Map.Entry.comparingByValue())
                    .map(Map.Entry::getKey)
                    .orElse(distribution.keySet().iterator().next());

                normalizedDist.put(highestKey, normalizedDist.get(highestKey) + diff);
            }

            distribution = normalizedDist;
        }

        // Store the normalized distribution
        this.tileDistribution = new HashMap<>(distribution);

    }

    public BiomeType getType() {
        return type;
    }

    public HashMap<Integer, Integer> getTileDistribution() {
        return tileDistribution;
    }
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }


    public List<Integer> getAllowedTileTypes() {
        return allowedTileTypes;
    }

    public void setAllowedTileTypes(List<Integer> allowedTileTypes) {
        this.allowedTileTypes = allowedTileTypes;
    }
    private void useFallbackDistribution() {
        // Provide safe default distribution
        Map<Integer, Integer> fallback = new HashMap<>();
        fallback.put(1, 70);  // grass
        fallback.put(2, 20);  // dirt
        fallback.put(3, 10);  // stone

        this.allowedTileTypes = new ArrayList<>(fallback.keySet());
        this.tileDistribution = new HashMap<>(fallback);

        GameLogger.info(String.format("Biome %s using fallback distribution: %s",
            name, fallback));
    }

    // Add this method to validate the entire biome state
    public void validate() {
        if (allowedTileTypes == null) {
            allowedTileTypes = new ArrayList<>();
        }

        if (tileDistribution == null || tileDistribution.isEmpty()) {
            useFallbackDistribution();
        }

        if (spawnableObjects == null) {
            spawnableObjects = new ArrayList<>();
        }
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/biomes/BiomeType.java
================
package io.github.pokemeetup.system.gameplay.overworld.biomes;

public enum BiomeType {
    PLAINS,
    FOREST,
    SNOW,
    HAUNTED,
    DESERT,
    RAIN_FOREST,
    BIG_MOUNTAINS,
    RUINS
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/Chunk.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.managers.BiomeTransitionResult;
import io.github.pokemeetup.system.data.BlockSaveData;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.system.gameplay.overworld.mechanics.AutoTileSystem;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.OpenSimplex2;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.*;

public class Chunk {
    public static final int CHUNK_SIZE = 16;

    private final BiomeManager biomeManager;
    private final long worldSeed;
    private final int chunkX;
    private final int chunkY;
    public boolean isDirty = false;
    private Biome biome;
    private Map<Vector2, PlaceableBlock> blocks = new HashMap<>();
    private int[][] tileData;
    private int[][] elevationBands;

    public Chunk() {
        this.chunkX = 0;
        this.chunkY = 0;
        this.worldSeed = 5;
        this.biomeManager = new BiomeManager(this.worldSeed);
    }

    public Chunk(int chunkX, int chunkY, Biome biome, long worldSeed, BiomeManager biomeManager) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
        this.biome = biome;
        this.worldSeed = worldSeed;
        this.biomeManager = biomeManager;
        this.tileData = new int[CHUNK_SIZE][CHUNK_SIZE];
        generateChunkData();
    }

    public void addBlock(PlaceableBlock block) {
        if (block != null) {
            blocks.put(block.getPosition(), block);
            isDirty = true;
        }
    }

    public void removeBlock(Vector2 position) {
        blocks.remove(position);
        isDirty = true;
    }

    public PlaceableBlock getBlock(Vector2 position) {
        return blocks.get(position);
    }

    public Map<Vector2, PlaceableBlock> getBlocks() {
        return new HashMap<>(blocks);
    }

    public boolean isDirty() {
        return isDirty;
    }

    public void setDirty(boolean dirty) {
        this.isDirty = dirty;
    }

    public Biome getBiome() {
        return biome;
    }

    public int getTileType(int localX, int localY) {
        if (localX < 0 || localX >= CHUNK_SIZE || localY < 0 || localY >= CHUNK_SIZE) {
            return -1;
        }
        return tileData[localX][localY];
    }

    public int[][] getTileData() {
        return tileData;
    }

    public void setTileData(int[][] tileData) {
        this.tileData = tileData;
    }

    public int getChunkX() {
        return chunkX;
    }

    public int getChunkY() {
        return chunkY;
    }

    public List<BlockSaveData.BlockData> getBlockDataForSave() {
        List<BlockSaveData.BlockData> blockDataList = new ArrayList<>();
        for (PlaceableBlock b : blocks.values()) {
            BlockSaveData.BlockData data = new BlockSaveData.BlockData();
            data.type = b.getId();
            data.x = (int) b.getPosition().x;
            data.y = (int) b.getPosition().y;
            data.isFlipped = b.isFlipped();
            data.isChestOpen = b.isChestOpen();
            if (b.getType() == PlaceableBlock.BlockType.CHEST && b.getChestData() != null) {
                data.chestData = b.getChestData();
            }
            blockDataList.add(data);
        }
        return blockDataList;
    }

    private void assignMountainTile(int x, int y, int[][] data, int[][] elevationBands) {
        int currentBand = elevationBands[x][y];
        if (currentBand <= 0) return;

        boolean isLowestBand = (currentBand == 1);

        int bandN = getBand(x, y + 1, elevationBands);
        int bandS = getBand(x, y - 1, elevationBands);
        int bandE = getBand(x + 1, y, elevationBands);
        int bandW = getBand(x - 1, y, elevationBands);

        int bandNE = getBand(x + 1, y + 1, elevationBands);
        int bandNW = getBand(x - 1, y + 1, elevationBands);
        int bandSE = getBand(x + 1, y - 1, elevationBands);
        int bandSW = getBand(x - 1, y - 1, elevationBands);

        boolean topLower = bandN < currentBand;
        boolean bottomLower = bandS < currentBand;
        boolean leftLower = bandW < currentBand;
        boolean rightLower = bandE < currentBand;

        // Decide which background set to use: GRASS_BG for band=1, ROCK_BG otherwise
        int topLeftCorner     = isLowestBand ? TileType.MOUNTAIN_TILE_TOP_LEFT_GRASS_BG : TileType.MOUNTAIN_TILE_TOP_LEFT_ROCK_BG;
        int topRightCorner    = isLowestBand ? TileType.MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG : TileType.MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG;
        int bottomLeftCorner  = isLowestBand ? TileType.MOUNTAIN_TILE_BOT_LEFT_GRASS_BG : TileType.MOUNTAIN_TILE_BOT_LEFT_ROCK_BG;
        int bottomRightCorner = isLowestBand ? TileType.MOUNTAIN_TILE_BOT_RIGHT_GRASS_BG : TileType.MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG;

        // If no side is lower, it's a plateau center.
        if (!topLower && !bottomLower && !leftLower && !rightLower) {
            data[x][y] = TileType.MOUNTAIN_TILE_CENTER;
            return;
        }

        // Check for standard corners first
        // Perfect corners: top-left, top-right, bottom-left, bottom-right
        if (topLower && leftLower && !rightLower && !bottomLower) {
            data[x][y] = topLeftCorner;
            return;
        }
        if (topLower && rightLower && !bottomLower && !leftLower) {
            data[x][y] = topRightCorner;
            return;
        }
        if (bottomLower && leftLower && !topLower && !rightLower) {
            data[x][y] = bottomLeftCorner;
            return;
        }
        if (bottomLower && rightLower && !topLower && !leftLower) {
            data[x][y] = bottomRightCorner;
            return;
        }

        // Check for single-direction cliffs (no corner)
        if (topLower && !(leftLower || rightLower || bottomLower)) {
            data[x][y] = TileType.MOUNTAIN_TILE_TOP_MID;
            return;
        }
        if (bottomLower && !(leftLower || rightLower || topLower)) {
            data[x][y] = TileType.MOUNTAIN_TILE_BOT_MID;
            return;
        }
        if (leftLower && !(topLower || bottomLower || rightLower)) {
            data[x][y] = TileType.MOUNTAIN_TILE_MID_LEFT;
            return;
        }
        if (rightLower && !(topLower || bottomLower || leftLower)) {
            data[x][y] = TileType.MOUNTAIN_TILE_MID_RIGHT;
            return;
        }
        if (!topLower && !leftLower && bandNW < currentBand) {
            data[x][y] = TileType.MOUNTAIN_TILE_CONNECTING_CORNER_TOP_LEFT;
            return;
        }

        // TOP-RIGHT CONNECTING CORNER:
        if (!topLower && !rightLower && bandNE < currentBand) {
            data[x][y] = TileType.MOUNTAIN_TILE_CONNECTING_CORNER_TOP_RIGHT;
            return;
        }

        // BOTTOM-LEFT CONNECTING CORNER:
        if (!bottomLower && !leftLower && bandSW < currentBand) {
            data[x][y] = TileType.MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_LEFT;
            return;
        }

        // BOTTOM-RIGHT CONNECTING CORNER:
        if (!bottomLower && !rightLower && bandSE < currentBand) {
            data[x][y] = TileType.MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_RIGHT;
            return;
        }

        // If multiple lowers but no neat configuration:
        // Default back to a logical side tile or a corner tile.
        // Prioritize top/bottom edges over side edges for a consistent look,
        // and if no single direction chosen, choose a side as fallback.

        if (topLower) {
            data[x][y] = TileType.MOUNTAIN_TILE_TOP_MID;
            return;
        }
        if (bottomLower) {
            data[x][y] = TileType.MOUNTAIN_TILE_BOT_MID;
            return;
        }
        if (leftLower) {
            data[x][y] = TileType.MOUNTAIN_TILE_MID_LEFT;
            return;
        }
        if (rightLower) {
            data[x][y] = TileType.MOUNTAIN_TILE_MID_RIGHT;
            return;
        }

        // If somehow none of the above conditions triggered (very unlikely),
        // default to center.
        data[x][y] = TileType.MOUNTAIN_TILE_CENTER;
    }

    public int[][] getElevationBands() {
        return this.elevationBands;
    }


    private void generateMountainShape(int maxLayers, Random rand) {
        if (maxLayers <= 0) return;

        // We will use multiple peaks and multiple noise layers for more natural shapes.
        int numPeaks = rand.nextInt(2) + 1; // 1 or 2 peaks per chunk
        List<Point> peaks = new ArrayList<>();
        for (int i = 0; i < numPeaks; i++) {
            int px = CHUNK_SIZE / 4 + rand.nextInt(CHUNK_SIZE / 2);
            int py = CHUNK_SIZE / 4 + rand.nextInt(CHUNK_SIZE / 2);
            peaks.add(new Point(px, py));
        }

        // Base radius for conceptual scaling; we won't rely solely on distance now.
        float baseRadius = CHUNK_SIZE * (0.3f + 0.1f * maxLayers);

        // Introduce multiple noise frequencies for terrain variation
        // For example, a coarse noise for general big shapes, and a finer noise for details.
        // We’ll use OpenSimplex2 noise again:
        // coarseNoise: large-scale shape
        // detailNoise: smaller-scale bumps
        // ridgeNoise: ridged noise to create sharper transitions.

        for (int x = 0; x < CHUNK_SIZE; x++) {
            for (int y = 0; y < CHUNK_SIZE; y++) {
                // Compute world coordinates if needed
                // Not mandatory if we want each chunk pattern unique:
                float worldCoordX = (chunkX * CHUNK_SIZE + x) * 0.5f;
                float worldCoordY = (chunkY * CHUNK_SIZE + y) * 0.5f;

                // Distance to closest peak to add a slight gradient
                double minDist = Double.MAX_VALUE;
                for (Point p : peaks) {
                    double dx = x - p.x;
                    double dy = y - p.y;
                    double dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) minDist = dist;
                }

                double distFactor = minDist / baseRadius;

                // Basic elevation from distance: closer to a peak = higher band
                // Invert distFactor so close to peak = near 0.0, far = near 1.0
                double baseElevation = Math.max(0, 1.0 - distFactor);

                // Add coarse noise for large shape variation
                double coarse = OpenSimplex2.noise2(worldSeed + 200, worldCoordX * 0.04f, worldCoordY * 0.04f);
                // Scale and bias so that coarse noise slightly reshapes the mountain
                baseElevation += coarse * 0.2; // +20% variation

                // Add detail noise for local bumps
                double detail = OpenSimplex2.noise2(worldSeed + 300, worldCoordX * 0.15f, worldCoordY * 0.15f);
                baseElevation += detail * 0.1; // small bumps

                // Create a ridged noise for more cliff-like features
                double ridgeRaw = OpenSimplex2.noise2(worldSeed + 400, worldCoordX * 0.08f, worldCoordY * 0.08f);
                double ridge = 1.0 - Math.abs(ridgeRaw); // ridged: invert absolute value
                ridge = ridge * ridge; // square to sharpen peaks
                baseElevation += (ridge - 0.5) * 0.2; // integrate ridge, centered around 0.5

                // Clamp elevation between 0 and 1
                baseElevation = Math.max(0, Math.min(1, baseElevation));

                // Now we determine bands from this elevation.
                // Instead of fixed thresholds, we let thresholds vary per tile with noise.
                // For example:
                double bandNoise = OpenSimplex2.noise2(worldSeed + 500, worldCoordX * 0.1f, worldCoordY * 0.1f);
                // bandNoise in [-1,1], shift to [0,1]
                bandNoise = (bandNoise + 1.0) / 2.0;

                // For maxLayers (1 to 3 or more), define thresholds dynamically:
                // Example for 3 layers: band3 if elevation > 0.7 + small random offset,
                // band2 if elevation > 0.4 + offset, else band1.
                // Offsets vary per tile by bandNoise.
                double topBandThreshold = 0.4 + bandNoise * 0.1;    // vary top threshold 0.4-0.5
                double midBandThreshold = 0.7 + bandNoise * 0.1;    // vary mid threshold 0.7-0.8

                // If maxLayers=1, all elevation >0 is band 1
                // If maxLayers=2, elevation > midBandThreshold = band 2 else band 1
                // If maxLayers=3, elevation > midBandThreshold=band3, >topBandThreshold=band2 else band1

                int band = 0;
                if (maxLayers == 1) {
                    if (baseElevation > 0.2) band = 1; // just a simple cutoff
                } else if (maxLayers == 2) {
                    if (baseElevation > midBandThreshold) band = 2;
                    else if (baseElevation > 0.2) band = 1; // ensure some base level
                } else {
                    // 3 or more layers - we treat similarly to 3-layer logic:
                    // For more than 3, you can add more thresholds or distribute evenly
                    if (maxLayers >= 3) {
                        // band 3 if elevation very high
                        // band 2 if medium
                        // band 1 if above a low threshold
                        if (baseElevation > midBandThreshold) band = 3;
                        else if (baseElevation > topBandThreshold) band = 2;
                        else if (baseElevation > 0.2) band = 1; // basic lower band
                    }

                    // If you have more than 3 layers, you can interpolate further:
                    // For layer 4, 5, etc., create additional thresholds:
                    // Example:
                    if (maxLayers > 3) {
                        // Add an extra layer between band 2 and 3:
                        double extraLayerThreshold = midBandThreshold + (1 - midBandThreshold)*0.5;
                        // If elevation > extraLayerThreshold and maxLayers=4: band=4, else band=3
                        if (maxLayers == 4 && baseElevation > extraLayerThreshold) {
                            band = 4;
                        }
                    }
                }

                elevationBands[x][y] = band;
            }
        }

        // After assigning bands, apply a more aggressive smoothing/erosion step to break patterns:
        applyErosionToBands(rand);
        smoothBandsForCohesion();
        // Another pass to further break uniformity
        applyErosionToBands(rand);
        smoothBandsForCohesion();
    }

    private void applyErosionToBands(Random rand) {
        // A simple erosion step: if a tile is a high band tile but surrounded mostly by lower bands, degrade it.
        // If a tile is lower but surrounded by higher, sometimes raise it. This breaks uniform patterns.
        int[][] temp = new int[CHUNK_SIZE][CHUNK_SIZE];
        for (int x = 1; x < CHUNK_SIZE - 1; x++) {
            for (int y = 1; y < CHUNK_SIZE - 1; y++) {
                int band = elevationBands[x][y];
                if (band == 0) {
                    temp[x][y] = 0;
                    continue;
                }

                int higherCount = 0;
                int lowerCount = 0;
                int sameCount = 0;
                int totalNeighbors = 0;
                for (int dx = -1; dx <= 1; dx++) {
                    for (int dy = -1; dy <= 1; dy++) {
                        if (dx == 0 && dy == 0) continue;
                        int nx = x+dx, ny = y+dy;
                        if (nx < 0 || ny < 0 || nx >= CHUNK_SIZE || ny >= CHUNK_SIZE) continue;
                        totalNeighbors++;
                        int nbBand = elevationBands[nx][ny];
                        if (nbBand > band) higherCount++;
                        else if (nbBand < band) lowerCount++;
                        else sameCount++;
                    }
                }

                // Erosion rules:
                // If a band is high and surrounded by many lower tiles, degrade it:
                if (band > 1 && lowerCount > higherCount + sameCount) {
                    temp[x][y] = band - 1;
                }
                // If a band is low but surrounded by higher tiles, sometimes raise it:
                else if (band > 0 && higherCount > lowerCount + sameCount && rand.nextFloat() < 0.1f) {
                    temp[x][y] = band + 1;
                } else {
                    temp[x][y] = band;
                }
            }
        }

        // Copy back
        for (int x = 1; x < CHUNK_SIZE - 1; x++) {
            System.arraycopy(temp[x], 1, elevationBands[x], 1, CHUNK_SIZE - 2);
        }
    }

    private int generateTransitionTileTile(int x, int y, BiomeTransitionResult biomeResult, float worldX, float worldY) {
        Biome primaryBiome = biomeResult.getPrimaryBiome();
        Biome secondaryBiome = biomeResult.getSecondaryBiome();
        float transitionFactor = biomeResult.getTransitionFactor();

        float noise = OpenSimplex2.noise2(worldSeed + 700, worldX * 0.1f, worldY * 0.1f);
        transitionFactor += noise * 0.2f;
        transitionFactor = Math.max(0, Math.min(1, transitionFactor));
        double selectionValue = (OpenSimplex2.noise2(worldSeed + 1100, worldX * 0.5f, worldY * 0.5f) + 1.0) / 2.0;

        if (selectionValue > transitionFactor) {
            return determineTileTypeForBiome(secondaryBiome, worldX, worldY);
        } else {
            return determineTileTypeForBiome(primaryBiome, worldX, worldY);
        }
    }



    private int determineTileTypeForBiome(Biome biome, float worldX, float worldY) {
        int initialTile = getInitialTileType(biome, worldX, worldY);
        return applyEcosystemRules(initialTile, worldX, worldY);
    }

    private int getInitialTileType(Biome biome, float worldX, float worldY) {
        Map<Integer, Integer> distribution = biome.getTileDistribution();
        List<Integer> allowedTypes = biome.getAllowedTileTypes();

        if (distribution == null || distribution.isEmpty() || allowedTypes == null || allowedTypes.isEmpty()) {
            GameLogger.error("Missing tile distribution or allowed types for biome: " + biome.getName());
            return TileType.GRASS; // fallback
        }

        double totalWeight = distribution.values().stream().mapToDouble(Integer::doubleValue).sum();
        double noiseValue = (OpenSimplex2.noise2(worldSeed + 1000, worldX * 0.5f, worldY * 0.5f) + 1.0) / 2.0;
        double roll = noiseValue * totalWeight;

        double currentTotal = 0;
        for (Map.Entry<Integer, Integer> entry : distribution.entrySet()) {
            currentTotal += entry.getValue();
            if (roll <= currentTotal) {
                return entry.getKey();
            }
        }

        return allowedTypes.get(0);
    }


    private boolean hasLowerNeighbor(int x, int y, int[][] elevationBands) {
        int band = getBand(x, y, elevationBands);
        int n = getBand(x, y + 1, elevationBands);
        int s = getBand(x, y - 1, elevationBands);
        int e = getBand(x + 1, y, elevationBands);
        int w = getBand(x - 1, y, elevationBands);
        return (n < band) || (s < band) || (e < band) || (w < band);
    }


    private boolean isCliffTile(int tile) {
        return tile != TileType.MOUNTAIN_TILE_CENTER &&
            tile != TileType.GRASS &&
            tile != TileType.MOUNTAIN_PEAK &&
            tile != TileType.MOUNTAIN_SNOW_BASE &&
            tile != TileType.STAIRS &&
            tile != TileType.CAVE_ENTRANCE &&
            tile != TileType.FLOWER && tile != TileType.FLOWER_1 && tile != TileType.FLOWER_2 &&
            tile != TileType.GRASS_2 && tile != TileType.GRASS_3 &&
            tile != TileType.TALL_GRASS && tile != TileType.TALL_GRASS_2 && tile != TileType.TALL_GRASS_3 &&
            tile != TileType.SAND && tile != TileType.DESERT_SAND &&
            tile != TileType.HAUNTED_GRASS && tile != TileType.HAUNTED_TALL_GRASS &&
            tile != TileType.RAIN_FOREST_GRASS && tile != TileType.RAIN_FOREST_TALL_GRASS &&
            tile != TileType.FOREST_GRASS && tile != TileType.FOREST_TALL_GRASS &&
            tile != TileType.SNOW && tile != TileType.SNOW_2 && tile != TileType.SNOW_3 && tile != TileType.SNOW_TALL_GRASS &&
            tile != TileType.RUINS_GRASS && tile != TileType.RUINS_GRASS_0 && tile != TileType.RUINS_TALL_GRASS &&
            tile != TileType.RUINS_BRICKS;
    }



    private boolean stairsExistBetween(int[][] elevationBands, int fromBand, int toBand) {
        for (int x = 0; x < CHUNK_SIZE; x++) {
            for (int y = 0; y < CHUNK_SIZE; y++) {
                if (tileData[x][y] == TileType.STAIRS) {
                    int band = getBand(x, y, elevationBands);
                    if (band == fromBand) {
                        // Check adjacent tiles for toBand
                        if (getBand(x, y + 1, elevationBands) == toBand ||
                            getBand(x, y - 1, elevationBands) == toBand ||
                            getBand(x + 1, y, elevationBands) == toBand ||
                            getBand(x - 1, y, elevationBands) == toBand) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    private boolean getRandomChance(float probability) {
        return MathUtils.random() < probability;
    }

    private Map<Integer, Integer> getNeighborTileCounts(int x, int y) {
        Map<Integer, Integer> counts = new HashMap<>();

        // Check all 8 surrounding tiles
        for (int dx = -1; dx <= 1; dx++) {
            for (int dy = -1; dy <= 1; dy++) {
                if (dx == 0 && dy == 0) continue;

                int nx = x + dx;
                int ny = y + dy;

                // Handle chunk boundaries
                if (nx >= 0 && nx < CHUNK_SIZE && ny >= 0 && ny < CHUNK_SIZE) {
                    int neighborTile = tileData[nx][ny];
                    counts.merge(neighborTile, 1, Integer::sum);
                }
            }
        }

        return counts;
    }

    private boolean hasWaterNeighbor(Map<Integer, Integer> neighborCounts) {
        return neighborCounts.containsKey(TileType.WATER) ||
            neighborCounts.containsKey(TileType.WATER_PUDDLE) ||
            neighborCounts.containsKey(TileType.WATER_PUDDLE_TOP_LEFT) ||
            neighborCounts.containsKey(TileType.WATER_PUDDLE_TOP_MIDDLE) ||
            neighborCounts.containsKey(TileType.WATER_PUDDLE_TOP_RIGHT) ||
            neighborCounts.containsKey(TileType.WATER_PUDDLE_LEFT_MIDDLE) ||
            neighborCounts.containsKey(TileType.WATER_PUDDLE_RIGHT_MIDDLE) ||
            neighborCounts.containsKey(TileType.WATER_PUDDLE_BOTTOM_LEFT) ||
            neighborCounts.containsKey(TileType.WATER_PUDDLE_BOTTOM_MIDDLE) ||
            neighborCounts.containsKey(TileType.WATER_PUDDLE_BOTTOM_RIGHT);
    }

    private boolean hasMatchingNeighbor(Map<Integer, Integer> neighborCounts, int tileType) {
        return neighborCounts.getOrDefault(tileType, 0) > 0;
    }

    private int applyEcosystemRules(int currentTile, float worldX, float worldY) {
        // Original ecosystem logic as provided by user
        int localX = Math.floorMod((int) (worldX / World.TILE_SIZE), CHUNK_SIZE);
        int localY = Math.floorMod((int) (worldY / World.TILE_SIZE), CHUNK_SIZE);

        Map<Integer, Integer> neighborCounts = getNeighborTileCounts(localX, localY);

        switch (currentTile) {
            case TileType.SAND:
            case TileType.DESERT_SAND:
                if (hasWaterNeighbor(neighborCounts)) {
                    return currentTile;
                }
                if (getRandomChance(0.75f) && (hasMatchingNeighbor(neighborCounts, TileType.SAND) ||
                    hasMatchingNeighbor(neighborCounts, TileType.DESERT_SAND))) {
                    return currentTile;
                }
                break;

            case TileType.GRASS:
            case TileType.GRASS_2:
            case TileType.GRASS_3:
                if (hasWaterNeighbor(neighborCounts)) {
                    return getRandomChance(0.25f) ? TileType.TALL_GRASS : currentTile; // Adjusted from original
                }
                if (getRandomChance(0.55f) && hasAnyGrassNeighbor(neighborCounts)) {
                    if (getRandomChance(0.08f)) {
                        return TileType.FLOWER;
                    }
                    if (getRandomChance(0.08f)) {
                        return getRandomChance(0.5f) ? TileType.FLOWER_1 : TileType.FLOWER_2;
                    }
                    return currentTile;
                }
                break;

            case TileType.SNOW:
            case TileType.SNOW_2:
            case TileType.SNOW_3:
                if (hasAnySnowNeighbor(neighborCounts)) {
                    if (getRandomChance(0.25f)) {
                        if (getRandomChance(0.20f)) {
                            return TileType.SNOW_TALL_GRASS;
                        } else {
                            float roll = MathUtils.random();
                            if (roll < 0.70f) {
                                return TileType.SNOW;
                            } else if (roll < 0.85f) {
                                return TileType.SNOW_2;
                            } else {
                                return TileType.SNOW_3;
                            }
                        }
                    }
                }
                break;

            // Include other biome ecosystem variants (FOREST_GRASS, RAIN_FOREST_GRASS, HAUNTED_GRASS, RUINS) as originally shown

            case TileType.FOREST_GRASS:
                if (getRandomChance(0.35f) && hasMatchingNeighbor(neighborCounts, TileType.FOREST_GRASS)) {
                    return getRandomChance(0.25f) ? TileType.FOREST_TALL_GRASS : TileType.FOREST_GRASS;
                }
                break;

            case TileType.RAIN_FOREST_GRASS:
                if (hasWaterNeighbor(neighborCounts)) {
                    return getRandomChance(0.35f) ? TileType.RAIN_FOREST_TALL_GRASS : TileType.RAIN_FOREST_GRASS;
                }
                if (getRandomChance(0.45f) && hasMatchingNeighbor(neighborCounts, TileType.RAIN_FOREST_GRASS)) {
                    return currentTile;
                }
                break;

            case TileType.HAUNTED_GRASS:
                if (getRandomChance(0.30f) && hasMatchingNeighbor(neighborCounts, TileType.HAUNTED_GRASS)) {
                    if (getRandomChance(0.25f)) {
                        return TileType.HAUNTED_TALL_GRASS;
                    } else if (getRandomChance(0.15f)) {
                        return getRandomChance(0.5f) ? TileType.HAUNTED_SHROOM : TileType.HAUNTED_SHROOMS;
                    }
                    return TileType.HAUNTED_GRASS;
                }
                break;

            case TileType.RUINS_GRASS:
            case TileType.RUINS_GRASS_0:
                if (getRandomChance(0.35f) && hasAnyRuinsNeighbor(neighborCounts)) {
                    if (getRandomChance(0.25f)) {
                        return TileType.RUINS_TALL_GRASS;
                    } else if (getRandomChance(0.20f)) {
                        return TileType.RUINS_BRICKS;
                    }
                    return currentTile;
                }
                break;

            case TileType.TALL_GRASS:
            case TileType.TALL_GRASS_2:
            case TileType.TALL_GRASS_3:
                if (!hasAnyGrassNeighbor(neighborCounts)) {
                    return TileType.GRASS;
                }
                break;
        }

        return currentTile;
    }

    private boolean hasAnyGrassNeighbor(Map<Integer, Integer> neighborCounts) {
        return neighborCounts.containsKey(TileType.GRASS) ||
            neighborCounts.containsKey(TileType.GRASS_2) ||
            neighborCounts.containsKey(TileType.GRASS_3);
    }

    private boolean hasAnySnowNeighbor(Map<Integer, Integer> neighborCounts) {
        return neighborCounts.containsKey(TileType.SNOW) ||
            neighborCounts.containsKey(TileType.SNOW_2) ||
            neighborCounts.containsKey(TileType.SNOW_3);
    }

    private boolean hasAnyRuinsNeighbor(Map<Integer, Integer> neighborCounts) {
        return neighborCounts.containsKey(TileType.RUINS_GRASS) ||
            neighborCounts.containsKey(TileType.RUINS_GRASS_0) ||
            neighborCounts.containsKey(TileType.RUINS_BRICKS) ||
            neighborCounts.containsKey(TileType.RUINS_TALL_GRASS);
    }

    private void generateChunkData() {
        Random rand = new Random(worldSeed + chunkX * 31L + chunkY * 17L);

        // First, get the biome for this chunk
        float worldX = (chunkX * CHUNK_SIZE + CHUNK_SIZE / 2) * World.TILE_SIZE;
        float worldY = (chunkY * CHUNK_SIZE + CHUNK_SIZE / 2) * World.TILE_SIZE;
        BiomeTransitionResult biomeResult = biomeManager.getBiomeAt(worldX, worldY);
        this.biome = biomeResult.getPrimaryBiome();

        // Determine mountain generation based on biome
        int maxLayers = determineNumberOfLayers(rand, biome.getType());
        elevationBands = new int[CHUNK_SIZE][CHUNK_SIZE];

        // Generate base tiles first using biome information
        tileData = new int[CHUNK_SIZE][CHUNK_SIZE];
        for (int x = 0; x < CHUNK_SIZE; x++) {
            for (int y = 0; y < CHUNK_SIZE; y++) {
                worldX = (chunkX * CHUNK_SIZE + x) * World.TILE_SIZE;
                worldY = (chunkY * CHUNK_SIZE + y) * World.TILE_SIZE;
                BiomeTransitionResult localBiome = biomeManager.getBiomeAt(worldX, worldY);
                tileData[x][y] = determineTileTypeForBiome(localBiome.getPrimaryBiome(), worldX, worldY);

                // Handle biome transitions
                if (localBiome.getSecondaryBiome() != null && localBiome.getTransitionFactor() < 1.0f) {
                    tileData[x][y] = generateTransitionTileTile(x, y, localBiome, worldX, worldY);
                }
            }
        }
        if (biome != null && biome.getType() == BiomeType.RAIN_FOREST) {
            generateRainForestPonds();
        }
        // If no mountain, we're done
        if (maxLayers == 0) {
            return;
        }

        // Generate varied mountain shapes
        generateMountainShape(maxLayers, rand);

        // Apply mountain tiles based on elevation bands
        applyMountainTiles();

        // Add features
        autotileCliffs(elevationBands, tileData);
        addStairsBetweenLayers(elevationBands, tileData);
        finalizeStairAccess(tileData, elevationBands);
        maybeAddCaveEntrance(elevationBands, tileData, rand);

        isDirty = true;
    }


    private void addStairsBetweenLayers(int[][] bands, int[][] tiles) {
        // For each elevation transition (0->1, 1->2, 2->3)
        for (int fromBand = 0; fromBand < 3; fromBand++) {
            int toBand = fromBand + 1;
            if (!layerExists(bands, toBand)) continue;

            // Place multiple stairs for each transition
            int stairsPlaced = 0;
            int requiredStairs = (fromBand == 0) ? 4 : 2; // More stairs at ground level

            // Try to place stairs on each side
            if (placeStairsOnSide(bands, tiles, fromBand, toBand, "north")) stairsPlaced++;
            if (placeStairsOnSide(bands, tiles, fromBand, toBand, "south")) stairsPlaced++;
            if (placeStairsOnSide(bands, tiles, fromBand, toBand, "east")) stairsPlaced++;
            if (placeStairsOnSide(bands, tiles, fromBand, toBand, "west")) stairsPlaced++;

            // If we couldn't place enough stairs on sides, try placing additional stairs
            while (stairsPlaced < requiredStairs) {
                if (placeAdditionalStairs(bands, tiles, fromBand, toBand)) {
                    stairsPlaced++;
                } else {
                    break; // No more valid positions found
                }
            }
        }
    }

    private boolean placeAdditionalStairs(int[][] bands, int[][] tiles, int fromBand, int toBand) {
        // Try to place stairs anywhere valid
        for (int x = 1; x < CHUNK_SIZE-1; x++) {
            for (int y = 1; y < CHUNK_SIZE-1; y++) {
                if (canPlaceStairsHere(x, y, bands, tiles, fromBand, toBand)) {
                    tiles[x][y] = TileType.STAIRS;
                    return true;
                }
            }
        }
        return false;
    }
    private boolean canPlaceStairsHere(int x, int y, int[][] bands, int[][] tiles, int fromBand, int toBand) {
        // Must be at the right elevation
        if (bands[x][y] != fromBand) return false;

        // Must be a cliff tile
        if (!isCliffTile(tiles[x][y])) return false;

        // Must have the higher band adjacent
        if (!hasAdjacentBand(x, y, toBand, bands)) return false;

        // Check for nearby stairs to prevent clustering
        if (hasNearbyStairs(x, y, tiles, 3)) return false;

        return true;
    }

    private boolean hasAdjacentBand(int x, int y, int targetBand, int[][] bands) {
        return getBand(x+1, y, bands) == targetBand ||
            getBand(x-1, y, bands) == targetBand ||
            getBand(x, y+1, bands) == targetBand ||
            getBand(x, y-1, bands) == targetBand;
    }

    private boolean hasNearbyStairs(int x, int y, int[][] tiles, int radius) {
        for (int dx = -radius; dx <= radius; dx++) {
            for (int dy = -radius; dy <= radius; dy++) {
                int nx = x + dx;
                int ny = y + dy;
                if (nx >= 0 && nx < CHUNK_SIZE && ny >= 0 && ny < CHUNK_SIZE) {
                    if (tiles[nx][ny] == TileType.STAIRS) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    private boolean placeStairsOnSide(int[][] bands, int[][] tiles, int fromBand, int toBand, String side) {
        int startX, startY, endX, endY;

        switch(side) {
            case "north":
                startX = 1; endX = CHUNK_SIZE-1;
                startY = CHUNK_SIZE-2; endY = CHUNK_SIZE-1;
                break;
            case "south":
                startX = 1; endX = CHUNK_SIZE-1;
                startY = 1; endY = 2;
                break;
            case "east":
                startX = CHUNK_SIZE-2; endX = CHUNK_SIZE-1;
                startY = 1; endY = CHUNK_SIZE-1;
                break;
            case "west":
                startX = 1; endX = 2;
                startY = 1; endY = CHUNK_SIZE-1;
                break;
            default:
                return false;
        }

        // Look for valid positions along this side
        for (int x = startX; x < endX; x++) {
            for (int y = startY; y < endY; y++) {
                if (canPlaceStairsHere(x, y, bands, tiles, fromBand, toBand)) {
                    tiles[x][y] = TileType.STAIRS;
                    return true;
                }
            }
        }
        return false;
    }private void finalizeStairAccess(int[][] tiles, int[][] bands) {
        // After all stairs are placed, ensure that the tile above the stairs is MOUNTAIN_TILE_CENTER if it’s in the higher band.
        for (int x = 0; x < CHUNK_SIZE; x++) {
            for (int y = 0; y < CHUNK_SIZE; y++) {
                if (tiles[x][y] == TileType.STAIRS) {
                    int stairBand = getBand(x, y, bands);
                    // Check the tile above (y+1) or whichever direction you consider "up"
                    int nx = x, ny = y + 1;
                    if (ny < CHUNK_SIZE) {
                        int nextBand = getBand(nx, ny, bands);
                        if (nextBand == stairBand + 1) {
                            // Ensure it's a MOUNTAIN_TILE_CENTER to allow walking up
                            tiles[nx][ny] = TileType.MOUNTAIN_TILE_CENTER;
                        }
                    }
                }
            }
        }
    }

    private void smoothBandsForCohesion() {
        int[][] temp = new int[CHUNK_SIZE][CHUNK_SIZE];

        for (int x = 1; x < CHUNK_SIZE - 1; x++) {
            for (int y = 1; y < CHUNK_SIZE - 1; y++) {
                int band = elevationBands[x][y];
                if (band == 0) {
                    temp[x][y] = 0;
                    continue;
                }

                int sameCount = 0;
                int total = 0;
                for (int dx = -1; dx <= 1; dx++) {
                    for (int dy = -1; dy <= 1; dy++) {
                        int nx = x + dx;
                        int ny = y + dy;
                        if (nx < 0 || ny < 0 || nx >= CHUNK_SIZE || ny >= CHUNK_SIZE) continue;
                        total++;
                        if (elevationBands[nx][ny] == band) {
                            sameCount++;
                        }
                    }
                }

                // If fewer than half of neighbors match this band,
                // reduce the band by 1 to integrate it better or flatten it.
                if (sameCount < 5 && band > 1) {
                    temp[x][y] = band - 1;
                } else {
                    temp[x][y] = band;
                }
            }
        }

        // Copy changes back
        for (int x = 1; x < CHUNK_SIZE - 1; x++) {
            System.arraycopy(temp[x], 1, elevationBands[x], 1, CHUNK_SIZE - 2);
        }
    }


    private int determineNumberOfLayers(Random rand, BiomeType biomeType) {
        // Adjusted to make mountains slightly more common
        float baseChance;
        switch(biomeType) {
            case SNOW:
                baseChance = 0.50f;  // 75% no mountain, so 25% mountain
                break;
            case DESERT:
                baseChance = 0.85f;  // 15% chance of mountain
                break;
            case PLAINS:
                baseChance = 0.80f;  // 20% chance
                break;
            default:
                baseChance = 0.82f;
        }

        float r = rand.nextFloat();
        if (r < baseChance) return 0;
        // Make sure at least 1 layer if mountain exists
        if (r < baseChance + 0.10f) return 1;
        if (r < baseChance + 0.14f) return 2;
        return 3;
    }
    private void applyMountainTiles() {
        for (int x = 0; x < CHUNK_SIZE; x++) {
            for (int y = 0; y < CHUNK_SIZE; y++) {
                if (elevationBands[x][y] > 0) {
                    assignMountainTile(x, y, tileData, elevationBands);
                }
            }
        }
    }
    private void autotileCliffs(int[][] bands, int[][] tiles) {
        // We look for places where a tile is in a higher band but has a neighboring tile in a lower band.
        // Those are edges and should be replaced with appropriate cliff tiles.
        for (int x = 0; x < CHUNK_SIZE; x++) {
            for (int y = 0; y < CHUNK_SIZE; y++) {
                int band = getBand(x, y, bands);
                if (band <= 0) continue; // no cliff on ground level

                // Check neighbors
                int up = getBand(x, y + 1, bands);
                int down = getBand(x, y - 1, bands);
                int left = getBand(x - 1, y, bands);
                int right = getBand(x + 1, y, bands);

                boolean topLower = (up < band);
                boolean bottomLower = (down < band);
                boolean leftLower = (left < band);
                boolean rightLower = (right < band);

                // Determine appropriate cliff tile based on which sides are lower
                tiles[x][y] = chooseCliffTile(topLower, bottomLower, leftLower, rightLower);
            }
        }
    }

    private int chooseCliffTile(boolean topLower, boolean bottomLower, boolean leftLower, boolean rightLower) {
        int lowers = 0;
        if (topLower) lowers++;
        if (bottomLower) lowers++;
        if (leftLower) lowers++;
        if (rightLower) lowers++;

        // Corners
        if (topLower && leftLower && !bottomLower && !rightLower) return TileType.MOUNTAIN_TILE_TOP_LEFT_ROCK_BG;
        if (topLower && rightLower && !bottomLower && !leftLower) return TileType.MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG;
        if (bottomLower && leftLower && !topLower && !rightLower) return TileType.MOUNTAIN_TILE_BOT_LEFT_ROCK_BG;
        if (bottomLower && rightLower && !topLower && !leftLower) return TileType.MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG;

        // Single-direction cliffs
        if (topLower && lowers == 1) return TileType.MOUNTAIN_TILE_TOP_MID;
        if (bottomLower && lowers == 1) return TileType.MOUNTAIN_TILE_BOT_MID;
        if (leftLower && lowers == 1) return TileType.MOUNTAIN_TILE_MID_LEFT;
        if (rightLower && lowers == 1) return TileType.MOUNTAIN_TILE_MID_RIGHT;

        // If no lowers (plateau) or fallback
        if (lowers == 0) return TileType.MOUNTAIN_TILE_CENTER;

        // If multiple lowers but not forming a neat corner,
        // just default to a side tile, e.g. top_mid if top is lower
        // This is a fallback scenario.
        if (topLower) return TileType.MOUNTAIN_TILE_TOP_MID;
        if (bottomLower) return TileType.MOUNTAIN_TILE_BOT_MID;
        return TileType.MOUNTAIN_TILE_MID_LEFT;
    }



    private boolean layerExists(int[][] bands, int targetBand) {
        for (int x = 0; x < CHUNK_SIZE; x++) {
            for (int y = 0; y < CHUNK_SIZE; y++) {
                if (bands[x][y] == targetBand) return true;
            }
        }
        return false;
    }

    private boolean isAdjacentBand(int x, int y, int targetBand, int[][] bands) {
        return getBand(x, y + 1, bands) == targetBand ||
            getBand(x, y - 1, bands) == targetBand ||
            getBand(x + 1, y, bands) == targetBand ||
            getBand(x - 1, y, bands) == targetBand;
    }


    private void maybeAddCaveEntrance(int[][] bands, int[][] tiles, Random rand) {
        // On upper layers, sometimes replace a suitable cliff tile with a cave entrance.
        // Rare chance, as in Pokémon. Let's say only band 2 or 3.
        if (rand.nextFloat() > 0.02f) return; // 2% chance per chunk

        for (int x = 1; x < CHUNK_SIZE - 1; x++) {
            for (int y = 1; y < CHUNK_SIZE - 1; y++) {
                int band = bands[x][y];
                if (band >= 2 && isCliffTile(tiles[x][y])) {
                    // Prefer a straight edge tile facing outward
                    if (isStraightEdgeCliff(x, y, bands, tiles)) {
                        tiles[x][y] = TileType.CAVE_ENTRANCE;
                        return;
                    }
                }
            }
        }
    }

    private boolean isStraightEdgeCliff(int x, int y, int[][] bands, int[][] tiles) {
        // A "straight edge" cliff might be a vertical or horizontal cliff facing a lower band.
        // Check if one side is lower and opposite side is equal band:
        int band = bands[x][y];
        int up = getBand(x, y + 1, bands);
        int down = getBand(x, y - 1, bands);
        int left = getBand(x - 1, y, bands);
        int right = getBand(x + 1, y, bands);

        // For cave entrances, top-facing or bottom-facing cliffs are common in Pokémon.
        // Let's say a top-facing cliff: the tile above is lower.
        // Adjust logic as you see fit.
        if (up < band && down == band && left == band && right == band) return true;
        if (down < band && up == band && left == band && right == band) return true;
        // Similarly for left/right facing
        if (left < band && right == band && up == band && down == band) return true;
        if (right < band && left == band && up == band && down == band) return true;

        return false;
    }

    private int getBand(int x, int y, int[][] bands) {
        if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= CHUNK_SIZE) return -1;
        return bands[x][y];
    }

    private void generateRainForestPonds() {
        boolean[][] waterMap = new boolean[CHUNK_SIZE][CHUNK_SIZE];
        Random random = new Random(worldSeed + chunkX * 31L + chunkY * 17L);

        for (int x = 0; x < CHUNK_SIZE; x++) {
            for (int y = 0; y < CHUNK_SIZE; y++) {
                float worldX = (chunkX * CHUNK_SIZE + x) * World.TILE_SIZE;
                float worldY = (chunkY * CHUNK_SIZE + y) * World.TILE_SIZE;

                double baseNoise = OpenSimplex2.noise2(worldSeed + 500, worldX * 0.08f, worldY * 0.08f);
                double shapeNoise = OpenSimplex2.noise2(worldSeed + 1000, worldX * 0.15f, worldY * 0.15f);
                double detailNoise = OpenSimplex2.noise2(worldSeed + 1500, worldX * 0.25f, worldY * 0.25f);

                double combinedNoise = baseNoise * 0.6 + shapeNoise * 0.3 + detailNoise * 0.1;
                waterMap[x][y] = combinedNoise > 0.45 && random.nextFloat() > 0.3;
            }
        }

        AutoTileSystem autoTileSystem = new AutoTileSystem();
        autoTileSystem.applyAutotiling(this, waterMap);
    }

    public boolean isPassable(int localX, int localY) {
        localX = (localX + CHUNK_SIZE) % CHUNK_SIZE;
        localY = (localY + CHUNK_SIZE) % CHUNK_SIZE;
        int tType = tileData[localX][localY];
        return TileType.isPassableTile(tType);
    }

    private static class Point {
        int x, y;

        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/ChunkManager.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.utils.ChunkPos;

import java.util.*;

import static io.github.pokemeetup.system.gameplay.overworld.World.TILE_SIZE;

public class ChunkManager {
    public static final int CHUNK_SIZE = 16;
    public static final float CHUNK_PIXEL_SIZE = CHUNK_SIZE * TILE_SIZE;
    private static final int LOAD_RADIUS = 3;
    public static final float VISIBILITY_BUFFER = 2f * CHUNK_PIXEL_SIZE;

    public static boolean isChunkVisible(ChunkPos chunkPos, Rectangle viewBounds) {
        // Convert chunk position to world coordinates
        float chunkWorldX = chunkPos.x * CHUNK_PIXEL_SIZE;
        float chunkWorldY = chunkPos.y * CHUNK_PIXEL_SIZE;

        // Create chunk bounds with buffer for smoother loading
        Rectangle chunkBounds = new Rectangle(
            chunkWorldX - VISIBILITY_BUFFER,
            chunkWorldY - VISIBILITY_BUFFER,
            CHUNK_PIXEL_SIZE + (VISIBILITY_BUFFER * 2),
            CHUNK_PIXEL_SIZE + (VISIBILITY_BUFFER * 2)
        );

        return viewBounds.overlaps(chunkBounds);
    }




    public static Rectangle calculateViewBounds(float playerX, float playerY, float viewportWidth, float viewportHeight) {
        // Add buffer zones for smoother loading
        float bufferZone = World.TILE_SIZE * 4;
        return new Rectangle(
            playerX - (viewportWidth / 2) - bufferZone,
            playerY - (viewportHeight / 2) - bufferZone,
            viewportWidth + (bufferZone * 2),
            viewportHeight + (bufferZone * 2)
        );
    }

    public static Set<Vector2> getChunksToLoad(Vector2 playerPosition, Rectangle viewBounds) {
        Set<Vector2> chunksNeeded = new HashSet<>();

        // Calculate chunk coordinates from view bounds
        int minChunkX = Math.floorDiv((int)viewBounds.x, World.CHUNK_SIZE * World.TILE_SIZE);
        int maxChunkX = Math.floorDiv((int)(viewBounds.x + viewBounds.width), World.CHUNK_SIZE * World.TILE_SIZE);
        int minChunkY = Math.floorDiv((int)viewBounds.y, World.CHUNK_SIZE * World.TILE_SIZE);
        int maxChunkY = Math.floorDiv((int)(viewBounds.y + viewBounds.height), World.CHUNK_SIZE * World.TILE_SIZE);

        // Add an extra radius for smoother transitions
        int extraRadius = 2;
        for (int x = minChunkX - extraRadius; x <= maxChunkX + extraRadius; x++) {
            for (int y = minChunkY - extraRadius; y <= maxChunkY + extraRadius; y++) {
                chunksNeeded.add(new Vector2(x, y));
            }
        }

        return chunksNeeded;
    }

}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/DayNightCycle.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.graphics.Color;

public class DayNightCycle {
    private static final float NIGHT_END = 5.0f;     // 5:00 AM
    private static final float DAWN_START = 5.0f;    // 5:00 AM
    private static final float DAWN_END = 6.0f;      // 6:00 AM
    private static final float DAY_START = 6.0f;     // 6:00 AM
    private static final float DAY_END = 18.0f;      // 6:00 PM
    private static final float DUSK_START = 18.0f;   // 6:00 PM
    private static final float DUSK_END = 19.0f;     // 7:00 PM
    private static final float NIGHT_START = 19.0f;  // 7:00 PM

    // Base colors with proper ambient lighting
    private static final Color DAY_COLOR = new Color(1.0f, 1.0f, 1.0f, 1.0f);
    private static final Color NIGHT_COLOR = new Color(0.25f, 0.25f, 0.45f, 1.0f);
    private static final Color DAWN_COLOR = new Color(0.85f, 0.75f, 0.65f, 1.0f);
    private static final Color DUSK_COLOR = new Color(0.85f, 0.65f, 0.55f, 1.0f);
    private static final Color DAWN_DUSK_COLOR = new Color(0.8f, 0.6f, 0.6f, 1);
    public enum TimePeriod {
        NIGHT, DAWN, DAY, DUSK
    }

    public static TimePeriod getTimePeriod(float hourOfDay) {
        if (hourOfDay >= NIGHT_START || hourOfDay < NIGHT_END) {
            return TimePeriod.NIGHT;
        } else if (hourOfDay >= DAWN_START && hourOfDay < DAWN_END) {
            return TimePeriod.DAWN;
        } else if (hourOfDay >= DAY_START && hourOfDay < DAY_END) {
            return TimePeriod.DAY;
        } else {
            return TimePeriod.DUSK;
        }
    }public static float getHourOfDay(double worldTimeInMinutes) {
        return (float)((worldTimeInMinutes % (24 * 60)) / 60.0);
    }


    public static Color getWorldColor(float hourOfDay) {
        // Add debug logging

        Color result = new Color();

        // Check if it's nighttime (including crossing midnight)
        if (hourOfDay >= NIGHT_START || hourOfDay < DAWN_START) {
            return new Color(NIGHT_COLOR);
        }

        // Dawn transition
        if (hourOfDay >= DAWN_START && hourOfDay < DAY_START) {
            float progress = (hourOfDay - DAWN_START) / (DAY_START - DAWN_START);
            return result.set(DAWN_COLOR).lerp(DAY_COLOR, progress);
        }

        // Day time
        if (hourOfDay >= DAY_START && hourOfDay < DUSK_START) {
            return new Color(DAY_COLOR);
        }

        // Dusk transition
        float progress = (hourOfDay - DUSK_START) / (NIGHT_START - DUSK_START);
        return result.set(DAY_COLOR).lerp(NIGHT_COLOR, progress);
    }

    private static float clamp(float value, float min, float max) {
        return Math.max(min, Math.min(max, value));
    }
    public static String getTimeString(double worldTimeInMinutes) {
        int hour = (int)(worldTimeInMinutes / 60) % 24;
        int minute = (int)(worldTimeInMinutes % 60);
        String amPm = hour >= 12 ? "PM" : "AM";
        hour = hour % 12;
        if (hour == 0) hour = 12;
        return String.format("%d:%02d %s", hour, minute, amPm);
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/entityai/PokemonAI.java
================
package io.github.pokemeetup.system.gameplay.overworld.entityai;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

import java.util.Collection;

public class PokemonAI {
    private boolean isPaused = false;

    public void setPaused(boolean paused) {
        this.isPaused = paused;
    }
    private static final float DECISION_INTERVAL = 2.0f;
    private static final float IDLE_MIN_DURATION = 1.5f;
    private static final float IDLE_MAX_DURATION = 4.0f;
    private static final float MOVEMENT_CHANCE = 0.6f;
    private static final float FLEE_RANGE = 150f;
    private static final float MIN_DISTANCE_TO_OTHERS = World.TILE_SIZE * 2;

    private final WildPokemon pokemon;
    private float decisionTimer = 0;
    private float stateTimer = 0;
    private float idleDuration = 0;
    private AIState currentState = AIState.IDLE;

    public PokemonAI(WildPokemon pokemon) {
        this.pokemon = pokemon;
    }

    public void update(float delta, World world) {
        if (world == null || pokemon == null) {
            GameLogger.error("AI Update skipped - null world or pokemon");
            return;
        }
        if (isPaused) return;

        stateTimer += delta;
        decisionTimer += delta;

        // Log current state
        if (decisionTimer >= DECISION_INTERVAL) {
            decisionTimer = 0;
            GameLogger.error(String.format(
                "Pokemon %s at (%.1f,%.1f) - State: %s, Timer: %.1f, Duration: %.1f",
                pokemon.getName(), pokemon.getX(), pokemon.getY(),
                currentState, stateTimer, idleDuration
            ));

            if (currentState == AIState.IDLE && stateTimer >= idleDuration) {
                if (MathUtils.random() < MOVEMENT_CHANCE) {
                    GameLogger.error("Attempting to choose new target");
                    chooseNewTarget(world);
                } else {
                    GameLogger.error("Staying idle");
                    enterIdleState();
                }
            }
        }

        // Check player proximity
        Player player = world.getPlayer();
        if (player != null) {
            float dist = Vector2.dst(
                pokemon.getX(), pokemon.getY(),
                player.getX() * World.TILE_SIZE, player.getY() * World.TILE_SIZE
            );
            if (dist < FLEE_RANGE) {
                GameLogger.error(String.format(
                    "Player detected at distance %.1f - initiating flee", dist
                ));
                enterFleeingState(world);
            }
        }
    }

    private void chooseNewTarget(World world) {
        if (pokemon.isMoving()) {
            GameLogger.error("Cannot choose new target while moving");
            return;
        }

        int currentTileX = (int)(pokemon.getX() / World.TILE_SIZE);
        int currentTileY = (int)(pokemon.getY() / World.TILE_SIZE);

        GameLogger.info(String.format(
            "Current position: Tile(%d,%d) Pixel(%.1f,%.1f)",
            currentTileX, currentTileY, pokemon.getX(), pokemon.getY()
        ));

        // Try all directions systematically
        int[] dx = {0, 0, -1, 1};
        int[] dy = {1, -1, 0, 0};
        String[] dirs = {"up", "down", "left", "right"};

        for (int i = 0; i < 4; i++) {
            int targetTileX = currentTileX + dx[i];
            int targetTileY = currentTileY + dy[i];

            GameLogger.info(String.format(
                "Checking move to (%d,%d) direction: %s",
                targetTileX, targetTileY, dirs[i]
            ));

            if (isValidMove(targetTileX, targetTileY, world)) {
                pokemon.moveToTile(targetTileX, targetTileY, dirs[i]);
                currentState = AIState.MOVING;
                GameLogger.info(String.format(
                    "Move validated - moving %s to (%d,%d)",
                    dirs[i], targetTileX, targetTileY
                ));
                return;
            }
        }

        GameLogger.error("No valid moves found - entering idle state");
        enterIdleState();
    }



    private boolean isValidMove(int tileX, int tileY, World world) {
        // Check passability
        if (!world.isPassable(tileX, tileY)) {
            return false;
        }

        // Convert to pixel coordinates for collision checks
        float pixelX = tileX * World.TILE_SIZE;
        float pixelY = tileY * World.TILE_SIZE;

        // Check distance from other Pokemon
        Collection<WildPokemon> nearby = world.getPokemonSpawnManager()
            .getPokemonInRange(pixelX, pixelY, MIN_DISTANCE_TO_OTHERS);

        // Allow if no nearby Pokemon or only self
        return nearby.isEmpty() || (nearby.size() == 1 && nearby.iterator().next() == pokemon);
    }

    private boolean checkForNearbyPlayer(World world) {
        Player player = world.getPlayer();
        if (player == null) return false;

        float distanceToPlayer = Vector2.dst(
            pokemon.getX(), pokemon.getY(),
            player.getX() * World.TILE_SIZE,
            player.getY() * World.TILE_SIZE
        );

        return distanceToPlayer < FLEE_RANGE;
    }

    private void enterFleeingState(World world) {
        Player player = world.getPlayer();
        if (player == null) return;

        // Calculate direction away from player in tile coordinates
        int pokemonTileX = (int)(pokemon.getX() / World.TILE_SIZE);
        int pokemonTileY = (int)(pokemon.getY() / World.TILE_SIZE);
        int playerTileX = (int)(player.getX());
        int playerTileY = (int)(player.getY());

        // Determine escape direction
        int dx = pokemonTileX - playerTileX;
        int dy = pokemonTileY - playerTileY;

        // Try to move away from player
        int targetTileX = pokemonTileX + (dx != 0 ? dx / Math.abs(dx) : 0);
        int targetTileY = pokemonTileY + (dy != 0 ? dy / Math.abs(dy) : 0);

        if (world.isPassable(targetTileX, targetTileY)) {
            String direction = "";
            if (Math.abs(dx) > Math.abs(dy)) {
                direction = dx > 0 ? "right" : "left";
            } else {
                direction = dy > 0 ? "up" : "down";
            }

            pokemon.moveToTile(targetTileX, targetTileY, direction);
            currentState = AIState.FLEEING;
        } else {
            // If can't move directly away, try to move perpendicular
            chooseNewTarget(world);
        }
    }

    public void enterIdleState() {
        currentState = AIState.IDLE;
        stateTimer = 0;
        idleDuration = MathUtils.random(IDLE_MIN_DURATION, IDLE_MAX_DURATION);
        pokemon.setMoving(false);
    }

    private enum AIState {
        IDLE,
        MOVING,
        FLEEING
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/mechanics/AutoTileSystem.java
================
package io.github.pokemeetup.system.gameplay.overworld.mechanics;

import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.HashMap;
import java.util.Map;

public class AutoTileSystem {
    private static final int N = 1;
    private static final int S = 2;
    private static final int E = 4;
    private static final int W = 8;
    private static final int NW = 16;
    private static final int NE = 32;
    private static final int SW = 64;
    private static final int SE = 128;

    // Predefined pond shapes:
    // Example: A simple 3x3 pond
    // You can define more shapes if desired.
    private static final boolean[][] POND_3X3 = {
        {true, true, true},
        {true, true, true},
        {true, true, true}
    };

    private final Map<Integer, Integer> tileMap = new HashMap<>();

    public AutoTileSystem() {
        initializeTileMap();
    }

    private void initializeTileMap() {
        // Full center remains the same
        tileMap.put(N | S | E | W | NW | NE | SW | SE, TileType.WATER_PUDDLE);

        // Currently, your top edges use S-based patterns, but they should actually be bottom edges:
        tileMap.put(S | E | W | SW | SE, TileType.WATER_PUDDLE_BOTTOM_MIDDLE);
        tileMap.put(S | E | SE, TileType.WATER_PUDDLE_BOTTOM_RIGHT);
        tileMap.put(S | W | SW, TileType.WATER_PUDDLE_BOTTOM_LEFT);

        // Your bottom edges use N-based patterns, but they should actually be top edges:
        tileMap.put(N | E | W | NW | NE, TileType.WATER_PUDDLE_TOP_MIDDLE);
        tileMap.put(N | E | NE, TileType.WATER_PUDDLE_TOP_LEFT);
        tileMap.put(N | W | NW, TileType.WATER_PUDDLE_TOP_RIGHT);

        // Left and right edges can remain as they are unless you also find them inverted:
        tileMap.put(N | S | E | NE | SE, TileType.WATER_PUDDLE_LEFT_MIDDLE);
        tileMap.put(N | S | W | NW | SW, TileType.WATER_PUDDLE_RIGHT_MIDDLE);
    }


    /**
     * Instead of dynamically shaping ponds from scattered tiles, we now:
     * 1. Check if there's any indication we should place a pond (e.g., from waterMap).
     * 2. If so, we place a predefined pond shape (like a 3x3 pond) at a chosen location.
     * <p>
     * In this simplified approach, we:
     * - Scan the waterMap for at least one water tile.
     * - If found, place a 3x3 pond shape near the center of the chunk.
     * <p>
     * You can extend this logic to:
     * - Choose random locations.
     * - Select from multiple pond shapes.
     * - Place multiple ponds per chunk.
     */
    private boolean[][] placePredefinedPonds(boolean[][] waterMap) {
        boolean[][] result = new boolean[Chunk.CHUNK_SIZE][Chunk.CHUNK_SIZE];

        // Check if we have any water tile. If yes, place a 3x3 pond in the center-ish
        // For demonstration, we ignore the original distribution and just place the pond.
        // You can refine the logic to ensure the chosen location coincides with where waterMap has water.
        int startX = Chunk.CHUNK_SIZE / 2 - 1;
        int startY = Chunk.CHUNK_SIZE / 2 - 1;

        // Ensure the pond fits in the chunk:
        if (startX >= 0 && startX + POND_3X3.length <= Chunk.CHUNK_SIZE &&
            startY >= 0 && startY + POND_3X3[0].length <= Chunk.CHUNK_SIZE) {
            for (int x = 0; x < POND_3X3.length; x++) {
                for (int y = 0; y < POND_3X3[0].length; y++) {
                    result[startX + x][startY + y] = POND_3X3[x][y];
                }
            }
        }

        return result;
    }

    public void applyAutotiling(Chunk chunk, boolean[][] waterMap) {
        // Completely override the old logic. We now just place a predefined pond shape.
        boolean[][] shapedWater = placePredefinedPonds(waterMap);

        int[][] tileData = chunk.getTileData();
        for (int x = 0; x < Chunk.CHUNK_SIZE; x++) {
            for (int y = 0; y < Chunk.CHUNK_SIZE; y++) {
                if (!shapedWater[x][y]) continue;

                int bitmask = calculateBitmask(x, y, shapedWater);
                tileData[x][y] = getWaterTileFromBitmask(bitmask);
            }
        }
    }

    private int calculateBitmask(int x, int y, boolean[][] waterMap) {
        int bitmask = 0;

        if (getWater(waterMap, x, y - 1)) bitmask |= N;  // North
        if (getWater(waterMap, x, y + 1)) bitmask |= S;  // South
        if (getWater(waterMap, x + 1, y)) bitmask |= E;  // East
        if (getWater(waterMap, x - 1, y)) bitmask |= W;  // West

        // Diagonals
        if (getWater(waterMap, x - 1, y - 1) && (bitmask & (N | W)) == (N | W)) bitmask |= NW;
        if (getWater(waterMap, x + 1, y - 1) && (bitmask & (N | E)) == (N | E)) bitmask |= NE;
        if (getWater(waterMap, x - 1, y + 1) && (bitmask & (S | W)) == (S | W)) bitmask |= SW;
        if (getWater(waterMap, x + 1, y + 1) && (bitmask & (S | E)) == (S | E)) bitmask |= SE;

        return bitmask;
    }

    private int getWaterTileFromBitmask(int bitmask) {
        Integer mappedTile = tileMap.get(bitmask);
        if (mappedTile != null) {
            return mappedTile;
        }
        return TileType.WATER_PUDDLE; // fallback
    }

    private boolean getWater(boolean[][] waterMap, int x, int y) {
        if (x < 0 || x >= Chunk.CHUNK_SIZE || y < 0 || y >= Chunk.CHUNK_SIZE) {
            return false;
        }
        return waterMap[x][y];
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/mechanics/MountainGenerator.java
================
package io.github.pokemeetup.system.gameplay.overworld.mechanics;

import com.badlogic.gdx.math.MathUtils;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.Random;

/**
 * MountainGenerator: Responsible for creating Gen 3–style mountains.
 * Uses a 3x3 tile system for mountain faces, corners, and edges.
 */
public class MountainGenerator {
    // Elevation thresholds
    private static final double LEVEL_LOW = 0.4;
    private static final double LEVEL_MID = 0.6;
    private static final double LEVEL_HIGH = 0.8;

    // Probabilities
    private static final float STAIRS_CHANCE = 0.05f;
    private static final float CAVE_CHANCE = 0.02f;

    private final BiomeManager biomeManager;
    private final MountainTileManager mountainTileManager;
    private final long seed;

    public MountainGenerator(BiomeManager biomeManager, MountainTileManager mountainTileManager, long seed) {
        this.biomeManager = biomeManager;
        this.mountainTileManager = mountainTileManager;
        this.seed = seed;
    }

    public void generateMountains(Chunk chunk) {
        int[][] tileData = chunk.getTileData();
        if (tileData == null) {
            tileData = new int[Chunk.CHUNK_SIZE][Chunk.CHUNK_SIZE];
            chunk.setTileData(tileData);
        }

        // Step 1: Generate elevation map
        double[][] elevationMap = new double[Chunk.CHUNK_SIZE][Chunk.CHUNK_SIZE];
        for (int x = 0; x < Chunk.CHUNK_SIZE; x++) {
            for (int y = 0; y < Chunk.CHUNK_SIZE; y++) {
                float worldX = (chunk.getChunkX() * Chunk.CHUNK_SIZE + x) * World.TILE_SIZE;
                float worldY = (chunk.getChunkY() * Chunk.CHUNK_SIZE + y) * World.TILE_SIZE;
                double height = biomeManager.getMountainHeight(worldX, worldY);
                elevationMap[x][y] = height;
            }
        }

        // Step 2: Assign base tiles by elevation band
        int[][] elevationBands = new int[Chunk.CHUNK_SIZE][Chunk.CHUNK_SIZE];
        for (int x = 0; x < Chunk.CHUNK_SIZE; x++) {
            for (int y = 0; y < Chunk.CHUNK_SIZE; y++) {
                double h = elevationMap[x][y];
                int band;
                int tile;

                if (h < LEVEL_LOW) {
                    band = 0;
                    tile = TileType.GRASS;
                } else if (h < LEVEL_MID) {
                    band = 1;
                    tile = TileType.MOUNTAIN_BASE;
                } else if (h < LEVEL_HIGH) {
                    band = 2;
                    tile = TileType.MOUNTAIN_BASE;
                } else {
                    band = 3;
                    BiomeType biomeType = chunk.getBiome() != null ? chunk.getBiome().getType() : BiomeType.PLAINS;
                    tile = (biomeType == BiomeType.SNOW || biomeType == BiomeType.BIG_MOUNTAINS)
                        ? TileType.MOUNTAIN_SNOW_BASE
                        : TileType.MOUNTAIN_PEAK;
                }

                tileData[x][y] = tile;
                elevationBands[x][y] = band;
            }
        }

        // Step 3: Replace tiles on steep transitions with cliff/edge tiles
        for (int x = 0; x < Chunk.CHUNK_SIZE; x++) {
            for (int y = 0; y < Chunk.CHUNK_SIZE; y++) {
                int currentBand = elevationBands[x][y];
                if (currentBand > 0 && hasLowerNeighbor(x, y, elevationBands)) {
                    int cliffTile = determineCliffTile(x, y, elevationBands);
                    tileData[x][y] = cliffTile;
                }
            }
        }

        // Step 4: Place stairs or caves
        Random random = new Random(seed + chunk.getChunkX() * 31L + chunk.getChunkY() * 17L);
        for (int x = 1; x < Chunk.CHUNK_SIZE - 1; x++) {
            for (int y = 1; y < Chunk.CHUNK_SIZE - 1; y++) {
                int tile = tileData[x][y];
                if (isCliffTile(tile)) {
                    if (random.nextFloat() < STAIRS_CHANCE && canPlaceStairs(x, y, elevationBands)) {
                        tileData[x][y] = TileType.STAIRS;
                        continue;
                    }
                    if (random.nextFloat() < CAVE_CHANCE && canPlaceCave(x, y, elevationBands)) {
                        tileData[x][y] = TileType.CAVE_ENTRANCE;
                    }
                }
            }
        }

        // Step 5: Auto-tiling / Smoothing if needed
        applyCliffAutotiling(tileData, elevationBands);

        chunk.setDirty(true);
    }

    private boolean hasLowerNeighbor(int x, int y, int[][] elevationBands) {
        int band = getBand(x, y, elevationBands);
        int n = getBand(x, y+1, elevationBands);
        int s = getBand(x, y-1, elevationBands);
        int e = getBand(x+1, y, elevationBands);
        int w = getBand(x-1, y, elevationBands);

        return (n < band) || (s < band) || (e < band) || (w < band);
    }

    private int determineCliffTile(int x, int y, int[][] elevationBands) {
        int band = getBand(x, y, elevationBands);
        int bandN = getBand(x, y+1, elevationBands);
        int bandS = getBand(x, y-1, elevationBands);
        int bandE = getBand(x+1, y, elevationBands);
        int bandW = getBand(x-1, y, elevationBands);

        boolean topLower = bandN < band;
        boolean bottomLower = bandS < band;
        boolean leftLower = bandW < band;
        boolean rightLower = bandE < band;

        boolean topSame = bandN == band;
        boolean bottomSame = bandS == band;
        boolean leftSame = bandW == band;
        boolean rightSame = bandE == band;

        // Determine tile type:
        // 1. Corners (two perpendicular directions lower):
        if (topLower && leftLower) {
            return pickCornerTile(TileType.MOUNTAIN_TILE_TOP_LEFT_ROCK_BG, TileType.MOUNTAIN_TILE_TOP_LEFT_GRASS_BG,
                bandN, bandW);
        } else if (topLower && rightLower) {
            return pickCornerTile(TileType.MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG, TileType.MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG,
                bandN, bandE);
        } else if (bottomLower && leftLower) {
            return pickCornerTile(TileType.MOUNTAIN_TILE_BOT_LEFT_ROCK_BG, TileType.MOUNTAIN_TILE_BOT_LEFT_GRASS_BG,
                bandS, bandW);
        } else if (bottomLower && rightLower) {
            return pickCornerTile(TileType.MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG, TileType.MOUNTAIN_TILE_BOT_RIGHT_GRASS_BG,
                bandS, bandE);
        }

        // 2. Edges (only one direction lower):
        if (topLower && !leftLower && !rightLower) {
            return TileType.MOUNTAIN_TILE_TOP_MID;
        } else if (bottomLower && !leftLower && !rightLower) {
            return TileType.MOUNTAIN_TILE_BOT_MID;
        } else if (leftLower && !topLower && !bottomLower) {
            return TileType.MOUNTAIN_TILE_MID_LEFT;
        } else if (rightLower && !topLower && !bottomLower) {
            return TileType.MOUNTAIN_TILE_MID_RIGHT;
        }

        // 3. If surrounded by same or no lower neighbors (plateau/center):
        if (topSame && bottomSame && leftSame && rightSame) {
            return TileType.MOUNTAIN_TILE_CENTER;
        }

        // Fallback to center if no condition fits perfectly
        return TileType.MOUNTAIN_TILE_CENTER;
    }

    /**
     * Picks the appropriate corner tile variant based on whether the adjacent lower tiles
     * lead down to a lowest band area (band 0). If any lower side is band 0, use grass_bg,
     * else use rock_bg.
     */
    private int pickCornerTile(int rockBgTile, int grassBgTile, int bandA, int bandB) {
        // If either adjacent lower band is the lowest band (0), pick grass_bg
        if (bandA == 0 || bandB == 0) {
            return grassBgTile;
        }
        // Otherwise, pick rock_bg
        return rockBgTile;
    }

    private boolean isCliffTile(int tile) {
        // Now we consider "cliff tiles" as any of these mountain tiles that are not just base or center.
        // Since we used new tile types, let's consider all non-center 3x3 tiles as "cliff" or "edge".
        // Adjust if you want a stricter definition.
        if (tile == TileType.MOUNTAIN_TILE_CENTER || tile == TileType.GRASS || tile == TileType.MOUNTAIN_BASE
            || tile == TileType.MOUNTAIN_PEAK || tile == TileType.MOUNTAIN_SNOW_BASE) {
            return false;
        }
        return true;
    }

    private boolean canPlaceStairs(int x, int y, int[][] elevationBands) {
        int band = getBand(x, y, elevationBands);
        int up = getBand(x, y+1, elevationBands);
        return up > band;
    }

    private boolean canPlaceCave(int x, int y, int[][] elevationBands) {
        int band = getBand(x, y, elevationBands);
        return band == 1 || band == 2; // mid or high elevation cliff
    }

    private void applyCliffAutotiling(int[][] tileData, int[][] elevationBands) {
        // Placeholder for further refinements if needed.
        for (int x = 1; x < Chunk.CHUNK_SIZE - 1; x++) {
            for (int y = 1; y < Chunk.CHUNK_SIZE - 1; y++) {
                int tile = tileData[x][y];
                // If needed, add logic to refine corners or edges further.
                tileData[x][y] = refineCliffTile(x, y, tileData, elevationBands);
            }
        }
    }

    private int refineCliffTile(int x, int y, int[][] tileData, int[][] elevationBands) {
        // Add logic if certain corner tiles don't fit conditions
        // For now, return as is.
        return tileData[x][y];
    }

    private int getBand(int x, int y, int[][] elevationBands) {
        if (x < 0 || x >= Chunk.CHUNK_SIZE || y < 0 || y >= Chunk.CHUNK_SIZE) {
            return -1; // Out of bounds considered lower
        }
        return elevationBands[x][y];
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/mechanics/MountainTileManager.java
================
package io.github.pokemeetup.system.gameplay.overworld.mechanics;

import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.utils.GameLogger;

import java.util.HashMap;
import java.util.Map;
import java.util.Random;

public class MountainTileManager {
    private final TextureAtlas atlas;
    private final Map<String, TextureRegion> mountainTiles;

    public enum MountainTileType {
        BASE_BROWN,
        BASE_SNOW,
        SLOPE_LEFT,
        SLOPE_RIGHT,
        CORNER_TOP_LEFT,
        CORNER_TOP_RIGHT,
        CORNER_BOTTOM_LEFT,
        CORNER_BOTTOM_RIGHT,
        PEAK_SNOW,
        PEAK_ROCK,
        CAVE_ENTRANCE,
        CLIFF_FACE,
        ROCK_SMALL,
        ROCK_MEDIUM,
        ROCK_LARGE,
        SNOW_OVERLAY_1,
        SNOW_OVERLAY_2,
        GRASS_OVERLAY
    }

    public MountainTileManager(TextureAtlas atlas) {
        this.atlas = atlas;
        this.mountainTiles = new HashMap<>();
        loadTiles();
    }

    private void loadTiles() {
        // Load all mountain tiles from atlas
        for (MountainTileType type : MountainTileType.values()) {
            String tileName = "mountain_" + type.name().toLowerCase();
            TextureRegion region = atlas.findRegion(tileName);
            if (region != null) {
                mountainTiles.put(tileName, region);
            } else {
                GameLogger.error("Failed to load mountain tile: " + tileName);
            }
        }
    }

    public TextureRegion getTile(MountainTileType type) {
        String tileName = "mountain_" + type.name().toLowerCase();
        return mountainTiles.get(tileName);
    }

    public TextureRegion getRandomRock(Random random) {
        MountainTileType[] rockTypes = {
            MountainTileType.ROCK_SMALL,
            MountainTileType.ROCK_MEDIUM,
            MountainTileType.ROCK_LARGE
        };
        return getTile(rockTypes[random.nextInt(rockTypes.length)]);
    }



    private boolean isHigherThan(int height1, int height2) {
        if (height2 == -1) return true;
        return height1 > height2;
    }

    // Method to determine if a tile should have snow overlay
    public boolean shouldHaveSnowOverlay(int height, Random random) {
        return height > 2 && random.nextFloat() < 0.7f;
    }

    // Get appropriate overlay based on height and neighbors
    public TextureRegion getOverlay(int height, Random random) {
        if (height > 3) {
            return getTile(random.nextBoolean() ?
                MountainTileType.SNOW_OVERLAY_1 :
                MountainTileType.SNOW_OVERLAY_2);
        }
        return getTile(MountainTileType.GRASS_OVERLAY);
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/multiworld/WorldManager.java
================
package io.github.pokemeetup.system.gameplay.overworld.multiworld;

import com.badlogic.gdx.utils.Json;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.system.data.*;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.storage.GameFileSystem;
import io.github.pokemeetup.utils.storage.JsonConfig;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class WorldManager {
    private static final String WORLDS_BASE_DIR = "worlds/";
    private static final String SINGLE_PLAYER_DIR = WORLDS_BASE_DIR + "singleplayer/";
    private static WorldManager instance;
    private final Map<String, WorldData> worlds;
    private final Object worldLock = new Object();
    private final String baseDirectory;
    private final GameFileSystem fs;
    private final Map<String, WorldData> worldCache = new ConcurrentHashMap<>();
    private final Object saveLock = new Object();
    private boolean isInitialized = false;

    private WorldManager() {
        this.worlds = new ConcurrentHashMap<>();
        this.baseDirectory = SINGLE_PLAYER_DIR;
        this.fs = GameFileSystem.getInstance();
        createDirectoryStructure();
    }

    public static synchronized WorldManager getInstance() {
        if (instance == null) {
            instance = new WorldManager();
        }
        return instance;
    }

    public synchronized void init() {
        if (isInitialized) {
            return;
        }

        synchronized (worldLock) {
            try {
                worlds.clear();

                initializeSingleplayerMode();


                isInitialized = true;

            } catch (Exception e) {
                GameLogger.error("Failed to initialize WorldManager: " + e.getMessage());
                throw new RuntimeException("WorldManager initialization failed", e);
            }
        }
    }

    private void initializeSingleplayerMode() {
        try {
            cleanupCorruptedWorlds();
            loadSingleplayerWorlds();
        } catch (Exception e) {
            GameLogger.error("Error initializing singleplayer mode: " + e.getMessage());
            throw e;
        }
    }

    public WorldData createWorld(String name, long seed, float treeSpawnRate, float pokemonSpawnRate) {
        synchronized (worldLock) {
            try {
                if (name == null || name.trim().isEmpty()) {
                    throw new IllegalArgumentException("World name cannot be null or empty");
                }

                if (worlds.containsKey(name)) {
                    GameLogger.info("Cleaning up existing world: " + name);
                    deleteWorld(name);
                }

                GameLogger.info("Creating new world: " + name + " with seed: " + seed);

                WorldData.WorldConfig config = new WorldData.WorldConfig();
                config.setSeed(seed);
                config.setTreeSpawnRate(treeSpawnRate);
                config.setPokemonSpawnRate(pokemonSpawnRate);

                WorldData world = new WorldData(name);
                world.setName(name);
                world.setLastPlayed(System.currentTimeMillis());
                world.setConfig(config);
                world.setPlayers(new HashMap<>());
                world.setPokemonData(new PokemonData());

                worlds.put(name, world);
                GameLogger.info("Created world data object");

                return world;

            } catch (Exception e) {
                GameLogger.error("Failed to create world: " + name + " - " + e.getMessage());
                throw new RuntimeException("World creation failed: " + e.getMessage(), e);
            }
        }
    }

    public void saveWorld(WorldData worldData) {
        GameLogger.info("Saving world: " + worldData.getName());

        synchronized (saveLock) {
            try {
                // Log pre-save state
                GameLogger.info("Saving world: " + worldData.getName() +
                    " with commands: " + worldData.commandsAllowed());

                // Create deep copy for saving
                WorldData saveData = worldData.copy();

                // Verify copy worked
                if (saveData.commandsAllowed() != worldData.commandsAllowed()) {
                    GameLogger.error("Command state mismatch in copy! Fixing...");
                    saveData.setCommandsAllowed(worldData.commandsAllowed());
                }
                Json json = JsonConfig.getInstance();
                String jsonStr = json.toJson(saveData);

                    // Singleplayer mode - save to local file system
                    String worldDirPath = baseDirectory + worldData.getName();
                    if (!fs.exists(worldDirPath)) {
                        fs.createDirectory(worldDirPath);
                    }

                    String tempFilePath = worldDirPath + "/world.json.temp";
                    fs.writeString(tempFilePath, jsonStr);

                    // Verify saved data
                    WorldData verification = json.fromJson(WorldData.class, fs.readString(tempFilePath));
                    if (verification != null) {
                        if (verification.commandsAllowed() != worldData.commandsAllowed()) {
                            GameLogger.error("Command state lost in save! Original: " +
                                worldData.commandsAllowed() + ", Saved: " + verification.commandsAllowed());
                            // Try to fix
                            verification.setCommandsAllowed(worldData.commandsAllowed());
                            fs.writeString(tempFilePath, json.toJson(verification));
                        }
                    }

                    // Move temp file to final location
                    String worldFilePath = worldDirPath + "/world.json";
                    if (fs.exists(worldFilePath)) {
                        fs.deleteFile(worldFilePath);
                    }
                    fs.moveFile(tempFilePath, worldFilePath);

                    GameLogger.info("Successfully saved world with commands state: " +
                        worldData.commandsAllowed());


            } catch (Exception e) {
                GameLogger.error("Failed to save world: " + worldData.getName() +
                    " - " + e.getMessage());
            }
        }
    }


    public WorldData getWorld(String name) {
        synchronized (worldLock) {
            try {

                WorldData world = worlds.get(name);
                if (world == null && GameContext.get().getGameClient().isSinglePlayer()) {
                    world = JsonConfig.loadWorldData(name);
                    if (world != null) {
                        applyWorldData(world);
                    }
                }
                return world;
            } catch (Exception e) {
                GameLogger.error("Error loading world: " + name + " - " + e.getMessage());
                throw new RuntimeException("Failed to load world", e);
            }
        }
    }

    private void createDirectoryStructure() {
        try {
            // Only create directories for singleplayer mode
            fs.createDirectory(WORLDS_BASE_DIR);
            fs.createDirectory(baseDirectory);
            fs.createDirectory(baseDirectory + "backups/");
            GameLogger.info("Directory structure initialized: " + baseDirectory);

        } catch (Exception e) {
            GameLogger.error("Failed to create directory structure: " + e.getMessage());
            throw new RuntimeException("Failed to initialize directory structure", e);
        }
    }

    public void deleteWorld(String name) {
        synchronized (worldLock) {
            WorldData removed = worlds.remove(name);
            if (removed != null) {
                deleteSingleplayerWorld(name);

                GameLogger.info("Deleted world: " + name);
            } else {
                GameLogger.info("Attempted to delete non-existent world: " + name);
            }
        }
    }

    private void applyWorldData(WorldData world) {
        if (world == null) return;

        try {
            world.validateAndRepair();
            worlds.put(world.getName(), world);

        } catch (Exception e) {
            GameLogger.error("Failed to apply world data: " + e.getMessage());
            throw new RuntimeException("World data application failed", e);
        }
    }

    public Map<String, WorldData> getWorlds() {
        return Collections.unmodifiableMap(worlds);}

    private void cleanupCorruptedWorlds() {
        if (!fs.exists("worlds/singleplayer/")) return;

        String[] directories = fs.list("worlds/singleplayer/");
        for (String dirName : directories) {
            String dirPath = "worlds/singleplayer/" + dirName;
            if (fs.isDirectory(dirPath)) continue;

            String worldFilePath = dirPath + "/world.json";
            if (fs.exists(worldFilePath)) {
                try {
                    Json json = JsonConfig.getInstance();
                    String content = fs.readString(worldFilePath);
                    WorldData world = json.fromJson(WorldData.class, content);

                    if (world == null) {
                        String backupPath = dirPath + "/world.json.corrupted";
                        fs.writeString(backupPath, content);
                        fs.deleteFile(worldFilePath);
                        world = new WorldData(dirName);
                        world.setLastPlayed(System.currentTimeMillis());
                        fs.writeString(worldFilePath, json.toJson(world));
                        GameLogger.info("Repaired corrupted world: " + dirName);
                    }
                } catch (Exception e) {
                    GameLogger.error("Failed to parse world file: " + dirName + " - " + e.getMessage());
                }
            }
        }
    }

    private void loadSingleplayerWorlds() {
        try {
            if (!fs.exists("worlds/singleplayer/")) {
                fs.createDirectory("worlds/singleplayer/");
                GameLogger.info("Created worlds directory.");
                return;
            }

            String[] worldFolders = fs.list("worlds/singleplayer/");
            if (worldFolders == null || worldFolders.length == 0) {
                GameLogger.info("No singleplayer worlds found.");
                return;
            }

            for (String dirName : worldFolders) {
                String dirPath = "worlds/singleplayer/" + dirName;
                if (fs.isDirectory(dirPath)) continue;

                String worldFilePath = dirPath + "/world.json";
                if (!fs.exists(worldFilePath)) {
                    GameLogger.info("Missing 'world.json' in: " + dirPath);
                    continue;
                }

                try {
                    // Load and validate the world
                    WorldData world = loadAndValidateWorld(dirName);
                    if (world != null) {
                        // Important: Add valid worlds to the worlds map
                        worlds.put(dirName, world);
                        GameLogger.info("Successfully loaded world: " + dirName);
                    }
                } catch (Exception e) {
                    GameLogger.error("Error loading world: " + dirName + " - " + e.getMessage());
                }
            }

            GameLogger.info("Loaded " + worlds.size() + " singleplayer worlds.");
        } catch (Exception e) {
            GameLogger.error("Error loading singleplayer worlds: " + e.getMessage());
        }
    }


    public WorldData loadAndValidateWorld(String worldName) {
        synchronized (saveLock) {
            try {
                // Check for cached world first
                WorldData cached = worldCache.get(worldName);
                if (cached != null) {
                    GameLogger.info("Found cached world: " + worldName);
                    return cached;
                }

                String worldPath = SINGLE_PLAYER_DIR + worldName + "/world.json";
                if (!fs.exists(worldPath)) {
                    GameLogger.error("World file not found: " + worldPath);
                    return null;
                }

                String jsonContent = fs.readString(worldPath);
                if (jsonContent == null || jsonContent.isEmpty()) {
                    GameLogger.error("World file is empty: " + worldPath);
                    return null;
                }

                WorldData worldData = JsonConfig.getInstance().fromJson(WorldData.class, jsonContent);
                if (worldData == null) {
                    GameLogger.error("Failed to parse world data from JSON");
                    return null;
                }

                // Log the loaded data state
                GameLogger.info("Loaded world data - Players: " +
                    (worldData.getPlayers() != null ? worldData.getPlayers().size() : 0));

                if (worldData.getPlayers() != null) {
                    for (Map.Entry<String, PlayerData> entry : worldData.getPlayers().entrySet()) {
                        PlayerData playerData = entry.getValue();
                        if (playerData != null) {
                            GameLogger.info("Loaded player: " + entry.getKey() +
                                " Items: " + playerData.getInventoryItems().size() +
                                " Pokemon: " + playerData.getPartyPokemon().size());
                        }
                    }
                }

                // Cache valid world
                worldCache.put(worldName, worldData);
                return worldData;

            } catch (Exception e) {
                GameLogger.error("Error loading world: " + worldName + " - " + e.getMessage());
                return null;
            }
        }
    }


    private void deleteSingleplayerWorld(String name) {
        try {
            String worldPath = "worlds/singleplayer/" + name;
            if (fs.exists(worldPath)) {
                fs.deleteDirectory(worldPath);
                GameLogger.info("Deleted singleplayer world directory: " + name);
            } else {
                GameLogger.info("Singleplayer world directory does not exist: " + name);
            }
        } catch (Exception e) {
            GameLogger.error("Failed to delete singleplayer world: " + name + " - " + e.getMessage());
            throw new RuntimeException("Singleplayer world deletion failed", e);
        }
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/PersistOperation.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.math.Vector2;

import java.util.ArrayList;
import java.util.List;

public class PersistOperation extends WorldObjectOperation {
    public final Vector2 chunkPos;
    public final List<WorldObject> objects;

    public PersistOperation(Vector2 chunkPos, List<WorldObject> objects) {
        super(WorldObjectOperation.OperationType.PERSIST);
        this.chunkPos = chunkPos;
        this.objects = new ArrayList<>(objects);
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/PokemonSpawnManager.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import static io.github.pokemeetup.system.gameplay.overworld.World.TILE_SIZE;

public class PokemonSpawnManager {
    public static final float POKEMON_DESPAWN_TIME = 120; // Increased from 120 to 300 seconds
    private static final float BASE_SPAWN_RATE = 0.25f;  // Base 30% chance per check
    private static final float SPAWN_CHECK_INTERVAL = 2.5f;
    private static final Map<BiomeType, Map<TimeOfDay, String[]>> POKEMON_SPAWNS = new HashMap<>();
    private static final float LEVEL_VARIANCE = 2f; // Random variance in levels
    private static final float MIN_SPAWN_DISTANCE_PIXELS = 5 * World.TILE_SIZE;
    private static final float MAX_SPAWN_DISTANCE_PIXELS = 15 * World.TILE_SIZE;
    private static final int MAX_POKEMON_PER_CHUNK = 4;
    private static final float MIN_POKEMON_SPACING = World.TILE_SIZE * 2;
    private final TextureAtlas atlas;
    private final Random random;
    private final Map<Vector2, List<WildPokemon>> pokemonByChunk;
    private final Map<UUID, WildPokemon> pokemonById;
    private final Map<UUID, NetworkSyncData> syncedPokemon = new ConcurrentHashMap<>();
    private float spawnTimer = 0;

    public PokemonSpawnManager(TextureAtlas atlas) {
        this.atlas = atlas;
        this.random = new Random();
        this.pokemonByChunk = new ConcurrentHashMap<>();
        this.pokemonById = new ConcurrentHashMap<>();
        initializePokemonSpawns();

    }

    public GameClient getGameClient() {
        return GameContext.get().getGameClient();
    }

    private void checkSpawns(Vector2 playerPos) {

        if (random.nextFloat() > BASE_SPAWN_RATE) {
            return;
        }

        Set<Vector2> loadedChunks = getLoadedChunksAroundPlayer(playerPos);
        if (loadedChunks.isEmpty()) {
            GameLogger.error("No loaded chunks found around player");
            return;
        }


        // Try to spawn in a valid location
        int attempts = 10;
        while (attempts > 0) {
            attempts--;

            // Calculate spawn position in pixels
            float angle = random.nextFloat() * MathUtils.PI2;
            float distance = MathUtils.random(MIN_SPAWN_DISTANCE_PIXELS, MAX_SPAWN_DISTANCE_PIXELS);
            float spawnPixelX = playerPos.x*TILE_SIZE+ MathUtils.cos(angle) * distance;
            float spawnPixelY = playerPos.y *TILE_SIZE+ MathUtils.sin(angle) * distance;

            Vector2 chunkPos = getChunkPosition(spawnPixelX, spawnPixelY);

            if (!loadedChunks.contains(chunkPos)) {
                GameLogger.error("Chunk not loaded, skipping");
                continue;
            }

            // Check chunk capacity
            List<WildPokemon> chunkPokemon = pokemonByChunk.getOrDefault(chunkPos, new ArrayList<>());
            if (chunkPokemon.size() >= MAX_POKEMON_PER_CHUNK) {

                continue;
            }

            // Validate spawn position
            if (isValidSpawnPosition(spawnPixelX, spawnPixelY)) {
                GameLogger.error("Valid spawn position found, spawning Pokemon");
                spawnPokemon(spawnPixelX, spawnPixelY, chunkPos);
                break;
            } else {
                GameLogger.error("Invalid spawn position, retrying");
            }
        }

        if (attempts == 0) {
            GameLogger.error("Failed to find valid spawn position after all attempts");
        }
    }


    private boolean isValidSpawnPosition(float pixelX, float pixelY) {
        // Convert to tile coordinates for passability check
        int tileX = (int)(pixelX / TILE_SIZE);
        int tileY = (int)(pixelY / TILE_SIZE);

        if (GameContext.get().getWorld() == null) {
            GameLogger.error("World reference is null in spawn validation");
            return false;
        }

        // Check if tile is passable
        if (!GameContext.get().getWorld().isPassable(tileX, tileY)) {
            return false;
        }

        // Check distance from other Pokemon
        Collection<WildPokemon> nearby = getPokemonInRange(pixelX, pixelY, MIN_POKEMON_SPACING);
        if (!nearby.isEmpty()) {
            return false;
        }

        // Check chunk loaded
        Vector2 chunkPos = getChunkPosition(pixelX, pixelY);
        return GameContext.get().getWorld().getChunks().containsKey(chunkPos);
    }


    private int calculatePokemonLevel(float x, float y) {
        // Calculate distance from world center
        float centerX = 0;
        float centerY = 0;
        float distance = Vector2.dst(x, y, centerX, centerY);

        // Base level increases with distance
        float baseLevel = 2 + (distance / (World.TILE_SIZE * 50));

        // Add random variance
        float variance = MathUtils.random(-LEVEL_VARIANCE, LEVEL_VARIANCE);

        return MathUtils.round(MathUtils.clamp(baseLevel + variance, 1, 100));
    }


    public Collection<WildPokemon> getPokemonInRange(float centerPixelX, float centerPixelY, float rangePixels) {
        List<WildPokemon> inRange = new ArrayList<>();
        float rangeSquared = rangePixels * rangePixels;

        // Get relevant chunks
        int chunkRadius = (int)Math.ceil(rangePixels / (World.CHUNK_SIZE * World.TILE_SIZE)) + 1;
        Vector2 centerChunk = getChunkPosition(centerPixelX, centerPixelY);

        for (int dx = -chunkRadius; dx <= chunkRadius; dx++) {
            for (int dy = -chunkRadius; dy <= chunkRadius; dy++) {
                Vector2 checkChunk = new Vector2(centerChunk.x + dx, centerChunk.y + dy);
                List<WildPokemon> pokemonInChunk = pokemonByChunk.get(checkChunk);

                if (pokemonInChunk != null) {
                    for (WildPokemon pokemon : pokemonInChunk) {
                        float dx2 = pokemon.getX() - centerPixelX;
                        float dy2 = pokemon.getY() - centerPixelY;
                        if (dx2 * dx2 + dy2 * dy2 <= rangeSquared) {
                            inRange.add(pokemon);
                        }
                    }
                }
            }
        }

        return inRange;
    }

    private void spawnPokemon(float pixelX, float pixelY, Vector2 chunkPos) {
        try {
            int tileX = (int)(pixelX / World.TILE_SIZE);
            int tileY = (int)(pixelY / World.TILE_SIZE);

            Biome biome = GameContext.get().getWorld().getBiomeAt(tileX, tileY);
            String pokemonName = selectPokemonForBiome(biome);
            if (pokemonName == null) return;

            TextureRegion sprite = atlas.findRegion(pokemonName.toUpperCase() + "_overworld");
            if (sprite == null) {
                GameLogger.error("Failed to load sprite for " + pokemonName);
                return;
            }

            // Snap to grid
            float snappedX = Math.round(pixelX / World.TILE_SIZE) * World.TILE_SIZE;
            float snappedY = Math.round(pixelY / World.TILE_SIZE) * World.TILE_SIZE;

            WildPokemon pokemon = new WildPokemon(
                pokemonName,
                calculatePokemonLevel(snappedX, snappedY),
                (int)snappedX,
                (int)snappedY,
                sprite
            );

            // Initialize world reference and AI
            pokemon.setWorld(GameContext.get().getWorld());
            pokemon.getAi().enterIdleState(); // Start in idle state

            // Add to collections
            pokemonById.put(pokemon.getUuid(), pokemon);
            pokemonByChunk.computeIfAbsent(chunkPos, k -> new ArrayList<>()).add(pokemon);

            // Update collision box
            pokemon.updateBoundingBox();

        } catch (Exception e) {
            GameLogger.error("Failed to spawn Pokemon: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void update(float delta, Vector2 playerPosition) {
        spawnTimer += delta;
        if (spawnTimer >= SPAWN_CHECK_INTERVAL) {
            spawnTimer = 0;
            checkSpawns(playerPosition);
            removeExpiredPokemon();
        }

        // Update existing Pokemon
        for (WildPokemon pokemon : pokemonById.values()) {
            try {
                pokemon.update(delta, GameContext.get().getWorld());
            } catch (Exception e) {
                GameLogger.error("Error updating " + pokemon.getName() + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
    }
    public void removePokemon(UUID pokemonId) {
        WildPokemon pokemon = pokemonById.remove(pokemonId);
        if (pokemon != null) {
            Vector2 chunkPos = getChunkPosition(pokemon.getX(), pokemon.getY());
            List<WildPokemon> pokemonList = pokemonByChunk.get(chunkPos);
            if (pokemonList != null) {
                pokemonList.remove(pokemon);
                if (pokemonList.isEmpty()) {
                    pokemonByChunk.remove(chunkPos);
                }
            }
            syncedPokemon.remove(pokemonId);

            // Network update if multiplayer
            if (!GameContext.get().getGameClient().isSinglePlayer()) {
                GameContext.get().getGameClient().sendPokemonDespawn(pokemonId);
            }
        }
    }
    private Set<Vector2> getLoadedChunksAroundPlayer(Vector2 playerPixelPos) {
        Set<Vector2> loadedChunks = new HashSet<>();

        int playerTileX = (int)(playerPixelPos.x / TILE_SIZE);
        int playerTileY = (int)(playerPixelPos.y / TILE_SIZE);

        Vector2 playerChunk = getChunkPosition(playerPixelPos.x*TILE_SIZE, playerPixelPos.y*TILE_SIZE);



        // Debug world state
        if (GameContext.get().getWorld() == null) {
            GameLogger.error("World reference is null!");
            return loadedChunks;
        }

        Map<Vector2, Chunk> worldChunks = GameContext.get().getWorld().getChunks();
        // Log some nearby chunk positions that should be loaded
        GameLogger.info("Checking chunks in radius 1:");
        int radius = 1;
        for (int dx = -radius; dx <= radius; dx++) {
            for (int dy = -radius; dy <= radius; dy++) {
                Vector2 checkPos = new Vector2(playerChunk.x + dx, playerChunk.y + dy);
                boolean isLoaded = worldChunks.containsKey(checkPos);

                if (isLoaded) {
                    loadedChunks.add(checkPos);
                }
            }
        }

        return loadedChunks;
    }

    private Vector2 getChunkPosition(float pixelX, float pixelY) {
        int chunkX = Math.floorDiv((int)pixelX, World.CHUNK_SIZE * TILE_SIZE);
        int chunkY = Math.floorDiv((int)pixelY, World.CHUNK_SIZE * TILE_SIZE);


        return new Vector2(chunkX, chunkY);
    }
    public Vector2 getSpawnPoint() {
        return new Vector2(
            World.HALF_WORLD_SIZE * World.TILE_SIZE,
            World.HALF_WORLD_SIZE * World.TILE_SIZE
        );
    }

    private void updateNetworkedPokemon(WildPokemon pokemon, NetworkSyncData syncData, float delta) {
        // Simple linear interpolation to target position
        if (syncData.isMoving && syncData.targetPosition != null) {
            Vector2 currentPos = new Vector2(pokemon.getX(), pokemon.getY());
            Vector2 targetPos = syncData.targetPosition;

            // Calculate interpolation
            float interpolationSpeed = 5f; // Adjust as needed
            float newX = MathUtils.lerp(currentPos.x, targetPos.x, delta * interpolationSpeed);
            float newY = MathUtils.lerp(currentPos.y, targetPos.y, delta * interpolationSpeed);

            // Update position
            pokemon.setX(newX);
            pokemon.setY(newY);
            pokemon.updateBoundingBox();
        }

        // Update animation state
        pokemon.setMoving(syncData.isMoving);
        pokemon.setDirection(syncData.direction);
    }

    private void sendPokemonUpdate(WildPokemon pokemon) {
        NetworkProtocol.PokemonUpdate update = new NetworkProtocol.PokemonUpdate();
        update.uuid = pokemon.getUuid();
        update.x = pokemon.getX();
        update.y = pokemon.getY();
        update.direction = pokemon.getDirection();
        update.isMoving = pokemon.isMoving();

        GameContext.get().getGameClient().sendPokemonUpdate(update);
    }

    private String selectPokemonForBiome(Biome biome) {
        GameLogger.info("Selecting Pokemon for biome: " + biome.getType());

        double worldTimeInMinutes = GameContext.get().getWorld().getWorldData().getWorldTimeInMinutes();
        float hourOfDay = DayNightCycle.getHourOfDay(worldTimeInMinutes);
        TimeOfDay timeOfDay = (hourOfDay >= 6 && hourOfDay < 18) ? TimeOfDay.DAY : TimeOfDay.NIGHT;

        GameLogger.info("Time of day: " + timeOfDay + " (Hour: " + hourOfDay + ")");

        Map<TimeOfDay, String[]> biomeSpawns = POKEMON_SPAWNS.get(biome.getType());
        if (biomeSpawns == null) {
            GameLogger.info("No spawns defined for biome, using default");
            return getDefaultPokemon(timeOfDay);
        }

        String[] possiblePokemon = biomeSpawns.get(timeOfDay);
        if (possiblePokemon == null || possiblePokemon.length == 0) {
            GameLogger.info("No Pokemon available for time of day, using default");
            return getDefaultPokemon(timeOfDay);
        }

        String selected = possiblePokemon[random.nextInt(possiblePokemon.length)];
        GameLogger.info("Selected Pokemon: " + selected);
        return selected;
    }

    private void initializePokemonSpawns() {
        // Plains biome
        Map<TimeOfDay, String[]> plainsSpawns = new HashMap<>();
        plainsSpawns.put(TimeOfDay.DAY, new String[]{
            "Pidgey", "Rattata", "Spearow", "Bulbasaur", "Squirtle",
            "Charmander", "Meowth", "Pikachu", "Jigglypuff", "Psyduck",
            "Machop", "Geodude", "Tentacool", "Staryu", "Clefairy",
            "Vulpix", "Growlithe", "Doduo", "Ponyta", "Magnemite",
            "Farfetch'd", "Dodrio", "Raticate", "Pidgeotto", "Vileplume"
        });
        plainsSpawns.put(TimeOfDay.NIGHT, new String[]{
            "Hoothoot", "Oddish", "Meowth", "Rattata", "Zubat",
            "Gastly", "Murkrow", "Mankey", "Abra", "Psyduck",
            "Onix", "Jigglypuff", "Golbat", "Venonat", "Grimer",
            "Koffing", "Sandslash", "Geodude", "Paras", "Vileplume",
            "Tentacruel", "Goldeen", "Staryu", "Doduo", "Tentacool"
        });
        POKEMON_SPAWNS.put(BiomeType.PLAINS, plainsSpawns);

        // Forest biome
        Map<TimeOfDay, String[]> forestSpawns = new HashMap<>();
        forestSpawns.put(TimeOfDay.DAY, new String[]{
            "Caterpie", "Weedle", "Oddish", "Bellsprout", "Pineco",
            "Shroomish", "Heracross", "Seedot", "Nuzleaf", "Roselia",
            "Tangela", "Paras", "Lotad", "Lombre", "Vileplume",
            "Parasect", "Exeggcute", "Bellossom", "Skitty",
            "Swablu"
        });
        forestSpawns.put(TimeOfDay.NIGHT, new String[]{
            "Hoothoot", "Spinarak", "Oddish", "Venonat", "Gastly",
            "Murkrow", "Drowzee", "Weepinbell", "Pidgeotto", "Misdreavus",
            "Sneasel", "Gloom", "Scyther", "Roselia", "Cacnea",
            "Skitty", "Ralts", "Kirlia", "Nuzleaf", "Parasect",
            "Venomoth", "Farfetch'd", "Abra", "Kadabra"
        });
        POKEMON_SPAWNS.put(BiomeType.FOREST, forestSpawns);

        // Snow biome
        Map<TimeOfDay, String[]> snowSpawns = new HashMap<>();
        snowSpawns.put(TimeOfDay.DAY, new String[]{
            "Swinub", "Snorunt", "Glalie", "Jynx", "Seel",
            "Piloswine", "Sneasel", "Dewgong", "Lapras", "Porygon",
            "Delibird", "Cubchoo"
        });
        snowSpawns.put(TimeOfDay.NIGHT, new String[]{
            "Sneasel", "Delibird", "Snorunt", "Glalie", "Swinub",
            "Seel", "Piloswine", "Grimer", "Jynx", "Dewgong",
            "Lapras", "Porygon"
        });
        POKEMON_SPAWNS.put(BiomeType.SNOW, snowSpawns);

        // Desert biome
        Map<TimeOfDay, String[]> desertSpawns = new HashMap<>();
        desertSpawns.put(TimeOfDay.DAY, new String[]{
            "Trapinch", "Sandshrew", "Geodude", "Baltoy", "Cacnea",
            "Diglett", "Sandslash", "Dugtrio", "Nidoran♂", "Nidoran♀",
            "Nidorino", "Nidorina", "Crobat", "Koffing", "Rhyhorn",
            "Kabuto", "Kabutops", "Omanyte", "Omastar",
            "Electrode", "Magmar", "Mr. Mime", "Persian", "Vulpix"
        });
        desertSpawns.put(TimeOfDay.NIGHT, new String[]{
            "Zubat", "Voltorb", "Cacnea", "Drowzee", "Abra",
            "Onix", "Rhyhorn", "Dugtrio", "Koffing", "Kangaskhan",
            "Machop", "Geodude", "Sandshrew", "Diglett", "Nidoran♂",
            "Nidoran♀", "Nidorino", "Nidorina", "Crobat",
            "Electrode", "Magmar", "Mr. Mime", "Persian"
        });
        POKEMON_SPAWNS.put(BiomeType.DESERT, desertSpawns);

        // Haunted biome
        Map<TimeOfDay, String[]> hauntedSpawns = new HashMap<>();
        hauntedSpawns.put(TimeOfDay.DAY, new String[]{
            "Misdreavus", "Shuppet", "Duskull", "Gengar", "Banette",
            "Haunter", "Sableye", "Spiritomb", "Dusclops", "Graveler",
            "Onix", "Geodude", "Rattata", "Zubat", "Gastly",
            "Cubone", "Marowak"
        });
        hauntedSpawns.put(TimeOfDay.NIGHT, new String[]{
            "Gastly", "Haunter", "Gengar", "Zubat", "Golbat",
            "Cubone", "Marowak", "Misdreavus", "Shuppet", "Duskull",
            "Dusclops", "Banette", "Sableye", "Spiritomb", "Murkrow"
        });
        POKEMON_SPAWNS.put(BiomeType.HAUNTED, hauntedSpawns);

        // Rain Forest biome
        Map<TimeOfDay, String[]> rainforestSpawns = new HashMap<>();
        rainforestSpawns.put(TimeOfDay.DAY, new String[]{
            "Treecko", "Slakoth", "Aipom", "Tropius", "Tangela",
            "Paras", "Lotad", "Lombre", "Seedot", "Nuzleaf",
            "Roselia", "Cacnea", "Sunkern", "Hoppip", "Exeggcute",
            "Bellossom", "Pineco", "Shroomish", "Heracross",
            "Slaking", "Vileplume", "Sceptile", "Beautifly"
        });
        rainforestSpawns.put(TimeOfDay.NIGHT, new String[]{
            "Caterpie", "Weedle", "Pidgey", "Oddish", "Venonat",
            "Paras", "Exeggcute", "Tangela", "Cacnea", "Sunkern",
            "Hoppip", "Bellossom", "Shroomish", "Heracross",
            "Vileplume", "Beautifly", "Pidgeotto",
            "Nidoran♂", "Nidoran♀", "Nidorino", "Nidorina",
            "Pikachu", "Meowth", "Rattata"
        });
        POKEMON_SPAWNS.put(BiomeType.RAIN_FOREST, rainforestSpawns);

        // Big Mountains biome
        Map<TimeOfDay, String[]> mountainSpawns = new HashMap<>();
        mountainSpawns.put(TimeOfDay.DAY, new String[]{
            "Machop", "Geodude", "Aron", "Onix", "Teddiursa",
            "Machoke", "Rhyhorn", "Steelix", "Graveler", "Pineco",
            "Nosepass", "Larvitar", "Pupitar", "Aggron", "Golem",
            "Sudowoodo", "Sableye"
        });
        mountainSpawns.put(TimeOfDay.NIGHT, new String[]{
            "Zubat", "Machop", "Geodude", "Sableye", "Larvitar",
            "Graveler", "Onix", "Steelix", "Sudowoodo", "Rhyhorn",
            "Pineco", "Nosepass", "Pupitar", "Aggron", "Golem"
        });
        POKEMON_SPAWNS.put(BiomeType.BIG_MOUNTAINS, mountainSpawns);

        // RUINS biome
        Map<TimeOfDay, String[]> ruinsSpawns = new HashMap<>();
        ruinsSpawns.put(TimeOfDay.DAY, new String[]{
            "Gastly", "Haunter", "Gengar", "Zubat", "Golbat",
            "Cubone", "Marowak", "Misdreavus", "Shuppet", "Duskull",
            "Dusclops", "Banette", "Sableye", "Spiritomb", "Graveler",
            "Onix", "Geodude", "Rattata"
        });
        ruinsSpawns.put(TimeOfDay.NIGHT, new String[]{
            "Gastly", "Haunter", "Gengar", "Zubat", "Golbat",
            "Cubone", "Marowak", "Misdreavus", "Shuppet", "Duskull",
            "Dusclops", "Banette", "Sableye", "Spiritomb", "Graveler",
            "Onix", "Geodude", "Rattata"
        });
        POKEMON_SPAWNS.put(BiomeType.RUINS, ruinsSpawns);
    }



    private void removeExpiredPokemon() {
        List<UUID> toRemove = new ArrayList<>();
        for (WildPokemon pokemon : pokemonById.values()) {
            if (pokemon.isExpired()) {
                toRemove.add(pokemon.getUuid());
                Vector2 chunkPos = getChunkPosition(pokemon.getX(), pokemon.getY());
                List<WildPokemon> pokemonList = pokemonByChunk.get(chunkPos);
                if (pokemonList != null) {
                    pokemonList.remove(pokemon);
                }
            }
        }

        for (UUID id : toRemove) {
            pokemonById.remove(id);
        }
    }

    // Add network update methods
    public void handleNetworkUpdate(NetworkProtocol.PokemonUpdate update) {
        WildPokemon pokemon = pokemonById.get(update.uuid);
        if (pokemon != null) {
            // Update Pokemon state from network data
            pokemon.setDirection(update.direction);
            pokemon.setMoving(update.isMoving);

            // Update sync data
            NetworkSyncData syncData = syncedPokemon.computeIfAbsent(
                update.uuid, k -> new NetworkSyncData());
            syncData.lastUpdateTime = System.currentTimeMillis();
            syncData.targetPosition = new Vector2(update.x, update.y);
            syncData.direction = update.direction;
            syncData.isMoving = update.isMoving;

            GameLogger.info("Received network update for Pokemon: " + pokemon.getName());
        }
    }

    public void handleNetworkDespawn(UUID pokemonId) {
        WildPokemon pokemon = pokemonById.remove(pokemonId);
        if (pokemon != null) {
            Vector2 chunkPos = getChunkPosition(pokemon.getX(), pokemon.getY());
            List<WildPokemon> pokemonList = pokemonByChunk.get(chunkPos);
            if (pokemonList != null) {
                pokemonList.remove(pokemon);
                GameLogger.info("Removed network-despawned Pokemon: " + pokemon.getName());
            }
        }
    }

    public void despawnPokemon(UUID pokemonId) {
        WildPokemon pokemon = pokemonById.get(pokemonId);
        if (pokemon != null && !pokemon.isDespawning()) {
            pokemon.startDespawnAnimation();

            // Send despawn update in multiplayer immediately
            // so other clients can show the animation too
            if (!GameContext.get().getGameClient().isSinglePlayer()) {
                GameContext.get().getGameClient().sendPokemonDespawn(pokemonId);
            }

            // The pokemon will be removed from collections when animation completes
            // via the normal update cycle checking isExpired()
        }
    }

    private WildPokemon createWildPokemon(Vector2 chunkPos, Biome biome) {
        int attempts = 10;
        while (attempts > 0) {
            int localX = random.nextInt(Chunk.CHUNK_SIZE);
            int localY = random.nextInt(Chunk.CHUNK_SIZE);

            int worldTileX = (int) (chunkPos.x * Chunk.CHUNK_SIZE) + localX;
            int worldTileY = (int) (chunkPos.y * Chunk.CHUNK_SIZE) + localY;

            if (GameContext.get().getWorld().isPassable(worldTileX, worldTileY)) {
                // Select Pokemon based on biome
                String pokemonName = selectPokemonForBiome(biome);
                if (pokemonName != null) {
                    TextureRegion overworldSprite = atlas.findRegion(pokemonName.toUpperCase() + "_overworld");
                    if (overworldSprite != null) {
                        float pixelX = worldTileX * World.TILE_SIZE;
                        float pixelY = worldTileY * World.TILE_SIZE;

                        // Snap to grid
                        float snappedX = Math.round(pixelX / World.TILE_SIZE) * World.TILE_SIZE;
                        float snappedY = Math.round(pixelY / World.TILE_SIZE) * World.TILE_SIZE;

                        return new WildPokemon(pokemonName, random.nextInt(22) + 1, (int) snappedX, (int) snappedY, overworldSprite);
                    }
                }
            }
            attempts--;
        }
        return null;
    }

    private boolean isSpecialSpawnTime(float hourOfDay) {
        // Dawn (5-7 AM) and Dusk (6-8 PM) have special spawns
        return (hourOfDay >= 5 && hourOfDay <= 7) ||
            (hourOfDay >= 18 && hourOfDay <= 20);
    }

    private String getDefaultPokemon(TimeOfDay timeOfDay) {
        return timeOfDay == TimeOfDay.DAY ? "Rattata" : "Hoothoot";
    }

    public Collection<WildPokemon> getAllWildPokemon() {

        return pokemonById.values();
    }



    private void sendSpawnUpdate(WildPokemon pokemon) {
        NetworkProtocol.WildPokemonSpawn spawnUpdate = new NetworkProtocol.WildPokemonSpawn();
        spawnUpdate.uuid = pokemon.getUuid();
        spawnUpdate.x = pokemon.getX();
        spawnUpdate.y = pokemon.getY();
        spawnUpdate.timestamp = System.currentTimeMillis();
        GameContext.get().getGameClient().sendPokemonSpawn(spawnUpdate);
    }

    private void sendDespawnUpdate(UUID pokemonId) {
        NetworkProtocol.PokemonDespawn despawnUpdate = new NetworkProtocol.PokemonDespawn();
        despawnUpdate.uuid = pokemonId;
        GameContext.get().getGameClient().sendPokemonDespawn(despawnUpdate.uuid);
    }

    public Map<UUID, WildPokemon> getPokemonById() {
        return pokemonById;
    }

    private void updatePokemonMovements(float delta) {
        for (List<WildPokemon> pokemonList : pokemonByChunk.values()) {
            for (WildPokemon pokemon : pokemonList) {
                pokemon.update(delta);
            }
        }
    }
    public void addPokemonToChunk(WildPokemon pokemon, Vector2 chunkPos) {
        try {
            List<WildPokemon> pokemonList = pokemonByChunk.computeIfAbsent(chunkPos, k -> new ArrayList<>());
            pokemonList.add(pokemon);
            pokemonById.put(pokemon.getUuid(), pokemon);
        } catch (Exception e) {
            GameLogger.error("Error adding Pokemon to chunk: " + e.getMessage());
        }
    }
    private enum TimeOfDay {
        DAY,
        NIGHT
    }

    public static class NetworkSyncData {
        public long lastUpdateTime;
        public Vector2 targetPosition;
        public String direction;
        public boolean isMoving;

        public NetworkSyncData() {
            this.lastUpdateTime = System.currentTimeMillis();
        }
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/RemoveOperation.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.math.Vector2;

public class RemoveOperation extends WorldObjectOperation {
    public final Vector2 chunkPos;
    public final String objectId;

    public RemoveOperation(Vector2 chunkPos, String objectId) {
        super(OperationType.REMOVE);
        this.chunkPos = chunkPos;
        this.objectId = objectId;
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/UpdateOperation.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;

public class UpdateOperation extends WorldObjectOperation {
    public Vector2 chunkPos;
    public NetworkProtocol.WorldObjectUpdate update;

    public UpdateOperation(Vector2 chunkPos, NetworkProtocol.WorldObjectUpdate update) {
        super(OperationType.UPDATE);
        this.type = OperationType.UPDATE;
        this.chunkPos = chunkPos;
        this.update = update;
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/WeatherAudioSystem.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

public class WeatherAudioSystem {
    private static final float THUNDER_MIN_INTERVAL = 5f;
    private static final float THUNDER_MAX_INTERVAL = 15f;

    private float thunderTimer;
    private float nextThunderTime;
    private boolean isThundering;
    private float lightningAlpha;
    private final AudioManager audioManager;

    public WeatherAudioSystem(AudioManager audioManager) {
        this.audioManager = audioManager;
        resetThunderTimer();
    }

    private void resetThunderTimer() {
        nextThunderTime = MathUtils.random(THUNDER_MIN_INTERVAL, THUNDER_MAX_INTERVAL);
        thunderTimer = 0;
    }

    public void update(float delta, WeatherSystem.WeatherType currentWeather, float intensity) {
        updateThunderAndLightning(delta, currentWeather, intensity);
        updateWeatherSounds(currentWeather, intensity);
    }

    private void updateThunderAndLightning(float delta, WeatherSystem.WeatherType currentWeather, float intensity) {
        if (currentWeather == WeatherSystem.WeatherType.THUNDERSTORM) {
            thunderTimer += delta;

            // Update lightning flash
            if (isThundering) {
                lightningAlpha = Math.max(0, lightningAlpha - delta * 2f);
                if (lightningAlpha <= 0) {
                    isThundering = false;
                }
            }

            // Check for new thunder
            if (thunderTimer >= nextThunderTime) {
                triggerThunderAndLightning(intensity);
                resetThunderTimer();
            }
        } else {
            lightningAlpha = 0;
            isThundering = false;
            resetThunderTimer();
        }
    }

    private void triggerThunderAndLightning(float intensity) {
        isThundering = true;
        lightningAlpha = 0.7f * intensity;

        // Play thunder sound with random variation
        float volume = 0.5f + (intensity * 0.5f);
        float pitch = 0.9f + (MathUtils.random() * 0.2f);
        audioManager.playWeatherSound(AudioManager.WeatherSoundEffect.THUNDER, volume, pitch);
    }

    private void updateWeatherSounds(WeatherSystem.WeatherType currentWeather, float intensity) {
        // Update looping weather sounds
        switch (currentWeather) {
            case RAIN:
                audioManager.updateWeatherLoop(AudioManager.WeatherSoundEffect.LIGHT_RAIN, intensity * 0.6f);
                break;

            case HEAVY_RAIN:
            case THUNDERSTORM:
                audioManager.stopWeatherLoop(AudioManager.WeatherSoundEffect.LIGHT_RAIN);
                break;

            case SNOW:
            case BLIZZARD:
                audioManager.updateWeatherLoop(AudioManager.WeatherSoundEffect.WIND, intensity * 0.4f);
                break;

            case SANDSTORM:
                audioManager.updateWeatherLoop(AudioManager.WeatherSoundEffect.SAND_WIND, intensity * 0.7f);
                break;

            default:
                // Stop all weather loops for clear weather
                audioManager.stopAllWeatherLoops();
                break;
        }
    }

    public void renderLightningEffect(SpriteBatch batch, float screenWidth, float screenHeight) {
        if (lightningAlpha > 0) {
            Color oldColor = batch.getColor();
            batch.setColor(1, 1, 1, lightningAlpha);

            // Save blend function
            int srcFunc = batch.getBlendSrcFunc();
            int dstFunc = batch.getBlendDstFunc();

            // Use additive blending for lightning
            batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE);

            // Draw full screen white rectangle for lightning flash
            batch.draw(TextureManager.getWhitePixel(), 0, 0, screenWidth, screenHeight);

            // Restore original blend function and color
            batch.setBlendFunction(srcFunc, dstFunc);
            batch.setColor(oldColor);
        }
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/WeatherSystem.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import io.github.pokemeetup.managers.BiomeTransitionResult;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import static com.badlogic.gdx.math.MathUtils.random;
import static io.github.pokemeetup.system.gameplay.overworld.WeatherSystem.WeatherType.HEAVY_RAIN;
import static io.github.pokemeetup.system.gameplay.overworld.WeatherSystem.WeatherType.RAIN;


public class WeatherSystem {
    private static final float SPAWN_MARGIN = 150f;
    private static final int MAX_PARTICLES = 300;
    private static final float MAX_PARTICLE_SPAWN_RATE = 300f; // Adjust as needed
    private static final float PARTICLE_DESPAWN_MARGIN = 150f;
    private static final float RAIN_SPEED = 800f;
    private static final float RAIN_ANGLE = 75f;
    private static final float RAIN_SCALE = 0.7f;
    private static final float RAIN_BASE_ALPHA = 0.7f;
    private static final float SNOW_SPEED = 300f;
    private static final float SAND_SPEED = 500f;
    private static final float WEATHER_CHECK_INTERVAL = 10f;
    private final List<WeatherParticle> particles;
    private final TextureRegion rainDrop;
    private final TextureRegion snowflake;
    private final TextureRegion sandParticle;
    private float fogOffsetX = 0f;
    private float fogOffsetY = 0f;
    private float particleSpawnAccumulator = 0f;
    private WeatherType currentWeather;
    private float intensity;
    private float accumulation;
    private float weatherCheckTimer = 0f;

    public WeatherSystem() {
        this.particles = new ArrayList<>();
        this.currentWeather = WeatherType.CLEAR;
        this.intensity = 0f;
        this.accumulation = 0f;
        this.rainDrop = TextureManager.effects.findRegion("rain_drop");
        this.snowflake = TextureManager.effects.findRegion("snowflake");
        this.sandParticle = TextureManager.effects.findRegion("sand_particle");
    }

    public List<WeatherParticle> getParticles() {
        return particles;
    }

    private void updateWeatherType(BiomeTransitionResult biomeTransition, float temperature, float timeOfDay) {
        Random random = new Random();
        float baseChance = random.nextFloat();

        if (baseChance > 0.3f) {
            switch (biomeTransition.getPrimaryBiome().getType()) {
                case RAIN_FOREST:
                    setWeather(WeatherType.HEAVY_RAIN, 0.8f);
                    break;

                case HAUNTED:
                    if (random.nextFloat() < 0.9f) {
                        setWeather(WeatherType.FOG, 0.9f);
                    } else {
                        setWeather(WeatherType.THUNDERSTORM, 0.9f);
                    }
                    break;


                case SNOW:
                    setWeather(temperature < 0 ? WeatherType.BLIZZARD : WeatherType.SNOW, 0.6f);
                    break;

                case DESERT:
                    if (temperature > 25) {
                        setWeather(WeatherType.SANDSTORM, 0.7f);
                    }
                    break;

                case FOREST:
                    if (random.nextFloat() > 0.5f) {
                        setWeather(WeatherType.RAIN, 0.5f);
                    }
                    break;

                default:
                    if (random.nextFloat() > 0.7f) {
                        setWeather(WeatherType.RAIN, 0.3f);
                    }
                    break;
            }
        } else {
            setWeather(WeatherType.CLEAR, 0f);
        }
    }

    public void update(float delta, BiomeTransitionResult biomeTransition, float temperature, float timeOfDay, GameScreen gameScreen) {
        weatherCheckTimer += delta;

        if (weatherCheckTimer >= WEATHER_CHECK_INTERVAL) {
            updateWeatherType(biomeTransition, temperature, timeOfDay);
            weatherCheckTimer = 0f;

            GameLogger.info(String.format(
                "Weather Updated - Type: %s, Intensity: %.2f, Temperature: %.1f",
                currentWeather, intensity, temperature
            ));
        }

        updateParticles(delta, gameScreen.getCamera());


        generateParticles(delta, gameScreen);

        updateAccumulation(delta);
        if (currentWeather == WeatherType.FOG) {
            float fogSpeedX = 20f;
            float fogSpeedY = 10f;
            fogOffsetX += fogSpeedX * delta;
            fogOffsetY += fogSpeedY * delta;
        }
    }

    private void generateParticles(float delta, GameScreen gameScreen) {
        if (currentWeather == WeatherType.CLEAR || currentWeather == WeatherType.FOG) {
            return;
        }

        float particleSpawnRate = intensity * MAX_PARTICLE_SPAWN_RATE;

        // Adjust spawn rate for heavy rain
        if (currentWeather == WeatherType.HEAVY_RAIN || currentWeather == WeatherType.THUNDERSTORM) {
            particleSpawnRate *= 1.5f;
        }

        particleSpawnAccumulator += delta * particleSpawnRate;

        int particlesToGenerate = (int) particleSpawnAccumulator;
        particleSpawnAccumulator -= particlesToGenerate;

        // Limit the maximum number of particles to prevent exceeding MAX_PARTICLES
        particlesToGenerate = Math.min(particlesToGenerate, MAX_PARTICLES - particles.size());

        for (int i = 0; i < particlesToGenerate; i++) {
            WeatherParticle particle = createParticle(gameScreen);
            if (particle != null) {
                particles.add(particle);
            }
        }
    }

    private WeatherParticle createParticle(GameScreen gameScreen) {
        OrthographicCamera camera = gameScreen.getCamera();
        float cameraX = camera.position.x;
        float cameraY = camera.position.y;
        float viewWidth = camera.viewportWidth * camera.zoom;
        float viewHeight = camera.viewportHeight * camera.zoom;

        float spawnX, spawnY;
        if (currentWeather == WeatherType.RAIN ||
            currentWeather == WeatherType.HEAVY_RAIN ||
            currentWeather == WeatherType.THUNDERSTORM) {


            spawnX = MathUtils.random(
                cameraX - viewWidth / 2 - SPAWN_MARGIN,
                cameraX + viewWidth / 2 + SPAWN_MARGIN
            );
            spawnY = cameraY + viewHeight / 2 + SPAWN_MARGIN;

            // Calculate rain velocity using consistent angle
            float speed = RAIN_SPEED * (currentWeather == WeatherType.HEAVY_RAIN ? 1.2f : 1f);
            float velocityX = -speed * MathUtils.cosDeg(RAIN_ANGLE);
            float velocityY = -speed * MathUtils.sinDeg(RAIN_ANGLE);

            return new WeatherParticle(
                spawnX, spawnY,
                velocityX, velocityY,
                rainDrop,
                false,
                RAIN_SCALE
            );
        }
        // Other weather types
        else {
            spawnX = cameraX + MathUtils.random(-viewWidth / 2 - SPAWN_MARGIN, viewWidth / 2 + SPAWN_MARGIN);
            spawnY = cameraY + viewHeight / 2 + SPAWN_MARGIN;

            switch (currentWeather) {
                case SNOW:
                case BLIZZARD:
                    return new WeatherParticle(
                        spawnX, spawnY,
                        MathUtils.random(-50, 50),
                        -SNOW_SPEED - MathUtils.random(0, 50),
                        snowflake,
                        true,
                        0.6f + MathUtils.random() * 0.8f
                    );

                case SANDSTORM:
                    spawnX = cameraX + viewWidth / 2 + SPAWN_MARGIN;
                    spawnY = cameraY + MathUtils.random(-viewHeight / 2 - SPAWN_MARGIN, viewHeight / 2 + SPAWN_MARGIN);
                    return new WeatherParticle(
                        spawnX, spawnY,
                        -SAND_SPEED - MathUtils.random(0, 100),
                        MathUtils.random(-60, 60),
                        sandParticle,
                        true,
                        0.7f + MathUtils.random() * 0.6f
                    );

                default:
                    return null;
            }
        }
    }

    public void updateParticles(float delta, OrthographicCamera camera) {
        float left = camera.position.x - (camera.viewportWidth / 2 + PARTICLE_DESPAWN_MARGIN) * camera.zoom;
        float right = camera.position.x + (camera.viewportWidth / 2 + PARTICLE_DESPAWN_MARGIN) * camera.zoom;
        float bottom = camera.position.y - (camera.viewportHeight / 2 + PARTICLE_DESPAWN_MARGIN) * camera.zoom;
        float top = camera.position.y + (camera.viewportHeight / 2 + PARTICLE_DESPAWN_MARGIN) * camera.zoom;

        particles.removeIf(particle -> {
            particle.update(delta);
            return particle.isOutOfBounds(left, right, bottom, top);
        });
    }


    public void render(SpriteBatch batch, OrthographicCamera camera) {
        if (currentWeather == WeatherType.CLEAR) return;

        Color prevColor = batch.getColor().cpy();
        int prevSrcFunc = batch.getBlendSrcFunc();
        int prevDstFunc = batch.getBlendDstFunc();

        if (currentWeather == WeatherType.RAIN ||
            currentWeather == WeatherType.HEAVY_RAIN ||
            currentWeather == WeatherType.THUNDERSTORM) {

            batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);
            batch.setColor(1, 1, 1, RAIN_BASE_ALPHA * intensity);
        } else {
            batch.setColor(1, 1, 1, intensity);
        }

        // Render all particles
        for (WeatherParticle particle : particles) {
            particle.render(batch);
        }

        // Restore batch state
        batch.setBlendFunction(prevSrcFunc, prevDstFunc);
        batch.setColor(prevColor);

        // Render fog if applicable
        if (currentWeather == WeatherType.FOG) {
            renderFog(batch,
                camera.position.x - camera.viewportWidth / 2,
                camera.position.y - camera.viewportHeight / 2,
                camera.viewportWidth,
                camera.viewportHeight
            );
        }
    }

    private void renderFog(SpriteBatch batch, float x, float y, float width, float height) {
        batch.setColor(1, 1, 1, 0.3f * intensity);

        TextureRegion fogTexture = TextureManager.effects.findRegion("fog");
        float fogTextureWidth = fogTexture.getRegionWidth();
        float fogTextureHeight = fogTexture.getRegionHeight();

        float startX = x - (fogOffsetX % (fogTextureWidth)) - fogTextureWidth;
        float startY = y - (fogOffsetY % (fogTextureHeight)) - fogTextureHeight;
        for (float posX = startX; posX < x + width; posX += fogTextureWidth) {
            for (float posY = startY; posY < y + height; posY += fogTextureHeight) {
                batch.draw(
                    fogTexture,
                    posX,
                    posY,
                    fogTextureWidth,
                    fogTextureHeight
                );
            }
        }

        batch.setColor(1, 1, 1, 1);
    }

    private void updateAccumulation(float delta) {
        float accumulationRate;

        if (currentWeather == WeatherType.SNOW || currentWeather == WeatherType.BLIZZARD) {
            accumulationRate = 0.1f * intensity;
        } else if (currentWeather.equals(RAIN)) {
            accumulationRate = 0.05f * intensity;
        } else if (currentWeather == HEAVY_RAIN || currentWeather == WeatherType.THUNDERSTORM) {
            accumulationRate = 0.15f * intensity;
        } else {
            accumulationRate = -0.05f;
        }

        accumulation = MathUtils.clamp(accumulation + accumulationRate * delta, 0, 1);
    }

    public void setWeather(WeatherType type, float intensity) {
        this.currentWeather = type;
        this.intensity = intensity;
    }

    public WeatherType getCurrentWeather() {
        return currentWeather;
    }

    public float getIntensity() {
        return intensity;
    }

    public float getAccumulation() {
        return accumulation;
    }

    public enum WeatherType {
        CLEAR,
        RAIN,
        HEAVY_RAIN,
        SNOW,
        BLIZZARD,
        SANDSTORM,
        FOG,
        THUNDERSTORM
    }
}

class WeatherParticle {
    private final TextureRegion texture;
    private float x, y;
    private float velocityX, velocityY;
    private float rotation;
    private float rotationSpeed;
    private float scale;
    private boolean rotating;
    public WeatherParticle(float x, float y, float velocityX, float velocityY,
                           TextureRegion texture, boolean rotating, float scale) {
        this.x = x;
        this.y = y;
        this.velocityX = velocityX;
        this.velocityY = velocityY;
        this.texture = texture;
        this.rotating = rotating;
        this.scale = scale;
        this.rotation = 0f;
    }

    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }

    public void update(float delta) {
        x += velocityX * delta;
        y += velocityY * delta;

        if (rotating) {
            rotation += rotationSpeed * delta;
        }
    }

    public void render(SpriteBatch batch) {
        if (rotating) {
            batch.draw(
                texture,
                x, y,
                texture.getRegionWidth() / 2f,
                texture.getRegionHeight() / 2f,
                texture.getRegionWidth(),
                texture.getRegionHeight(),
                scale, scale,
                rotation
            );
        } else {
            batch.draw(
                texture,
                x, y,
                texture.getRegionWidth() * scale,
                texture.getRegionHeight() * scale
            );
        }
    }

    public boolean isOutOfBounds(float left, float right, float bottom, float top) {
        return x < left || x > right || y < bottom || y > top;
    }

    public boolean isInView(float left, float right, float bottom, float top) {
        float margin = 100;
        return x >= left - margin && x <= right + margin &&
            y >= bottom - margin && y <= top + margin;
    }

}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/World.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonReader;
import com.badlogic.gdx.utils.JsonValue;
import com.badlogic.gdx.utils.JsonWriter;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.blocks.BlockManager;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.managers.*;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.*;
import io.github.pokemeetup.system.gameplay.SpawnPointValidator;
import io.github.pokemeetup.system.gameplay.inventory.secureinventories.InventorySlotData;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.system.gameplay.overworld.multiworld.WorldManager;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.PerlinNoise;
import io.github.pokemeetup.utils.storage.JsonConfig;
import io.github.pokemeetup.utils.textures.BlockTextureManager;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

public class World {
    public static final int INITIAL_LOAD_RADIUS = 2;   // Reduced from 4
    public static final int WORLD_SIZE = 100000;
    public static final int TILE_SIZE = 32;
    public static final int CHUNK_SIZE = 16;
    public static final float INTERACTION_RANGE = TILE_SIZE * 1.5f;
    public static final int HALF_WORLD_SIZE = WORLD_SIZE / 2;
    private static final float COLOR_TRANSITION_SPEED = 2.0f;
    private static final int CHUNK_UNLOAD_RADIUS = INITIAL_LOAD_RADIUS + 2;
    private static final int MAX_CHUNKS_IN_MEMORY = 100;
    private static final long CHUNK_SAVE_INTERVAL = 60000;
    public static int DEFAULT_X_POSITION = 0;
    public static int DEFAULT_Y_POSITION = 0;
    private final Map<Vector2, Long> lastChunkAccess = new ConcurrentHashMap<>();
    private final Set<Vector2> dirtyChunks = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final BiomeRenderer biomeRenderer;
    private Color currentWorldColor = new Color(1, 1, 1, 1);
    private Color previousWorldColor = null;
    private float colorTransitionProgress = 1.0f;
    private volatile boolean initialChunksRequested = false;
    private Map<Vector2, Chunk> chunks;
    private Map<Vector2, Future<Chunk>> loadingChunks;
    private Queue<Vector2> initialChunkLoadQueue = new LinkedList<>();
    private ExecutorService chunkLoadExecutor = Executors.newFixedThreadPool(4);
    private BiomeManager biomeManager;
    private PlayerData currentPlayerData;
    private WorldObject nearestPokeball;
    private long lastPlayed;
    private BlockManager blockManager;
    private String name;
    private WorldData worldData;
    private PokemonSpawnManager pokemonSpawnManager;
    private long worldSeed;
    private WorldObject.WorldObjectManager objectManager;
    private WeatherSystem weatherSystem;
    private WeatherAudioSystem weatherAudioSystem;
    private BiomeTransitionResult currentBiomeTransition;
    private float temperature = 20.0f; // Default temperature
    private boolean initialized = false;
    private Map<Vector2, Float> lightLevelMap = new HashMap<>();
    private boolean isDisposed = false;
    private WaterEffectManager waterEffectManager;
    private WaterEffectsRenderer waterEffects;

    public World(WorldData worldData) {
        try {
            GameLogger.info("Initializing multiplayer world: " + worldData.getName());
            this.worldData = worldData;
            this.name = worldData.getName();
            this.worldSeed = worldData.getConfig().getSeed();
            this.blockManager = new BlockManager(this);
            this.biomeManager = new BiomeManager(this.worldSeed);
            this.biomeRenderer = new BiomeRenderer();
            this.chunks = new ConcurrentHashMap<>();
            this.loadingChunks = new ConcurrentHashMap<>();
            this.initialChunkLoadQueue = new LinkedList<>();
            this.chunkLoadExecutor = Executors.newFixedThreadPool(4);

            loadChunksFromWorldData();
            if (worldData.getBlockData() != null) {
                migrateBlocksToChunks();
            }

            this.objectManager = new WorldObject.WorldObjectManager(worldSeed, GameContext.get().getGameClient());
            this.pokemonSpawnManager = new PokemonSpawnManager(TextureManager.pokemonoverworld);
            this.weatherSystem = new WeatherSystem();
            this.weatherAudioSystem = new WeatherAudioSystem(AudioManager.getInstance());

            GameLogger.info("Multiplayer world initialization complete");

        } catch (Exception e) {
            GameLogger.error("Failed to initialize multiplayer world: " + e.getMessage());
            throw new RuntimeException("World initialization failed", e);
        }
        this.waterEffectManager = new WaterEffectManager();
        waterEffects = new WaterEffectsRenderer();
    }


    public World(String name, long seed, BiomeManager manager) {
        try {
            GameLogger.info("Initializing singleplayer world: " + name);
            this.name = name;
            this.biomeManager = manager;
            this.worldSeed = seed;

            // Create new world data
            this.worldData = new WorldData(name);
            WorldData.WorldConfig config = new WorldData.WorldConfig(seed);
            this.worldData.setConfig(config);
            // Initialize basic managers
            this.blockManager = new BlockManager(this);
            this.biomeRenderer = new BiomeRenderer();

            this.chunks = new ConcurrentHashMap<>();
            this.loadingChunks = new ConcurrentHashMap<>();

            WorldData existingData = JsonConfig.loadWorldData(name);
            if (existingData != null) {
                GameLogger.info("Found existing world data for: " + name);
                this.worldData = existingData;
                loadChunksFromWorldData();// In World constructor after loadChunksFromWorldData()
                if (worldData != null && worldData.getBlockData() != null) {
                    migrateBlocksToChunks();
                }
            }

            this.weatherSystem = new WeatherSystem();
            this.weatherAudioSystem = new WeatherAudioSystem(AudioManager.getInstance());
            this.objectManager = new WorldObject.WorldObjectManager(worldSeed, GameContext.get().getGameClient());
            this.pokemonSpawnManager = new PokemonSpawnManager(TextureManager.pokemonoverworld);

            // Generate initial chunks if needed
            if (chunks.isEmpty()) {
                initializeChunksAroundOrigin();
            }

        } catch (Exception e) {
            GameLogger.error("Failed to initialize singleplayer world: " + e.getMessage());
            throw new RuntimeException("World initialization failed", e);
        }
        this.waterEffectManager = new WaterEffectManager();

        waterEffects = new WaterEffectsRenderer();
    }

    public Color getBiomeColor(BiomeType type) {
        switch (type) {
            case PLAINS:
                return new Color(0.4f, 0.8f, 0.4f, 1f); // greenish
            case FOREST:
                return new Color(0.2f, 0.6f, 0.2f, 1f); // darker green
            case DESERT:
                return new Color(0.9f, 0.9f, 0.5f, 1f); // sandy
            case SNOW:
                return new Color(0.9f, 0.9f, 1f, 1f);   // snowy white
            case RUINS:
                return new Color(0.5f, 0.5f, 0.5f, 1f); // grayish
            case HAUNTED:
                return new Color(0.3f, 0.3f, 0.4f, 1f); // gloomy
            case RAIN_FOREST:
                return new Color(0.0f, 0.5f, 0.3f, 1f); // lush green
            case BIG_MOUNTAINS:
                return new Color(0.5f, 0.5f, 0.6f, 1f); // bluish gray for mountains
            default:
                return new Color(0.4f, 0.8f, 0.4f, 1f); // fallback
        }
    }

    public Float getLightLevelAtTile(Vector2 tilePos) {
        return lightLevelMap.get(tilePos);
    }

    public Color getCurrentWorldColor() {
        return currentWorldColor;
    }


    private void loadChunksFromWorldData() {
        try {
            Map<Vector2, Chunk> worldChunks = worldData.getChunks();
            if (worldChunks != null) {
                chunks.clear();
                this.chunks.putAll(worldChunks);
                GameLogger.info("Loaded " + chunks.size() + " chunks");
            }

            Map<Vector2, List<WorldObject>> worldObjects = worldData.getChunkObjects();
            if (worldObjects != null) {
                int objectCount = 0;
                for (Map.Entry<Vector2, List<WorldObject>> entry : worldObjects.entrySet()) {
                    Vector2 chunkPos = entry.getKey();
                    List<WorldObject> objects = entry.getValue();

                    if (objects != null) {
                        objectManager.setObjectsForChunk(chunkPos, objects);
                        objectCount += objects.size();
                    }
                }
                GameLogger.info("Loaded " + objectCount + " world objects");
            }

        } catch (Exception e) {
            GameLogger.error("Failed to load world data: " + e.getMessage());
            throw new RuntimeException("World data loading failed", e);
        }
    }

    public WeatherSystem getWeatherSystem() {
        return weatherSystem;
    }

    public void requestInitialChunks(Vector2 playerPosition) {
        if (initialChunksRequested) {
            GameLogger.info("Initial chunks already requested");
            return;
        }

        GameLogger.info("Requesting initial chunks around: " + playerPosition);
        initialChunksRequested = true;

        int playerChunkX = (int) Math.floor(playerPosition.x / (CHUNK_SIZE * TILE_SIZE));
        int playerChunkY = (int) Math.floor(playerPosition.y / (CHUNK_SIZE * TILE_SIZE));

        for (int dx = -INITIAL_LOAD_RADIUS; dx <= INITIAL_LOAD_RADIUS; dx++) {
            for (int dy = -INITIAL_LOAD_RADIUS; dy <= INITIAL_LOAD_RADIUS; dy++) {
                Vector2 chunkPos = new Vector2(playerChunkX + dx, playerChunkY + dy);
                if (!chunks.containsKey(chunkPos)) {
                    try {
                        if (GameContext.get().getGameClient() != null && !GameContext.get().getGameClient().isSinglePlayer()) {
                            GameContext.get().getGameClient().requestChunk(chunkPos);
                        } else {
                            loadChunkAsync(chunkPos);
                        }
                        GameLogger.info("Requested chunk at: " + chunkPos);
                    } catch (Exception e) {
                        GameLogger.error("Error requesting chunk at " + chunkPos + ": " + e.getMessage());
                    }
                }
            }
        }
    }


    public void savePlayerData(String username, PlayerData data) {
        if (worldData != null) {
            boolean isMultiplayer = false;
            if (GameContext.get().getGameClient() != null) {
                isMultiplayer = !GameContext.get().getGameClient().isSinglePlayer();
            }

            if (isMultiplayer) {
                // Only send data to server in multiplayer
                if (GameContext.get().getGameClient() != null) {
                    UUID playerUUID = UUID.nameUUIDFromBytes(username.getBytes());
                    GameContext.get().getGameClient().savePlayerData(playerUUID, data);
                }
            } else {
                // Only save locally in singleplayer
                worldData.savePlayerData(username, data, false);
            }
        }
    }


    public void processChunkData(NetworkProtocol.ChunkData chunkData) {
        Vector2 chunkPos = new Vector2(chunkData.chunkX, chunkData.chunkY);

        try {
            // Create biome from data
            Biome biome = biomeManager.getBiome(chunkData.biomeType);
            if (biome == null) {
                GameLogger.error("Invalid biome type for chunk: " + chunkData.biomeType);
                return;
            }

            // Create and set up chunk
            Chunk chunk = new Chunk(chunkData.chunkX, chunkData.chunkY, biome, worldSeed, biomeManager);
            chunk.setTileData(chunkData.tileData);

            // Process blocks if present
            if (chunkData.blockData != null) {
                for (BlockSaveData.BlockData blockData : chunkData.blockData) {
                    try {
                        PlaceableBlock.BlockType blockType = PlaceableBlock.BlockType.fromId(blockData.type);
                        if (blockType == null) {
                            GameLogger.error("Unknown block type: " + blockData.type);
                            continue;
                        }

                        Vector2 pos = new Vector2(blockData.x, blockData.y);
                        PlaceableBlock block = new PlaceableBlock(blockType, pos, null, blockData.isFlipped);

                        // Handle chest-specific data
                        if (blockType == PlaceableBlock.BlockType.CHEST) {
                            block.setChestOpen(blockData.isChestOpen);
                            if (blockData.chestData != null) {
                                block.setChestData(blockData.chestData);
                                GameLogger.info("Loaded chest at " + pos + " with " +
                                    (blockData.chestData.items != null ?
                                        blockData.chestData.items.stream().filter(Objects::nonNull).count() : 0) +
                                    " items");
                            }
                        }

                        // Set texture
                        TextureRegion baseRegion = BlockTextureManager.getBlockFrame(block, 0);
                        if (baseRegion != null) {
                            block.setTexture(new TextureRegion(baseRegion));
                            chunk.addBlock(block);
                            GameLogger.info("Added block: " + blockType + " at " + pos);
                        } else {
                            GameLogger.error("No texture found for block type: " + blockType);
                        }

                    } catch (Exception e) {
                        GameLogger.error("Failed to process block data: " + e.getMessage());
                    }
                }
            }

            // Process world objects
            if (chunkData.worldObjects != null) {
                List<WorldObject> objects = new ArrayList<>();

                for (Map<String, Object> objData : chunkData.worldObjects) {
                    try {
                        String typeStr = (String) objData.get("type");
                        WorldObject.ObjectType type = WorldObject.ObjectType.valueOf(typeStr);
                        int tileX = ((Number) objData.get("tileX")).intValue();
                        int tileY = ((Number) objData.get("tileY")).intValue();

                        WorldObject obj = new WorldObject(tileX, tileY, null, type);

                        // Set object ID if present
                        if (objData.containsKey("id")) {
                            obj.setId((String) objData.get("id"));
                        } else {
                            obj.setId(UUID.randomUUID().toString());
                        }

                        // Set any additional properties from data
                        obj.updateFromData(objData);
                        objects.add(obj);

                    } catch (Exception e) {
                        GameLogger.error("Failed to create world object from data: " + e.getMessage());
                    }
                }

                // Add objects to object manager
                if (!objects.isEmpty()) {
                    objectManager.setObjectsForChunk(chunkPos, objects);
                    GameLogger.info("Added " + objects.size() + " objects to chunk " + chunkPos);
                }
            }

            // Add chunk to world
            chunks.put(chunkPos, chunk);
            GameLogger.info("Processed chunk data for " + chunkPos);

        } catch (Exception e) {
            GameLogger.error("Failed to process chunk data at " + chunkPos + ": " + e.getMessage());
        }
    }

    public boolean areInitialChunksLoaded() {
        if (!initialChunksRequested) {
            GameLogger.error("Initial chunks not yet requested");
            return false;
        }

        int totalRequired = (INITIAL_LOAD_RADIUS * 2 + 1) * (INITIAL_LOAD_RADIUS * 2 + 1);
        int loadedCount = chunks.size();

        boolean allLoaded = loadedCount >= totalRequired;

        if (!allLoaded) {
            GameLogger.info("Still loading chunks: " + loadedCount + "/" + totalRequired);
            // Log missing chunk positions
            if (GameContext.get().getPlayer() != null) {
                int playerChunkX = (int) Math.floor(GameContext.get().getPlayer().getX() / (CHUNK_SIZE * TILE_SIZE));
                int playerChunkY = (int) Math.floor(GameContext.get().getPlayer().getY() / (CHUNK_SIZE * TILE_SIZE));

                for (int dx = -INITIAL_LOAD_RADIUS; dx <= INITIAL_LOAD_RADIUS; dx++) {
                    for (int dy = -INITIAL_LOAD_RADIUS; dy <= INITIAL_LOAD_RADIUS; dy++) {
                        Vector2 chunkPos = new Vector2(playerChunkX + dx, playerChunkY + dy);
                        if (!chunks.containsKey(chunkPos)) {
                            GameLogger.error("Missing chunk at: " + chunkPos);
                        }
                    }
                }
            }
        }

        return allLoaded;
    }


    public void initializeWorldFromData(WorldData worldData) {
        setWorldData(worldData);
        loadChunksFromWorldData();
    }

    public boolean areAllChunksLoaded() {
        int totalChunks = (INITIAL_LOAD_RADIUS * 2 + 1) * (INITIAL_LOAD_RADIUS * 2 + 1);
        int loadedChunks = 0;

        for (int dx = -INITIAL_LOAD_RADIUS; dx <= INITIAL_LOAD_RADIUS; dx++) {
            for (int dy = -INITIAL_LOAD_RADIUS; dy <= INITIAL_LOAD_RADIUS; dy++) {
                Vector2 chunkPos = new Vector2(dx, dy);
                if (chunks.containsKey(chunkPos)) {
                    loadedChunks++;
                }
            }
        }
        if (chunks.size() != loadedChunks) {
            GameLogger.error("Chunk count mismatch - Map size: " + chunks.size() +
                ", Counted: " + loadedChunks);
        }

        GameLogger.info("Chunks loaded: " + loadedChunks + "/" + totalChunks);
        return loadedChunks == totalChunks;
    }

    public void forceLoadMissingChunks() {
        GameLogger.info("Forcing load of any missing chunks...");
        int loaded = 0;

        for (int dx = -INITIAL_LOAD_RADIUS; dx <= INITIAL_LOAD_RADIUS; dx++) {
            for (int dy = -INITIAL_LOAD_RADIUS; dy <= INITIAL_LOAD_RADIUS; dy++) {
                Vector2 chunkPos = new Vector2(dx, dy);
                if (!chunks.containsKey(chunkPos)) {
                    try {
                        Chunk chunk = loadOrGenerateChunk(chunkPos);
                        if (chunk != null) {
                            chunks.put(chunkPos, chunk);
                            loaded++;
                        }
                    } catch (Exception e) {
                        GameLogger.error("Failed to force load chunk at " + chunkPos +
                            ": " + e.getMessage());
                    }
                }
            }
        }

        GameLogger.info("Force loaded " + loaded + " missing chunks");
    }

    public WildPokemon getNearestInteractablePokemon(Player player) {
        // Convert player position to pixels
        float playerPixelX = player.getTileX() * TILE_SIZE + (Player.FRAME_WIDTH / 2f);
        float playerPixelY = player.getTileY() * TILE_SIZE + (Player.FRAME_HEIGHT / 2f);

        float checkX = playerPixelX;
        float checkY = playerPixelY;
        float interactionDistance = TILE_SIZE * 1.5f;

        // Adjust check position based on facing direction
        switch (player.getDirection()) {
            case "up":
                checkY += interactionDistance;
                break;
            case "down":
                checkY -= interactionDistance;
                break;
            case "left":
                checkX -= interactionDistance;
                break;
            case "right":
                checkX += interactionDistance;
                break;
        }

        WildPokemon nearest = null;
        float shortestDistance = interactionDistance;

        Collection<WildPokemon> nearbyPokemon = pokemonSpawnManager.getPokemonInRange(
            checkX, checkY, interactionDistance
        );

        for (WildPokemon pokemon : nearbyPokemon) {
            float distance = Vector2.dst(
                checkX,
                checkY,
                pokemon.getX(),
                pokemon.getY()
            );

            if (distance < shortestDistance) {
                shortestDistance = distance;
                nearest = pokemon;
            }
        }

        return nearest;
    }


    public BlockManager getBlockManager() {

        return blockManager;
    }


    public void save() {
        try {
            boolean isMultiplayer = GameContext.get().getGameClient() != null &&
                !GameContext.get().getGameClient().isSinglePlayer();

            if (isMultiplayer) {
                // Only update player data in multiplayer
                if (GameContext.get().getPlayer() != null) {
                    PlayerData currentState = new PlayerData(GameContext.get().getPlayer().getUsername());
                    currentState.updateFromPlayer(GameContext.get().getPlayer());
                    // Send to server via GameClient
                    GameContext.get().getGameClient().savePlayerData(
                        UUID.nameUUIDFromBytes(currentState.getUsername().getBytes()),
                        currentState
                    );
                }
                return; // Don't save world data in multiplayer
            }
            // Update player data first
            if (GameContext.get().getPlayer() != null) {
                PlayerData currentState = new PlayerData(GameContext.get().getPlayer().getUsername());
                currentState.updateFromPlayer(GameContext.get().getPlayer());
                worldData.savePlayerData(GameContext.get().getPlayer().getUsername(), currentState, false);
                GameLogger.info("Updated player data for: " + GameContext.get().getPlayer().getUsername());
            }

            for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
                if (entry.getValue().isDirty()) {
                    saveChunkData(entry.getKey(), entry.getValue());
                }
            }

            // Set last played time
            worldData.setLastPlayed(System.currentTimeMillis());
            worldData.setDirty(true);

            // Save through WorldManager
            WorldManager.getInstance()
                .saveWorld(worldData);

            // Verify save
            FileHandle worldFile = Gdx.files.local("worlds/singleplayer/" + name + "/world.json");
            if (!worldFile.exists()) {
                GameLogger.error("Save failed - world file not created!");
                return;
            }

            GameLogger.info("World saved successfully: " + name);

        } catch (Exception e) {
            GameLogger.error("Failed to save world: " + name + " - " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void dispose() {
        try {
            GameLogger.info("Disposing world: " + name);

            // Final save
            save();

            // Clear collections
            chunks.clear();
            loadingChunks.clear();
            lastChunkAccess.clear();
            dirtyChunks.clear();
            if (waterEffects != null) {
                waterEffects.dispose();
            }
            // Dispose executors
            if (chunkLoadExecutor != null) {
                chunkLoadExecutor.shutdown();
                try {
                    if (!chunkLoadExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                        chunkLoadExecutor.shutdownNow();
                    }
                } catch (InterruptedException e) {
                    chunkLoadExecutor.shutdownNow();
                }
            }

            isDisposed = true;
        } catch (Exception e) {
            GameLogger.error("Error disposing world: " + e.getMessage());
        }
    }

    public long getLastPlayed() {
        return lastPlayed;
    }

    public void setLastPlayed(long lastPlayed) {
        this.lastPlayed = lastPlayed;
    }

    public Player getPlayer() {
        return GameContext.get().getPlayer();
    }

    public void setPlayer(Player player) {
        GameContext.get().setPlayer(player);
        // Initialize player data
        if (player != null) {
            this.currentPlayerData = new PlayerData(player.getUsername());
            this.currentPlayerData.updateFromPlayer(player);
        }
    }


    public void saveChunkData(Vector2 chunkPos, Chunk chunk) {
        if (GameContext.get().getGameClient() != null) {
            if (!GameContext.get().getGameClient().isSinglePlayer()) {
                return;
            }
        }

        try {
            ChunkData data = new ChunkData();
            data.x = (int) chunkPos.x;
            data.y = (int) chunkPos.y;
            data.biomeType = chunk.getBiome().getType();
            data.tileData = chunk.getTileData();
            data.blocks = chunk.getBlockDataForSave();
            List<WorldObject> objects = objectManager.getObjectsForChunk(chunkPos);
            data.objects = objects.stream()
                .map(WorldObjectData::new)
                .collect(Collectors.toList());

            Json json = new Json();
            json.setOutputType(JsonWriter.OutputType.json);
            registerCustomSerializers(json);

            String baseDir =
                "worlds/singleplayer/" + name + "/chunks/";
            String filename = String.format("chunk_%d_%d.json", (int) chunkPos.x, (int) chunkPos.y);
            FileHandle chunkFile = Gdx.files.local(baseDir + filename);

            chunkFile.parent().mkdirs();

            // Write json
            String jsonString = json.prettyPrint(data);
            chunkFile.writeString(jsonString, false);

            // Update in-memory data
            chunks.put(chunkPos, chunk);
            worldData.getChunks().put(chunkPos, chunk);
            worldData.addChunkObjects(chunkPos, objects);
            worldData.setDirty(true);


        } catch (Exception e) {
            GameLogger.error("Failed to save chunk at " + chunkPos + ": " + e.getMessage());
            e.printStackTrace();
        }
    }

    private Chunk loadChunkData(Vector2 chunkPos, boolean isMultiplayer) {
        try {
            String baseDir = isMultiplayer ?
                "worlds/" + name + "/chunks/" :
                "worlds/singleplayer/" + name + "/chunks/";

            String filename = String.format("chunk_%d_%d.json", (int) chunkPos.x, (int) chunkPos.y);
            FileHandle chunkFile = Gdx.files.local(baseDir + filename);

            if (!chunkFile.exists()) {
                return null;
            }

            // Load and parse raw JSON
            String jsonContent = chunkFile.readString();
            Json json = new Json();
            registerCustomSerializers(json);

            // Read the ChunkData object
            ChunkData chunkData = json.fromJson(ChunkData.class, jsonContent);

            // Create chunk with original biome
            BiomeType biomeType = chunkData.biomeType;
            Biome biome = biomeManager.getBiome(biomeType);
            Chunk chunk = new Chunk((int) chunkPos.x, (int) chunkPos.y, biome, worldSeed, biomeManager);

            // Load tile data
            chunk.setTileData(chunkData.tileData);

            // Load blocks
            if (chunkData.blocks != null) {

                for (BlockSaveData.BlockData blockDataItem : chunkData.blocks) {
                    try {
                        PlaceableBlock.BlockType blockType = PlaceableBlock.BlockType.fromId(blockDataItem.type);
                        if (blockType == null) {
                            GameLogger.error("Unknown block type: " + blockDataItem.type);
                            continue;
                        }

                        int x = blockDataItem.x;
                        int y = blockDataItem.y;
                        Vector2 pos = new Vector2(x, y);

                        // Create the PlaceableBlock instance without texture
                        PlaceableBlock block = new PlaceableBlock(blockType, pos, null, blockDataItem.isFlipped);

                        // Set isChestOpen
                        if (blockType == PlaceableBlock.BlockType.CHEST) {
                            block.setChestOpen(blockDataItem.isChestOpen);

                            // Handle chest data
                            if (blockDataItem.chestData != null) {
                                block.setChestData(blockDataItem.chestData);
                                GameLogger.info("Loaded chest at " + pos + " with " +
                                    blockDataItem.chestData.items.stream().filter(Objects::nonNull).count() + " items");
                            }
                        }

                        // In loadChunkData or processChunkData when setting the block texture:
                        TextureRegion baseRegion = BlockTextureManager.getBlockFrame(block, 0);
                        if (baseRegion != null) {
                            // Create a new TextureRegion to avoid flipping the shared atlas region
                            TextureRegion texture = new TextureRegion(baseRegion);
                            // Don't call texture.flip(). We'll rely solely on PlaceableBlock.render() for flipping visuals.
                            block.setTexture(texture);
                        } else {
                            GameLogger.error("No texture found for block type: " + block.getId());
                        }
                        chunk.addBlock(block);


                    } catch (Exception e) {
                        GameLogger.error("Failed to load block: " + e.getMessage());
                    }
                }
            }
            if (chunkData.objects != null) {
                List<WorldObject> objects = new ArrayList<>();
                for (WorldObjectData objData : chunkData.objects) {
                    try {
                        WorldObject.ObjectType type = objData.type;
                        float x = objData.x;
                        float y = objData.y;
                        WorldObject obj = objectManager.createObject(type, x, y);
                        if (obj != null) {
                            objects.add(obj);
                        }
                    } catch (Exception e) {
                        GameLogger.error("Failed to load object: " + e.getMessage());
                    }
                }
                objectManager.setObjectsForChunk(chunkPos, objects);
            }

            return chunk;

        } catch (Exception e) {
            GameLogger.error("Error loading chunk at " + chunkPos + ": " + e.getMessage());
            return null;
        }
    }


    private void registerCustomSerializers(Json json) {
        // Serializer for UUID
        json.setSerializer(UUID.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, UUID object, Class knownType) {
                json.writeValue(object.toString());
            }

            @Override
            public UUID read(Json json, JsonValue jsonData, Class type) {
                return UUID.fromString(jsonData.asString());
            }
        });

        // Serializer for Vector2
        json.setSerializer(Vector2.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, Vector2 object, Class knownType) {
                json.writeObjectStart();
                json.writeValue("x", object.x);
                json.writeValue("y", object.y);
                json.writeObjectEnd();
            }

            @Override
            public Vector2 read(Json json, JsonValue jsonData, Class type) {
                float x = jsonData.getFloat("x");
                float y = jsonData.getFloat("y");
                return new Vector2(x, y);
            }
        });


        json.setSerializer(ItemData.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, ItemData object, Class knownType) {
                json.writeObjectStart();
                json.writeValue("itemId", object.getItemId());
                json.writeValue("count", object.getCount());
                json.writeValue("uuid", object.getUuid().toString());
                json.writeValue("durability", object.getDurability());
                json.writeValue("maxDurability", object.getMaxDurability());
                json.writeObjectEnd();
            }

            @Override
            public ItemData read(Json json, JsonValue jsonData, Class type) {
                ItemData item = new ItemData();
                // Handle both "itemId" and "id" fields for backward compatibility
                if (jsonData.has("itemId")) {
                    item.setItemId(jsonData.getString("itemId"));
                } else if (jsonData.has("id")) {
                    // Backward compatibility with old data
                    item.setItemId(jsonData.getString("id"));
                } else {
                    // Handle missing itemId/id
                    GameLogger.error("ItemData missing 'itemId' or 'id' field during deserialization. Skipping item.");
                    return null; // Skip this item or set a default value
                }
                item.setCount(jsonData.getInt("count", 1));
                String uuidStr = jsonData.getString("uuid", null);
                if (uuidStr != null) {
                    item.setUuid(UUID.fromString(uuidStr));
                } else {
                    item.setUuid(UUID.randomUUID());
                }
                item.setDurability(jsonData.getInt("durability", -1));
                item.setMaxDurability(jsonData.getInt("maxDurability", -1));
                return item;
            }
        });
        json.setSerializer(ChunkData.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, ChunkData object, Class knownType) {
                object.write(json);
            }

            @Override
            public ChunkData read(Json json, JsonValue jsonData, Class type) {
                ChunkData data = new ChunkData();
                data.read(jsonData, json);
                return data;
            }
        });

    }


    public Map<Vector2, Chunk> getChunks() {
        return chunks;
    }

    public void updatePlayerData() {
        if (GameContext.get().getPlayer() != null && currentPlayerData != null) {
            currentPlayerData.updateFromPlayer(GameContext.get().getPlayer());
        }
    }

    public PlayerData getPlayerData() {
        updatePlayerData();
        return currentPlayerData;
    }

    public String getName() {
        return name;
    }

    public WorldData getWorldData() {
        return worldData;
    }

    public void setWorldData(WorldData data) {
        if (data == null) {
            throw new IllegalArgumentException("WorldData cannot be null");
        }
        this.worldData = data;
        this.name = data.getName();
        this.worldSeed = data.getConfig().getSeed();
        this.biomeManager = new BiomeManager(this.worldSeed);

        // Clear existing chunks and objects
        this.chunks.clear();

        // Load chunks and objects from worldData
        loadChunksFromWorldData();

        GameLogger.info("Set WorldData for world: " + name +
            " Time: " + data.getWorldTimeInMinutes() +
            " Played: " + data.getPlayedTime());
    }

    public BiomeManager getBiomeManager() {
        return biomeManager;
    }

    public Biome getBiomeAt(int tileX, int tileY) {
        float worldX = tileX * TILE_SIZE;
        float worldY = tileY * TILE_SIZE;

        BiomeTransitionResult transition = biomeManager.getBiomeAt(worldX, worldY);

        return transition.getPrimaryBiome();
    }

    private void initializeChunksAroundOrigin() {
        validateChunkState();
        GameLogger.info("Starting chunk initialization around origin");
        for (int radius = 0; radius <= INITIAL_LOAD_RADIUS; radius++) {
            for (int dx = -radius; dx <= radius; dx++) {
                for (int dy = -radius; dy <= radius; dy++) {
                    if (Math.max(Math.abs(dx), Math.abs(dy)) == radius) {
                        Vector2 chunkPos = new Vector2(dx, dy);
                        loadChunkAsync(chunkPos);
                    }
                }
            }
        }
    }

    public Chunk loadOrGenerateChunk(Vector2 chunkPos) {
        try {
            boolean isMultiplayer = false;
            if (GameContext.get().getGameClient() != null){
                isMultiplayer= !GameContext.get().getGameClient().isSinglePlayer();
            }
            // First try to load saved biome type
            BiomeType savedBiomeType = biomeManager.loadChunkBiomeData(chunkPos, name, isMultiplayer);

            // Try to load chunk data
            Chunk chunk = loadChunkData(chunkPos, isMultiplayer);

            if (chunk == null) {
                int worldX = (int) (chunkPos.x * Chunk.CHUNK_SIZE);
                int worldY = (int) (chunkPos.y * Chunk.CHUNK_SIZE);

                // Use saved biome type if available, otherwise generate new
                Biome biome;
                if (savedBiomeType != null) {
                    biome = biomeManager.getBiome(savedBiomeType);
                } else {
                    BiomeTransitionResult biomeTransition = biomeManager.getBiomeAt(
                        worldX * TILE_SIZE,
                        worldY * TILE_SIZE
                    );
                    biome = biomeTransition.getPrimaryBiome();
                }

                if (biome == null) {
                    GameLogger.error("Null biome at " + worldX + "," + worldY);
                    biome = biomeManager.getBiome(BiomeType.PLAINS); // Fallback biome
                }

                // Create the chunk
                chunk = new Chunk(
                    (int) chunkPos.x,
                    (int) chunkPos.y, biome,
                    worldSeed,
                    biomeManager
                );

                // Now save the biome data
                if (savedBiomeType == null) {
                    // Since we didn't have saved biome data, save it now
                    biomeManager.saveChunkBiomeData(chunkPos, chunk, name, isMultiplayer);
                }

                objectManager.generateObjectsForChunk(chunkPos, chunk, biome);
                saveChunkData(chunkPos, chunk);
            }

            return chunk;

        } catch (Exception e) {
            GameLogger.error("Failed to load/generate chunk at " + chunkPos + ": " + e.getMessage());
            return null;
        }
    }

    private void updateWorldColor() {
        float hourOfDay = DayNightCycle.getHourOfDay(worldData.getWorldTimeInMinutes());
        Color targetColor = DayNightCycle.getWorldColor(hourOfDay);

        // Initialize colors if they haven't been set
        if (currentWorldColor == null) {
            currentWorldColor = new Color(targetColor);
        }
        if (previousWorldColor == null) {
            previousWorldColor = new Color(targetColor);
            colorTransitionProgress = 1.0f;
        }


        // Start new transition if target color is different and previous transition is complete
        if (!targetColor.equals(currentWorldColor) && colorTransitionProgress >= 1.0f) {
            previousWorldColor.set(currentWorldColor);
            colorTransitionProgress = 0.0f;
        }

        // Update transition
        if (colorTransitionProgress < 1.0f) {
            colorTransitionProgress = Math.min(1.0f, colorTransitionProgress +
                Gdx.graphics.getDeltaTime() * COLOR_TRANSITION_SPEED);

            // Interpolate between colors
            currentWorldColor.r = previousWorldColor.r + (targetColor.r - previousWorldColor.r) * colorTransitionProgress;
            currentWorldColor.g = previousWorldColor.g + (targetColor.g - previousWorldColor.g) * colorTransitionProgress;
            currentWorldColor.b = previousWorldColor.b + (targetColor.b - previousWorldColor.b) * colorTransitionProgress;
            currentWorldColor.a = 1f;
        } else if (!currentWorldColor.equals(targetColor)) {
            // Ensure we reach the target color exactly
            currentWorldColor.set(targetColor);
        }
    }

    private void validateChunkState() {
        if (chunks == null) {
            chunks = new ConcurrentHashMap<>();
        }
        if (loadingChunks == null) {
            loadingChunks = new ConcurrentHashMap<>();
        }
        if (initialChunkLoadQueue == null) {
            initialChunkLoadQueue = new LinkedList<>();
        }
    }

    public void loadChunkAsync(Vector2 chunkPos) {
        if (isDisposed) {
            return; // Skip loading if disposed
        }
        try {
            if (loadingChunks.containsKey(chunkPos)) {
                return;
            }

            CompletableFuture<Chunk> future = CompletableFuture.supplyAsync(() -> {
                try {
                    return loadOrGenerateChunk(chunkPos);
                } catch (Exception e) {
                    GameLogger.error("Failed to load chunk at " + chunkPos + ": " + e.getMessage());
                    return null;
                }
            }, chunkLoadExecutor).thenApplyAsync(chunk -> {
                if (chunk != null) {
                    chunks.put(chunkPos, chunk);
                    loadingChunks.remove(chunkPos);
                }
                return chunk;
            });

            loadingChunks.put(chunkPos, future);
        } catch (Exception e) {
            GameLogger.error("Error initiating chunk load: " + e.getMessage());
        }
    }

    public void update(float delta, Vector2 playerPosition, float viewportWidth, float viewportHeight, GameScreen gameScreen) {
        if (isDisposed) {
            return; // Skip update if disposed
        }
        validateChunkState();

        if (!initialChunksRequested) {
            requestInitialChunks(playerPosition);
            return;
        }

        if (worldData != null) {
            worldData.updateTime(delta);
        }
        updateWorldColor();
        updateLightLevels();
        updateWeather(delta, playerPosition, gameScreen);

        int currentChunkX = (int) Math.floor(playerPosition.x / CHUNK_SIZE);
        int currentChunkY = (int) Math.floor(playerPosition.y / CHUNK_SIZE);

        // Manage chunks
        manageChunks(currentChunkX, currentChunkY);
        waterEffectManager.update(delta);

        // Check if player is on water tile
        int playerTileX = (int) (playerPosition.x / TILE_SIZE);
        int playerTileY = (int) (playerPosition.y / TILE_SIZE);

        Chunk currentChunk = getChunkAtPosition(playerTileX, playerTileY);
        if (currentChunk != null) {
            int localX = Math.floorMod(playerTileX, Chunk.CHUNK_SIZE);
            int localY = Math.floorMod(playerTileY, Chunk.CHUNK_SIZE);

            if (TileType.isWaterPuddle(currentChunk.getTileType(localX, localY))) {
                if (GameContext.get().getPlayer() != null && GameContext.get().getPlayer().isMoving()) {
                    waterEffectManager.createRipple(
                        playerPosition.x * TILE_SIZE + Player.FRAME_WIDTH / 2,
                        playerPosition.y * TILE_SIZE + Player.FRAME_HEIGHT / 2
                    );
                }
            }
        }
        // Update game systems
        updateGameSystems(delta, playerPosition);
    }

    public void updateGameSystems(float delta, Vector2 playerPosition) {
        BiomeTransitionResult currentBiomeTransition = biomeManager.getBiomeAt(
            playerPosition.x * TILE_SIZE,
            playerPosition.y * TILE_SIZE
        );

        Biome currentBiome = currentBiomeTransition.getPrimaryBiome();

        if (AudioManager.getInstance() != null) {
            AudioManager.getInstance().updateBiomeMusic(currentBiome.getType());
            AudioManager.getInstance().update(delta);
        }
        // Update other systems
        pokemonSpawnManager.update(delta, playerPosition);

        objectManager.update(chunks);
        checkPlayerInteractions(playerPosition);
    }

    // In World.java
    private void manageChunks(int playerChunkX, int playerChunkY) {
        try {
            Set<Vector2> requiredChunks = new HashSet<>();
            int loadedThisFrame = 0;
            final int MAX_CHUNKS_PER_FRAME = 2;

            // Get required chunks in Manhattan distance order
            for (int radius = 0; radius <= INITIAL_LOAD_RADIUS; radius++) {
                for (int dx = -radius; dx <= radius; dx++) {
                    for (int dy = -radius; dy <= radius; dy++) {
                        if (Math.abs(dx) + Math.abs(dy) == radius) {
                            requiredChunks.add(new Vector2(playerChunkX + dx, playerChunkY + dy));
                        }
                    }
                }
            }

            // Process chunks with rate limiting
            for (Vector2 chunkPos : requiredChunks) {
                if (loadedThisFrame >= MAX_CHUNKS_PER_FRAME) break;

                if (!chunks.containsKey(chunkPos) && !loadingChunks.containsKey(chunkPos)) {
                    loadChunkAsync(chunkPos);
                    loadedThisFrame++;
                }
                lastChunkAccess.put(chunkPos, System.currentTimeMillis());
            }

        } catch (Exception e) {
            GameLogger.error("Error in chunk management: " + e.getMessage());
        }
    }


    private void cleanupOldChunks(int playerChunkX, int playerChunkY) {
        try {
            // Remove chunks that are too far or haven't been accessed recently
            Iterator<Map.Entry<Vector2, Chunk>> iterator = chunks.entrySet().iterator();
            while (iterator.hasNext()) {
                Map.Entry<Vector2, Chunk> entry = iterator.next();
                Vector2 chunkPos = entry.getKey();

                // Calculate distance from player
                float distance = Vector2.dst(
                    chunkPos.x, chunkPos.y,
                    playerChunkX, playerChunkY
                );

                // Check if chunk should be unloaded
                boolean tooFar = distance > CHUNK_UNLOAD_RADIUS;
                boolean notRecentlyAccessed = !lastChunkAccess.containsKey(chunkPos) ||
                    System.currentTimeMillis() - lastChunkAccess.get(chunkPos) > CHUNK_SAVE_INTERVAL;
                boolean tooManyChunks = chunks.size() > MAX_CHUNKS_IN_MEMORY;

                if ((tooFar || notRecentlyAccessed) && tooManyChunks) {
                    // Save chunk before removing
                    saveChunkData(chunkPos, entry.getValue());
                    iterator.remove();
                    lastChunkAccess.remove(chunkPos);
                    GameLogger.info("Unloaded chunk at " + chunkPos);
                }
            }
        } catch (Exception e) {
            GameLogger.error("Error cleaning up chunks: " + e.getMessage());
        }
    }

    public PokemonSpawnManager getPokemonSpawnManager() {
        return pokemonSpawnManager;
    }

    public void render(SpriteBatch batch, Rectangle viewBounds, Player player) {
        if (chunks.isEmpty()) {
            GameLogger.error("No chunks available for rendering!");
            return;
        }
        Color originalColor = batch.getColor().cpy();

        // Set the blending function to the default before rendering
        batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        // Save the original color

        try {   // Set color BEFORE any rendering occurs
            if (currentWorldColor != null) {
                // Debug the color being applied
                batch.setColor(currentWorldColor);
            }
            Rectangle expandedBounds = getExpandedViewBounds(viewBounds);

            // Sort chunks by Y position for correct layering
            List<Map.Entry<Vector2, Chunk>> sortedChunks = getSortedChunks();

            sortedChunks.sort(Comparator.comparingDouble(entry -> entry.getKey().y));
            // === RENDER PASS 1: Ground and Terrain ===
            renderTerrainLayer(batch, sortedChunks, expandedBounds);

            if (blockManager != null) {
                blockManager.render(batch, worldData.getWorldTimeInMinutes());
            }

            // === RENDER PASS 2: Object Bases and Low Objects ===
            renderLowObjects(batch, expandedBounds);


            // === RENDER PASS 3: Characters and Mid-Layer Objects ===
            renderMidLayer(batch, player, expandedBounds);

            // === RENDER PASS 4: High Objects and Tree Tops ===

            // === RENDER PASS 5: Effects and Overlays ===
            //            weatherSystem.render(batch, gameScreen.getCamera());

            if (waterEffects != null && waterEffects.isInitialized()) {
                waterEffects.update(Gdx.graphics.getDeltaTime());
                waterEffects.render(batch, player);
            }
            if (weatherAudioSystem != null) {
                weatherAudioSystem.renderLightningEffect(batch, viewBounds.width, viewBounds.height);
            }

            if (currentWorldColor != null) {
                batch.setColor(currentWorldColor);
            }
            waterEffectManager.render(batch);
        } finally {      // IMPORTANT: Always restore the original color when done
            batch.setColor(originalColor);
        }
    }

    public void render(SpriteBatch batch, Rectangle viewBounds, Player player, GameScreen gameScreen) {
        if (chunks.isEmpty()) {
            GameLogger.error("No chunks available for rendering!");
            return;
        }

        Color originalColor = batch.getColor().cpy();
        batch.setBlendFunction(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);

        try {
            if (currentWorldColor != null) {
                batch.setColor(currentWorldColor);
            }
            Rectangle expandedBounds = getExpandedViewBounds(viewBounds);
            List<Map.Entry<Vector2, Chunk>> sortedChunks = getSortedChunks();

            sortedChunks.sort(Comparator.comparingDouble(entry -> entry.getKey().y));

            // Get the player's tile position
            int playerTileX = (int) (player.getX() / World.TILE_SIZE);
            int playerTileY = (int) (player.getY() / World.TILE_SIZE);

            // **Render Terrain (including full tall grass tiles)**
            renderTerrainLayer(batch, sortedChunks, expandedBounds);

            if (blockManager != null) {
                blockManager.render(batch, worldData.getWorldTimeInMinutes());
            }

            // **Render Objects Behind Player**
            renderLowObjects(batch, expandedBounds);

            // **Render Wild Pokémon Behind Player**
            renderWildPokemon(batch);

            // **Render Bottom Part of Tall Grass Over Player**
//            renderTallGrassOverPlayer(batch, playerTileX, playerTileY);

            // **Render Player and Mid-Layer Objects**
            renderMidLayer(batch, player, expandedBounds);

            // **Render Water Effects (e.g., puddle splashes)**
            if (waterEffects != null && waterEffects.isInitialized()) {
                waterEffects.update(Gdx.graphics.getDeltaTime());
                waterEffects.render(batch, player);
            }

            // **Render High Objects (Trees, etc.)**
            renderHighObjects(batch, expandedBounds);

            // **Render Weather Effects, Water Effects, etc.**
            if (weatherSystem != null && gameScreen != null) {
                weatherSystem.render(batch, gameScreen.getCamera());
            }

            if (weatherAudioSystem != null) {
                weatherAudioSystem.renderLightningEffect(batch, viewBounds.width, viewBounds.height);
            }

        } finally {
            batch.setColor(originalColor);
        }
    }


    public void updateLightLevels() {
        lightLevelMap.clear();

        // Only process lighting during night
        float hourOfDay = DayNightCycle.getHourOfDay(worldData.getWorldTimeInMinutes());
        DayNightCycle.TimePeriod timePeriod = DayNightCycle.getTimePeriod(hourOfDay);
        if (timePeriod != DayNightCycle.TimePeriod.NIGHT) {
            return;
        }

        // Iterate through all chunks to find furnaces
        for (Chunk chunk : chunks.values()) {
            for (PlaceableBlock block : chunk.getBlocks().values()) {
                if (block.getId().equalsIgnoreCase("furnace")) {
                    Vector2 blockPos = block.getPosition();
                    int lightRadius = 7;  // Adjust radius as needed
                    float maxLightLevel = 1.0f;

                    // Calculate light for surrounding tiles
                    for (int dx = -lightRadius; dx <= lightRadius; dx++) {
                        for (int dy = -lightRadius; dy <= lightRadius; dy++) {
                            Vector2 tilePos = new Vector2(blockPos.x + dx, blockPos.y + dy);
                            float distance = blockPos.dst(tilePos);

                            if (distance <= lightRadius) {
                                // Calculate light intensity based on distance
                                float lightLevel = maxLightLevel * (1 - (distance / lightRadius));

                                // Account for existing light level at this tile
                                lightLevelMap.merge(tilePos, lightLevel, Math::max);
                            }
                        }
                    }
                }
            }
        }
    }

    public void migrateBlocksToChunks() {
        if (worldData == null || worldData.getBlockData() == null) return;

        try {
            BlockSaveData blockData = worldData.getBlockData();
            Map<String, List<BlockSaveData.BlockData>> oldBlocks = blockData.getPlacedBlocks();

            for (Map.Entry<String, List<BlockSaveData.BlockData>> entry : oldBlocks.entrySet()) {
                for (BlockSaveData.BlockData blockDataItem : entry.getValue()) {
                    try {
                        // Get chunk for this block
                        int chunkX = Math.floorDiv(blockDataItem.x, CHUNK_SIZE);
                        int chunkY = Math.floorDiv(blockDataItem.y, CHUNK_SIZE);
                        Vector2 chunkPos = new Vector2(chunkX, chunkY);

                        // Get or create chunk
                        Chunk chunk = chunks.get(chunkPos);
                        if (chunk == null) continue;
                        PlaceableBlock.BlockType type = PlaceableBlock.BlockType.fromId(blockDataItem.type);
                        if (type == null) {
                            GameLogger.error("Failed to find block type: " + blockDataItem.type);
                            continue;
                        }
                        Vector2 pos = new Vector2(blockDataItem.x, blockDataItem.y);

                        // Create the PlaceableBlock instance without texture
                        PlaceableBlock block = new PlaceableBlock(type, pos, null, blockDataItem.isFlipped);

                        // Set isChestOpen for chests
                        if (type == PlaceableBlock.BlockType.CHEST) {
                            block.setChestOpen(blockDataItem.isChestOpen);
                        }

                        // Now get the texture using the new getBlockFrame method
                        TextureRegion texture = BlockTextureManager.getBlockFrame(block, 0);
                        if (texture != null) {
                            block.setTexture(texture);
                            chunk.addBlock(block);
                            chunk.setDirty(true);
                        }
                    } catch (Exception e) {
                        GameLogger.error("Failed to migrate block: " + e.getMessage());
                    }
                }
            }

            // Clear old block data
            worldData.setBlockData(null);

            // Save all modified chunks
            for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
                if (entry.getValue().isDirty()) {
                    saveChunkData(entry.getKey(), entry.getValue());
                }
            }

            GameLogger.info("Block migration complete");
        } catch (Exception e) {
            GameLogger.error("Block migration failed: " + e.getMessage());
        }
    }


    private List<Map.Entry<Vector2, Chunk>> getSortedChunks() {
        List<Map.Entry<Vector2, Chunk>> sortedChunks = new ArrayList<>(chunks.entrySet());
        sortedChunks.sort(Comparator.comparingDouble(entry -> entry.getKey().y));
        return sortedChunks;
    }

    private void renderTerrainLayer(SpriteBatch batch,
                                    List<Map.Entry<Vector2, Chunk>> sortedChunks,
                                    Rectangle expandedBounds) {
        for (Map.Entry<Vector2, Chunk> entry : sortedChunks) {
            Vector2 chunkPos = entry.getKey();
            if (isChunkVisible(chunkPos, expandedBounds)) {
                Chunk chunk = entry.getValue();
                getNeighboringBiomes(chunkPos);
                biomeRenderer.renderChunk(batch, chunk, this);
            }
        }
    }


    private Rectangle getExpandedViewBounds(Rectangle viewBounds) {
        float buffer = TILE_SIZE * 2;
        return new Rectangle(
            viewBounds.x - buffer,
            viewBounds.y - buffer,
            viewBounds.width + (buffer * 2),
            viewBounds.height + (buffer * 2)
        );
    }

    private void renderLowObjects(SpriteBatch batch, Rectangle expandedBounds) {
        for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
            Vector2 pos = entry.getKey();
            if (isChunkVisible(pos, expandedBounds)) {
                List<WorldObject> chunkObjects = objectManager.getObjectsForChunk(pos);
                for (WorldObject obj : chunkObjects) {
                    if (obj.getType().renderLayer == WorldObject.ObjectType.RenderLayer.BELOW_PLAYER) {
                        objectManager.renderObject(batch, obj, this);
                    }
                }
            }
        }
    }


    private void renderHighObjects(SpriteBatch batch, Rectangle expandedBounds) {
        List<WorldObject> treeTopsToRender = new ArrayList<>();
        for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
            if (isChunkVisible(entry.getKey(), expandedBounds)) {
                List<WorldObject> chunkObjects = objectManager.getObjectsForChunk(entry.getKey());
                for (WorldObject obj : chunkObjects) {
                    if (isTreeObject(obj)) {
                        treeTopsToRender.add(obj);
                    }
                }
            }
        }

        // Sort tree tops by Y position
        treeTopsToRender.sort(Comparator.comparingDouble(WorldObject::getPixelY));

        // Render tree tops
        for (WorldObject tree : treeTopsToRender) {
            objectManager.renderTreeTop(batch, tree, this);
        }
    }

    private boolean isTreeObject(WorldObject obj) {
        return obj.getType() == WorldObject.ObjectType.TREE_0 ||
            obj.getType() == WorldObject.ObjectType.TREE_1 ||
            obj.getType() == WorldObject.ObjectType.SNOW_TREE ||
            obj.getType() == WorldObject.ObjectType.HAUNTED_TREE ||
            obj.getType() == WorldObject.ObjectType.RAIN_TREE || obj.getType() == WorldObject.ObjectType.RUINS_TREE || obj.getType() == WorldObject.ObjectType.APRICORN_TREE;
    }

    private void renderMidLayer(SpriteBatch batch, Player player, Rectangle expandedBounds) {
        List<ObjectWithYPosition> behindPlayerQueue = new ArrayList<>();
        List<ObjectWithYPosition> frontPlayerQueue = new ArrayList<>();

        Color originalColor = batch.getColor().cpy();
        // First pass: Separate objects into behind and front queues
        for (Map.Entry<Vector2, Chunk> entry : chunks.entrySet()) {
            if (isChunkVisible(entry.getKey(), expandedBounds)) {
                List<WorldObject> chunkObjects = objectManager.getObjectsForChunk(entry.getKey());
                for (WorldObject obj : chunkObjects) {
                    if (isTreeObject(obj)) {
                        // Tree bases always go behind player
                        behindPlayerQueue.add(new ObjectWithYPosition(obj.getPixelY(), obj, RenderType.TREE_BASE));
                        // Tree tops always go in front
                        frontPlayerQueue.add(new ObjectWithYPosition(
                            obj.getPixelY() + World.TILE_SIZE * 2,
                            obj,
                            RenderType.TREE_TOP
                        ));
                    } else if (obj.getType().renderLayer == WorldObject.ObjectType.RenderLayer.BELOW_PLAYER) {
                        behindPlayerQueue.add(new ObjectWithYPosition(obj.getPixelY(), obj, RenderType.REGULAR_OBJECT));
                    }
                }
            }
        }

        // Sort both queues by Y position
        behindPlayerQueue.sort(Comparator.comparingDouble(a -> a.y));
        frontPlayerQueue.sort(Comparator.comparingDouble(a -> a.y));

        // Render in three phases:
        // 1. Everything behind the player
        for (ObjectWithYPosition item : behindPlayerQueue) {
            switch (item.renderType) {
                case TREE_BASE:
                    objectManager.renderTreeBase(batch, (WorldObject) item.object, this);
                    break;
                case REGULAR_OBJECT:
                    objectManager.renderObject(batch, (WorldObject) item.object, this);
                    break;
            }
        }

        // 2. Render the player
        player.render(batch);
        batch.setColor(originalColor);

        // 3. Everything in front of the player
        for (ObjectWithYPosition item : frontPlayerQueue) {
            if (item.renderType == RenderType.TREE_TOP) {
                objectManager.renderTreeTop(batch, (WorldObject) item.object, this);
            }
        }
        batch.setColor(originalColor);
    }

    private Map<BiomeRenderer.Direction, Biome> getNeighboringBiomes(Vector2 chunkPos) {
        Map<BiomeRenderer.Direction, Biome> neighbors = new EnumMap<>(BiomeRenderer.Direction.class);

        for (BiomeRenderer.Direction dir : BiomeRenderer.Direction.values()) {
            Vector2 neighborPos = new Vector2(
                chunkPos.x + (dir == BiomeRenderer.Direction.EAST ? 1 : dir == BiomeRenderer.Direction.WEST ? -1 : 0),
                chunkPos.y + (dir == BiomeRenderer.Direction.NORTH ? 1 : dir == BiomeRenderer.Direction.SOUTH ? -1 : 0)
            );

            Chunk neighborChunk = chunks.get(neighborPos);
            if (neighborChunk != null) {
                neighbors.put(dir, neighborChunk.getBiome());
            }
        }

        return neighbors;
    }

    public boolean isTallGrassTile(int tileType) {
        return tileType == TileType.TALL_GRASS ||
            tileType == TileType.TALL_GRASS_2 ||
            tileType == TileType.TALL_GRASS_3 ||
            tileType == TileType.FOREST_TALL_GRASS ||
            tileType == TileType.RAIN_FOREST_TALL_GRASS ||
            tileType == TileType.HAUNTED_TALL_GRASS ||
            tileType == TileType.SNOW_TALL_GRASS ||
            tileType == TileType.RUINS_TALL_GRASS;
    }

    private boolean isChunkVisible(Vector2 chunkPos, Rectangle viewBounds) {
        float chunkWorldX = chunkPos.x * CHUNK_SIZE * TILE_SIZE;
        float chunkWorldY = chunkPos.y * CHUNK_SIZE * TILE_SIZE;
        float chunkSize = CHUNK_SIZE * TILE_SIZE;

        Rectangle chunkRect = new Rectangle(chunkWorldX, chunkWorldY, chunkSize, chunkSize);

        return viewBounds.overlaps(chunkRect);
    }

    public WorldObject.WorldObjectManager getObjectManager() {
        return objectManager;
    }

    public boolean isPokemonAt(int tileX, int tileY) {
        float pixelX = tileX * TILE_SIZE;
        float pixelY = tileY * TILE_SIZE;

        // Create a collision box for the tile
        Rectangle tileBox = new Rectangle(
            pixelX,
            pixelY,
            TILE_SIZE,
            TILE_SIZE
        );
        Collection<WildPokemon> nearbyPokemon = pokemonSpawnManager.getPokemonInRange(
            pixelX + ((float) TILE_SIZE / 2),
            pixelY + ((float) TILE_SIZE / 2),
            TILE_SIZE * 2
        );

        for (WildPokemon pokemon : nearbyPokemon) {
            if (pokemon.getBoundingBox().overlaps(tileBox)) {
                return true;
            }
        }
        return false;
    }

    public void loadChunksAroundPositionSynchronously(Vector2 position, int radius) {
        int chunkX = (int) Math.floor(position.x / CHUNK_SIZE);
        int chunkY = (int) Math.floor(position.y / CHUNK_SIZE);

        GameLogger.info("Loading chunks around position " + position + " with radius " + radius);

        for (int dx = -radius; dx <= radius; dx++) {
            for (int dy = -radius; dy <= radius; dy++) {
                Vector2 chunkPos = new Vector2(chunkX + dx, chunkY + dy);
                if (!chunks.containsKey(chunkPos)) {
                    try {
                        // Load chunk synchronously
                        Chunk chunk = loadOrGenerateChunk(chunkPos);
                        if (chunk != null) {
                            chunks.put(chunkPos, chunk);
                            GameLogger.info("Loaded chunk at " + chunkPos);
                        } else {
                            GameLogger.error("Failed to load/generate chunk at " + chunkPos);
                        }
                    } catch (Exception e) {
                        GameLogger.error("Error loading chunk at " + chunkPos + ": " + e.getMessage());
                    }
                }
            }
        }

        // Verify all chunks were loaded
        int totalChunks = (radius * 2 + 1) * (radius * 2 + 1);
        int loadedChunks = 0;

        for (int dx = -radius; dx <= radius; dx++) {
            for (int dy = -radius; dy <= radius; dy++) {
                if (chunks.containsKey(new Vector2(chunkX + dx, chunkY + dy))) {
                    loadedChunks++;
                }
            }
        }

        GameLogger.info("Loaded " + loadedChunks + "/" + totalChunks + " chunks");
    }

    public boolean isPassable(int worldX, int worldY) {
        if (!isPositionLoaded(worldX, worldY)) {
            return false;
        }

        try {
            // Convert pixel coordinates to chunk coordinates
            int chunkX = Math.floorDiv(worldX, Chunk.CHUNK_SIZE);
            int chunkY = Math.floorDiv(worldY, Chunk.CHUNK_SIZE);
            Vector2 chunkPos = new Vector2(chunkX, chunkY);

            Chunk chunk = chunks.get(chunkPos);
            if (chunk == null) return false;

            int localX = Math.floorMod(worldX, Chunk.CHUNK_SIZE);
            int localY = Math.floorMod(worldY, Chunk.CHUNK_SIZE);

            String currentDirection = GameContext.get().getPlayer() != null ? GameContext.get().getPlayer().getDirection() : "down";

            // Basic tile passability
            if (!chunk.isPassable(localX, localY)) {
                handleCollision(currentDirection);
                return false;
            }
            // Check block collision
            if (blockManager != null && blockManager.hasCollisionAt(worldX, worldY)) {
                return false;
            }

            // Calculate pixel-based collision box
            Rectangle movementBounds = new Rectangle(
                worldX * TILE_SIZE,  // Now using actual pixel position
                worldY * TILE_SIZE,
                TILE_SIZE * 0.5f,    // Half tile collision size
                TILE_SIZE * 0.5f
            );

            // Check collisions with objects and Pokemon
            return !checkObjectCollision(movementBounds, currentDirection) &&
                !checkPokemonCollision(worldX, worldY, currentDirection);

        } catch (Exception e) {
            GameLogger.error("Error checking passability: " + e.getMessage());
            return false;
        }
    }

    public GameClient getGameClient() {
        if (GameContext.get().getGameClient() == null) {
            throw new IllegalStateException("GameClient is null - World not properly initialized");
        }
        return GameContext.get().getGameClient();
    }

    private boolean isPositionLoaded(int worldX, int worldY) {
        int chunkX = Math.floorDiv(worldX, Chunk.CHUNK_SIZE);
        int chunkY = Math.floorDiv(worldY, Chunk.CHUNK_SIZE);
        return chunks.containsKey(new Vector2(chunkX, chunkY));
    }

    private void handleCollision(String direction) {
        if (GameContext.get().getPlayer() != null) {
            switch (direction) {
                case "up":
                    GameContext.get().getPlayer().setDirection("up");
                    break;
                case "down":
                    GameContext.get().getPlayer().setDirection("down");
                    break;
                case "left":
                    GameContext.get().getPlayer().setDirection("left");
                    break;
                case "right":
                    GameContext.get().getPlayer().setDirection("right");
                    break;
            }
            GameContext.get().getPlayer().setMoving(false);
        }
    }

    private boolean checkObjectCollision(Rectangle movementBounds, String direction) {
        List<WorldObject> nearbyObjects = objectManager.getObjectsNearPosition(
            movementBounds.x + movementBounds.width / 2,
            movementBounds.y + movementBounds.height / 2
        );

        for (WorldObject obj : nearbyObjects) {
            Rectangle collisionBox = obj.getCollisionBox();
            if (collisionBox != null && collisionBox.overlaps(movementBounds)) {
                if (GameContext.get().getPlayer() != null) {
                    GameContext.get().getPlayer().setDirection(direction);
                    GameContext.get().getPlayer().setMoving(false);
                }
                return true;
            }
        }
        return false;
    }

    private boolean checkPokemonCollision(int worldX, int worldY, String direction) {
        if (isPokemonAt(worldX, worldY)) {
            if (GameContext.get().getPlayer() != null) {
                // Set player direction and stop moving
                GameContext.get().getPlayer().setDirection(direction);
                GameContext.get().getPlayer().setMoving(false);
            }
            return true;
        }
        return false;
    }

    private void checkPlayerInteractions(Vector2 playerPosition) {
        // Convert player position from tile coordinates to pixel coordinates
        float playerPixelX = playerPosition.x * TILE_SIZE;
        float playerPixelY = playerPosition.y * TILE_SIZE;

        nearestPokeball = null;
        float closestDistance = Float.MAX_VALUE;

        // Check in current chunk and adjacent chunks
        int chunkX = (int) Math.floor(playerPixelX / (Chunk.CHUNK_SIZE * TILE_SIZE));
        int chunkY = (int) Math.floor(playerPixelY / (Chunk.CHUNK_SIZE * TILE_SIZE));

        // Check current and surrounding chunks
        for (int dx = -1; dx <= 1; dx++) {
            for (int dy = -1; dy <= 1; dy++) {
                Vector2 chunkPos = new Vector2(chunkX + dx, chunkY + dy);
                List<WorldObject> objects = objectManager.getObjectsForChunk(chunkPos);

                if (objects != null) {
                    for (WorldObject obj : objects) {
                        if (obj.getType() == WorldObject.ObjectType.POKEBALL) {
                            // Calculate distance using pixel coordinates
                            float dx2 = playerPixelX - obj.getPixelX();
                            float dy2 = playerPixelY - obj.getPixelY();
                            float distance = (float) Math.sqrt(dx2 * dx2 + dy2 * dy2);
                            if (distance <= INTERACTION_RANGE && distance < closestDistance) {
                                closestDistance = distance;
                                nearestPokeball = obj;
                            }
                        }
                    }
                }
            }
        }
    }

    public void initializeFromServer(long seed, double worldTimeInMinutes, float dayLength) {
        try {
            GameLogger.info("Initializing world from server with seed: " + seed);

            // Create new WorldData if it doesn't exist
            if (worldData == null) {
                worldData = new WorldData(name);
                GameLogger.info("Created new WorldData instance");
            }

            // Set config and time values first
            WorldData.WorldConfig config = new WorldData.WorldConfig(seed);
            worldData.setConfig(config);
            worldData.setWorldTimeInMinutes(worldTimeInMinutes);
            worldData.setDayLength(dayLength);

            // Initialize other world components
            this.worldSeed = seed;
            this.biomeManager = new BiomeManager(seed);
            if (blockManager == null) {
                blockManager = new BlockManager(this);
            }


            // Initialize managers
            if (objectManager == null) {
                objectManager = new WorldObject.WorldObjectManager(worldSeed, GameContext.get().getGameClient());
            }

            if (pokemonSpawnManager == null) {
                pokemonSpawnManager = new PokemonSpawnManager(TextureManager.pokemonoverworld);
            }

            GameLogger.info("World initialization complete - " +
                "Time: " + worldTimeInMinutes +
                " Day Length: " + dayLength +
                " Seed: " + seed);

        } catch (Exception e) {
            GameLogger.error("Failed to initialize world from server: " + e.getMessage());
            throw new RuntimeException("World initialization failed", e);
        }
    }

    private void renderWildPokemon(SpriteBatch batch) {
        Collection<WildPokemon> allPokemon = pokemonSpawnManager.getAllWildPokemon();

        List<WildPokemon> sortedPokemon = new ArrayList<>(allPokemon);
        sortedPokemon.sort((p1, p2) -> Float.compare(p2.getY(), p1.getY()));

        for (WildPokemon pokemon : sortedPokemon) {
            if (pokemon == null || pokemon.getAnimations() == null) {
                continue;
            }


            pokemon.render(batch);
        }
    }

    public void removeWorldObject(WorldObject obj) {
        int chunkX = (int) Math.floor(obj.getPixelX() / (Chunk.CHUNK_SIZE * TILE_SIZE));
        int chunkY = (int) Math.floor(obj.getPixelY() / (Chunk.CHUNK_SIZE * TILE_SIZE));
        Vector2 chunkPos = new Vector2(chunkX, chunkY);

        List<WorldObject> objects = objectManager.getObjectsForChunk(chunkPos);
        if (objects != null) {
            objects.remove(obj);
        }
    }

    private void updateWeather(float delta, Vector2 playerPosition, GameScreen gameScreen) {
        // Calculate world position in pixels
        float worldX = playerPosition.x * TILE_SIZE;
        float worldY = playerPosition.y * TILE_SIZE;

        // Get current biome and calculate temperature
        currentBiomeTransition = biomeManager.getBiomeAt(worldX, worldY);
        temperature = calculateTemperature();

        // Debug weather state
        if (Math.random() < 0.01) {
        }

        // Update weather systems
        float timeOfDay = (float) (worldData.getWorldTimeInMinutes() % (24 * 60)) / 60f;
        weatherSystem.update(delta, currentBiomeTransition, temperature, timeOfDay, gameScreen);
        weatherAudioSystem.update(delta, weatherSystem.getCurrentWeather(), weatherSystem.getIntensity());
    }

    private float calculateTemperature() {
        BiomeType biomeType = currentBiomeTransition.getPrimaryBiome().getType();
        float baseTemp;

        switch (biomeType) {
            case SNOW:
                baseTemp = 0.0f;
                break;
            case DESERT:
                baseTemp = 35.0f;
                break;
            case HAUNTED:
                baseTemp = 15.0f;
                break;
            case RAIN_FOREST:
                baseTemp = 28.0f;
                break;
            case FOREST:
                baseTemp = 22.0f;
                break;
            default:
                baseTemp = 20.0f;
        }

        float timeOfDay = (float) (worldData.getWorldTimeInMinutes() % (24 * 60)) / 60f;
        float timeVariation = (float) Math.sin((timeOfDay - 6) * Math.PI / 12) * 5.0f;

        return baseTemp + timeVariation;
    }

    public boolean isInitialized() {
        return initialized;
    }

    public Chunk getChunkAtPosition(float x, float y) {
        int chunkX = Math.floorDiv((int) x, Chunk.CHUNK_SIZE);
        int chunkY = Math.floorDiv((int) y, Chunk.CHUNK_SIZE);
        return chunks.get(new Vector2(chunkX, chunkY));
    }

    public WorldObject getNearestPokeball() {
        return nearestPokeball;
    }

    private enum RenderType {
        TREE_BASE,
        TREE_TOP,
        REGULAR_OBJECT,
        PLAYER
    }

    private static class ObjectWithYPosition {
        public float y;
        public Object object;
        public RenderType renderType;

        public ObjectWithYPosition(float y, Object object, RenderType renderType) {
            this.y = y;
            this.object = object;
            this.renderType = renderType;
        }
    }

    public static class ChunkData {
        public int x;
        public int y;
        public BiomeType biomeType;
        public int[][] tileData;
        public List<WorldObjectData> objects;
        public List<BlockSaveData.BlockData> blocks;
        public long lastModified;
        public boolean isMultiplayer;


        public ChunkData() {
            this.tileData = new int[Chunk.CHUNK_SIZE][Chunk.CHUNK_SIZE];
            this.objects = new ArrayList<>();
            this.blocks = new ArrayList<>();
        }

        public void write(Json json) {
            json.writeObjectStart();
            json.writeValue("x", x);
            json.writeValue("y", y);
            json.writeValue("biomeType", biomeType.name());
            json.writeValue("tileData", tileData);
            json.writeValue("objects", objects);
            json.writeValue("blocks", blocks, ArrayList.class, BlockSaveData.BlockData.class);
            json.writeValue("lastModified", lastModified);
            json.writeValue("isMultiplayer", isMultiplayer);
            json.writeObjectEnd();
        }

        public void read(JsonValue jsonData, Json json) {
            x = jsonData.getInt("x");
            y = jsonData.getInt("y");
            biomeType = BiomeType.valueOf(jsonData.getString("biomeType"));
            tileData = json.readValue(int[][].class, jsonData.get("tileData"));
            objects = json.readValue(ArrayList.class, WorldObjectData.class, jsonData.get("objects"));

            JsonValue blocksValue = jsonData.get("blocks");
            if (blocksValue != null && blocksValue.isArray()) {
                blocks = json.readValue(ArrayList.class, BlockSaveData.BlockData.class, blocksValue);
            } else {
                blocks = new ArrayList<>();
            }

            lastModified = jsonData.getLong("lastModified", System.currentTimeMillis());
            isMultiplayer = jsonData.getBoolean("isMultiplayer", false);
        }
    }

    public static class WorldObjectData {
        public float x;
        public float y;
        public WorldObject.ObjectType type;

        public WorldObjectData() {
        }

        public WorldObjectData(WorldObject obj) {
            this.x = obj.getPixelX();
            this.y = obj.getPixelY();
            this.type = obj.getType();
        }
    }

}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/WorldObject.java
================
package io.github.pokemeetup.system.gameplay.overworld;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.multiplayer.client.GameClient;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;

import static com.badlogic.gdx.math.MathUtils.random;

public class WorldObject {
    private static final float POKEBALL_DESPAWN_TIME = 300f;
    private static final Map<ObjectType, TextureRegion> textureCache = new HashMap<>();

    static {
        initializeTextures();
    }

    public ObjectType type;
    private WorldObject attachedTo;
    private float pixelX;
    private float pixelY;
    private TextureRegion texture;
    private String id;
    private boolean isCollidable;
    private float spawnTime;
    private int tileX, tileY;

    public WorldObject(int tileX, int tileY, TextureRegion texture, ObjectType type) {
        this.id = UUID.randomUUID().toString();
        this.tileX = tileX;
        this.tileY = tileY;
        this.pixelX = tileX * World.TILE_SIZE;
        this.pixelY = tileY * World.TILE_SIZE;
        this.texture = texture;
        this.attachedTo = null;
        this.type = type;
        this.isCollidable = type.isCollidable;
        this.spawnTime = type.isPermanent ? 0 : System.currentTimeMillis() / 1000f;
    }

    public WorldObject() {
        this.id = UUID.randomUUID().toString();
        this.isCollidable = false;
        this.spawnTime = 0f;
        this.attachedTo = null;
    }

    private static void initializeTextures() {
        try {
            // Initialize texture cache if not already done
            if (textureCache.isEmpty()) {
                TextureAtlas atlas = TextureManager.tiles;
                if (atlas != null) {
                    textureCache.put(ObjectType.TREE_0, atlas.findRegion("tree_0"));
                    textureCache.put(ObjectType.TREE_1, atlas.findRegion("tree_1"));
                    textureCache.put(ObjectType.SNOW_TREE, atlas.findRegion("snow_tree"));
                    textureCache.put(ObjectType.HAUNTED_TREE, atlas.findRegion("haunted_tree"));
                    textureCache.put(ObjectType.POKEBALL, atlas.findRegion("pokeball"));
                    textureCache.put(ObjectType.CACTUS, atlas.findRegion("desert_cactus"));
                    textureCache.put(ObjectType.BUSH, atlas.findRegion("bush"));
                    textureCache.put(ObjectType.VINES, atlas.findRegion("vines"));
                    textureCache.put(ObjectType.DEAD_TREE, atlas.findRegion("dead_tree"));
                    textureCache.put(ObjectType.SMALL_HAUNTED_TREE, atlas.findRegion("small_haunted_tree"));
                    textureCache.put(ObjectType.RUIN_POLE, atlas.findRegion("ruins_pole"));
                    textureCache.put(ObjectType.RUINS_TREE, atlas.findRegion("ruins_tree"));
                    textureCache.put(ObjectType.APRICORN_TREE, atlas.findRegion("apricorn_tree_grown"));
                    // Add other object types as needed
                }
            }
        } catch (Exception e) {
            GameLogger.error("Failed to initialize textures: " + e.getMessage());
        }
    }

// In WorldObject class, update the updateFromData method with proper null checks and defaults:

    public void updateFromData(Map<String, Object> data) {
        if (data == null) return;

        try {
            // Handle required fields with proper null checks and defaults
            Object tileXObj = data.get("tileX");
            Object tileYObj = data.get("tileY");
            if (tileXObj instanceof Number && tileYObj instanceof Number) {
                this.tileX = ((Number) tileXObj).intValue();
                this.tileY = ((Number) tileYObj).intValue();
                this.pixelX = tileX * World.TILE_SIZE;
                this.pixelY = tileY * World.TILE_SIZE;
            }

            // Handle optional spawnTime with default
            Object spawnTimeObj = data.get("spawnTime");
            this.spawnTime = spawnTimeObj instanceof Number ?
                ((Number) spawnTimeObj).floatValue() :
                (type != null && type.isPermanent ? 0 : System.currentTimeMillis() / 1000f);

            // Handle optional isCollidable with default based on type
            Object collidableObj = data.get("isCollidable");
            this.isCollidable = collidableObj instanceof Boolean ?
                (Boolean) collidableObj :
                (type != null && type.isCollidable);

            // Handle type with validation
            String typeStr = (String) data.get("type");
            if (typeStr != null) {
                try {
                    this.type = ObjectType.valueOf(typeStr);
                } catch (IllegalArgumentException e) {
                    GameLogger.error("Invalid object type: " + typeStr);
                }
            }

            // Handle optional ID with UUID generation if missing
            String idStr = (String) data.get("id");
            this.id = idStr != null ? idStr : UUID.randomUUID().toString();

            ensureTexture();
        } catch (Exception e) {
            GameLogger.error("Error updating WorldObject from data: " + e.getMessage() +
                "\nData: " + data.toString());
        }
    }

    // In getSerializableData, ensure we're sending all required fields:
    public Map<String, Object> getSerializableData() {
        Map<String, Object> data = new HashMap<>();
        data.put("tileX", tileX);
        data.put("tileY", tileY);
        data.put("type", type != null ? type.name() : null);
        data.put("spawnTime", spawnTime);
        data.put("isCollidable", isCollidable);
        data.put("id", id);
        return data;
    }

    public WorldObject copy() {
        // Create a new object with the same tile position and type
        WorldObject copy = new WorldObject(this.tileX, this.tileY, this.texture, this.type);

        // Copy all basic fields
        copy.id = this.id;  // Keep same ID for tracking
        copy.pixelX = this.pixelX;
        copy.pixelY = this.pixelY;
        copy.isCollidable = this.isCollidable;
        copy.spawnTime = this.spawnTime;

        // The texture is shared and doesn't need deep copying
        copy.texture = this.texture;

        // If there's an attached object, copy that too
        if (this.attachedTo != null) {
            copy.attachedTo = this.attachedTo.copy();
        }

        return copy;
    }

    public TextureRegion getTexture() {
        ensureTexture();
        return texture;
    }

    public void setTexture(TextureRegion texture) {
        this.texture = texture;
    }

    private void ensureTexture() {
        if (texture == null && type != null) {
            texture = textureCache.get(type);
            if (texture == null) {

                texture = textureCache.get(ObjectType.TREE_0);
            }
        }
    }

    public boolean isStatic() {
        return type == ObjectType.TREE_0 ||
            type == ObjectType.TREE_1 ||
            type == ObjectType.BUSH || type == ObjectType.APRICORN_TREE ||
            type == ObjectType.DEAD_TREE || type == ObjectType.RAIN_TREE
            || type == ObjectType.RUINS_TREE || type == ObjectType.RUIN_POLE || type == ObjectType.SNOW_TREE || type == ObjectType.HAUNTED_TREE ||
            type == ObjectType.CACTUS;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }


    public void updateFromNetwork(NetworkProtocol.WorldObjectUpdate update) {
        this.tileX = (int) update.data.get("tileX");
        this.tileY = (int) update.data.get("tileY");
        this.pixelX = tileX * World.TILE_SIZE;
        this.pixelY = tileY * World.TILE_SIZE;
        this.spawnTime = (float) update.data.get("spawnTime");
        this.isCollidable = (boolean) update.data.get("isCollidable");
    }

    public ObjectType getType() {
        return type;
    }

    public void setType(ObjectType type) {
        this.type = type;
    }

    public boolean isExpired() {
        if (type.isPermanent) return false;
        float currentTime = System.currentTimeMillis() / 1000f;
        return currentTime - spawnTime > POKEBALL_DESPAWN_TIME;
    }

    public Rectangle getBoundingBox() {
        if (type == ObjectType.APRICORN_TREE) {
            float treeBaseX = pixelX - World.TILE_SIZE;  // Center the 3-tile width
            float treeBaseY = pixelY;  // Bottom of tree

            return new Rectangle(
                treeBaseX,
                treeBaseY,
                World.TILE_SIZE * 3,  // 3 tiles wide
                World.TILE_SIZE * 3   // 3 tiles high
            );
        }
      if (type == ObjectType.TREE_0 ||type==ObjectType.RUINS_TREE|| type == ObjectType.TREE_1 || type == ObjectType.SNOW_TREE || type == ObjectType.HAUNTED_TREE || type == ObjectType.RAIN_TREE) {
            // Tree collision box: 2x2 tiles at the base only
            float treeBaseX = pixelX - World.TILE_SIZE; // Center the 2-tile width base
            float treeBaseY = pixelY; // Bottom of tree

            return new Rectangle(
                treeBaseX,
                treeBaseY,
                World.TILE_SIZE * 2, // 2 tiles wide
                World.TILE_SIZE * 2  // 2 tiles high (base only)
            );
        } else {
            return new Rectangle(
                pixelX,
                pixelY,
                type.widthInTiles * World.TILE_SIZE,
                type.heightInTiles * World.TILE_SIZE
            );
        }
    }

    public float getPixelX() {
        return pixelX;
    }

    public float getPixelY() {
        return pixelY;
    }

    public int getTileX() {
        return tileX;
    }

    public void setTileX(int tileX) {
        this.tileX = tileX;
    }

    public int getTileY() {
        return tileY;
    }

    public void setTileY(int tileY) {
        this.tileY = tileY;
    }

    public Rectangle getCollisionBox() {
        if (!type.isCollidable) {
            return null;
        }

        if (type == ObjectType.APRICORN_TREE) {
            return new Rectangle(
                pixelX,               // start at center column
                pixelY,               // bottom of the tree
                World.TILE_SIZE,      // 32px wide, one tile
                World.TILE_SIZE * 2   // 64px tall, two tiles high
            );
        } else if (type == ObjectType.RUINS_TREE) {
            // 2x2 collision as before
            float treeBaseX = pixelX;
            float treeBaseY = pixelY;
            return new Rectangle(treeBaseX, treeBaseY, World.TILE_SIZE * 2, World.TILE_SIZE * 2);
        } else if (isTreeType(type)) {
            // Regular trees (2x2 base collision)
            float treeBaseX = pixelX - World.TILE_SIZE;
            float treeBaseY = pixelY;
            return new Rectangle(treeBaseX, treeBaseY, World.TILE_SIZE * 2, World.TILE_SIZE * 2);
        }

        // Standard objects
        return new Rectangle(
            pixelX,
            pixelY,
            type.widthInTiles * World.TILE_SIZE,
            type.heightInTiles * World.TILE_SIZE
        );
    }

    private boolean isTreeType(ObjectType type) {
        return type == ObjectType.TREE_0 ||
            type == ObjectType.TREE_1 ||
            type == ObjectType.SNOW_TREE ||
            type == ObjectType.HAUNTED_TREE ||
            type == ObjectType.RUINS_TREE ||
            type == ObjectType.APRICORN_TREE ||
            type == ObjectType.RAIN_TREE;
    }

    // Add this to your WorldObject class
    public enum ObjectType {
        // Static objects
        TREE_0(true, true, 2, 3, RenderLayer.LAYERED),
        TREE_1(true, true, 2, 3, RenderLayer.LAYERED),
        SNOW_TREE(true, true, 2, 3, RenderLayer.LAYERED),
        HAUNTED_TREE(true, true, 2, 3, RenderLayer.LAYERED),
        RUINS_TREE(true, true, 2, 3, RenderLayer.LAYERED),
        APRICORN_TREE(true, true, 3, 3, RenderLayer.LAYERED),

        // Environmental objects
        CACTUS(true, true, 1, 2, RenderLayer.BELOW_PLAYER),
        DEAD_TREE(true, true, 1, 2, RenderLayer.BELOW_PLAYER),
        SMALL_HAUNTED_TREE(true, true, 1, 2, RenderLayer.BELOW_PLAYER),
        BUSH(true, true, 3,
            2, RenderLayer.BELOW_PLAYER),
        VINES(true, false, 1, 2, RenderLayer.BELOW_PLAYER),
        RUIN_POLE(true, true, 1, 3, RenderLayer.BELOW_PLAYER),
        POKEBALL(true, true, 1, 1, RenderLayer.BELOW_PLAYER),
        RAIN_TREE(true, true, 2, 3, RenderLayer.LAYERED),
        CHERRY_TREE(true, true, 2, 3, RenderLayer.LAYERED),
        SUNFLOWER(true, false, 1, 2, RenderLayer.BELOW_PLAYER);   // No collision

        public final boolean isPermanent;    // Permanent or temporary object
        public final boolean isCollidable;   // Has collision or not
        public final int widthInTiles;       // Width in tiles
        public final int heightInTiles;      // Height in tiles

        public final RenderLayer renderLayer;

        ObjectType(boolean isPermanent, boolean isCollidable,
                   int widthInTiles, int heightInTiles, RenderLayer renderLayer) {
            this.isPermanent = isPermanent;
            this.isCollidable = isCollidable;
            this.widthInTiles = widthInTiles;
            this.heightInTiles = heightInTiles;
            this.renderLayer = renderLayer;
        }

        public enum RenderLayer {
            BELOW_PLAYER,
            ABOVE_PLAYER,
            LAYERED,
            ABOVE_TALL_GRASS
        }
    }

    public static class WorldObjectManager {
        public static final float POKEBALL_SPAWN_CHANCE = 0.025f;
        public static final int MAX_POKEBALLS_PER_CHUNK = 1;
        private final GameClient gameClient;
        private final Map<Vector2, List<WorldObject>> objectsByChunk = new ConcurrentHashMap<>();
        private final Map<WorldObject.ObjectType, TextureRegion> objectTextures;
        private final long worldSeed;
        private final ConcurrentLinkedQueue<WorldObjectOperation> operationQueue = new ConcurrentLinkedQueue<>();

        public WorldObjectManager(long seed, GameClient gameClient) {
            this.worldSeed = seed;
            this.gameClient = gameClient;
            TextureAtlas atlas = TextureManager.tiles;
            this.objectTextures = new HashMap<>();
            objectTextures.put(ObjectType.TREE_0, atlas.findRegion("treeONE"));
            objectTextures.put(ObjectType.TREE_1, atlas.findRegion("treeTWO"));
            objectTextures.put(ObjectType.SNOW_TREE, atlas.findRegion("snow_tree"));
            objectTextures.put(ObjectType.HAUNTED_TREE, atlas.findRegion("haunted_tree"));
            objectTextures.put(ObjectType.POKEBALL, atlas.findRegion("pokeball"));
            objectTextures.put(ObjectType.CACTUS, atlas.findRegion("desert_cactus"));
            objectTextures.put(ObjectType.BUSH, atlas.findRegion("bush"));
            objectTextures.put(ObjectType.SUNFLOWER, atlas.findRegion("sunflower"));
            objectTextures.put(ObjectType.VINES, atlas.findRegion("vines"));
            objectTextures.put(ObjectType.DEAD_TREE, atlas.findRegion("dead_tree"));
            objectTextures.put(ObjectType.SMALL_HAUNTED_TREE, atlas.findRegion("small_haunted_tree"));
            objectTextures.put(ObjectType.RAIN_TREE, atlas.findRegion("rain_tree"));
            objectTextures.put(ObjectType.CHERRY_TREE, atlas.findRegion("CherryTree"));
            objectTextures.put(ObjectType.RUIN_POLE, atlas.findRegion("ruins_pole"));
            objectTextures.put(ObjectType.RUINS_TREE, atlas.findRegion("ruins_tree"));
            objectTextures.put(ObjectType.APRICORN_TREE, atlas.findRegion("apricorn_tree_grown"));

        }


        public void setObjectsForChunk(Vector2 chunkPos, List<WorldObject> objects) {
            try {
                if (objects == null) {
                    objectsByChunk.remove(chunkPos);
                    return;
                }

                // Create a defensive copy of the list
                List<WorldObject> safeObjects = new CopyOnWriteArrayList<>();
                for (WorldObject obj : objects) {
                    if (obj != null) {
                        // Ensure each object has an ID
                        if (obj.getId() == null || obj.getId().isEmpty()) {
                            obj.setId(UUID.randomUUID().toString());
                        }
                        safeObjects.add(obj);
                    }
                }

                // Update the chunk's objects
                objectsByChunk.put(chunkPos, safeObjects);

                // Sync to server if in multiplayer
                if (gameClient != null && !gameClient.isSinglePlayer()) {
                    sendChunkObjectSync(safeObjects);
                }

            } catch (Exception e) {
                GameLogger.error("Error setting chunk objects: " + e.getMessage());
            }
        }

        private void sendChunkObjectSync(List<WorldObject> objects) {
            try {
                for (WorldObject obj : objects) {
                    NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
                    update.objectId = obj.getId();
                    update.type = NetworkProtocol.NetworkObjectUpdateType.ADD;
                    update.data = obj.getSerializableData();

                    gameClient.getClient().sendTCP(update);
                }
            } catch (Exception e) {
                GameLogger.error("Failed to send chunk object sync: " + e.getMessage());
            }
        }

        public void removeObjectFromChunk(Vector2 chunkPos, String objectId) {
            try {
                List<WorldObject> objects = objectsByChunk.get(chunkPos);
                if (objects != null) {
                    boolean removed = objects.removeIf(obj -> obj.getId().equals(objectId));

                    if (removed) {
                        // Ensure we're using CopyOnWriteArrayList for thread safety
                        objectsByChunk.put(chunkPos, new CopyOnWriteArrayList<>(objects));

                        // Notify server in multiplayer
                        if (gameClient != null && !gameClient.isSinglePlayer()) {
                            NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
                            update.objectId = objectId;
                            update.type = NetworkProtocol.NetworkObjectUpdateType.REMOVE;
                            gameClient.getClient().sendTCP(update);
                        }

                        GameLogger.info("Removed object " + objectId + " from chunk " + chunkPos);
                    }
                }
            } catch (Exception e) {
                GameLogger.error("Error removing object from chunk: " + e.getMessage());
            }
        }


        public void generateObjectsForChunk(Vector2 chunkPos, Chunk chunk, Biome biome) {
            List<WorldObject> objects = new CopyOnWriteArrayList<>();

            if (objectsByChunk.containsKey(chunkPos)) {
                objectsByChunk.get(chunkPos);
                return;
            }

            try {
                Random random = new Random((long) (worldSeed + chunkPos.x * 31 + chunkPos.y * 17));

                for (WorldObject.ObjectType objectType : biome.getSpawnableObjects()) {
                    double spawnChance = biome.getSpawnChanceForObject(objectType);
                    int attempts = (int) (Chunk.CHUNK_SIZE * Chunk.CHUNK_SIZE * spawnChance);

                    for (int i = 0; i < attempts; i++) {
                        int x = random.nextInt(Chunk.CHUNK_SIZE);
                        int y = random.nextInt(Chunk.CHUNK_SIZE);

                        if (canPlaceObject(chunk, x, y, objects, biome, objectType)) {
                            TextureRegion texture = objectTextures.get(objectType);
                            if (texture != null) {
                                WorldObject obj = createObject(objectType, x, y, chunkPos);
                                if (obj != null) {
                                    objects.add(obj);
                                }
                            }
                        }
                    }
                }

                // Store generated objects
                objectsByChunk.put(chunkPos, objects);

                // Sync to server in multiplayer
                if (gameClient != null && !gameClient.isSinglePlayer()) {
                    sendChunkObjectSync(objects);
                }

            } catch (Exception e) {
                GameLogger.error("Error generating chunk objects: " + e.getMessage());
            }
        }


        private WorldObject createObject(ObjectType type, int localX, int localY, Vector2 chunkPos) {
            try {
                int worldTileX = (int) (chunkPos.x * Chunk.CHUNK_SIZE + localX);
                int worldTileY = (int) (chunkPos.y * Chunk.CHUNK_SIZE + localY);

                TextureRegion texture = objectTextures.get(type);
                if (texture != null) {
                    WorldObject object = new WorldObject(worldTileX, worldTileY, texture, type);
                    object.setId(UUID.randomUUID().toString());
                    return object;
                }
            } catch (Exception e) {
                GameLogger.error("Error creating object: " + e.getMessage());
            }
            return null;
        }

        private boolean canPlaceObject(Chunk chunk, int x, int y, List<WorldObject> objects, Biome biome, ObjectType newObjectType) {
            // Check tile type compatibility
            int tileType = chunk.getTileType(x, y);
            if (!biome.getAllowedTileTypes().contains(tileType)) {
                return false;
            }

            // Convert to world coordinates
            int worldTileX = chunk.getChunkX() * Chunk.CHUNK_SIZE + x;
            int worldTileY = chunk.getChunkY() * Chunk.CHUNK_SIZE + y;

            // Calculate bounds for the new object
            Rectangle newObjectBounds = getObjectBounds(worldTileX, worldTileY, newObjectType);

            if (!chunk.isPassable(x, y)) {
                return false;
            }
            int band = chunk.getElevationBands()[x][y];
            if (band >= 1 && isTreeType(newObjectType)) {
                return false;
            }
            // Check spacing against existing objects by bounding boxes
            for (WorldObject obj : objects) {
                Rectangle existingBounds = getObjectBounds(obj.getTileX(), obj.getTileY(), obj.getType());
                if (boundsOverlapWithPadding(newObjectBounds, existingBounds, getRequiredSpacing(newObjectType))) {
                    return false;
                }
            }

            // Strict tile-based adjacency check for trees
            // If the new object is a tree, ensure no other tree is in any adjacent tile (including diagonals).
            if (isTreeType(newObjectType)) {
                for (WorldObject obj : objects) {
                    if (isTreeType(obj.getType())) {
                        int dx = Math.abs(obj.getTileX() - worldTileX);
                        int dy = Math.abs(obj.getTileY() - worldTileY);

                        // If another tree is within one tile horizontally, vertically, or diagonally, prevent placement.
                        // dx <= 1 and dy <= 1 means a tile directly adjacent in any of the 8 directions.
                        if (dx <= 1 && dy <= 1) {
                            return false;
                        }
                    }
                }
            }

            return true;
        }


        private Rectangle getObjectBounds(int tileX, int tileY, ObjectType type) {
            float width = type.widthInTiles * World.TILE_SIZE;
            float height = type.heightInTiles * World.TILE_SIZE;

            // Special handling for trees which have different base positions
            float xOffset = 0;
            if (isTreeType(type)) {
                if (type == ObjectType.APRICORN_TREE) {
                    width = World.TILE_SIZE * 3;
                    height = World.TILE_SIZE * 3;
                    xOffset = -World.TILE_SIZE; // Center the 3-tile width
                } else {
                    width = World.TILE_SIZE * 2;
                    height = World.TILE_SIZE * 2;
                    xOffset = -World.TILE_SIZE; // Center the 2-tile width
                }
            }

            return new Rectangle(
                tileX * World.TILE_SIZE + xOffset,
                tileY * World.TILE_SIZE,
                width,
                height
            );
        }

        private boolean boundsOverlapWithPadding(Rectangle bounds1, Rectangle bounds2, int spacing) {
            // Instead of big padding, use minimal or none
            float padding = World.TILE_SIZE * Math.min(spacing, 1);
            Rectangle paddedBounds = new Rectangle(
                bounds1.x - padding,
                bounds1.y - padding,
                bounds1.width + (padding * 2),
                bounds1.height + (padding * 2)
            );
            return paddedBounds.overlaps(bounds2);
        }



        private boolean isNearChunkEdge(int localX, int localY, ObjectType type) {
            // Either return false entirely or reduce buffer drastically
            // For example:
            int buffer = 0; // allow placing near edges
            return false;
        }


        private boolean isTreeType(ObjectType type) {
            return type == ObjectType.TREE_0 ||
                type == ObjectType.TREE_1 ||
                type == ObjectType.SNOW_TREE ||
                type == ObjectType.HAUNTED_TREE ||
                type == ObjectType.RUINS_TREE ||
                type == ObjectType.APRICORN_TREE ||
                type == ObjectType.RAIN_TREE;
        }

        private int getRequiredSpacing(ObjectType type) {
            switch (type) {
                case APRICORN_TREE:
                    return 3; // Slightly more strict for apricorn trees
                case TREE_0:
                case TREE_1:
                case SNOW_TREE:
                case HAUNTED_TREE:
                case RAIN_TREE:
                case RUINS_TREE:
                    return 2; // More strict than before for large trees
                default:
                    return 1; // Smaller objects remain at spacing 1
            }
        }



        public void renderTreeBase(SpriteBatch batch, WorldObject tree, World world) {
            TextureRegion treeRegion = tree.getTexture();
            boolean flipY = treeRegion.isFlipY();

            int totalWidth = treeRegion.getRegionWidth();   // For apricorn: should be 96
            int totalHeight = treeRegion.getRegionHeight(); // Also 96 for apricorn
            int baseHeight = totalHeight / 3;               // For apricorn: 96/3 = 32

            float renderX = tree.getPixelX() - World.TILE_SIZE;
            float renderY = tree.getPixelY();
            Vector2 tilePos = new Vector2(tree.getTileX(), tree.getTileY());
            Float lightLevel = world.getLightLevelAtTile(tilePos);

            Color originalColor = batch.getColor().cpy();
            if (lightLevel != null && lightLevel > 0) {
                Color lightColor = new Color(1f, 0.8f, 0.6f, 1f);
                Color baseColor = world.getCurrentWorldColor().cpy();
                baseColor.lerp(lightColor, lightLevel * 0.7f);
                batch.setColor(baseColor);
            }

            int baseY = flipY ? 0 : totalHeight - baseHeight;
            TextureRegion baseRegion = new TextureRegion(treeRegion, 0, baseY, totalWidth, baseHeight);
            if (flipY != baseRegion.isFlipY()) {
                baseRegion.flip(false, true);
            }

            // If it's an apricorn tree, draw full width (96px) and base height (32px)
            // Otherwise, normal trees are drawn as before.
            float drawWidth = tree.getType() == ObjectType.APRICORN_TREE ? World.TILE_SIZE * 3 : World.TILE_SIZE * 2;
            float drawHeight = World.TILE_SIZE; // base is always one tile high visually

            batch.draw(baseRegion, renderX, renderY, drawWidth, drawHeight);
            batch.setColor(originalColor);
        }

        public void renderTreeTop(SpriteBatch batch, WorldObject tree, World world) {
            TextureRegion treeRegion = tree.getTexture();
            boolean flipY = treeRegion.isFlipY();

            int totalWidth = treeRegion.getRegionWidth();
            int totalHeight = treeRegion.getRegionHeight();
            int topHeight = (totalHeight * 2) / 3; // top 2/3
            float renderX = tree.getPixelX() - World.TILE_SIZE;
            float renderY = tree.getPixelY() + World.TILE_SIZE;

            Vector2 tilePos = new Vector2(tree.getTileX(), tree.getTileY());
            Float lightLevel = world.getLightLevelAtTile(tilePos);

            Color originalColor = batch.getColor().cpy();
            if (lightLevel != null && lightLevel > 0) {
                Color lightColor = new Color(1f, 0.8f, 0.6f, 1f);
                Color baseColor = world.getCurrentWorldColor().cpy();
                baseColor.lerp(lightColor, lightLevel * 0.7f);
                batch.setColor(baseColor);
            }

            int topY = flipY ? totalHeight - topHeight : 0;
            TextureRegion topRegion = new TextureRegion(treeRegion, 0, topY, totalWidth, topHeight);
            if (flipY != topRegion.isFlipY()) {
                topRegion.flip(false, true);
            }

            // For apricorn tree: draw full 96px width, 64px height
            float drawWidth = tree.getType() == ObjectType.APRICORN_TREE ? World.TILE_SIZE * 3 : World.TILE_SIZE * 2;
            float drawHeight = World.TILE_SIZE * 2; // top portion covers two tiles high normally

            // For apricorn:
            // totalHeight = 96, baseHeight=32, topHeight=64
            // so top portion is indeed 64px high, which matches World.TILE_SIZE*2.

            batch.draw(topRegion, renderX, renderY, drawWidth, drawHeight);

            batch.setColor(originalColor);
        }

        public void renderObject(SpriteBatch batch, WorldObject object, World world) {
            // Layered objects are rendered separately; skip them here
            if (object.getType().renderLayer == WorldObject.ObjectType.RenderLayer.LAYERED) {
                return;
            }

            TextureRegion objectTexture = object.getTexture();
            float renderX = object.getPixelX();
            float renderY = object.getPixelY();

            // Get the object's width and height in pixels
            float width = object.getType().widthInTiles * World.TILE_SIZE;
            float height = object.getType().heightInTiles * World.TILE_SIZE;

            // Apply lighting based on world light levels
            Vector2 tilePos = new Vector2(object.getTileX(), object.getTileY());
            Float lightLevel = world.getLightLevelAtTile(tilePos);

            // Save the original batch color
            Color originalColor = batch.getColor().cpy();

            // Apply lighting if available
            if (lightLevel != null && lightLevel > 0) {
                Color lightColor = new Color(1f, 0.8f, 0.6f, 1f);
                Color baseColor = world.getCurrentWorldColor().cpy();
                baseColor.lerp(lightColor, lightLevel * 0.7f);
                batch.setColor(baseColor);
            } else {
                // Ensure the current world color is applied
                batch.setColor(world.getCurrentWorldColor());
            }

            // Render the object
            batch.draw(objectTexture, renderX, renderY, width, height);

            // Restore the original batch color
            batch.setColor(originalColor);
        }


        public List<WorldObject> getObjectsNearPosition(float x, float y) {
            List<WorldObject> nearbyObjects = new ArrayList<>();
            int searchRadius = 2; // Search in nearby chunks

            int centerChunkX = (int) Math.floor(x / (Chunk.CHUNK_SIZE * World.TILE_SIZE));
            int centerChunkY = (int) Math.floor(y / (Chunk.CHUNK_SIZE * World.TILE_SIZE));

            for (int dx = -searchRadius; dx <= searchRadius; dx++) {
                for (int dy = -searchRadius; dy <= searchRadius; dy++) {
                    Vector2 chunkPos = new Vector2(centerChunkX + dx, centerChunkY + dy);
                    List<WorldObject> chunkObjectList = objectsByChunk.get(chunkPos);

                    if (chunkObjectList != null) {
                        for (WorldObject obj : chunkObjectList) {
                            float distX = Math.abs(obj.getPixelX() - x);
                            float distY = Math.abs(obj.getPixelY() - y);

                            if (distX <= World.TILE_SIZE * 3 && distY <= World.TILE_SIZE * 3) {
                                nearbyObjects.add(obj);
                            }
                        }
                    }
                }
            }

            return nearbyObjects;
        }

        public void updateObject(NetworkProtocol.WorldObjectUpdate update) {
            for (List<WorldObject> objects : objectsByChunk.values()) {
                for (WorldObject obj : objects) {
                    if (obj.getId().equals(update.objectId)) {
                        obj.updateFromData(update.data);
                        return;
                    }
                }
            }
        }

        public void removeObjectById(String objectId) {
            for (List<WorldObject> objects : objectsByChunk.values()) {
                objects.removeIf(obj -> obj.getId().equals(objectId));
            }
        }

        public List<WorldObject> getObjectsForChunk(Vector2 chunkPos) {
            List<WorldObject> objects = objectsByChunk.get(chunkPos);
            return objects != null ? objects : Collections.emptyList();
        }

        public void addObjectToChunk(WorldObject object) {
            int actualChunkX = (int) Math.floor(object.getPixelX() / (Chunk.CHUNK_SIZE * World.TILE_SIZE));
            int actualChunkY = (int) Math.floor(object.getPixelY() / (Chunk.CHUNK_SIZE * World.TILE_SIZE));
            Vector2 actualChunkPos = new Vector2(actualChunkX, actualChunkY);

            List<WorldObject> objects = objectsByChunk.computeIfAbsent(actualChunkPos, k -> new CopyOnWriteArrayList<>());
            objects.add(object);

        }

        private void handlePokeballSpawning(Vector2 chunkPos, Chunk chunk) {
            // Get or create the chunk's object list
            List<WorldObject> objects = objectsByChunk.computeIfAbsent(chunkPos,
                k -> new CopyOnWriteArrayList<>());

            // Count existing pokeballs in chunk
            long pokeballCount = objects.stream()
                .filter(obj -> obj.getType() == ObjectType.POKEBALL)
                .count();

            // Check if we can spawn a pokeball
            if (pokeballCount < MAX_POKEBALLS_PER_CHUNK && MathUtils.random() < POKEBALL_SPAWN_CHANCE) {
                int attempts = 10;
                while (attempts > 0) {
                    // Get random position within chunk
                    int localX = random.nextInt(Chunk.CHUNK_SIZE);
                    int localY = random.nextInt(Chunk.CHUNK_SIZE);

                    // Convert to world coordinates
                    int worldTileX = (int)(chunkPos.x * Chunk.CHUNK_SIZE + localX);
                    int worldTileY = (int)(chunkPos.y * Chunk.CHUNK_SIZE + localY);

                    // Check if location is valid (grass or sand tiles)
                    int tileType = chunk.getTileType(localX, localY);
                    if (tileType == TileType.GRASS || tileType == TileType.SAND) {
                        // Check area is clear of other objects
                        boolean locationClear = true;
                        for (WorldObject obj : objects) {
                            if (Math.abs(obj.getTileX() - worldTileX) < 2 &&
                                Math.abs(obj.getTileY() - worldTileY) < 2) {
                                locationClear = false;
                                break;
                            }
                        }

                        if (locationClear) {
                            // Create and add pokeball
                            TextureRegion pokeballTexture = objectTextures.get(ObjectType.POKEBALL);
                            if (pokeballTexture != null) {
                                WorldObject pokeball = new WorldObject(
                                    worldTileX, worldTileY,
                                    pokeballTexture, ObjectType.POKEBALL
                                );
                                objects.add(pokeball);

                                // Send network update in multiplayer
                                if (gameClient != null && !gameClient.isSinglePlayer()) {
                                    NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
                                    update.objectId = pokeball.getId();
                                    update.type = NetworkProtocol.NetworkObjectUpdateType.ADD;
                                    update.data = pokeball.getSerializableData();

                                    gameClient.sendWorldObjectUpdate(update);
                                }

                                GameLogger.info("Spawned pokeball at " + worldTileX + "," + worldTileY);
                                break;
                            }
                        }
                    }
                    attempts--;
                }
            }
        }
        public void update(Map<Vector2, Chunk> loadedChunks) {
            WorldObjectOperation operation;
            while ((operation = operationQueue.poll()) != null) {
                try {
                    switch (operation.type) {
                        case REMOVE:
                            RemoveOperation removeOp = (RemoveOperation) operation;
                            List<WorldObject> removeList = objectsByChunk.get(removeOp.chunkPos);
                            if (removeList != null) {
                                removeList.removeIf(obj -> obj.getId().equals(removeOp.objectId));
                                objectsByChunk.put(removeOp.chunkPos, new CopyOnWriteArrayList<>(removeList));

                                // Save chunk after removal
                                if (gameClient != null && gameClient.getCurrentWorld() != null) {
                                    Chunk chunk = gameClient.getCurrentWorld().getChunkAtPosition(
                                        removeOp.chunkPos.x, removeOp.chunkPos.y);
                                    if (chunk != null) {
                                        gameClient.getCurrentWorld().saveChunkData(removeOp.chunkPos, chunk);
                                    }
                                }
                            }
                            break;

                        case PERSIST:
                            PersistOperation persistOp = (PersistOperation) operation;
                            updateChunkObjectsList(persistOp.chunkPos, persistOp.objects);
                            break;

                        case ADD:
                            AddOperation addOp = (AddOperation) operation;
                            List<WorldObject> addList = objectsByChunk.computeIfAbsent(
                                addOp.chunkPos, k -> new CopyOnWriteArrayList<>());
                            addList.add(addOp.object);
                            break;

                        case UPDATE:
                            handleUpdateOperation((UpdateOperation) operation);
                            break;
                    }
                } catch (Exception e) {
                    GameLogger.error("Error processing operation: " + e.getMessage());
                }
            }

            // Update existing chunks
            for (Map.Entry<Vector2, Chunk> entry : loadedChunks.entrySet()) {
                Vector2 chunkPos = entry.getKey();
                List<WorldObject> objects = objectsByChunk.computeIfAbsent(chunkPos,
                    k -> new CopyOnWriteArrayList<>());

                // Remove expired objects
                boolean changed = objects.removeIf(WorldObject::isExpired);
                if (changed) {
                    operationQueue.add(new PersistOperation(chunkPos, new ArrayList<>(objects)));
                }

                handlePokeballSpawning(chunkPos, entry.getValue());
            }

            // Clean up unloaded chunks
            cleanupUnloadedChunks(loadedChunks);
        }

        private void handleUpdateOperation(UpdateOperation updateOp) {
            try {
                List<WorldObject> updateList = objectsByChunk.get(updateOp.chunkPos);
                if (updateList != null) {
                    for (WorldObject obj : updateList) {
                        if (obj.getId().equals(updateOp.update.objectId)) {
                            obj.updateFromNetwork(updateOp.update);
                            // Queue persist after update
                            operationQueue.add(new PersistOperation(updateOp.chunkPos, new ArrayList<>(updateList)));
                            break;
                        }
                    }
                }
            } catch (Exception e) {
                GameLogger.error("Error handling update operation: " + e.getMessage());
            }
        }

        private void cleanupUnloadedChunks(Map<Vector2, Chunk> loadedChunks) {
            // Identify chunks to remove
            List<Vector2> chunksToRemove = new ArrayList<>();
            for (Vector2 chunkPos : objectsByChunk.keySet()) {
                if (!loadedChunks.containsKey(chunkPos)) {
                    chunksToRemove.add(chunkPos);
                }
            }

            // Remove chunks and persist their final state
            for (Vector2 chunkPos : chunksToRemove) {
                List<WorldObject> objects = objectsByChunk.get(chunkPos);
                if (objects != null) {
                    // Final persist operation before removal
                    operationQueue.add(new PersistOperation(chunkPos, new ArrayList<>(objects)));
                }
                objectsByChunk.remove(chunkPos);
            }
        }

        private void updateChunkObjectsList(Vector2 chunkPos, List<WorldObject> objects) {
            // Update the runtime state
            objectsByChunk.put(chunkPos, new CopyOnWriteArrayList<>(objects));

        }


        private boolean shouldSpawnPokeball(List<WorldObject> chunkObjects) {
            long pokeballCount = chunkObjects.stream()
                .filter(obj -> obj.getType() == ObjectType.POKEBALL)
                .count();
            return pokeballCount < MAX_POKEBALLS_PER_CHUNK &&
                new Random().nextInt(101) < POKEBALL_SPAWN_CHANCE;
        }

        private void spawnPokeball(Vector2 chunkPos, List<WorldObject> objects, Chunk chunk) {
            for (int attempts = 0; attempts < 10; attempts++) {
                int localX = random.nextInt(Chunk.CHUNK_SIZE);
                int localY = random.nextInt(Chunk.CHUNK_SIZE);

                // Only spawn on grass or sand
                int tileType = chunk.getTileType(localX, localY);
                if (tileType == TileType.GRASS || tileType == TileType.SAND) {

                    int worldTileX = (int) (chunkPos.x * Chunk.CHUNK_SIZE) + localX;
                    int worldTileY = (int) (chunkPos.y * Chunk.CHUNK_SIZE) + localY;

                    boolean locationClear = true;
                    for (WorldObject obj : objects) {
                        if (Math.abs(obj.getTileX() - worldTileX) < 2 &&
                            Math.abs(obj.getTileY() - worldTileY) < 2) {
                            locationClear = false;
                            break;
                        }
                    }
                    if (shouldSpawnPokeball(objects)) {
                        if (locationClear) {
                            TextureRegion pokeballTexture = objectTextures.get(WorldObject.ObjectType.POKEBALL);
                            if (pokeballTexture != null) {
                                WorldObject pokeball = new WorldObject(worldTileX, worldTileY,
                                    pokeballTexture, WorldObject.ObjectType.POKEBALL);
                                objects.add(pokeball);

                                if (gameClient != null && !gameClient.isSinglePlayer()) {
                                    sendObjectSpawn(pokeball);
                                }
                            }
                        }
                    }
                }
            }
        }

        private void sendObjectSpawn(WorldObject object) {
            if (gameClient == null || gameClient.isSinglePlayer()) return;

            NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
            update.objectId = object.getId();
            update.type = NetworkProtocol.NetworkObjectUpdateType.ADD;
            update.data = object.getSerializableData();

            gameClient.sendWorldObjectUpdate(update);
        }

        private void sendObjectRemove(String objectId) {
            if (gameClient == null || gameClient.isSinglePlayer()) return;

            NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
            update.objectId = objectId;  // Use objectId directly
            update.type = NetworkProtocol.NetworkObjectUpdateType.REMOVE;

            gameClient.sendWorldObjectUpdate(update);
        }


        public WorldObject createObject(WorldObject.ObjectType type, float x, float y) {
            TextureRegion texture = objectTextures.get(type);
            if (texture == null) {
                throw new IllegalStateException("No texture found for object type: " + type);
            }

            int tileX = (int) (x / World.TILE_SIZE);
            int tileY = (int) (y / World.TILE_SIZE);

            return new WorldObject(tileX, tileY, texture, type);
        }

        private void tryPlaceObject(int x, int y, List<WorldObject> objects,
                                    ObjectType type, Vector2 chunkPos) {
            int worldTileX = (int) (chunkPos.x * Chunk.CHUNK_SIZE + x);
            int worldTileY = (int) (chunkPos.y * Chunk.CHUNK_SIZE + y);

            TextureRegion texture = objectTextures.get(type);
            if (texture != null) {
                WorldObject object = new WorldObject(worldTileX, worldTileY, texture, type);
                objects.add(object);
                GameLogger.error("Placed " + type + " at " + worldTileX + "," + worldTileY);
            } else {
                GameLogger.error("Missing texture for " + type);
            }
        }


    }

}

================
File: main/java/io/github/pokemeetup/system/gameplay/overworld/WorldObjectOperation.java
================
package io.github.pokemeetup.system.gameplay.overworld;

public class WorldObjectOperation {
    public enum OperationType {
        ADD,
        REMOVE,
        UPDATE,
        PERSIST
    }

    public OperationType type;

    public WorldObjectOperation(OperationType type) {
        this.type = type;
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/PlayerAnimations.java
================
package io.github.pokemeetup.system.gameplay;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.textures.TextureManager;

public class PlayerAnimations {
    public static final float BASE_MOVE_TIME = 0.45f;
    public static final float RUN_SPEED_MULTIPLIER = 1.5f;

    public static final float WALK_FRAME_DURATION = BASE_MOVE_TIME / 3f;
    public static final float RUN_FRAME_DURATION  = (BASE_MOVE_TIME / RUN_SPEED_MULTIPLIER) / 3f;

    // Punch and Chop keep 4 frames:
    public static final float PUNCH_ANIMATION_DURATION = 0.8f; // total cycle ~0.8
    public static final float PUNCH_FRAME_DURATION     = PUNCH_ANIMATION_DURATION / 4f; // => 0.2
    public static final float CHOP_ANIMATION_DURATION  = 0.6f; // total cycle ~0.6
    public static final float CHOP_FRAME_DURATION      = CHOP_ANIMATION_DURATION / 4f; // => 0.15

    private volatile boolean isInitialized = false;
    private volatile boolean isDisposed    = false;

    // Standing frames [up=0, down=1, left=2, right=3]
    private TextureRegion[] standingFrames;

    // Movement animations
    private Animation<TextureRegion> walkUpAnimation;
    private Animation<TextureRegion> walkDownAnimation;
    private Animation<TextureRegion> walkLeftAnimation;
    private Animation<TextureRegion> walkRightAnimation;
    private Animation<TextureRegion> runUpAnimation;
    private Animation<TextureRegion> runDownAnimation;
    private Animation<TextureRegion> runLeftAnimation;
    private Animation<TextureRegion> runRightAnimation;

    // Punch/Chop animations [up=0, down=1, left=2, right=3]
    private Animation<TextureRegion>[] punchAnimations;
    private Animation<TextureRegion>[] chopAnimations;

    private boolean isPunching  = false;
    private boolean isChopping  = false;
    private float   punchAnimationTime = 0f;
    private float   chopAnimationTime  = 0f;

    public PlayerAnimations() {
        loadAnimations();
    }

    public void startPunching() {
        isPunching = true;
        punchAnimationTime = 0f;
        GameLogger.info("Started punching animation");
    }

    public void stopPunching() {
        isPunching = false;
        punchAnimationTime = 0f;
        if (punchAnimations != null) {
            for (Animation<TextureRegion> anim : punchAnimations) {
                if (anim != null) {
                    anim.setPlayMode(Animation.PlayMode.NORMAL);
                }
            }
        }
        GameLogger.info("Punching animation stopped");
    }

    public void startChopping() {
        isChopping = true;
        chopAnimationTime = 0f;
        GameLogger.info("Started chopping animation");
    }

    public void stopChopping() {
        isChopping = false;
        chopAnimationTime = 0f;
        if (chopAnimations != null) {
            for (Animation<TextureRegion> anim : chopAnimations) {
                if (anim != null) {
                    anim.setPlayMode(Animation.PlayMode.NORMAL);
                }
            }
        }
        GameLogger.info("Chopping animation stopped");
    }

    /**
     * Returns the current frame (TextureRegion) based on direction, movement state, punching, chopping, etc.
     */
    public TextureRegion getCurrentFrame(String direction, boolean isMoving, boolean isRunning, float stateTime) {
        if (!isInitialized || isDisposed) {
            loadAnimations();
        }

        // 1) Chop animation has priority if active
        if (isChopping) {
            int dirIndex = getDirectionIndex(direction);
            if (chopAnimations != null && dirIndex >= 0 && dirIndex < chopAnimations.length) {
                chopAnimationTime += Gdx.graphics.getDeltaTime();
                TextureRegion frame = chopAnimations[dirIndex].getKeyFrame(chopAnimationTime, true);

                // If you want a one-loop chop, you can check isAnimationFinished here,
                // but currently it loops:
                if (chopAnimationTime >= CHOP_ANIMATION_DURATION) {
                    chopAnimationTime = 0f;
                }

                return (frame != null) ? frame : getStandingFrame(direction);
            }
        }

        // 2) Punch animation if active
        if (isPunching) {
            int dirIndex = getDirectionIndex(direction);
            if (punchAnimations != null && dirIndex >= 0 && dirIndex < punchAnimations.length) {
                punchAnimationTime += Gdx.graphics.getDeltaTime();
                TextureRegion frame = punchAnimations[dirIndex].getKeyFrame(punchAnimationTime, true);

                if (punchAnimationTime >= PUNCH_ANIMATION_DURATION) {
                    punchAnimationTime = 0f;
                }

                return (frame != null) ? frame : getStandingFrame(direction);
            }
        }

        // 3) Normal walk/run
        if (!isMoving) {
            return getStandingFrame(direction);
        }
        Animation<TextureRegion> currentAnimation = getAnimation(direction, isRunning);
        return currentAnimation.getKeyFrame(stateTime, true);
    }

    @SuppressWarnings("unchecked")
    private synchronized void loadAnimations() {
        try {
            TextureAtlas atlas = TextureManager.getBoy();
            if (atlas == null) {
                throw new RuntimeException("TextureAtlas is null");
            }

            // Prepare arrays
            chopAnimations  = new Animation[4];
            punchAnimations = new Animation[4];
            standingFrames  = new TextureRegion[4];

            // -- 1) Load Chop (4 frames each)
            // The index order below matches your atlas listing for each direction.
            // Adjust if your actual order is different in the final atlas.
            int[][] chopIndices = {
                /* up=0    */ {1, 3, 0, 2},
                /* down=1  */ {2, 0, 1, 3},
                /* left=2  */ {1, 3, 0, 2},
                /* right=3 */ {1, 3, 0, 2},
            };
            String[] directions = {"up", "down", "left", "right"};
            for (int i = 0; i < directions.length; i++) {
                TextureRegion[] frames = new TextureRegion[4];
                for (int f = 0; f < 4; f++) {
                    // e.g. "boy_axe_up", index= chopIndices[0][f]
                    TextureRegion reg = atlas.findRegion("boy_axe_" + directions[i], chopIndices[i][f]);
                    if (reg == null) {
                        throw new RuntimeException("Missing chop frame: boy_axe_" + directions[i] + " idx=" + chopIndices[i][f]);
                    }
                    frames[f] = reg;
                }
                chopAnimations[i] = new Animation<>(CHOP_FRAME_DURATION, frames);
                chopAnimations[i].setPlayMode(Animation.PlayMode.NORMAL);
            }

            // -- 2) Load Punch (4 frames each)
            int[][] punchIndices = {
                /* up=0    */ {1, 3, 2, 0},
                /* down=1  */ {1, 3, 0, 2},
                /* left=2  */ {0, 1, 3, 2},
                /* right=3 */ {1, 3, 0, 2},
            };
            for (int i = 0; i < directions.length; i++) {
                TextureRegion[] frames = new TextureRegion[4];
                for (int f = 0; f < 4; f++) {
                    TextureRegion reg = atlas.findRegion("boy_punch_" + directions[i], punchIndices[i][f]);
                    if (reg == null) {
                        throw new RuntimeException("Missing punch frame: boy_punch_" + directions[i] + " idx=" + punchIndices[i][f]);
                    }
                    frames[f] = reg;
                }
                punchAnimations[i] = new Animation<>(PUNCH_FRAME_DURATION, frames);
                punchAnimations[i].setPlayMode(Animation.PlayMode.NORMAL);
            }

            // -- 3) Load Walk (3 frames each)
            // According to your listing, e.g. boy_walk_down index: 1,0,2, etc.
            int[][] walkIndices = {
                /* up=0    */ {1, 0, 2},  // boy_walk_up:    index 1,0,2
                /* down=1  */ {1, 0, 2},  // boy_walk_down:  index 1,0,2
                /* left=2  */ {0, 2, 1},  // boy_walk_left:  index 0,2,1
                /* right=3 */ {0, 1, 2},  // boy_walk_right: index 0,1,2
            };
            for (int i = 0; i < directions.length; i++) {
                TextureRegion[] frames = new TextureRegion[3];
                for (int f = 0; f < 3; f++) {
                    TextureRegion reg = atlas.findRegion("boy_walk_" + directions[i], walkIndices[i][f]);
                    if (reg == null) {
                        throw new RuntimeException("Missing walk frame: boy_walk_" + directions[i] + " idx=" + walkIndices[i][f]);
                    }
                    frames[f] = reg;
                }
                Animation<TextureRegion> walkAnim = new Animation<>(WALK_FRAME_DURATION, frames);
                walkAnim.setPlayMode(Animation.PlayMode.LOOP);

                assignWalkAnimation(i, walkAnim);

                // Pick one as the standing frame (often the “middle” or “first”):
                if (standingFrames[i] == null) {
                    standingFrames[i] = frames[0];
                }
            }

            // -- 4) Load Run (3 frames each)
            // According to your listing, e.g. boy_run_down index:2,0,1, etc.
            int[][] runIndices = {
                /* up=0    */ {0, 2, 1}, // boy_run_up:    index 0,2,1
                /* down=1  */ {2, 0, 1}, // boy_run_down:  index 2,0,1
                /* left=2  */ {2, 1, 0}, // boy_run_left:  index 2,1,0
                /* right=3 */ {2, 0, 1}, // boy_run_right: index 2,0,1
            };
            for (int i = 0; i < directions.length; i++) {
                TextureRegion[] frames = new TextureRegion[3];
                for (int f = 0; f < 3; f++) {
                    TextureRegion reg = atlas.findRegion("boy_run_" + directions[i], runIndices[i][f]);
                    if (reg == null) {
                        throw new RuntimeException("Missing run frame: boy_run_" + directions[i] + " idx=" + runIndices[i][f]);
                    }
                    frames[f] = reg;
                }
                Animation<TextureRegion> runAnim = new Animation<>(RUN_FRAME_DURATION, frames);
                runAnim.setPlayMode(Animation.PlayMode.LOOP);

                assignRunAnimation(i, runAnim);
            }

            isInitialized = true;
            isDisposed    = false;

        } catch (Exception e) {
            GameLogger.error("Failed to load animations: " + e.getMessage());
            isInitialized = false;
            throw new RuntimeException("Animation loading failed", e);
        }
    }

    private void assignWalkAnimation(int index, Animation<TextureRegion> animation) {
        switch (index) {
            case 0: walkUpAnimation    = animation; break;
            case 1: walkDownAnimation  = animation; break;
            case 2: walkLeftAnimation  = animation; break;
            case 3: walkRightAnimation = animation; break;
        }
    }

    private void assignRunAnimation(int index, Animation<TextureRegion> animation) {
        switch (index) {
            case 0: runUpAnimation    = animation; break;
            case 1: runDownAnimation  = animation; break;
            case 2: runLeftAnimation  = animation; break;
            case 3: runRightAnimation = animation; break;
        }
    }

    /**
     * Returns the index 0..3 for up/down/left/right.
     */
    private int getDirectionIndex(String dir) {
        if (dir == null) return 1; // default 'down'
        switch (dir.toLowerCase()) {
            case "up":    return 0;
            case "down":  return 1;
            case "left":  return 2;
            case "right": return 3;
            default:      return 1; // fallback 'down'
        }
    }

    private Animation<TextureRegion> getAnimation(String direction, boolean isRunning) {
        int dirIndex = getDirectionIndex(direction);
        switch (dirIndex) {
            case 0: return isRunning ? runUpAnimation    : walkUpAnimation;
            case 1: return isRunning ? runDownAnimation  : walkDownAnimation;
            case 2: return isRunning ? runLeftAnimation  : walkLeftAnimation;
            case 3: return isRunning ? runRightAnimation : walkRightAnimation;
        }
        return walkDownAnimation; // fallback
    }

    public TextureRegion getStandingFrame(String direction) {
        if (!isInitialized || isDisposed) {
            loadAnimations();
        }
        return standingFrames[getDirectionIndex(direction)];
    }

    public synchronized void dispose() {
        isDisposed    = true;
        isInitialized = false;
    }

    public boolean isDisposed() {
        return isDisposed;
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/PokemonAnimations.java
================
package io.github.pokemeetup.system.gameplay;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.utils.GameLogger;

import java.util.Random;

public class PokemonAnimations {
    public static final float IDLE_BOUNCE_DURATION = 1.0f;
    private static final float IDLE_BOUNCE_HEIGHT = 2f;
    private static final float IDLE_ANIMATION_CHANCE = 0.01f; // Chance to start idle animation per frame

    private float idleTime = 0f;
    private boolean isIdling = false;

    public boolean isIdling() {
        return isIdling;
    }

    private float idleOffset = 0f;
    private float timeSinceLastIdle = 0f;
    private final Random random = new Random();
        // Constants for 256x256 sprite sheet with 4x4 grid
        private static final int SPRITE_SHEET_SIZE = 256;
        private static final int FRAMES_PER_DIRECTION = 4;
    private static final int FRAME_WIDTH = SPRITE_SHEET_SIZE / FRAMES_PER_DIRECTION;  // 64
    private static final int FRAME_HEIGHT = SPRITE_SHEET_SIZE / FRAMES_PER_DIRECTION; // 64
    private static final float FRAME_DURATION = 0.2f;

    // Animations for each direction
    private Animation<TextureRegion> walkDownAnimation;  // Row 0
    private Animation<TextureRegion> walkLeftAnimation;  // Row 1
    private Animation<TextureRegion> walkRightAnimation; // Row 2
    private Animation<TextureRegion> walkUpAnimation;    // Row 3

    private final TextureRegion[] standingFrames;
    private float stateTime;
    private TextureRegion defaultFrame;
    private boolean isMoving;
    private String currentDirection;

    public boolean isMoving() {
        return isMoving;
    }

    private boolean isInitialized;

    public PokemonAnimations(TextureRegion spriteSheet) {
        this.standingFrames = new TextureRegion[4];
        this.stateTime = 0f;

        if (spriteSheet == null) {
            GameLogger.error("Sprite sheet is null");
            createDefaultFrame();
            return;
        }

        try {
            // Verify sprite sheet dimensions
            if (spriteSheet.getRegionWidth() != SPRITE_SHEET_SIZE ||
                spriteSheet.getRegionHeight() != SPRITE_SHEET_SIZE) {
                GameLogger.error(String.format(
                    "Invalid sprite sheet dimensions. Expected %dx%d, got %dx%d",
                    SPRITE_SHEET_SIZE, SPRITE_SHEET_SIZE,
                    spriteSheet.getRegionWidth(), spriteSheet.getRegionHeight()
                ));
            }

            initializeAnimations(spriteSheet);
            isInitialized = true;
//            GameLogger.info("Successfully initialized Pokemon animations");
        } catch (Exception e) {
            GameLogger.error("Failed to initialize animations: " + e.getMessage());
            e.printStackTrace();
            createDefaultFrame();
        }
    }

    private void initializeAnimations(TextureRegion spriteSheet) {
        // Split sprite sheet into frames
        TextureRegion[][] allFrames = new TextureRegion[4][FRAMES_PER_DIRECTION];

        for (int row = 0; row < 4; row++) {
            for (int col = 0; col < FRAMES_PER_DIRECTION; col++) {
                // Calculate frame coordinates
                int x = col * FRAME_WIDTH;
                int y = row * FRAME_HEIGHT;


                allFrames[row][col] = new TextureRegion(
                    spriteSheet,
                    x, y,
                    FRAME_WIDTH, FRAME_HEIGHT
                );

                // Store first frame of each row as standing frame
                if (col == 0) {
                    standingFrames[row] = new TextureRegion(allFrames[row][0]);
                }
            }
        }

        // Create animations for each direction
        walkDownAnimation = new Animation<>(FRAME_DURATION, allFrames[0]);
        walkLeftAnimation = new Animation<>(FRAME_DURATION, allFrames[1]);
        walkRightAnimation = new Animation<>(FRAME_DURATION, allFrames[2]);
        walkUpAnimation = new Animation<>(FRAME_DURATION, allFrames[3]);

        // Set default frame
        defaultFrame = standingFrames[0];

//        GameLogger.info("Created all animations successfully");
    }

    private void createDefaultFrame() {
        Pixmap pixmap = new Pixmap(FRAME_WIDTH, FRAME_HEIGHT, Pixmap.Format.RGBA8888);
        pixmap.setColor(Color.MAGENTA);
        pixmap.fill();
        Texture texture = new Texture(pixmap);
        pixmap.dispose();

        defaultFrame = new TextureRegion(texture);
        for (int i = 0; i < 4; i++) {
            standingFrames[i] = new TextureRegion(defaultFrame);
        }
    }

    public TextureRegion getCurrentFrame(String direction, boolean isMoving, float delta) {
        if (!isInitialized) {
            return defaultFrame;
        }

        this.isMoving = isMoving;
        this.currentDirection = direction;

        TextureRegion frame;
        if (isMoving) {
            stateTime += delta;
            Animation<TextureRegion> currentAnimation = getAnimationForDirection(direction);
            frame = currentAnimation.getKeyFrame(stateTime, true);
        } else {
            frame = getStandingFrame(direction);
        }

        return frame != null ? frame : defaultFrame;
    }  public float getIdleOffset() {
        if (!isIdling) return 0f;

        // Create a smooth bounce effect using sine
        float progress = idleTime / IDLE_BOUNCE_DURATION;
        return IDLE_BOUNCE_HEIGHT * (float)Math.sin(progress * Math.PI * 2) * (1 - progress);
    }

    private TextureRegion getStandingFrame(String direction) {
        switch (direction.toLowerCase()) {
            case "down":
                return standingFrames[0];
            case "left":
                return standingFrames[1];
            case "right":
                return standingFrames[2];
            case "up":
                return standingFrames[3];
            default:
                return standingFrames[0]; // Default to down
        }
    }

    private Animation<TextureRegion> getAnimationForDirection(String direction) {
        switch (direction.toLowerCase()) {
            case "down":
                return walkDownAnimation;
            case "left":
                return walkLeftAnimation;
            case "right":
                return walkRightAnimation;
            case "up":
                return walkUpAnimation;
            default:
                return walkDownAnimation;
        }
    }

    public void startMoving(String direction) {
        if (!isMoving || !direction.equals(currentDirection)) {
            this.isMoving = true;
            this.currentDirection = direction;
            // Don't reset stateTime to keep animations smooth
        }
    }

    public void stopMoving() {
        this.isMoving = false;
    }

    public void update(float delta) {
        if (isMoving) {
            stateTime += delta;
            isIdling = false;
            idleTime = 0f;
            timeSinceLastIdle = 0f;
        } else {
            // Handle idle animation
            timeSinceLastIdle += delta;

            // Randomly start new idle animation
            if (!isIdling && random.nextFloat() < IDLE_ANIMATION_CHANCE * delta) {
                isIdling = true;
                idleTime = 0f;
            }

            if (isIdling) {
                idleTime += delta;
                if (idleTime >= IDLE_BOUNCE_DURATION) {
                    isIdling = false;
                    idleTime = 0f;
                    idleOffset = 0f;
                }
            }
        }
    }
}

================
File: main/java/io/github/pokemeetup/system/gameplay/SpawnPointValidator.java
================
package io.github.pokemeetup.system.gameplay;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.utils.textures.TileType;

import java.util.List;

public class SpawnPointValidator {
    private static final int SPAWN_CHECK_RADIUS = 5;

    public static Vector2 findValidSpawnPoint(World world, int startX, int startY) {
        int radius = 0;
        int maxRadius = 100;
        while (radius < maxRadius) {
            for (int dx = -radius; dx <= radius; dx++) {
                for (int dy = -radius; dy <= radius; dy++) {
                    int checkX = startX + dx;
                    int checkY = startY + dy;

                    if (isValidSpawnLocation(world, checkX, checkY)) {
                        if (hasEnoughClearSpace(world, checkX, checkY)) {
                            return new Vector2(checkX, checkY);
                        }
                    }
                }
            }
            radius++;
        }
        return new Vector2(World.DEFAULT_X_POSITION, World.DEFAULT_Y_POSITION);
    }

    private static boolean isValidSpawnLocation(World world, int x, int y) {
        if (!world.isPassable(x, y)) {
            return false;
        }
        Chunk chunk = world.getChunkAtPosition(x, y);
        if (chunk != null) {
            int localX = Math.floorMod(x, Chunk.CHUNK_SIZE);
            int localY = Math.floorMod(y, Chunk.CHUNK_SIZE);
            int tileType = chunk.getTileType(localX, localY);

            if (TileType.isMountainTile(tileType) && !TileType.isPassableMountainTile(tileType)) {
                return false;
            }
        }
        List<WorldObject> nearbyObjects = world.getObjectManager().getObjectsNearPosition(
            x * World.TILE_SIZE,
            y * World.TILE_SIZE
        );

        for (WorldObject obj : nearbyObjects) {
            if (obj.getBoundingBox().contains(x * World.TILE_SIZE, y * World.TILE_SIZE)) {
                return false;
            }
        }

        return true;
    }

    private static boolean hasEnoughClearSpace(World world, int centerX, int centerY) {
        for (int dx = -SPAWN_CHECK_RADIUS; dx <= SPAWN_CHECK_RADIUS; dx++) {
            for (int dy = -SPAWN_CHECK_RADIUS; dy <= SPAWN_CHECK_RADIUS; dy++) {
                if (!isValidSpawnLocation(world, centerX + dx, centerY + dy)) {
                    return false;
                }
            }
        }
        return true;
    }
}

================
File: main/java/io/github/pokemeetup/system/GlobalInputProcessor.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.Input;
import com.badlogic.gdx.InputAdapter;
import io.github.pokemeetup.utils.GameLogger;

public class GlobalInputProcessor extends InputAdapter {
    private final InputManager inputManager;

    public GlobalInputProcessor(InputManager inputManager) {
        this.inputManager = inputManager;
    }

    @Override
    public boolean keyDown(int keycode) {
        InputManager.UIState currentState = inputManager.getCurrentState();
        GameLogger.info("GlobalInputProcessor keyDown: keycode=" + keycode + ", currentState=" + currentState);

        // Handle ESCAPE key to toggle game menu
        if (keycode == Input.Keys.ESCAPE) {
            if (currentState != InputManager.UIState.MENU) {
                inputManager.setUIState(InputManager.UIState.MENU);
            } else {
                inputManager.setUIState(InputManager.UIState.NORMAL);
            }
            return true; // Event handled
        }

        // Handle 'E' key to toggle inventory
        if (keycode == Input.Keys.E) {
            if (currentState == InputManager.UIState.INVENTORY ||
                currentState == InputManager.UIState.CRAFTING ||
                currentState == InputManager.UIState.CHEST_SCREEN) {
                inputManager.setUIState(InputManager.UIState.NORMAL);
            } else if (currentState == InputManager.UIState.NORMAL) {
                inputManager.setUIState(InputManager.UIState.INVENTORY);
            }
            return true; // Event handled
        }

        // Do not consume movement keys
        if (keycode == Input.Keys.W || keycode == Input.Keys.A ||
            keycode == Input.Keys.S || keycode == Input.Keys.D ||
            keycode == Input.Keys.UP || keycode == Input.Keys.DOWN ||
            keycode == Input.Keys.LEFT || keycode == Input.Keys.RIGHT) {
            return false; // Let InputHandler process these
        }

        return false; // Do not consume other keys
    }

    @Override
    public boolean keyUp(int keycode) {
        // Do not handle keyUp events for ESCAPE and E keys
        return false;
    }
}

================
File: main/java/io/github/pokemeetup/system/InputHandler.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.Input;
import com.badlogic.gdx.InputAdapter;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.audio.AudioManager;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.screens.otherui.BuildModeUI;
import io.github.pokemeetup.system.battle.BattleInitiationHandler;
import io.github.pokemeetup.system.data.ChestData;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.ChestInteractionHandler;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.utils.GameLogger;

import java.util.List;
import java.util.Objects;
import java.util.UUID;

public class InputHandler extends InputAdapter {
    private static final float SWING_INTERVAL = 0.5f;          // Time between each 'swing' for durability
    private static final int DURABILITY_LOSS_PER_SWING = 1;
    private static final float TREE_CHOP_WITH_AXE_TIME = 2.0f;
    private static final float TREE_CHOP_WITHOUT_AXE_TIME = 5.0f;
    private static final float CHOP_SOUND_INTERVAL_WITH_AXE = 0.6f;
    private static final float CHOP_SOUND_INTERVAL_WITHOUT_AXE = 0.6f;

    private final PickupActionHandler pickupHandler;
    private final BattleInitiationHandler battleInitiationHandler;
    private final GameScreen gameScreen;
    private final ChestInteractionHandler chestHandler;
    private final InputManager inputManager;

    private boolean upPressed, downPressed, leftPressed, rightPressed;

    // Chopping/punching states
    private boolean isChopping = false;         // are we actively chopping a tree?
    private boolean isPunching = false;         // are we actively punching (no axe found)?
    private boolean isBreaking = false;         // are we actively breaking a block?

    private float chopProgress = 0f;
    private float breakProgress = 0f;
    private float swingTimer = 0f;
    private float lastChopSoundTime = 0f;
    private float lastBreakSoundTime = 0f;

    private boolean hasAxe = false;             // do we have a wooden axe?

    private WorldObject targetObject = null;    // the tree / object being chopped
    private PlaceableBlock targetBlock = null;  // the block being broken

    public InputHandler(
        PickupActionHandler pickupHandler,
        BattleInitiationHandler battleInitiationHandler,
        GameScreen gameScreen,
        ChestInteractionHandler handler,
        InputManager uiControlManager
    ) {
        this.pickupHandler = pickupHandler;
        this.inputManager = uiControlManager;
        this.battleInitiationHandler = battleInitiationHandler;
        this.gameScreen = gameScreen;
        this.chestHandler = handler;
    }

    /************************************************************************
     *  Interaction / chest / crafting / build logic
     ************************************************************************/
    public void handleInteraction() {
        GameLogger.info("handleInteraction() called");

        // Check if chest is open
        if (chestHandler.isChestOpen()) {
            GameLogger.info("Chest is already open");
            return;
        }

        // Chest
        if (chestHandler.canInteractWithChest(GameContext.get().getPlayer())) {
            GameLogger.info("Interacting with chest");
            handleChestInteraction();
            return;
        }

        // Build mode
        if (GameContext.get().getPlayer().isBuildMode()) {
            GameLogger.info("Player is in build mode, handling block placement");
            handleBlockPlacement();
            return;
        }

        // Crafting table
        if (canInteractWithCraftingTable()) {
            GameLogger.info("Interacting with crafting table");
            handleCraftingTableInteraction();
            return;
        }

        // If none of the above => pick up items or initiate a battle
        GameLogger.info("Handling pickup action");
        pickupHandler.handlePickupAction();

        GameLogger.info("Attempting to initiate battle");
        battleInitiationHandler.handleBattleInitiation();
    }

    private void handleChestInteraction() {
        if (chestHandler.isChestOpen()) {
            GameLogger.info("Chest is already open, not handling interaction");
            return;
        }

        if (chestHandler.canInteractWithChest(GameContext.get().getPlayer())) {
            Vector2 chestPos = chestHandler.getCurrentChestPosition();
            PlaceableBlock chestBlock = GameContext.get().getPlayer().getWorld().getBlockManager()
                .getBlockAt((int) chestPos.x, (int) chestPos.y);

            if (chestBlock != null && chestBlock.getType() == PlaceableBlock.BlockType.CHEST) {
                chestBlock.setChestOpen(true);
                ChestData chestData = chestBlock.getChestData();
                chestHandler.setChestOpen(true);
                gameScreen.openChestScreen(chestPos, chestData);
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.CHEST_OPEN);
            } else {
                GameLogger.error("No chest block found at position: " + chestPos);
            }
        }
    }

    private void handleBlockPlacement() {
        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();
        switch (GameContext.get().getPlayer().getDirection()) {
            case "up":    targetY++; break;
            case "down":  targetY--; break;
            case "left":  targetX--; break;
            case "right": targetX++; break;
        }

        BuildModeUI buildUI = GameContext.get().getBuildModeUI();
        if (buildUI.isInBuildingMode()) {
            if (buildUI.tryPlaceBuilding(targetX, targetY)) {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_PLACE_0);
                GameLogger.info("Building placed at " + targetX + "," + targetY);
            }
        } else {
            if (buildUI.tryPlaceBlock(targetX, targetY)) {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_PLACE_0);
                GameLogger.info("Block placed at " + targetX + "," + targetY);
            }
        }
    }

    private boolean canInteractWithCraftingTable() {
        if (GameContext.get().getPlayer() == null || GameContext.get().getPlayer().getWorld() == null) {
            GameLogger.info("Cannot interact: player or world is null");
            return false;
        }
        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();
        String direction = GameContext.get().getPlayer().getDirection();
        switch (direction) {
            case "up":    targetY++; break;
            case "down":  targetY--; break;
            case "left":  targetX--; break;
            case "right": targetX++; break;
        }

        PlaceableBlock block = GameContext.get().getPlayer().getWorld().getBlockManager().getBlockAt(targetX, targetY);
        return (block != null && block.getType() == PlaceableBlock.BlockType.CRAFTINGTABLE);
    }

    private void handleCraftingTableInteraction() {
        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();
        switch (GameContext.get().getPlayer().getDirection()) {
            case "up":    targetY++; break;
            case "down":  targetY--; break;
            case "left":  targetX--; break;
            case "right": targetX++; break;
        }
        Vector2 craftingTablePosition = new Vector2(targetX, targetY);
        gameScreen.openExpandedCrafting(craftingTablePosition);
    }

    /************************************************************************
     *  Movement key handling
     ************************************************************************/
    public void moveUp(boolean pressed)    { upPressed    = pressed; }
    public void moveDown(boolean pressed)  { downPressed  = pressed; }
    public void moveLeft(boolean pressed)  { leftPressed  = pressed; }
    public void moveRight(boolean pressed) { rightPressed = pressed; }

    /************************************************************************
     *  KeyDown / KeyUp
     ************************************************************************/
    @Override
    public boolean keyDown(int keycode) {
        InputManager.UIState currentState = inputManager.getCurrentState();
        GameLogger.info("InputHandler keyDown: keycode=" + keycode + ", currentState=" + currentState);

        // If in BUILD_MODE, handle block flipping if R is pressed
        if (currentState == InputManager.UIState.BUILD_MODE) {
            if (keycode == Input.Keys.R) {
                handleBlockFlip();
                return true;
            }
        }

        // Only process input in NORMAL and BUILD_MODE
        if (currentState != InputManager.UIState.NORMAL &&
            currentState != InputManager.UIState.BUILD_MODE) {
            return false;
        }

        // Interaction
        if (keycode == Input.Keys.X) {
            handleInteraction();
            return true;
        }

        // Movement / actions
        switch (keycode) {
            case Input.Keys.G:
                GameLogger.info("G key pressed - toggling building mode");
                if (GameContext.get().getBuildModeUI() != null) {
                    GameContext.get().getBuildModeUI().toggleBuildingMode();
                }
                return true;

            case Input.Keys.W:
            case Input.Keys.UP:
                moveUp(true);
                return true;

            case Input.Keys.S:
            case Input.Keys.DOWN:
                moveDown(true);
                return true;

            case Input.Keys.A:
            case Input.Keys.LEFT:
                moveLeft(true);
                return true;

            case Input.Keys.D:
            case Input.Keys.RIGHT:
                moveRight(true);
                return true;

            case Input.Keys.Z: // run
                GameContext.get().getPlayer().setRunning(true);
                GameLogger.info("Running Started");
                return true;

            case Input.Keys.Q: // Chop or punch
                startChopOrPunch();
                return true;

            case Input.Keys.B: // build mode
                toggleBuildMode();
                return true;

            default:
                // If in BUILD_MODE, handle numeric keys for hotbar
                if (currentState == InputManager.UIState.BUILD_MODE &&
                    keycode >= Input.Keys.NUM_1 && keycode <= Input.Keys.NUM_9) {
                    int slot = (keycode - Input.Keys.NUM_1);
                    GameContext.get().getBuildModeUI().selectSlot(slot);
                    GameLogger.info("Hotbar Slot Selected: " + slot);
                    return true;
                }
                return false;
        }
    }

    @Override
    public boolean keyUp(int keycode) {
        InputManager.UIState currentState = inputManager.getCurrentState();
        GameLogger.info("InputHandler keyUp: keycode=" + keycode + ", currentState=" + currentState);

        if (currentState != InputManager.UIState.NORMAL &&
            currentState != InputManager.UIState.BUILD_MODE) {
            return false;
        }

        switch (keycode) {
            case Input.Keys.W:
            case Input.Keys.UP:
                moveUp(false);
                return true;
            case Input.Keys.S:
            case Input.Keys.DOWN:
                moveDown(false);
                return true;
            case Input.Keys.A:
            case Input.Keys.LEFT:
                moveLeft(false);
                return true;
            case Input.Keys.D:
            case Input.Keys.RIGHT:
                moveRight(false);
                return true;
            case Input.Keys.Z:
                GameContext.get().getPlayer().setRunning(false);
                GameLogger.info("Running Stopped");
                return true;
            case Input.Keys.Q:
                stopChopOrPunch();
                return true;
        }
        return false;
    }

    public void toggleBuildMode() {
        if (inputManager.getCurrentState() == InputManager.UIState.BUILD_MODE) {
            inputManager.setUIState(InputManager.UIState.NORMAL);
            GameContext.get().getPlayer().setBuildMode(false);
        } else {
            inputManager.setUIState(InputManager.UIState.BUILD_MODE);
            GameContext.get().getPlayer().setBuildMode(true);
        }
    }

    /************************************************************************
     *  Punch / Chop combined logic
     ************************************************************************/
    public void startChopOrPunch() {
        // If we're already chopping or breaking, do nothing
        if (isChopping || isBreaking || isPunching) return;

        checkForAxe(); // sets hasAxe = true if wooden_axe found

        // Try to find a choppable object
        targetObject = findChoppableObject();
        if (targetObject != null) {
            // We have a tree/WorldObject
            isChopping = true;
            chopProgress = 0f;
            swingTimer = 0f;
            lastChopSoundTime = 0f;

            if (hasAxe) {
                GameContext.get().getPlayer().getAnimations().startChopping();
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);
            } else {
                GameContext.get().getPlayer().getAnimations().startPunching();
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD_HAND);
            }

            // Let server know
            if (GameContext.get().getGameClient() != null && !GameContext.get().getGameClient().isSinglePlayer()) {
                NetworkProtocol.PlayerAction action = new NetworkProtocol.PlayerAction();
                action.playerId = GameContext.get().getPlayer().getUsername();
                action.actionType = NetworkProtocol.ActionType.CHOP_START;
                action.targetPosition = new Vector2(targetObject.getPixelX(), targetObject.getPixelY());
                GameContext.get().getGameClient().sendPlayerAction(action);
            }

        } else {
            // If no choppable object => check for breakable block
            PlaceableBlock block = findBreakableBlock();
            if (block != null) {
                startBreaking(block);
            } else {
                // Otherwise => do punching (no block, no tree)
                isPunching = true;
                GameContext.get().getPlayer().getAnimations().startPunching();
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD_HAND);

                // Let server know
                if (GameContext.get().getGameClient() != null && !GameContext.get().getGameClient().isSinglePlayer()) {
                    NetworkProtocol.PlayerAction action = new NetworkProtocol.PlayerAction();
                    action.playerId = GameContext.get().getPlayer().getUsername();
                    action.actionType = NetworkProtocol.ActionType.PUNCH_START;
                    action.targetPosition = null; // no target
                    GameContext.get().getGameClient().sendPlayerAction(action);
                }
            }
        }
    }

    public void stopChopOrPunch() {
        // If we were chopping, breaking, or punching => stop
        if (isChopping || isBreaking) {
            isChopping = false;
            isBreaking = false;
            chopProgress = 0f;
            breakProgress = 0f;
            targetObject = null;
            targetBlock = null;
            GameContext.get().getPlayer().getAnimations().stopChopping();
            GameContext.get().getPlayer().getAnimations().stopPunching();

            // Send CHOP_STOP
            if (GameContext.get().getGameClient() != null && !GameContext.get().getGameClient().isSinglePlayer()) {
                NetworkProtocol.PlayerAction action = new NetworkProtocol.PlayerAction();
                action.playerId = GameContext.get().getPlayer().getUsername();
                action.actionType = NetworkProtocol.ActionType.CHOP_STOP;
                GameContext.get().getGameClient().sendPlayerAction(action);
            }
        }
        else if (isPunching) {
            // Stop punching
            isPunching = false;
            GameContext.get().getPlayer().getAnimations().stopPunching();

            // Send PUNCH_STOP
            if (GameContext.get().getGameClient() != null && !GameContext.get().getGameClient().isSinglePlayer()) {
                NetworkProtocol.PlayerAction action = new NetworkProtocol.PlayerAction();
                action.playerId = GameContext.get().getPlayer().getUsername();
                action.actionType = NetworkProtocol.ActionType.PUNCH_STOP;
                GameContext.get().getGameClient().sendPlayerAction(action);
            }
        }
    }

    /************************************************************************
     *  Block flipping (in build mode)
     ************************************************************************/
    private void handleBlockFlip() {
        if (!GameContext.get().getPlayer().isBuildMode()) {
            GameLogger.info("Not in build mode, can't flip");
            return;
        }

        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();
        switch (GameContext.get().getPlayer().getDirection()) {
            case "up":    targetY++; break;
            case "down":  targetY--; break;
            case "left":  targetX--; break;
            case "right": targetX++; break;
        }

        PlaceableBlock block = GameContext.get().getWorld().getBlockManager().getBlockAt(targetX, targetY);
        if (block == null) {
            GameLogger.info("No block found at target position");
            return;
        }
        if (!block.getType().isFlippable) {
            GameLogger.info("Block is not flippable: " + block.getType().id);
            return;
        }

        GameLogger.info("Flipping block " + block.getType().id + " at " + targetX + "," + targetY);
        block.toggleFlip();

        // Save updated block in chunk
        Vector2 chunkPos = new Vector2(
            Math.floorDiv(targetX, World.CHUNK_SIZE),
            Math.floorDiv(targetY, World.CHUNK_SIZE)
        );
        Chunk chunk = GameContext.get().getWorld().getChunks().get(chunkPos);
        if (chunk != null) {
            chunk.getBlocks().put(new Vector2(targetX, targetY), block);
            GameContext.get().getWorld().saveChunkData(chunkPos, chunk);
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_PLACE_0);
        } else {
            GameLogger.error("Failed to find chunk for saving flipped block");
        }
    }

    /************************************************************************
     *  Update method called each frame
     ************************************************************************/
    public void update(float deltaTime) {
        // If we are actively chopping, punching, or breaking a block => handle progress
        if (isChopping && targetObject != null) {
            updateChopping(deltaTime);
        }
        if (isBreaking && targetBlock != null) {
            updateBreaking(deltaTime);
        }
        // (If isPunching with no block or object, we do not have a “progress.”
        //  So punching is purely an animation until user releases Q.)

        // Movement
        if (inputManager.getCurrentState() == InputManager.UIState.NORMAL ||
            inputManager.getCurrentState() == InputManager.UIState.BUILD_MODE) {
            if (upPressed)    GameContext.get().getPlayer().move("up");
            if (downPressed)  GameContext.get().getPlayer().move("down");
            if (leftPressed)  GameContext.get().getPlayer().move("left");
            if (rightPressed) GameContext.get().getPlayer().move("right");
        }
    }

    /************************************************************************
     *  Chopping logic
     ************************************************************************/
    private void updateChopping(float deltaTime) {
        if (!isValidTarget(targetObject)) {
            stopChopOrPunch();
            return;
        }

        chopProgress += deltaTime;
        lastChopSoundTime += deltaTime;
        swingTimer += deltaTime;

        // If we have an actual wooden axe item => faster chop times
        ItemData axeItem = hasAxe ? findAxeInInventory() : null;
        float chopTime = (hasAxe && axeItem != null) ? TREE_CHOP_WITH_AXE_TIME : TREE_CHOP_WITHOUT_AXE_TIME;
        float soundInterval = hasAxe ? CHOP_SOUND_INTERVAL_WITH_AXE : CHOP_SOUND_INTERVAL_WITHOUT_AXE;

        // Play repeated chop/punch sounds
        if (lastChopSoundTime >= soundInterval) {
            if (hasAxe && axeItem != null) {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);
                if (swingTimer >= SWING_INTERVAL) {
                    handleToolDurabilityPerSwing(axeItem);
                    swingTimer = 0f;
                }
            } else {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD_HAND);
            }
            lastChopSoundTime = 0f;
        }

        // If we have chopped long enough => remove object
        if (chopProgress >= chopTime) {
            GameLogger.info("Tree chopped down! " + (hasAxe ? "(with axe)" : "(without axe)"));
            destroyObject(targetObject);
            stopChopOrPunch();
        }
    }

    // degrade the axe by 1 per swing
    private void handleToolDurabilityPerSwing(ItemData axeItem) {
        if (axeItem == null) return;
        axeItem.updateDurability(-DURABILITY_LOSS_PER_SWING);

        GameContext.get().getPlayer().getInventory().notifyObservers();

        if (axeItem.isBroken()) {
            playToolBreakEffect();
            // Remove broken axe
            for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                ItemData item = GameContext.get().getPlayer().getInventory().getItemAt(i);
                if (item != null && item.getUuid().equals(axeItem.getUuid())) {
                    GameContext.get().getPlayer().getInventory().removeItemAt(i);
                    break;
                }
            }
            hasAxe = false;
            stopChopOrPunch();
            GameLogger.info("Axe broke during use!");
        } else {
            if (axeItem.getDurabilityPercentage() <= 0.1f) {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.DAMAGE);
            }
        }
    }

    private void playToolBreakEffect() {
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);
        AudioManager.getInstance().playSound(AudioManager.SoundEffect.TOOL_BREAK);

        // Switch from chop anim to "punch" anim
        GameContext.get().getPlayer().getAnimations().stopChopping();
        GameContext.get().getPlayer().getAnimations().startPunching();
    }

    private boolean isValidTarget(WorldObject obj) {
        if (obj == null || GameContext.get().getPlayer() == null ||
            GameContext.get().getPlayer().getWorld() == null) {
            return false;
        }

        float playerCenterX = GameContext.get().getPlayer().getTileX() * World.TILE_SIZE + (World.TILE_SIZE / 2f);
        float playerCenterY = GameContext.get().getPlayer().getTileY() * World.TILE_SIZE + (World.TILE_SIZE / 2f);
        Rectangle treeBox = obj.getCollisionBox();
        if (treeBox == null) return false;

        float treeCenterX = treeBox.x + treeBox.width  / 2f;
        float treeCenterY = treeBox.y + treeBox.height / 2f;
        float distance = Vector2.dst(playerCenterX, playerCenterY, treeCenterX, treeCenterY);

        float maxRange = World.TILE_SIZE * 2.5f;
        Vector2 chunkPos = new Vector2(
            (int)Math.floor(obj.getPixelX() / (World.CHUNK_SIZE*World.TILE_SIZE)),
            (int)Math.floor(obj.getPixelY() / (World.CHUNK_SIZE*World.TILE_SIZE))
        );

        return GameContext.get().getPlayer().getWorld().getChunks().containsKey(chunkPos) && distance <= maxRange;
    }

    // Check if a world object is "choppable" (tree, etc.)
    private boolean isChoppable(WorldObject obj) {
        return obj.getType() == WorldObject.ObjectType.TREE_0 ||
            obj.getType() == WorldObject.ObjectType.TREE_1 ||
            obj.getType() == WorldObject.ObjectType.SNOW_TREE ||
            obj.getType() == WorldObject.ObjectType.HAUNTED_TREE ||
            obj.getType() == WorldObject.ObjectType.RAIN_TREE ||
            obj.getType() == WorldObject.ObjectType.APRICORN_TREE ||
            obj.getType() == WorldObject.ObjectType.RUINS_TREE;
    }

    private WorldObject findChoppableObject() {
        if (GameContext.get().getPlayer() == null ||
            GameContext.get().getPlayer().getWorld() == null) {
            return null;
        }

        float playerCenterX = (GameContext.get().getPlayer().getTileX() + 0.5f)* World.TILE_SIZE;
        float playerCenterY = (GameContext.get().getPlayer().getTileY() + 0.5f)* World.TILE_SIZE;
        String direction = GameContext.get().getPlayer().getDirection();

        // A small offset in front of the player
        float dirOffset = World.TILE_SIZE;
        float interactX = playerCenterX, interactY = playerCenterY;
        switch (direction) {
            case "up":    interactY += dirOffset; break;
            case "down":  interactY -= dirOffset; break;
            case "left":  interactX -= dirOffset; break;
            case "right": interactX += dirOffset; break;
        }

        // Our search area
        Rectangle searchArea = new Rectangle(
            interactX - World.TILE_SIZE * 1.5f,
            interactY - World.TILE_SIZE * 1.5f,
            World.TILE_SIZE * 3,
            World.TILE_SIZE * 3
        );

        // Grab objects near that point
        List<WorldObject> nearby = GameContext.get().getPlayer().getWorld().getObjectManager()
            .getObjectsNearPosition(interactX, interactY);

        WorldObject bestObj = null;
        float bestDist = Float.MAX_VALUE;

        for (WorldObject obj : nearby) {
            if (!isChoppable(obj)) continue;
            Rectangle objBox = obj.getCollisionBox();
            if (objBox == null) continue;

            if (objBox.overlaps(searchArea)) {
                // measure distance
                float cx = objBox.x + objBox.width/2f;
                float cy = objBox.y + objBox.height/2f;
                float dist = Vector2.dst(interactX, interactY, cx, cy);

                // optionally weigh direction
                if (dist < bestDist) {
                    bestDist = dist;
                    bestObj = obj;
                }
            }
        }

        // Only return if we are within 2.5 tiles
        return (bestDist <= World.TILE_SIZE * 2.5f) ? bestObj : null;
    }

    private ItemData findAxeInInventory() {
        Inventory inv = GameContext.get().getPlayer().getInventory();
        for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
            ItemData item = inv.getItemAt(i);
            if (item != null && item.getItemId().equals(ItemManager.ItemIDs.WOODEN_AXE)) {
                return item;
            }
        }
        return null;
    }

    private void checkForAxe() {
        List<ItemData> items = GameContext.get().getPlayer().getInventory().getAllItems();
        hasAxe = items.stream()
            .anyMatch(it -> it != null && ItemManager.ItemIDs.WOODEN_AXE.equals(it.getItemId()));
    }

    /************************************************************************
     *  Block Breaking
     ************************************************************************/
    private PlaceableBlock findBreakableBlock() {
        int targetX = GameContext.get().getPlayer().getTileX();
        int targetY = GameContext.get().getPlayer().getTileY();
        switch (GameContext.get().getPlayer().getDirection()) {
            case "up":    targetY++; break;
            case "down":  targetY--; break;
            case "left":  targetX--; break;
            case "right": targetX++; break;
        }
        return GameContext.get().getPlayer().getWorld().getBlockManager().getBlockAt(targetX, targetY);
    }

    private void startBreaking(PlaceableBlock block) {
        if (isBreaking) return;

        checkForAxe();
        isBreaking = true;
        targetBlock = block;
        breakProgress = 0f;
        lastBreakSoundTime = 0f;

        if (hasAxe) {
            GameContext.get().getPlayer().getAnimations().startChopping();
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);
        } else {
            GameContext.get().getPlayer().getAnimations().startPunching();
            AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD_HAND);
        }
    }

    private void updateBreaking(float deltaTime) {
        if (targetBlock == null) {
            if (targetObject != null) {
                updateChopping(deltaTime);
            }
            return;
        }

        breakProgress += deltaTime;
        lastBreakSoundTime += deltaTime;

        float breakInterval = hasAxe ? CHOP_SOUND_INTERVAL_WITH_AXE : CHOP_SOUND_INTERVAL_WITHOUT_AXE;
        if (lastBreakSoundTime >= breakInterval) {
            if (hasAxe) {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);
            } else {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD_HAND);
            }
            lastBreakSoundTime = 0f;
        }

        float needed = targetBlock.getType().getBreakTime(hasAxe);
        if (breakProgress >= needed) {
            destroyBlock(targetBlock);
            stopChopOrPunch(); // stop break
        }
    }

    private void destroyBlock(PlaceableBlock block) {
        if (block == null) return;

        try {
            World world = GameContext.get().getPlayer().getWorld();
            if (world == null) return;

            Vector2 pos = block.getPosition();
            Chunk chunk = world.getChunkAtPosition(pos.x, pos.y);
            if (chunk != null) {
                chunk.removeBlock(pos);

                // If multiplayer => send block remove
                if (GameContext.get().getGameClient() != null &&
                    !GameContext.get().getGameClient().isSinglePlayer()) {
                    NetworkProtocol.BlockPlacement removal = new NetworkProtocol.BlockPlacement();
                    removal.username = GameContext.get().getPlayer().getUsername();
                    removal.blockTypeId = block.getType().id;
                    removal.tileX = (int) pos.x;
                    removal.tileY = (int) pos.y;
                    removal.action = NetworkProtocol.BlockAction.REMOVE;
                    GameContext.get().getGameClient().sendBlockPlacement(removal);
                }

                // Give item to player
                String itemId = block.getType().itemId;
                if (itemId != null) {
                    ItemData blockItem = new ItemData(
                        itemId, 1, UUID.randomUUID()
                    );
                    GameContext.get().getPlayer().getInventory().addItem(blockItem);
                    GameLogger.info("Added item to inventory: " + itemId);
                } else {
                    GameLogger.error("No item ID found for block type: " + block.getType().id);
                }

                // break sound
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);

                // Save chunk
                Vector2 chunkPos = new Vector2(
                    (int)Math.floor(pos.x / World.CHUNK_SIZE),
                    (int)Math.floor(pos.y / World.CHUNK_SIZE)
                );
                world.saveChunkData(chunkPos, chunk);
            }
        } catch (Exception e) {
            GameLogger.error("Failed to destroy block: " + e.getMessage());
        }
    }

    /************************************************************************
     *  Destroying world objects (trees, etc.)
     ************************************************************************/
    private void destroyObject(WorldObject obj) {
        if (obj == null) return;

        try {
            World w = GameContext.get().getPlayer().getWorld();
            if (w == null) return;

            WorldObject.WorldObjectManager manager = w.getObjectManager();
            if (manager == null) return;

            // play break sound
            if (hasAxe) {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD);
            } else {
                AudioManager.getInstance().playSound(AudioManager.SoundEffect.BLOCK_BREAK_WOOD_HAND);
            }

            Vector2 chunkPos = new Vector2(
                (int)Math.floor(obj.getPixelX()/(World.CHUNK_SIZE*World.TILE_SIZE)),
                (int)Math.floor(obj.getPixelY()/(World.CHUNK_SIZE*World.TILE_SIZE))
            );

            // remove object locally
            manager.removeObjectFromChunk(chunkPos, obj.getId());

            // If multiplayer => broadcast removal
            if (GameContext.get().getGameClient() != null &&
                !GameContext.get().getGameClient().isSinglePlayer()) {
                NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
                update.objectId = obj.getId();
                update.type = NetworkProtocol.NetworkObjectUpdateType.REMOVE;
                update.data = obj.getSerializableData();
                GameContext.get().getGameClient().sendWorldObjectUpdate(update);
            }

            // Drop items
            int planks = hasAxe ? 4 : 1;
            ItemData woodPlanks = new ItemData("wooden_planks", planks, UUID.randomUUID());
            GameContext.get().getPlayer().getInventory().addItem(woodPlanks);

            // Save chunk
            Chunk chunk = w.getChunkAtPosition(chunkPos.x * Chunk.CHUNK_SIZE, chunkPos.y * Chunk.CHUNK_SIZE);
            if (chunk != null) {
                w.saveChunkData(chunkPos, chunk);
            }
        } catch (Exception e) {
            GameLogger.error("Failed to destroy object: " + e.getMessage());
            stopChopOrPunch();
        }
    }

    /************************************************************************
     *  Utility
     ************************************************************************/
    public void resetMovementFlags() {
        upPressed = downPressed = leftPressed = rightPressed = false;
        if (GameContext.get().getPlayer() != null) {
            GameContext.get().getPlayer().setRunning(false);
        }
    }

    public void setRunning(boolean running) {
        if (GameContext.get().getPlayer() != null) {
            GameContext.get().getPlayer().setRunning(running);
        }
    }
}

================
File: main/java/io/github/pokemeetup/system/InputManager.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.InputProcessor;
import com.badlogic.gdx.InputMultiplexer;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.screens.ChestScreen;
import io.github.pokemeetup.screens.CraftingTableScreen;
import io.github.pokemeetup.screens.GameScreen;
import io.github.pokemeetup.screens.InventoryScreen;
import io.github.pokemeetup.screens.otherui.BuildModeUI;
import io.github.pokemeetup.screens.otherui.GameMenu;
import io.github.pokemeetup.utils.GameLogger;

public class InputManager {
    private final GlobalInputProcessor globalInputProcessor;
    private final GameScreen gameScreen;
    private final InputMultiplexer inputMultiplexer;
    private UIState currentState;
    public InputManager(GameScreen gameScreen) {
        this.gameScreen = gameScreen;
        this.inputMultiplexer = new InputMultiplexer();
        this.currentState = UIState.NORMAL;
        this.globalInputProcessor = new GlobalInputProcessor(this);
        // Initialize input processors based on the initial state
        updateInputProcessors();
    }

    public void setUIState(UIState newState) {
        if (currentState != newState) {
            currentState = newState;
            GameLogger.info("Switching UI state to: " + currentState);
            handleUIStateChange();
            updateInputProcessors();
        }
    }

    public UIState getCurrentState() {
        return currentState;
    }

    private void handleUIStateChange() {
        switch (currentState) {
            case NORMAL:
                hideAllUI();
                break;
            case INVENTORY:
                showInventoryScreen();
                break;
            case BUILD_MODE:
                showBuildModeUI();
                break;
            case CRAFTING:
                showCraftingScreen();
                break;
            case MENU:
                showGameMenu();
                break;
            case CHEST_SCREEN:
                showChestScreen();
                break;
            case BATTLE:
                // Battle UI is managed separately
                break;
            case STARTER_SELECTION:
                // Starter selection is shown during initialization
                break;
        }
        if (gameScreen.getInputHandler() != null) {
            gameScreen.getInputHandler().resetMovementFlags();
        }
    }

    public void hideAllUI() {
        if (gameScreen.getInventoryScreen() != null) {
            gameScreen.getInventoryScreen().hide();
        }
        if (gameScreen.getGameMenu() != null) {
            gameScreen.getGameMenu().hide();
        }
        if (gameScreen.getBuildModeUI() != null) {
            gameScreen.getBuildModeUI().hide();
        }
        if (gameScreen.getCraftingScreen() != null) {
            gameScreen.getCraftingScreen().hide();
        }
        if (gameScreen.getChestScreen() != null) {
            gameScreen.getChestScreen().hide();
        }
    }

    private void showInventoryScreen() {
        if (gameScreen.getInventoryScreen() == null) {
            GameContext.get().setInventoryScreen(new InventoryScreen(GameContext.get().getPlayer(), gameScreen.getSkin(), GameContext.get().getPlayer().getInventory(), gameScreen.getInputManager()));
        }
        gameScreen.getInventoryScreen().show();
    }

    private void showBuildModeUI() {
        if (GameContext.get().getBuildModeUI() == null) {
            GameContext.get().setBuildModeUI(new BuildModeUI(gameScreen.getSkin()));
        }
        GameContext.get().getBuildModeUI().show();
    }

    private void showCraftingScreen() {
        if (gameScreen.getCraftingScreen() == null) {
            gameScreen.setCraftingScreen(new CraftingTableScreen(GameContext.get().getPlayer(), gameScreen.getSkin(), GameContext.get().getWorld(), GameContext.get().getGameClient(), gameScreen, this));
        }
        gameScreen.getCraftingScreen().show();
    }

    private void showGameMenu() {
        if (gameScreen.getGameMenu() == null) {
            gameScreen.setGameMenu(new GameMenu(
                gameScreen.getGame(),
                gameScreen.getSkin(),
                this
            ));
        }
        gameScreen.getGameMenu().show();
    }

    private void showChestScreen() {
        if (gameScreen.getChestScreen() == null) {
            gameScreen.setChestScreen(new ChestScreen(GameContext.get().getPlayer(), gameScreen.getSkin(), null, null, gameScreen));
        }
        gameScreen.getChestScreen().show();
    }

    public void updateInputProcessors() {
        inputMultiplexer.clear();

        if (GameContext.get().getUiStage() != null) {
            inputMultiplexer.addProcessor(GameContext.get().getUiStage());
        }

        switch (currentState) {
            case STARTER_SELECTION:
                break;
            case INVENTORY:
                if (GameContext.get().getInventoryScreen() != null) {
                    inputMultiplexer.addProcessor(GameContext.get().getInventoryScreen().getStage());
                }
                break;
            case CRAFTING:
                if (GameContext.get().getCraftingScreen() != null && GameContext.get().getCraftingScreen().getStage() != null) {
                    inputMultiplexer.addProcessor(GameContext.get().getCraftingScreen().getStage());
                }
                break;
            case MENU:
                if (GameContext.get().getGameMenu() != null && GameContext.get().getGameMenu().getStage() != null) {
                    inputMultiplexer.addProcessor(GameContext.get().getGameMenu().getStage());
                }
                break;
            case CHEST_SCREEN:
                if (gameScreen.getChestScreen() != null && gameScreen.getChestScreen().getStage() != null) {
                    inputMultiplexer.addProcessor(gameScreen.getChestScreen().getStage());
                }
                break;
            case BATTLE:
                if (gameScreen.getBattleStage() != null) {
                    inputMultiplexer.addProcessor(gameScreen.getBattleStage());
                }
                break;
            case NORMAL:
            case BUILD_MODE:
                break;
        }

        if (gameScreen.getInputHandler() != null) {
            inputMultiplexer.addProcessor(gameScreen.getInputHandler());
        }

        inputMultiplexer.addProcessor(globalInputProcessor);

        Gdx.input.setInputProcessor(inputMultiplexer);
    }


    public enum UIState {
        NORMAL,
        INVENTORY,
        BUILD_MODE,
        CRAFTING,
        MENU,
        STARTER_SELECTION,
        CHEST_SCREEN,
        BATTLE
    }
}

================
File: main/java/io/github/pokemeetup/system/PickupActionHandler.java
================
package io.github.pokemeetup.system;

// In package io.github.pokemeetup.system or a suitable package
public interface PickupActionHandler {
    void handlePickupAction();
}

================
File: main/java/io/github/pokemeetup/system/Player.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.*;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.utils.viewport.ScreenViewport;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.pokemon.PokemonParty;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.PokemonData;
import io.github.pokemeetup.system.gameplay.PlayerAnimations;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

import static io.github.pokemeetup.system.gameplay.overworld.World.INTERACTION_RANGE;
import static io.github.pokemeetup.system.gameplay.overworld.World.TILE_SIZE;

public class Player {
    public static final int FRAME_WIDTH = 32;
    public static final int FRAME_HEIGHT = 48;
    private static final float COLLISION_BOX_WIDTH_RATIO = 0.6f;
    private static final float COLLISION_BOX_HEIGHT_RATIO = 0.4f;
    private static final float TILE_TRANSITION_TIME = 0.2f;
    private static final float RUN_SPEED_MULTIPLIER = 1.5f;
    private static final float COLLISION_BUFFER = 4f;
    private static final long VALIDATION_INTERVAL = 1000;
    private static final float INPUT_BUFFER_TIME = 0.1f;
    private final Object movementLock = new Object();
    private final Object resourceLock = new Object();
    private final Object fontLock = new Object();
    private final Object inventoryLock = new Object();
    private PlayerAnimations animations;
    private String username;
    private World world;
    private float inputBufferTimer = 0f;
    private String bufferedDirection = null;
    private Vector2 position = new Vector2();
    private Rectangle collisionBox;
    private Rectangle nextPositionBox;
    private PokemonParty pokemonParty = new PokemonParty();
    private Inventory buildInventory = new Inventory();
    private Vector2 renderPosition = new Vector2();
    private Vector2 lastPosition = new Vector2();
    private Vector2 targetPosition = new Vector2();
    private Vector2 startPosition = new Vector2();
    private String direction = "down";
    private boolean isMoving = false;
    private boolean isRunning = false;
    private boolean buildMode = false;
    private TextureRegion currentFrame;
    private Inventory inventory = new Inventory();
    private float stateTime = 0f;
    private float x = 0f;
    private float y = 0f;
    private int tileX, tileY;
    private int targetTileX, targetTileY;
    private BitmapFont font;
    private PlayerData playerData;
    private float movementProgress;
    private boolean resourcesInitialized = false;
    private long lastValidationTime = 0;
    private volatile boolean disposed = false;
    private float diagonalMoveTimer = 0f;
    private volatile boolean fontInitialized = false;
    private Skin skin;
    private Stage stage;
    public Player(int startTileX, int startTileY, World world) {
        this(startTileX, startTileY, world, "Player");
        this.playerData = new PlayerData("Player");
        this.stage = new Stage(new ScreenViewport());
        this.skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));
    }

    public Player(String username, World world) {
        this(0, 0, world, username);
        GameLogger.info("Creating new player: " + username);
        this.animations = new PlayerAnimations();
        this.world = world;
        this.position = new Vector2(0, 0);
        this.targetPosition = new Vector2(0, 0);
        this.renderPosition = new Vector2(0, 0);
        this.lastPosition = new Vector2(0, 0);
        this.startPosition = new Vector2(0, 0);
        this.stage = new Stage(new ScreenViewport());
        this.skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));

        float boxWidth = FRAME_WIDTH * COLLISION_BOX_WIDTH_RATIO;
        float boxHeight = FRAME_HEIGHT * COLLISION_BOX_HEIGHT_RATIO;
        this.collisionBox = new Rectangle(0, 0, boxWidth, boxHeight);
        this.nextPositionBox = new Rectangle(0, 0, boxWidth, boxHeight);
        this.direction = "down";
        this.inventory = new Inventory();
        this.buildInventory = new Inventory();
        this.pokemonParty = new PokemonParty();
        this.playerData = new PlayerData(username);

        initFont();
        initializeBuildInventory();

        Gdx.app.postRunnable(this::initializeGraphics);
        GameLogger.info("Player initialized: " + username + " at (0,0)");
    }

    public Player(int startTileX, int startTileY, World world, String username) {
        this.world = world;
        this.username = username != null ? username : "Player";


        float boxWidth = FRAME_WIDTH * COLLISION_BOX_WIDTH_RATIO;
        float boxHeight = FRAME_HEIGHT * COLLISION_BOX_HEIGHT_RATIO;

        this.collisionBox = new Rectangle(0, 0, boxWidth, boxHeight);
        this.nextPositionBox = new Rectangle(0, 0, boxWidth, boxHeight);

        initializePosition(startTileX, startTileY);

        this.playerData = new PlayerData("Player");
        initFont();
        this.direction = "down";
        this.inventory = new Inventory();
        this.buildInventory = new Inventory();
        this.pokemonParty = new PokemonParty();

        // Load saved state if available
        initializeBuildInventory();
        initializeFromSavedState();
        this.renderPosition = new Vector2(x, y);
        this.lastPosition = new Vector2(x, y);
        Gdx.app.postRunnable(this::initializeGLResources);

    }

    private void initializeGLResources() {
        try {
            // Only create OpenGL resources here
            this.stage = new Stage(new ScreenViewport());
            this.skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));
            this.font = new BitmapFont(Gdx.files.internal("Skins/default.fnt"));
            font.getData().setScale(0.8f);
            font.setColor(Color.WHITE);
            this.animations = new PlayerAnimations();
            this.initialized = true;

            GameLogger.info("Player GL resources initialized: " + username);

        } catch (Exception e) {
            GameLogger.error("Failed to initialize GL resources: " + e.getMessage());
        }
    }
    public PlayerAnimations getAnimations() {
        return animations;
    }

    private void initializeGraphics() {
        // Post font initialization to the main thread
        Gdx.app.postRunnable(() -> {
            synchronized (fontLock) {
                if (!fontInitialized) {
                    try {
                        if (font != null) {
                            font.dispose();
                        }
                        font = new BitmapFont(Gdx.files.internal("Skins/default.fnt"));
                        font.getData().setScale(0.8f);
                        font.setColor(Color.WHITE);
                        fontInitialized = true;
                        GameLogger.info("Font initialized successfully");
                    } catch (Exception e) {
                        GameLogger.error("Failed to initialize font: " + e.getMessage());
                    }
                }
            }
        });

        this.animations = new PlayerAnimations();
    }

    private void initFont() {
        this.font = new BitmapFont(Gdx.files.internal("Skins/default.fnt"));
        font.getData().setScale(0.8f);
        font.setColor(Color.WHITE);
    }

    public void initializeInWorld(World world) {
        if (world == null) {
            GameLogger.error("Cannot initialize player in null world");
            return;
        }

        this.world = world;

        updateCollisionBoxes();

        GameLogger.info("Player initialized in world: " + username);
    }

    public void updateFromPlayerData(PlayerData data) {
        if (data == null) {
            GameLogger.error("Attempted to update from null PlayerData");
            return;
        }

        try {
            this.playerData = data;

            // Initialize pokemon party
            if (this.pokemonParty == null) {
                this.pokemonParty = new PokemonParty();
            }

            // Safely process Pokemon data
            if (data.getPartyPokemon() != null) {
                for (PokemonData pokemonData : data.getPartyPokemon()) {
                    if (pokemonData != null) {
                        try {
                            Pokemon pokemon = pokemonData.toPokemon();
                            if (pokemon != null) {
                                this.pokemonParty.addPokemon(pokemon);
                            }
                        } catch (Exception e) {
                            GameLogger.error("Error converting Pokemon data: " + e.getMessage());
                        }
                    }
                }
            }

            // Initialize inventory
            if (this.inventory == null) {
                this.inventory = new Inventory();
            }

            if (data.getInventoryItems() != null) {
                this.inventory.clear();
                for (ItemData item : data.getInventoryItems()) {
                    if (item != null) {
                        this.inventory.addItem(item);
                    }
                }
            }
            if (data.getX() != 0 || data.getY() != 0) {
                this.setX(data.getX());
                this.setY(data.getY());
            }

            GameLogger.info("Updated player data for: " + this.getUsername());

        } catch (Exception e) {
            GameLogger.error("Error updating player data: " + e.getMessage());
        }
    }

    private void initializeBuildInventory() {
        // Add default blocks to build inventory
        for (PlaceableBlock.BlockType blockType : PlaceableBlock.BlockType.values()) {
            ItemData blockItem = new ItemData(blockType.getId(), 64); // Give a stack of blocks
            buildInventory.addItem(blockItem);
        }
    }

    private void initializePosition(int startTileX, int startTileY) {
        this.tileX = startTileX;
        this.tileY = startTileY;

        this.x = tileToPixelX(startTileX);
        this.y = tileToPixelY(startTileY);

        this.position = new Vector2(x, y);
        this.targetPosition = new Vector2(x, y);
        this.renderPosition = new Vector2(x, y);
        this.lastPosition = new Vector2(x, y);
        this.startPosition = new Vector2(x, y);
        // Set initial target tiles (no movement yet
        this.targetTileX = tileX;
        this.targetTileY = tileY;
    }

    private float tileToPixelX(int tileX) {
        return tileX * World.TILE_SIZE;
    }

    private float tileToPixelY(int tileY) {
        return tileY * World.TILE_SIZE;
    }

    private int pixelToTileX(float pixelX) {
        return (int) Math.floor(pixelX / World.TILE_SIZE);
    }

    private int pixelToTileY(float pixelY) {
        return (int) Math.floor(pixelY / World.TILE_SIZE);
    }

    private void initializeFromSavedState() {
        if (world != null && world.getWorldData() != null) {
            PlayerData savedData = world.getWorldData().getPlayerData(username, false);
            if (savedData != null) {
                savedData.applyToPlayer(this);
                GameLogger.info("Loaded saved state for player: " + username);
            } else {
                this.playerData = new PlayerData(username);
                GameLogger.info("Created new player data for: " + username);
            }
        }
    }

    public float getX() {
        return x;
    }

    public void setX(float x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    public void update(float deltaTime) {
        if (!resourcesInitialized || disposed || animations == null || animations.isDisposed()) {
            initializeResources();
        }

        synchronized (movementLock) {
            // Update timers
            if (diagonalMoveTimer > 0) {
                diagonalMoveTimer -= deltaTime;
            }
            if (inputBufferTimer > 0) {
                inputBufferTimer -= deltaTime;
                if (inputBufferTimer <= 0 && bufferedDirection != null) {
                    move(bufferedDirection);
                    bufferedDirection = null;
                }
            }

            // Handle movement
            if (isMoving) {
                float speed = isRunning ? RUN_SPEED_MULTIPLIER : 1.0f;
                movementProgress += (deltaTime / TILE_TRANSITION_TIME) * speed;

                if (movementProgress >= 1.0f) {
                    completeMovement();
                } else {
                    updatePosition(movementProgress);
                }
            }

            // Update animation
            stateTime += deltaTime;
            currentFrame = animations.getCurrentFrame(direction, isMoving, isRunning, stateTime);
        }
    }

    private void updatePosition(float progress) {
        float smoothProgress = smoothstep(progress);


        x = MathUtils.lerp(startPosition.x, targetPosition.x, smoothProgress);
        y = MathUtils.lerp(startPosition.y, targetPosition.y, smoothProgress);

        position.set(x, y);
        renderPosition.set(x, y);


        updateCollisionBoxes();
    }

    private void updateCollisionBoxes() {
        // Position collision boxes in pixel coordinates
        collisionBox.setPosition(x + (FRAME_WIDTH - collisionBox.width) / 2f, y + COLLISION_BUFFER);

        nextPositionBox.setPosition(targetPosition.x + (FRAME_WIDTH - nextPositionBox.width) / 2f, targetPosition.y + COLLISION_BUFFER);
    }

    private float smoothstep(float x) {
        x = MathUtils.clamp(x, 0f, 1f);
        return x * x * (3 - 2 * x);
    }

    public void move(String newDirection) {
        synchronized (movementLock) {
            if (isMoving) {
                if (movementProgress > 0.7f) {
                    bufferedDirection = newDirection;
                    inputBufferTimer = INPUT_BUFFER_TIME;
                }
                return;
            }

            direction = newDirection;

            if (world == null) {
                GameLogger.error("Cannot move - world is null! Player: " + username);
                return;
            }

            int newTileX = getTileX();
            int newTileY = getTileY();

            switch (newDirection) {
                case "up":
                    newTileY += 1;
                    break;
                case "down":
                    newTileY -= 1;
                    break;
                case "left":
                    newTileX -= 1;
                    break;
                case "right":
                    newTileX += 1;
                    break;
                default:
                    return;
            }

            if (world != null && world.isPassable(newTileX, newTileY)) {
                targetTileX = newTileX;
                targetTileY = newTileY;
                targetPosition.set(tileToPixelX(newTileX), tileToPixelY(newTileY));
                startPosition.set(x, y);
                lastPosition.set(x, y);
                isMoving = true;
                movementProgress = 0f;
            }
        }
    }

    private void completeMovement() {
        x = targetPosition.x;
        y = targetPosition.y;
        tileX = targetTileX;
        tileY = targetTileY;
        position.set(x, y);
        renderPosition.set(x, y);

        isMoving = false;
        movementProgress = 0f;
        if (bufferedDirection != null) {
            String nextDirection = bufferedDirection;
            bufferedDirection = null;
            move(nextDirection);
        }
    }

    public volatile boolean initialized = false;
    public void render(SpriteBatch batch) {
        synchronized (resourceLock) {
            if (!initialized) {
                return;
            }
            if (!fontInitialized) {
                initializeGraphics();
                return;
            }
            if (!resourcesInitialized || disposed || animations == null || animations.isDisposed()) {
                initializeResources();
            }
            if (currentFrame != null) {
                Color originalColor = batch.getColor().cpy();

                if (world != null) {
                    // Get base color from the world
                    Color baseColor = world.getCurrentWorldColor();

                    // Convert position to tile coordinates
                    int tileX = (int) (x / World.TILE_SIZE);
                    int tileY = (int) (y / World.TILE_SIZE);
                    Vector2 tilePos = new Vector2(tileX, tileY);

                    // Get light level at this position
                    Float lightLevel = world.getLightLevelAtTile(tilePos);
                    if (lightLevel != null && lightLevel > 0) {
                        Color lightColor = new Color(1f, 0.9f, 0.7f, 1f);
                        baseColor = baseColor.cpy().lerp(lightColor, lightLevel);
                    }

                    // Set the adjusted color
                    batch.setColor(baseColor);
                }

                if (currentFrame instanceof Sprite) {
                    Sprite sprite = (Sprite) currentFrame;
                    sprite.setPosition(renderPosition.x, renderPosition.y);
                    sprite.setOrigin(0, 0);
                    sprite.draw(batch);
                } else {
                    // Use the frame's width and height directly
                    batch.draw(currentFrame, renderPosition.x, renderPosition.y,
                        currentFrame.getRegionWidth(), currentFrame.getRegionHeight());
                }

                // Restore original batch color
                batch.setColor(originalColor);
            }

            if (username != null && !username.isEmpty() && font != null &&
                !username.equals("Player") && !username.equals("ThumbnailPlayer")) {
                try {
                    font.draw(batch, username,
                        renderPosition.x - (float) FRAME_WIDTH / 2,
                        renderPosition.y + FRAME_HEIGHT + 15);
                } catch (Exception e) {
                    GameLogger.error("Font rendering error: " + e.getMessage());
                    fontInitialized = false;
                }
            }
        }
    }

    public void setRenderPosition(Vector2 renderPosition) {
        this.renderPosition = renderPosition;
    }

    public int getTileX() {
        return pixelToTileX(x);
    }

    public void setTileX(int tileX) {
        this.tileX = tileX;
    }

    public int getTileY() {
        return pixelToTileY(y);
    }

    public void setTileY(int tileY) {
        this.tileY = tileY;
    }

    public void selectBlockItem(int slot) {
        if (!buildMode) return;

        ItemData itemData = buildInventory.getItemAt(slot);
        Item heldBlock = null;
        if (itemData != null) {
            Item baseItem = ItemManager.getItem(itemData.getItemId());
            if (baseItem == null) {
                GameLogger.error("Failed to get base item for: " + itemData.getItemId());
                return;
            }
            heldBlock = baseItem.copy();
            heldBlock.setCount(itemData.getCount());

            GameLogger.info("Selected block item: " + itemData.getItemId() + " x" + itemData.getCount());
        } else {
            GameLogger.info("Cleared held block");
        }
    }

    public boolean canPickupItem(float itemX, float itemY) {
        float playerCenterX = x + (FRAME_WIDTH / 2f);
        float playerCenterY = y + (FRAME_HEIGHT / 2f);
        float itemCenterX = itemX + (TILE_SIZE / 2f);
        float itemCenterY = itemY + (TILE_SIZE / 2f);
        float dx = itemCenterX - playerCenterX;
        float dy = itemCenterY - playerCenterY;
        float distance = (float) Math.sqrt(dx * dx + dy * dy);
        boolean inCorrectDirection = false;
        switch (direction) {
            case "up":
                inCorrectDirection = dy > 0 && Math.abs(dx) < TILE_SIZE;
                break;
            case "down":
                inCorrectDirection = dy < 0 && Math.abs(dx) < TILE_SIZE;
                break;
            case "left":
                inCorrectDirection = dx < 0 && Math.abs(dy) < TILE_SIZE;
                break;
            case "right":
                inCorrectDirection = dx > 0 && Math.abs(dy) < TILE_SIZE;
                break;
        }

        boolean canPickup = distance <= INTERACTION_RANGE && inCorrectDirection;
        if (canPickup) {
            GameLogger.info("Can pickup item at distance: " + distance + " in direction: " + direction);
        }
        return canPickup;
    }

    public void updatePlayerData() {
        playerData.setX(x);
        playerData.setY(y);
        playerData.setDirection(direction);
        playerData.setMoving(isMoving);
        playerData.setWantsToRun(isRunning);
        playerData.setInventoryItems(inventory.getAllItems());

        // Create a fixed-size list for party Pokemon
        List<PokemonData> partyData = new ArrayList<>(Collections.nCopies(PokemonParty.MAX_PARTY_SIZE, null));

        synchronized (pokemonParty.partyLock) {  // Use the party's lock for thread safety
            List<Pokemon> currentParty = pokemonParty.getParty();

            // Log the current party state
            GameLogger.info("Converting party of size " + currentParty.size() + " to PokemonData");

            // Convert each Pokemon to PokemonData while maintaining slot positions
            for (int i = 0; i < PokemonParty.MAX_PARTY_SIZE; i++) {
                Pokemon pokemon = i < currentParty.size() ? currentParty.get(i) : null;
                if (pokemon != null) {
                    try {
                        PokemonData pokemonData = PokemonData.fromPokemon(pokemon);
                        if (pokemonData.verifyIntegrity()) {
                            partyData.set(i, pokemonData);
                            GameLogger.info("Added Pokemon to slot " + i + ": " + pokemon.getName());
                        } else {
                            GameLogger.error("Pokemon data failed integrity check at slot " + i);
                            partyData.set(i, null);
                        }
                    } catch (Exception e) {
                        GameLogger.error("Failed to convert Pokemon at slot " + i + ": " + e.getMessage());
                        partyData.set(i, null);
                    }
                }
            }
        }

        // Verify the party data before setting
        boolean hasValidPokemon = partyData.stream().anyMatch(Objects::nonNull);
        if (!hasValidPokemon) {
            GameLogger.error("No valid Pokemon found in party data!");
        }

        // Set the verified party data
        playerData.setPartyPokemon(partyData);

        // Log final state
        GameLogger.info("Updated player data with " +
            partyData.stream().filter(Objects::nonNull).count() + " Pokemon in party");
    }

    public void initializeResources() {
        synchronized (resourceLock) {
            try {
                if (resourcesInitialized && !disposed && animations != null && !animations.isDisposed()) {
                    return;
                }

                GameLogger.info("Initializing player resources");

                // Create new animations only if needed
                if (animations == null || animations.isDisposed()) {
                    animations = new PlayerAnimations();
                    GameLogger.info("Created new PlayerAnimations");
                }

                // Always get a fresh frame
                currentFrame = animations.getStandingFrame("down");
                if (currentFrame == null) {
                    throw new RuntimeException("Failed to get initial frame");
                }

                resourcesInitialized = true;
                disposed = false;
                GameLogger.info("Player resources initialized successfully");

            } catch (Exception e) {
                GameLogger.error("Failed to initialize player resources: " + e.getMessage());
                resourcesInitialized = false;
                disposed = true;
                throw new RuntimeException("Resource initialization failed", e);
            }
        }
    }

    public void validateResources() {
        long currentTime = System.currentTimeMillis();
        if (currentTime - lastValidationTime > VALIDATION_INTERVAL) {
            synchronized (resourceLock) {
                if (!resourcesInitialized || disposed || animations == null || animations.isDisposed()) {
                    initializeResources();
                }
                lastValidationTime = currentTime;
            }
        }
    }

    public void dispose() {
        synchronized (resourceLock) {
            if (disposed) {
                return;
            }

            Gdx.app.postRunnable(() -> {
                try {
                    GameLogger.info("Disposing player resources");

                    synchronized (fontLock) {
                        if (font != null) {
                            font.dispose();
                            font = null;
                            fontInitialized = false;
                        }
                    }

                    if (animations != null) {
                        animations.dispose();
                        animations = null;
                    }

                    currentFrame = null;
                    resourcesInitialized = false;
                    disposed = true;

                    GameLogger.info("Player resources disposed successfully");

                } catch (Exception e) {
                    GameLogger.error("Error disposing player resources: " + e.getMessage());
                }
            });
        }
    }

    public Vector2 getPosition() {
        return new Vector2(position);
    }

    public String getDirection() {
        return direction;
    }

    public void setDirection(String direction) {
        this.direction = direction;
    }

    public boolean isMoving() {
        return isMoving;
    }

    public void setMoving(boolean moving) {
        isMoving = moving;
    }

    public boolean isRunning() {
        return isRunning;
    }

    public void setRunning(boolean running) {
        this.isRunning = running;
    }

    public boolean isBuildMode() {
        return buildMode;
    }

    public void setBuildMode(boolean buildMode) {
        this.buildMode = buildMode;
    }

    public Inventory getInventory() {
        synchronized (inventoryLock) {
            if (inventory == null) {
                GameLogger.error("Player inventory is null - creating new");
                inventory = new Inventory();
            }
            return inventory;
        }
    }

    public void setInventory(Inventory inv) {
        synchronized (inventoryLock) {
            if (inv == null) {
                GameLogger.error("Attempt to set null inventory");
                return;
            }

            // Copy items from old inventory if it exists
            if (this.inventory != null) {
                List<ItemData> oldItems = this.inventory.getAllItems();
                for (ItemData item : oldItems) {
                    if (item != null) {
                        inv.addItem(item.copy());
                    }
                }
            }

            this.inventory = inv;
            GameLogger.info("Set player inventory with " +
                inv.getAllItems().stream().filter(Objects::nonNull).count() + " items");
        }
    }

    public Inventory getBuildInventory() {
        return buildInventory;
    }

    public PokemonParty getPokemonParty() {
        return pokemonParty;
    }

    public void setPokemonParty(PokemonParty pokemonParty) {
        this.pokemonParty = pokemonParty;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public World getWorld() {
        return world;
    }

    // Pokemon Management

    public void setWorld(World world) {
        synchronized (movementLock) {
            this.world = world;
        }
    }

    public PlayerData getPlayerData() {
        return playerData;
    }

    public void setPlayerData(PlayerData playerData) {
        this.playerData = playerData;
    }


    public Stage getStage() {
        return stage;
    }

    public void setStage(Stage stage) {
        this.stage = stage;
    }

    public Skin getSkin() {
        return skin;
    }

    public void setSkin(Skin skin) {
        this.skin = skin;
    }
}

================
File: main/java/io/github/pokemeetup/system/servers/PluginContext.java
================
package io.github.pokemeetup.system.servers;

import io.github.pokemeetup.system.data.WorldData;

import java.util.Map;

public class PluginContext {
    private WorldData world;
    private Map<String, Object> config;

    public PluginContext(WorldData world, Map<String, Object> config) {
        this.world = world;
        this.config = config;
    }

    public WorldData getWorld() { return world; }
    public Map<String, Object> getConfig() { return config; }
}

================
File: main/java/io/github/pokemeetup/system/UITransitionManager.java
================
package io.github.pokemeetup.system;

import com.badlogic.gdx.graphics.Color;

public class UITransitionManager {
    public static final float DEFAULT_TRANSITION_TIME = 0.3f;
    private final Color color = new Color(1, 1, 1, 1);
    private float alpha = 1f;
    private TransitionAction currentTransition;

    public void startShowTransition(float duration, Runnable onComplete) {
        clearTransitions();
        currentTransition = new TransitionAction(
            duration,
            0f,
            1f,
            onComplete
        );
    }

    public void startHideTransition(float duration, Runnable onComplete) {
        clearTransitions();
        currentTransition = new TransitionAction(
            duration,
            1f,
            0f,
            onComplete
        );
    }

    public void update(float delta) {
        if (currentTransition != null) {
            currentTransition.update(delta);
        }
    }

    public void clearTransitions() {
        if (currentTransition != null) {
            currentTransition.complete();
            currentTransition = null;
        }
    }

    public Color getColor() {
        return color;
    }

    public class TransitionAction {
        private final float duration;
        private final float startAlpha;
        private final float targetAlpha;
        private final Runnable onComplete;
        private float currentTime = 0;
        private boolean isComplete = false;

        public TransitionAction(float duration, float startAlpha, float targetAlpha, Runnable onComplete) {
            this.duration = duration;
            this.startAlpha = startAlpha;
            this.targetAlpha = targetAlpha;
            this.onComplete = onComplete;
        }

        public void update(float delta) {
            if (isComplete) return;

            currentTime += delta;
            float progress = Math.min(currentTime / duration, 1f);
            float smoothProgress = smoothStep(progress);
            alpha = startAlpha + (targetAlpha - startAlpha) * smoothProgress;
            color.a = alpha;

            if (progress >= 1f) {
                complete();
            }
        }

        public void complete() {
            if (isComplete) return;
            isComplete = true;
            alpha = targetAlpha;
            color.a = alpha;
            if (onComplete != null) {
                onComplete.run();
            }
        }

        private float smoothStep(float x) {
            return x * x * (3 - 2 * x);
        }
    }
}

================
File: main/java/io/github/pokemeetup/utils/ChunkPos.java
================
package io.github.pokemeetup.utils;

import java.io.Serializable;

public class ChunkPos implements Serializable {
    public final int x;
    public final int y;

    public ChunkPos(int x, int y) {
        this.x = x;
        this.y = y;
    }

    // Override equals and hashCode using integers
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof ChunkPos)) return false;
        ChunkPos other = (ChunkPos) obj;
        return x == other.x && y == other.y;
    }

    @Override
    public int hashCode() {
        return 31 * x + y;
    }

    @Override
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

================
File: main/java/io/github/pokemeetup/utils/DialogStyles.java
================
package io.github.pokemeetup.utils;

import com.badlogic.gdx.scenes.scene2d.ui.*;

public class DialogStyles {
    public static void applyStyles(Skin skin) {
        // Window style for dialogs
        Window.WindowStyle windowStyle = skin.get(Window.WindowStyle.class);
        windowStyle.titleFont.getData().setScale(1.2f);

        // Text button style
        TextButton.TextButtonStyle buttonStyle = skin.get(TextButton.TextButtonStyle.class);
        buttonStyle.font.getData().setScale(1.0f);

        // Label styles
        Label.LabelStyle titleStyle = new Label.LabelStyle(skin.get(Label.LabelStyle.class));
        titleStyle.font.getData().setScale(1.2f);
        skin.add("title", titleStyle);

        Label.LabelStyle smallStyle = new Label.LabelStyle(skin.get(Label.LabelStyle.class));
        smallStyle.font.getData().setScale(0.8f);
        skin.add("small", smallStyle);

        // TextField style
        TextField.TextFieldStyle textFieldStyle = skin.get(TextField.TextFieldStyle.class);
        textFieldStyle.font.getData().setScale(1.0f);
    }
}

================
File: main/java/io/github/pokemeetup/utils/GameInitializer.java
================
package io.github.pokemeetup.utils;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;

public class GameInitializer {
    private static String basePath = "";
    private static boolean isAndroid = false;
    private static boolean isInitialized = false;

    public static void init(String internalPath, boolean isAndroidPlatform) {
        basePath = internalPath;
        isAndroid = isAndroidPlatform;
        // Don't create directories here - wait for Gdx to be initialized
    }

    public static void initializeDirectories() {
        if (!isInitialized && Gdx.files != null) {
            createRequiredDirectories();
            isInitialized = true;
        }
    }

    private static void createRequiredDirectories() {
        if (Gdx.files == null) return;

        String[] dirs = {"worlds", "save", "configs", "atlas", "audio"};
        for (String dir : dirs) {
            String fullPath = getFullPath(dir);
            if (isAndroid) {
                java.io.File directory = new java.io.File(fullPath);
                if (!directory.exists()) {
                    directory.mkdirs();
                }
            } else {
                FileHandle dirHandle = Gdx.files.local(dir);
                if (!dirHandle.exists()) {
                    dirHandle.mkdirs();
                }
            }
        }
    }

    public static FileHandle getFileHandle(String path) {
        if (Gdx.files == null) {
            throw new IllegalStateException("Gdx.files not initialized yet");
        }

        if (isAndroid) {
            return new FileHandle(new java.io.File(basePath + path));
        }
        return Gdx.files.local(path);
    }

    public static String getFullPath(String path) {
        return isAndroid ? basePath + path : path;
    }

    public static boolean isAndroid() {
        return isAndroid;
    }
}

================
File: main/java/io/github/pokemeetup/utils/GameLogger.java
================
package io.github.pokemeetup.utils;

import com.badlogic.gdx.Gdx;

public class GameLogger {
    public static boolean isInfoEnabled = true;
    public static boolean isErrorEnabled = true;

    public static void info(String message) {
        if (isInfoEnabled) {
            if (Gdx.app != null) {
                Gdx.app.log("Game", message);
            } else {
                System.out.println(message);
            }
        }
    }

    public static void error(String message) {
        if (isErrorEnabled) {
            if (Gdx.app != null) {
                Gdx.app.error("Game", message);
            } else {
                System.out.println(message);
            }
        }
    }
}

================
File: main/java/io/github/pokemeetup/utils/OpenSimplex2.java
================
package io.github.pokemeetup.utils;

public class OpenSimplex2 {

    private static final long PRIME_X = 0x5205402B9270C86FL;
    private static final long PRIME_Y = 0x598CD327003817B5L;
    private static final long PRIME_Z = 0x5BCC226E9FA0BACBL;
    private static final long PRIME_W = 0x56CC5227E58F554BL;
    private static final long HASH_MULTIPLIER = 0x53A3F72DEEC546F5L;
    private static final long SEED_FLIP_3D = -0x52D547B2E96ED629L;
    private static final long SEED_OFFSET_4D = 0xE83DC3E0DA7164DL;

    private static final double ROOT2OVER2 = 0.7071067811865476;
    private static final double SKEW_2D = 0.366025403784439;
    private static final double UNSKEW_2D = -0.21132486540518713;

    private static final double ROOT3OVER3 = 0.577350269189626;
    private static final double FALLBACK_ROTATE_3D = 2.0 / 3.0;
    private static final double ROTATE_3D_ORTHOGONALIZER = UNSKEW_2D;

    private static final float SKEW_4D = -0.138196601125011f;
    private static final float UNSKEW_4D = 0.309016994374947f;
    private static final float LATTICE_STEP_4D = 0.2f;

    private static final int N_GRADS_2D_EXPONENT = 7;
    private static final int N_GRADS_3D_EXPONENT = 8;
    private static final int N_GRADS_4D_EXPONENT = 9;
    private static final int N_GRADS_2D = 1 << N_GRADS_2D_EXPONENT;
    private static final int N_GRADS_3D = 1 << N_GRADS_3D_EXPONENT;
    private static final int N_GRADS_4D = 1 << N_GRADS_4D_EXPONENT;

    private static final double NORMALIZER_2D = 0.01001634121365712;
    private static final double NORMALIZER_3D = 0.07969837668935331;
    private static final double NORMALIZER_4D = 0.0220065933241897;

    private static final float RSQUARED_2D = 0.5f;
    private static final float RSQUARED_3D = 0.6f;
    private static final float RSQUARED_4D = 0.6f;


    /*
     * Noise Evaluators
     */

    /**
     * 2D Simplex noise, standard lattice orientation.
     */
    public static float noise2(long seed, double x, double y) {

        // Get points for A2* lattice
        double s = SKEW_2D * (x + y);
        double xs = x + s, ys = y + s;

        return noise2_UnskewedBase(seed, xs, ys);
    }

    /**
     * 2D Simplex noise, with Y pointing down the main diagonal.
     * Might be better for a 2D sandbox style game, where Y is vertical.
     * Probably slightly less optimal for heightmaps or continent maps,
     * unless your map is centered around an equator. It's a subtle
     * difference, but the option is here to make it an easy choice.
     */
    public static float noise2_ImproveX(long seed, double x, double y) {

        // Skew transform and rotation baked into one.
        double xx = x * ROOT2OVER2;
        double yy = y * (ROOT2OVER2 * (1 + 2 * SKEW_2D));

        return noise2_UnskewedBase(seed, yy + xx, yy - xx);
    }

    /**
     * 2D Simplex noise base.
     */
    private static float noise2_UnskewedBase(long seed, double xs, double ys) {

        // Get base points and offsets.
        int xsb = fastFloor(xs), ysb = fastFloor(ys);
        float xi = (float)(xs - xsb), yi = (float)(ys - ysb);

        // Prime pre-multiplication for hash.
        long xsbp = xsb * PRIME_X, ysbp = ysb * PRIME_Y;

        // Unskew.
        float t = (xi + yi) * (float)UNSKEW_2D;
        float dx0 = xi + t, dy0 = yi + t;

        // First vertex.
        float value = 0;
        float a0 = RSQUARED_2D - dx0 * dx0 - dy0 * dy0;
        if (a0 > 0) {
            value = (a0 * a0) * (a0 * a0) * grad(seed, xsbp, ysbp, dx0, dy0);
        }

        // Second vertex.
        float a1 = (float)(2 * (1 + 2 * UNSKEW_2D) * (1 / UNSKEW_2D + 2)) * t + ((float)(-2 * (1 + 2 * UNSKEW_2D) * (1 + 2 * UNSKEW_2D)) + a0);
        if (a1 > 0) {
            float dx1 = dx0 - (float)(1 + 2 * UNSKEW_2D);
            float dy1 = dy0 - (float)(1 + 2 * UNSKEW_2D);
            value += (a1 * a1) * (a1 * a1) * grad(seed, xsbp + PRIME_X, ysbp + PRIME_Y, dx1, dy1);
        }

        // Third vertex.
        if (dy0 > dx0) {
            float dx2 = dx0 - (float)UNSKEW_2D;
            float dy2 = dy0 - (float)(UNSKEW_2D + 1);
            float a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if (a2 > 0) {
                value += (a2 * a2) * (a2 * a2) * grad(seed, xsbp, ysbp + PRIME_Y, dx2, dy2);
            }
        }
        else
        {
            float dx2 = dx0 - (float)(UNSKEW_2D + 1);
            float dy2 = dy0 - (float)UNSKEW_2D;
            float a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if (a2 > 0) {
                value += (a2 * a2) * (a2 * a2) * grad(seed, xsbp + PRIME_X, ysbp, dx2, dy2);
            }
        }

        return value;
    }

    /**
     * 3D OpenSimplex2 noise, with better visual isotropy in (X, Y).
     * Recommended for 3D terrain and time-varied animations.
     * The Z coordinate should always be the "different" coordinate in whatever your use case is.
     * If Y is vertical in world coordinates, call noise3_ImproveXZ(x, z, Y) or use noise3_XZBeforeY.
     * If Z is vertical in world coordinates, call noise3_ImproveXZ(x, y, Z).
     * For a time varied animation, call noise3_ImproveXY(x, y, T).
     */
    public static float noise3_ImproveXY(long seed, double x, double y, double z) {

        // Re-orient the cubic lattices without skewing, so Z points up the main lattice diagonal,
        // and the planes formed by XY are moved far out of alignment with the cube faces.
        // Orthonormal rotation. Not a skew transform.
        double xy = x + y;
        double s2 = xy * ROTATE_3D_ORTHOGONALIZER;
        double zz = z * ROOT3OVER3;
        double xr = x + s2 + zz;
        double yr = y + s2 + zz;
        double zr = xy * -ROOT3OVER3 + zz;

        // Evaluate both lattices to form a BCC lattice.
        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    /**
     * 3D OpenSimplex2 noise, with better visual isotropy in (X, Z).
     * Recommended for 3D terrain and time-varied animations.
     * The Y coordinate should always be the "different" coordinate in whatever your use case is.
     * If Y is vertical in world coordinates, call noise3_ImproveXZ(x, Y, z).
     * If Z is vertical in world coordinates, call noise3_ImproveXZ(x, Z, y) or use noise3_ImproveXY.
     * For a time varied animation, call noise3_ImproveXZ(x, T, y) or use noise3_ImproveXY.
     */
    public static float noise3_ImproveXZ(long seed, double x, double y, double z) {

        // Re-orient the cubic lattices without skewing, so Y points up the main lattice diagonal,
        // and the planes formed by XZ are moved far out of alignment with the cube faces.
        // Orthonormal rotation. Not a skew transform.
        double xz = x + z;
        double s2 = xz * ROTATE_3D_ORTHOGONALIZER;
        double yy = y * ROOT3OVER3;
        double xr = x + s2 + yy;
        double zr = z + s2 + yy;
        double yr = xz * -ROOT3OVER3 + yy;

        // Evaluate both lattices to form a BCC lattice.
        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    /**
     * 3D OpenSimplex2 noise, fallback rotation option
     * Use noise3_ImproveXY or noise3_ImproveXZ instead, wherever appropriate.
     * They have less diagonal bias. This function's best use is as a fallback.
     */
    public static float noise3_Fallback(long seed, double x, double y, double z) {

        // Re-orient the cubic lattices via rotation, to produce a familiar look.
        // Orthonormal rotation. Not a skew transform.
        double r = FALLBACK_ROTATE_3D * (x + y + z);
        double xr = r - x, yr = r - y, zr = r - z;

        // Evaluate both lattices to form a BCC lattice.
        return noise3_UnrotatedBase(seed, xr, yr, zr);
    }

    /**
     * Generate overlapping cubic lattices for 3D OpenSimplex2 noise.
     */
    private static float noise3_UnrotatedBase(long seed, double xr, double yr, double zr) {

        // Get base points and offsets.
        int xrb = fastRound(xr), yrb = fastRound(yr), zrb = fastRound(zr);
        float xri = (float)(xr - xrb), yri = (float)(yr - yrb), zri = (float)(zr - zrb);

        // -1 if positive, 1 if negative.
        int xNSign = (int)(-1.0f - xri) | 1, yNSign = (int)(-1.0f - yri) | 1, zNSign = (int)(-1.0f - zri) | 1;

        // Compute absolute values, using the above as a shortcut. This was faster in my tests for some reason.
        float ax0 = xNSign * -xri, ay0 = yNSign * -yri, az0 = zNSign * -zri;

        // Prime pre-multiplication for hash.
        long xrbp = xrb * PRIME_X, yrbp = yrb * PRIME_Y, zrbp = zrb * PRIME_Z;

        // Loop: Pick an edge on each lattice copy.
        float value = 0;
        float a = (RSQUARED_3D - xri * xri) - (yri * yri + zri * zri);
        for (int l = 0; ; l++) {

            // Closest point on cube.
            if (a > 0) {
                value += (a * a) * (a * a) * grad(seed, xrbp, yrbp, zrbp, xri, yri, zri);
            }

            // Second-closest point.
            if (ax0 >= ay0 && ax0 >= az0) {
                float b = a + ax0 + ax0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp - xNSign * PRIME_X, yrbp, zrbp, xri + xNSign, yri, zri);
                }
            }
            else if (ay0 > ax0 && ay0 >= az0) {
                float b = a + ay0 + ay0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp, yrbp - yNSign * PRIME_Y, zrbp, xri, yri + yNSign, zri);
                }
            }
            else
            {
                float b = a + az0 + az0;
                if (b > 1) {
                    b -= 1;
                    value += (b * b) * (b * b) * grad(seed, xrbp, yrbp, zrbp - zNSign * PRIME_Z, xri, yri, zri + zNSign);
                }
            }

            // Break from loop if we're done, skipping updates below.
            if (l == 1) break;

            // Update absolute value.
            ax0 = 0.5f - ax0;
            ay0 = 0.5f - ay0;
            az0 = 0.5f - az0;

            // Update relative coordinate.
            xri = xNSign * ax0;
            yri = yNSign * ay0;
            zri = zNSign * az0;

            // Update falloff.
            a += (0.75f - ax0) - (ay0 + az0);

            // Update prime for hash.
            xrbp += (xNSign >> 1) & PRIME_X;
            yrbp += (yNSign >> 1) & PRIME_Y;
            zrbp += (zNSign >> 1) & PRIME_Z;

            // Update the reverse sign indicators.
            xNSign = -xNSign;
            yNSign = -yNSign;
            zNSign = -zNSign;

            // And finally update the seed for the other lattice copy.
            seed ^= SEED_FLIP_3D;
        }

        return value;
    }

    /**
     * 4D OpenSimplex2 noise, with XYZ oriented like noise3_ImproveXY
     * and W for an extra degree of freedom. W repeats eventually.
     * Recommended for time-varied animations which texture a 3D object (W=time)
     * in a space where Z is vertical
     */
    public static float noise4_ImproveXYZ_ImproveXY(long seed, double x, double y, double z, double w) {

        double xy = x + y;
        double s2 = xy * -0.21132486540518699998;
        double zz = z * 0.28867513459481294226;
        double ww = w * 0.2236067977499788;
        double xr = x + (zz + ww + s2), yr = y + (zz + ww + s2);
        double zr = xy * -0.57735026918962599998 + (zz + ww);
        double wr = z * -0.866025403784439 + ww;

        return noise4_UnskewedBase(seed, xr, yr, zr, wr);
    }

    /**
     * 4D OpenSimplex2 noise, with XYZ oriented like noise3_ImproveXZ
     * and W for an extra degree of freedom. W repeats eventually.
     * Recommended for time-varied animations which texture a 3D object (W=time)
     * in a space where Y is vertical
     */
    public static float noise4_ImproveXYZ_ImproveXZ(long seed, double x, double y, double z, double w) {

        double xz = x + z;
        double s2 = xz * -0.21132486540518699998;
        double yy = y * 0.28867513459481294226;
        double ww = w * 0.2236067977499788;
        double xr = x + (yy + ww + s2), zr = z + (yy + ww + s2);
        double yr = xz * -0.57735026918962599998 + (yy + ww);
        double wr = y * -0.866025403784439 + ww;

        return noise4_UnskewedBase(seed, xr, yr, zr, wr);
    }

    /**
     * 4D OpenSimplex2 noise, with XYZ oriented like noise3_Fallback
     * and W for an extra degree of freedom. W repeats eventually.
     * Recommended for time-varied animations which texture a 3D object (W=time)
     * where there isn't a clear distinction between horizontal and vertical
     */
    public static float noise4_ImproveXYZ(long seed, double x, double y, double z, double w) {

        double xyz = x + y + z;
        double ww = w * 0.2236067977499788;
        double s2 = xyz * -0.16666666666666666 + ww;
        double xs = x + s2, ys = y + s2, zs = z + s2, ws = -0.5 * xyz + ww;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    /**
     * 4D OpenSimplex2 noise, with XY and ZW forming orthogonal triangular-based planes.
     * Recommended for 3D terrain, where X and Y (or Z and W) are horizontal.
     * Recommended for noise(x, y, sin(time), cos(time)) trick.
     */
    public static float noise4_ImproveXY_ImproveZW(long seed, double x, double y, double z, double w) {

        double s2 = (x + y) * -0.178275657951399372 + (z + w) * 0.215623393288842828;
        double t2 = (z + w) * -0.403949762580207112 + (x + y) * -0.375199083010075342;
        double xs = x + s2, ys = y + s2, zs = z + t2, ws = w + t2;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    /**
     * 4D OpenSimplex2 noise, fallback lattice orientation.
     */
    public static float noise4_Fallback(long seed, double x, double y, double z, double w) {

        // Get points for A4 lattice
        double s = SKEW_4D * (x + y + z + w);
        double xs = x + s, ys = y + s, zs = z + s, ws = w + s;

        return noise4_UnskewedBase(seed, xs, ys, zs, ws);
    }

    /**
     * 4D OpenSimplex2 noise base.
     */
    private static float noise4_UnskewedBase(long seed, double xs, double ys, double zs, double ws) {

        // Get base points and offsets
        int xsb = fastFloor(xs), ysb = fastFloor(ys), zsb = fastFloor(zs), wsb = fastFloor(ws);
        float xsi = (float)(xs - xsb), ysi = (float)(ys - ysb), zsi = (float)(zs - zsb), wsi = (float)(ws - wsb);

        // Determine which lattice we can be confident has a contributing point its corresponding cell's base simplex.
        // We only look at the spaces between the diagonal planes. This proved effective in all of my tests.
        float siSum = (xsi + ysi) + (zsi + wsi);
        int startingLattice = (int)(siSum * 1.25);

        // Offset for seed based on first lattice copy.
        seed += startingLattice * SEED_OFFSET_4D;

        // Offset for lattice point relative positions (skewed)
        float startingLatticeOffset = startingLattice * -LATTICE_STEP_4D;
        xsi += startingLatticeOffset; ysi += startingLatticeOffset; zsi += startingLatticeOffset; wsi += startingLatticeOffset;

        // Prep for vertex contributions.
        float ssi = (siSum + startingLatticeOffset * 4) * UNSKEW_4D;

        // Prime pre-multiplication for hash.
        long xsvp = xsb * PRIME_X, ysvp = ysb * PRIME_Y, zsvp = zsb * PRIME_Z, wsvp = wsb * PRIME_W;

        // Five points to add, total, from five copies of the A4 lattice.
        float value = 0;
        for (int i = 0; ; i++) {

            // Next point is the closest vertex on the 4-simplex whose base vertex is the aforementioned vertex.
            double score0 = 1.0 + ssi * (-1.0 / UNSKEW_4D); // Seems slightly faster than 1.0-xsi-ysi-zsi-wsi
            if (xsi >= ysi && xsi >= zsi && xsi >= wsi && xsi >= score0) {
                xsvp += PRIME_X;
                xsi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (ysi > xsi && ysi >= zsi && ysi >= wsi && ysi >= score0) {
                ysvp += PRIME_Y;
                ysi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (zsi > xsi && zsi > ysi && zsi >= wsi && zsi >= score0) {
                zsvp += PRIME_Z;
                zsi -= 1;
                ssi -= UNSKEW_4D;
            }
            else if (wsi > xsi && wsi > ysi && wsi > zsi && wsi >= score0) {
                wsvp += PRIME_W;
                wsi -= 1;
                ssi -= UNSKEW_4D;
            }

            // gradient contribution with falloff.
            float dx = xsi + ssi, dy = ysi + ssi, dz = zsi + ssi, dw = wsi + ssi;
            float a = (dx * dx + dy * dy) + (dz * dz + dw * dw);
            if (a < RSQUARED_4D) {
                a -= RSQUARED_4D;
                a *= a;
                value += a * a * grad(seed, xsvp, ysvp, zsvp, wsvp, dx, dy, dz, dw);
            }

            // Break from loop if we're done, skipping updates below.
            if (i == 4) break;

            // Update for next lattice copy shifted down by <-0.2, -0.2, -0.2, -0.2>.
            xsi += LATTICE_STEP_4D; ysi += LATTICE_STEP_4D; zsi += LATTICE_STEP_4D; wsi += LATTICE_STEP_4D;
            ssi += LATTICE_STEP_4D * 4 * UNSKEW_4D;
            seed -= SEED_OFFSET_4D;

            // Because we don't always start on the same lattice copy, there's a special reset case.
            if (i == startingLattice) {
                xsvp -= PRIME_X;
                ysvp -= PRIME_Y;
                zsvp -= PRIME_Z;
                wsvp -= PRIME_W;
                seed += SEED_OFFSET_4D * 5;
            }
        }

        return value;
    }

    /*
     * Utility
     */

    private static float grad(long seed, long xsvp, long ysvp, float dx, float dy) {
        long hash = seed ^ xsvp ^ ysvp;
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_2D_EXPONENT + 1);
        int gi = (int)hash & ((N_GRADS_2D - 1) << 1);
        return GRADIENTS_2D[gi | 0] * dx + GRADIENTS_2D[gi | 1] * dy;
    }

    private static float grad(long seed, long xrvp, long yrvp, long zrvp, float dx, float dy, float dz) {
        long hash = (seed ^ xrvp) ^ (yrvp ^ zrvp);
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_3D_EXPONENT + 2);
        int gi = (int)hash & ((N_GRADS_3D - 1) << 2);
        return GRADIENTS_3D[gi | 0] * dx + GRADIENTS_3D[gi | 1] * dy + GRADIENTS_3D[gi | 2] * dz;
    }

    private static float grad(long seed, long xsvp, long ysvp, long zsvp, long wsvp, float dx, float dy, float dz, float dw) {
        long hash = seed ^ (xsvp ^ ysvp) ^ (zsvp ^ wsvp);
        hash *= HASH_MULTIPLIER;
        hash ^= hash >> (64 - N_GRADS_4D_EXPONENT + 2);
        int gi = (int)hash & ((N_GRADS_4D - 1) << 2);
        return (GRADIENTS_4D[gi | 0] * dx + GRADIENTS_4D[gi | 1] * dy) + (GRADIENTS_4D[gi | 2] * dz + GRADIENTS_4D[gi | 3] * dw);
    }

    private static int fastFloor(double x) {
        int xi = (int)x;
        return x < xi ? xi - 1 : xi;
    }

    private static int fastRound(double x) {
        return x < 0 ? (int)(x - 0.5) : (int)(x + 0.5);
    }

    /*
     * gradients
     */

    private static float[] GRADIENTS_2D;
    private static float[] GRADIENTS_3D;
    private static float[] GRADIENTS_4D;
    static {

        GRADIENTS_2D = new float[N_GRADS_2D * 2];
        float[] grad2 = {
            0.38268343236509f,   0.923879532511287f,
            0.923879532511287f,  0.38268343236509f,
            0.923879532511287f, -0.38268343236509f,
            0.38268343236509f,  -0.923879532511287f,
            -0.38268343236509f,  -0.923879532511287f,
            -0.923879532511287f, -0.38268343236509f,
            -0.923879532511287f,  0.38268343236509f,
            -0.38268343236509f,   0.923879532511287f,
            //-------------------------------------//
            0.130526192220052f,  0.99144486137381f,
            0.608761429008721f,  0.793353340291235f,
            0.793353340291235f,  0.608761429008721f,
            0.99144486137381f,   0.130526192220051f,
            0.99144486137381f,  -0.130526192220051f,
            0.793353340291235f, -0.60876142900872f,
            0.608761429008721f, -0.793353340291235f,
            0.130526192220052f, -0.99144486137381f,
            -0.130526192220052f, -0.99144486137381f,
            -0.608761429008721f, -0.793353340291235f,
            -0.793353340291235f, -0.608761429008721f,
            -0.99144486137381f,  -0.130526192220052f,
            -0.99144486137381f,   0.130526192220051f,
            -0.793353340291235f,  0.608761429008721f,
            -0.608761429008721f,  0.793353340291235f,
            -0.130526192220052f,  0.99144486137381f,
        };
        for (int i = 0; i < grad2.length; i++) {
            grad2[i] = (float)(grad2[i] / NORMALIZER_2D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_2D.length; i++, j++) {
            if (j == grad2.length) j = 0;
            GRADIENTS_2D[i] = grad2[j];
        }

        GRADIENTS_3D = new float[N_GRADS_3D * 4];
        float[] grad3 = {
            2.22474487139f,       2.22474487139f,      -1.0f,                 0.0f,
            2.22474487139f,       2.22474487139f,       1.0f,                 0.0f,
            3.0862664687972017f,  1.1721513422464978f,  0.0f,                 0.0f,
            1.1721513422464978f,  3.0862664687972017f,  0.0f,                 0.0f,
            -2.22474487139f,       2.22474487139f,      -1.0f,                 0.0f,
            -2.22474487139f,       2.22474487139f,       1.0f,                 0.0f,
            -1.1721513422464978f,  3.0862664687972017f,  0.0f,                 0.0f,
            -3.0862664687972017f,  1.1721513422464978f,  0.0f,                 0.0f,
            -1.0f,                -2.22474487139f,      -2.22474487139f,       0.0f,
            1.0f,                -2.22474487139f,      -2.22474487139f,       0.0f,
            0.0f,                -3.0862664687972017f, -1.1721513422464978f,  0.0f,
            0.0f,                -1.1721513422464978f, -3.0862664687972017f,  0.0f,
            -1.0f,                -2.22474487139f,       2.22474487139f,       0.0f,
            1.0f,                -2.22474487139f,       2.22474487139f,       0.0f,
            0.0f,                -1.1721513422464978f,  3.0862664687972017f,  0.0f,
            0.0f,                -3.0862664687972017f,  1.1721513422464978f,  0.0f,
            //--------------------------------------------------------------------//
            -2.22474487139f,      -2.22474487139f,      -1.0f,                 0.0f,
            -2.22474487139f,      -2.22474487139f,       1.0f,                 0.0f,
            -3.0862664687972017f, -1.1721513422464978f,  0.0f,                 0.0f,
            -1.1721513422464978f, -3.0862664687972017f,  0.0f,                 0.0f,
            -2.22474487139f,      -1.0f,                -2.22474487139f,       0.0f,
            -2.22474487139f,       1.0f,                -2.22474487139f,       0.0f,
            -1.1721513422464978f,  0.0f,                -3.0862664687972017f,  0.0f,
            -3.0862664687972017f,  0.0f,                -1.1721513422464978f,  0.0f,
            -2.22474487139f,      -1.0f,                 2.22474487139f,       0.0f,
            -2.22474487139f,       1.0f,                 2.22474487139f,       0.0f,
            -3.0862664687972017f,  0.0f,                 1.1721513422464978f,  0.0f,
            -1.1721513422464978f,  0.0f,                 3.0862664687972017f,  0.0f,
            -1.0f,                 2.22474487139f,      -2.22474487139f,       0.0f,
            1.0f,                 2.22474487139f,      -2.22474487139f,       0.0f,
            0.0f,                 1.1721513422464978f, -3.0862664687972017f,  0.0f,
            0.0f,                 3.0862664687972017f, -1.1721513422464978f,  0.0f,
            -1.0f,                 2.22474487139f,       2.22474487139f,       0.0f,
            1.0f,                 2.22474487139f,       2.22474487139f,       0.0f,
            0.0f,                 3.0862664687972017f,  1.1721513422464978f,  0.0f,
            0.0f,                 1.1721513422464978f,  3.0862664687972017f,  0.0f,
            2.22474487139f,      -2.22474487139f,      -1.0f,                 0.0f,
            2.22474487139f,      -2.22474487139f,       1.0f,                 0.0f,
            1.1721513422464978f, -3.0862664687972017f,  0.0f,                 0.0f,
            3.0862664687972017f, -1.1721513422464978f,  0.0f,                 0.0f,
            2.22474487139f,      -1.0f,                -2.22474487139f,       0.0f,
            2.22474487139f,       1.0f,                -2.22474487139f,       0.0f,
            3.0862664687972017f,  0.0f,                -1.1721513422464978f,  0.0f,
            1.1721513422464978f,  0.0f,                -3.0862664687972017f,  0.0f,
            2.22474487139f,      -1.0f,                 2.22474487139f,       0.0f,
            2.22474487139f,       1.0f,                 2.22474487139f,       0.0f,
            1.1721513422464978f,  0.0f,                 3.0862664687972017f,  0.0f,
            3.0862664687972017f,  0.0f,                 1.1721513422464978f,  0.0f,
        };
        for (int i = 0; i < grad3.length; i++) {
            grad3[i] = (float)(grad3[i] / NORMALIZER_3D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_3D.length; i++, j++) {
            if (j == grad3.length) j = 0;
            GRADIENTS_3D[i] = grad3[j];
        }

        GRADIENTS_4D = new float[N_GRADS_4D * 4];
        float[] grad4 = {
            -0.6740059517812944f,   -0.3239847771997537f,   -0.3239847771997537f,    0.5794684678643381f,
            -0.7504883828755602f,   -0.4004672082940195f,    0.15296486218853164f,   0.5029860367700724f,
            -0.7504883828755602f,    0.15296486218853164f,  -0.4004672082940195f,    0.5029860367700724f,
            -0.8828161875373585f,    0.08164729285680945f,   0.08164729285680945f,   0.4553054119602712f,
            -0.4553054119602712f,   -0.08164729285680945f,  -0.08164729285680945f,   0.8828161875373585f,
            -0.5029860367700724f,   -0.15296486218853164f,   0.4004672082940195f,    0.7504883828755602f,
            -0.5029860367700724f,    0.4004672082940195f,   -0.15296486218853164f,   0.7504883828755602f,
            -0.5794684678643381f,    0.3239847771997537f,    0.3239847771997537f,    0.6740059517812944f,
            -0.6740059517812944f,   -0.3239847771997537f,    0.5794684678643381f,   -0.3239847771997537f,
            -0.7504883828755602f,   -0.4004672082940195f,    0.5029860367700724f,    0.15296486218853164f,
            -0.7504883828755602f,    0.15296486218853164f,   0.5029860367700724f,   -0.4004672082940195f,
            -0.8828161875373585f,    0.08164729285680945f,   0.4553054119602712f,    0.08164729285680945f,
            -0.4553054119602712f,   -0.08164729285680945f,   0.8828161875373585f,   -0.08164729285680945f,
            -0.5029860367700724f,   -0.15296486218853164f,   0.7504883828755602f,    0.4004672082940195f,
            -0.5029860367700724f,    0.4004672082940195f,    0.7504883828755602f,   -0.15296486218853164f,
            -0.5794684678643381f,    0.3239847771997537f,    0.6740059517812944f,    0.3239847771997537f,
            -0.6740059517812944f,    0.5794684678643381f,   -0.3239847771997537f,   -0.3239847771997537f,
            -0.7504883828755602f,    0.5029860367700724f,   -0.4004672082940195f,    0.15296486218853164f,
            -0.7504883828755602f,    0.5029860367700724f,    0.15296486218853164f,  -0.4004672082940195f,
            -0.8828161875373585f,    0.4553054119602712f,    0.08164729285680945f,   0.08164729285680945f,
            -0.4553054119602712f,    0.8828161875373585f,   -0.08164729285680945f,  -0.08164729285680945f,
            -0.5029860367700724f,    0.7504883828755602f,   -0.15296486218853164f,   0.4004672082940195f,
            -0.5029860367700724f,    0.7504883828755602f,    0.4004672082940195f,   -0.15296486218853164f,
            -0.5794684678643381f,    0.6740059517812944f,    0.3239847771997537f,    0.3239847771997537f,
            0.5794684678643381f,   -0.6740059517812944f,   -0.3239847771997537f,   -0.3239847771997537f,
            0.5029860367700724f,   -0.7504883828755602f,   -0.4004672082940195f,    0.15296486218853164f,
            0.5029860367700724f,   -0.7504883828755602f,    0.15296486218853164f,  -0.4004672082940195f,
            0.4553054119602712f,   -0.8828161875373585f,    0.08164729285680945f,   0.08164729285680945f,
            0.8828161875373585f,   -0.4553054119602712f,   -0.08164729285680945f,  -0.08164729285680945f,
            0.7504883828755602f,   -0.5029860367700724f,   -0.15296486218853164f,   0.4004672082940195f,
            0.7504883828755602f,   -0.5029860367700724f,    0.4004672082940195f,   -0.15296486218853164f,
            0.6740059517812944f,   -0.5794684678643381f,    0.3239847771997537f,    0.3239847771997537f,
            //------------------------------------------------------------------------------------------//
            -0.753341017856078f,    -0.37968289875261624f,  -0.37968289875261624f,  -0.37968289875261624f,
            -0.7821684431180708f,   -0.4321472685365301f,   -0.4321472685365301f,    0.12128480194602098f,
            -0.7821684431180708f,   -0.4321472685365301f,    0.12128480194602098f,  -0.4321472685365301f,
            -0.7821684431180708f,    0.12128480194602098f,  -0.4321472685365301f,   -0.4321472685365301f,
            -0.8586508742123365f,   -0.508629699630796f,     0.044802370851755174f,  0.044802370851755174f,
            -0.8586508742123365f,    0.044802370851755174f, -0.508629699630796f,     0.044802370851755174f,
            -0.8586508742123365f,    0.044802370851755174f,  0.044802370851755174f, -0.508629699630796f,
            -0.9982828964265062f,   -0.03381941603233842f,  -0.03381941603233842f,  -0.03381941603233842f,
            -0.37968289875261624f,  -0.753341017856078f,    -0.37968289875261624f,  -0.37968289875261624f,
            -0.4321472685365301f,   -0.7821684431180708f,   -0.4321472685365301f,    0.12128480194602098f,
            -0.4321472685365301f,   -0.7821684431180708f,    0.12128480194602098f,  -0.4321472685365301f,
            0.12128480194602098f,  -0.7821684431180708f,   -0.4321472685365301f,   -0.4321472685365301f,
            -0.508629699630796f,    -0.8586508742123365f,    0.044802370851755174f,  0.044802370851755174f,
            0.044802370851755174f, -0.8586508742123365f,   -0.508629699630796f,     0.044802370851755174f,
            0.044802370851755174f, -0.8586508742123365f,    0.044802370851755174f, -0.508629699630796f,
            -0.03381941603233842f,  -0.9982828964265062f,   -0.03381941603233842f,  -0.03381941603233842f,
            -0.37968289875261624f,  -0.37968289875261624f,  -0.753341017856078f,    -0.37968289875261624f,
            -0.4321472685365301f,   -0.4321472685365301f,   -0.7821684431180708f,    0.12128480194602098f,
            -0.4321472685365301f,    0.12128480194602098f,  -0.7821684431180708f,   -0.4321472685365301f,
            0.12128480194602098f,  -0.4321472685365301f,   -0.7821684431180708f,   -0.4321472685365301f,
            -0.508629699630796f,     0.044802370851755174f, -0.8586508742123365f,    0.044802370851755174f,
            0.044802370851755174f, -0.508629699630796f,    -0.8586508742123365f,    0.044802370851755174f,
            0.044802370851755174f,  0.044802370851755174f, -0.8586508742123365f,   -0.508629699630796f,
            -0.03381941603233842f,  -0.03381941603233842f,  -0.9982828964265062f,   -0.03381941603233842f,
            -0.37968289875261624f,  -0.37968289875261624f,  -0.37968289875261624f,  -0.753341017856078f,
            -0.4321472685365301f,   -0.4321472685365301f,    0.12128480194602098f,  -0.7821684431180708f,
            -0.4321472685365301f,    0.12128480194602098f,  -0.4321472685365301f,   -0.7821684431180708f,
            0.12128480194602098f,  -0.4321472685365301f,   -0.4321472685365301f,   -0.7821684431180708f,
            -0.508629699630796f,     0.044802370851755174f,  0.044802370851755174f, -0.8586508742123365f,
            0.044802370851755174f, -0.508629699630796f,     0.044802370851755174f, -0.8586508742123365f,
            0.044802370851755174f,  0.044802370851755174f, -0.508629699630796f,    -0.8586508742123365f,
            -0.03381941603233842f,  -0.03381941603233842f,  -0.03381941603233842f,  -0.9982828964265062f,
            -0.3239847771997537f,   -0.6740059517812944f,   -0.3239847771997537f,    0.5794684678643381f,
            -0.4004672082940195f,   -0.7504883828755602f,    0.15296486218853164f,   0.5029860367700724f,
            0.15296486218853164f,  -0.7504883828755602f,   -0.4004672082940195f,    0.5029860367700724f,
            0.08164729285680945f,  -0.8828161875373585f,    0.08164729285680945f,   0.4553054119602712f,
            -0.08164729285680945f,  -0.4553054119602712f,   -0.08164729285680945f,   0.8828161875373585f,
            -0.15296486218853164f,  -0.5029860367700724f,    0.4004672082940195f,    0.7504883828755602f,
            0.4004672082940195f,   -0.5029860367700724f,   -0.15296486218853164f,   0.7504883828755602f,
            0.3239847771997537f,   -0.5794684678643381f,    0.3239847771997537f,    0.6740059517812944f,
            -0.3239847771997537f,   -0.3239847771997537f,   -0.6740059517812944f,    0.5794684678643381f,
            -0.4004672082940195f,    0.15296486218853164f,  -0.7504883828755602f,    0.5029860367700724f,
            0.15296486218853164f,  -0.4004672082940195f,   -0.7504883828755602f,    0.5029860367700724f,
            0.08164729285680945f,   0.08164729285680945f,  -0.8828161875373585f,    0.4553054119602712f,
            -0.08164729285680945f,  -0.08164729285680945f,  -0.4553054119602712f,    0.8828161875373585f,
            -0.15296486218853164f,   0.4004672082940195f,   -0.5029860367700724f,    0.7504883828755602f,
            0.4004672082940195f,   -0.15296486218853164f,  -0.5029860367700724f,    0.7504883828755602f,
            0.3239847771997537f,    0.3239847771997537f,   -0.5794684678643381f,    0.6740059517812944f,
            -0.3239847771997537f,   -0.6740059517812944f,    0.5794684678643381f,   -0.3239847771997537f,
            -0.4004672082940195f,   -0.7504883828755602f,    0.5029860367700724f,    0.15296486218853164f,
            0.15296486218853164f,  -0.7504883828755602f,    0.5029860367700724f,   -0.4004672082940195f,
            0.08164729285680945f,  -0.8828161875373585f,    0.4553054119602712f,    0.08164729285680945f,
            -0.08164729285680945f,  -0.4553054119602712f,    0.8828161875373585f,   -0.08164729285680945f,
            -0.15296486218853164f,  -0.5029860367700724f,    0.7504883828755602f,    0.4004672082940195f,
            0.4004672082940195f,   -0.5029860367700724f,    0.7504883828755602f,   -0.15296486218853164f,
            0.3239847771997537f,   -0.5794684678643381f,    0.6740059517812944f,    0.3239847771997537f,
            -0.3239847771997537f,   -0.3239847771997537f,    0.5794684678643381f,   -0.6740059517812944f,
            -0.4004672082940195f,    0.15296486218853164f,   0.5029860367700724f,   -0.7504883828755602f,
            0.15296486218853164f,  -0.4004672082940195f,    0.5029860367700724f,   -0.7504883828755602f,
            0.08164729285680945f,   0.08164729285680945f,   0.4553054119602712f,   -0.8828161875373585f,
            -0.08164729285680945f,  -0.08164729285680945f,   0.8828161875373585f,   -0.4553054119602712f,
            -0.15296486218853164f,   0.4004672082940195f,    0.7504883828755602f,   -0.5029860367700724f,
            0.4004672082940195f,   -0.15296486218853164f,   0.7504883828755602f,   -0.5029860367700724f,
            0.3239847771997537f,    0.3239847771997537f,    0.6740059517812944f,   -0.5794684678643381f,
            -0.3239847771997537f,    0.5794684678643381f,   -0.6740059517812944f,   -0.3239847771997537f,
            -0.4004672082940195f,    0.5029860367700724f,   -0.7504883828755602f,    0.15296486218853164f,
            0.15296486218853164f,   0.5029860367700724f,   -0.7504883828755602f,   -0.4004672082940195f,
            0.08164729285680945f,   0.4553054119602712f,   -0.8828161875373585f,    0.08164729285680945f,
            -0.08164729285680945f,   0.8828161875373585f,   -0.4553054119602712f,   -0.08164729285680945f,
            -0.15296486218853164f,   0.7504883828755602f,   -0.5029860367700724f,    0.4004672082940195f,
            0.4004672082940195f,    0.7504883828755602f,   -0.5029860367700724f,   -0.15296486218853164f,
            0.3239847771997537f,    0.6740059517812944f,   -0.5794684678643381f,    0.3239847771997537f,
            -0.3239847771997537f,    0.5794684678643381f,   -0.3239847771997537f,   -0.6740059517812944f,
            -0.4004672082940195f,    0.5029860367700724f,    0.15296486218853164f,  -0.7504883828755602f,
            0.15296486218853164f,   0.5029860367700724f,   -0.4004672082940195f,   -0.7504883828755602f,
            0.08164729285680945f,   0.4553054119602712f,    0.08164729285680945f,  -0.8828161875373585f,
            -0.08164729285680945f,   0.8828161875373585f,   -0.08164729285680945f,  -0.4553054119602712f,
            -0.15296486218853164f,   0.7504883828755602f,    0.4004672082940195f,   -0.5029860367700724f,
            0.4004672082940195f,    0.7504883828755602f,   -0.15296486218853164f,  -0.5029860367700724f,
            0.3239847771997537f,    0.6740059517812944f,    0.3239847771997537f,   -0.5794684678643381f,
            0.5794684678643381f,   -0.3239847771997537f,   -0.6740059517812944f,   -0.3239847771997537f,
            0.5029860367700724f,   -0.4004672082940195f,   -0.7504883828755602f,    0.15296486218853164f,
            0.5029860367700724f,    0.15296486218853164f,  -0.7504883828755602f,   -0.4004672082940195f,
            0.4553054119602712f,    0.08164729285680945f,  -0.8828161875373585f,    0.08164729285680945f,
            0.8828161875373585f,   -0.08164729285680945f,  -0.4553054119602712f,   -0.08164729285680945f,
            0.7504883828755602f,   -0.15296486218853164f,  -0.5029860367700724f,    0.4004672082940195f,
            0.7504883828755602f,    0.4004672082940195f,   -0.5029860367700724f,   -0.15296486218853164f,
            0.6740059517812944f,    0.3239847771997537f,   -0.5794684678643381f,    0.3239847771997537f,
            0.5794684678643381f,   -0.3239847771997537f,   -0.3239847771997537f,   -0.6740059517812944f,
            0.5029860367700724f,   -0.4004672082940195f,    0.15296486218853164f,  -0.7504883828755602f,
            0.5029860367700724f,    0.15296486218853164f,  -0.4004672082940195f,   -0.7504883828755602f,
            0.4553054119602712f,    0.08164729285680945f,   0.08164729285680945f,  -0.8828161875373585f,
            0.8828161875373585f,   -0.08164729285680945f,  -0.08164729285680945f,  -0.4553054119602712f,
            0.7504883828755602f,   -0.15296486218853164f,   0.4004672082940195f,   -0.5029860367700724f,
            0.7504883828755602f,    0.4004672082940195f,   -0.15296486218853164f,  -0.5029860367700724f,
            0.6740059517812944f,    0.3239847771997537f,    0.3239847771997537f,   -0.5794684678643381f,
            0.03381941603233842f,   0.03381941603233842f,   0.03381941603233842f,   0.9982828964265062f,
            -0.044802370851755174f, -0.044802370851755174f,  0.508629699630796f,     0.8586508742123365f,
            -0.044802370851755174f,  0.508629699630796f,    -0.044802370851755174f,  0.8586508742123365f,
            -0.12128480194602098f,   0.4321472685365301f,    0.4321472685365301f,    0.7821684431180708f,
            0.508629699630796f,    -0.044802370851755174f, -0.044802370851755174f,  0.8586508742123365f,
            0.4321472685365301f,   -0.12128480194602098f,   0.4321472685365301f,    0.7821684431180708f,
            0.4321472685365301f,    0.4321472685365301f,   -0.12128480194602098f,   0.7821684431180708f,
            0.37968289875261624f,   0.37968289875261624f,   0.37968289875261624f,   0.753341017856078f,
            0.03381941603233842f,   0.03381941603233842f,   0.9982828964265062f,    0.03381941603233842f,
            -0.044802370851755174f,  0.044802370851755174f,  0.8586508742123365f,    0.508629699630796f,
            -0.044802370851755174f,  0.508629699630796f,     0.8586508742123365f,   -0.044802370851755174f,
            -0.12128480194602098f,   0.4321472685365301f,    0.7821684431180708f,    0.4321472685365301f,
            0.508629699630796f,    -0.044802370851755174f,  0.8586508742123365f,   -0.044802370851755174f,
            0.4321472685365301f,   -0.12128480194602098f,   0.7821684431180708f,    0.4321472685365301f,
            0.4321472685365301f,    0.4321472685365301f,    0.7821684431180708f,   -0.12128480194602098f,
            0.37968289875261624f,   0.37968289875261624f,   0.753341017856078f,     0.37968289875261624f,
            0.03381941603233842f,   0.9982828964265062f,    0.03381941603233842f,   0.03381941603233842f,
            -0.044802370851755174f,  0.8586508742123365f,   -0.044802370851755174f,  0.508629699630796f,
            -0.044802370851755174f,  0.8586508742123365f,    0.508629699630796f,    -0.044802370851755174f,
            -0.12128480194602098f,   0.7821684431180708f,    0.4321472685365301f,    0.4321472685365301f,
            0.508629699630796f,     0.8586508742123365f,   -0.044802370851755174f, -0.044802370851755174f,
            0.4321472685365301f,    0.7821684431180708f,   -0.12128480194602098f,   0.4321472685365301f,
            0.4321472685365301f,    0.7821684431180708f,    0.4321472685365301f,   -0.12128480194602098f,
            0.37968289875261624f,   0.753341017856078f,     0.37968289875261624f,   0.37968289875261624f,
            0.9982828964265062f,    0.03381941603233842f,   0.03381941603233842f,   0.03381941603233842f,
            0.8586508742123365f,   -0.044802370851755174f, -0.044802370851755174f,  0.508629699630796f,
            0.8586508742123365f,   -0.044802370851755174f,  0.508629699630796f,    -0.044802370851755174f,
            0.7821684431180708f,   -0.12128480194602098f,   0.4321472685365301f,    0.4321472685365301f,
            0.8586508742123365f,    0.508629699630796f,    -0.044802370851755174f, -0.044802370851755174f,
            0.7821684431180708f,    0.4321472685365301f,   -0.12128480194602098f,   0.4321472685365301f,
            0.7821684431180708f,    0.4321472685365301f,    0.4321472685365301f,   -0.12128480194602098f,
            0.753341017856078f,     0.37968289875261624f,   0.37968289875261624f,   0.37968289875261624f,
        };
        for (int i = 0; i < grad4.length; i++) {
            grad4[i] = (float)(grad4[i] / NORMALIZER_4D);
        }
        for (int i = 0, j = 0; i < GRADIENTS_4D.length; i++, j++) {
            if (j == grad4.length) j = 0;
            GRADIENTS_4D[i] = grad4[j];
        }
    }
}

================
File: main/java/io/github/pokemeetup/utils/PasswordUtils.java
================
package io.github.pokemeetup.utils;

import at.favre.lib.crypto.bcrypt.BCrypt;

public class PasswordUtils {

    public static String hashPassword(String password) {
        try {
            return BCrypt.withDefaults().hashToString(10, password.toCharArray());
        } catch (Exception e) {
            GameLogger.info("Error hashing password: " + e.getMessage());
            return null;
        }
    }

    public static boolean verifyPassword(String plainPassword, String storedHash) {
        try {
            if (storedHash == null) {
                GameLogger.info("Stored hash is null for password verification");
                return false;
            }
            return BCrypt.verifyer().verify(plainPassword.toCharArray(), storedHash).verified;
        } catch (Exception e) {
            GameLogger.info("Error verifying password: " + e.getMessage());
            return false;
        }
    }
}

================
File: main/java/io/github/pokemeetup/utils/PerlinNoise.java
================
package io.github.pokemeetup.utils;

import java.util.Random;

public class PerlinNoise {
    private static final int PERMUTATION_SIZE = 256;
    private static final int PERMUTATION_MASK = PERMUTATION_SIZE - 1;
    private final int[] permutation;
    public PerlinNoise(int seed) {
        Random random = new Random(seed);
        this.permutation = new int[PERMUTATION_SIZE * 2];

        // Initialize the permutation array
        int[] p = new int[PERMUTATION_SIZE];
        for (int i = 0; i < PERMUTATION_SIZE; i++) {
            p[i] = i;
        }

        // Fisher-Yates shuffle
        for (int i = PERMUTATION_SIZE - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            int temp = p[i];
            p[i] = p[j];
            p[j] = temp;
        }

        // Duplicate the permutation array
        for (int i = 0; i < PERMUTATION_SIZE * 2; i++) {
            permutation[i] = p[i & PERMUTATION_MASK];
        }
    }

    // In PerlinNoise class

    public double noise(double x, double y) {
        return generateNoise(x, y) * 1.05; // Slightly amplify to reach edges
    }


    private double generateNoise(double x, double y) {
        // Get integer coordinates
        int X = fastFloor(x) & PERMUTATION_MASK;
        int Y = fastFloor(y) & PERMUTATION_MASK;

        // Get relative coordinates within unit square
        x -= fastFloor(x);
        y -= fastFloor(y);

        // Compute fade curves
        double u = fade(x);
        double v = fade(y);

        // Hash coordinates of the 4 square corners
        int A = permutation[X] + Y;
        int AA = permutation[A];
        int AB = permutation[A + 1];
        int B = permutation[X + 1] + Y;
        int BA = permutation[B];
        int BB = permutation[B + 1];

        // Add blended results from 4 corners of the square
        double result = lerp(v,
            lerp(u, grad(permutation[AA], x, y),
                grad(permutation[BA], x - 1, y)),
            lerp(u, grad(permutation[AB], x, y - 1),
                grad(permutation[BB], x - 1, y - 1)));

        return result / 0.7071; // Approximate maximum value for 2D Perlin noise
    }
    private static double fade(double t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }

    private static double lerp(double t, double a, double b) {
        return a + t * (b - a);
    }

    private static double grad(int hash, double x, double y) {
        int h = hash & 7;
        double u = h < 4 ? x : y;
        double v = h < 4 ? y : x;
        return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
    }

    private static int fastFloor(double x) {
        int xi = (int) x;
        return x < xi ? xi - 1 : xi;
    }
}

================
File: main/java/io/github/pokemeetup/utils/ResponsiveLayout.java
================
package io.github.pokemeetup.utils;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.math.Vector2;

public class ResponsiveLayout {
    // Screen size breakpoints
    public static final int SMALL_SCREEN_WIDTH = 800;
    public static final int MEDIUM_SCREEN_WIDTH = 1280;

    public static ScreenSize getScreenSize() {
        int width = Gdx.graphics.getWidth();
        if (width <= SMALL_SCREEN_WIDTH) return ScreenSize.SMALL;
        if (width <= MEDIUM_SCREEN_WIDTH) return ScreenSize.MEDIUM;
        return ScreenSize.LARGE;
    }

    public static float getFontScale() {
        switch (getScreenSize()) {
            case SMALL:
                return 0.5f;
            case MEDIUM:
                return 0.75f;
            default:
                return 1f;
        }
    }

    public static float getPadding() {
        switch (getScreenSize()) {
            case SMALL:
                return 10f;
            case MEDIUM:
                return 15f;
            default:
                return 20f;
        }
    }

    public static Vector2 getElementSize(float baseWidth, float baseHeight) {
        float scale = getFontScale();
        return new Vector2(baseWidth * scale, baseHeight * scale);
    }

    // Screen size categories
    public enum ScreenSize {
        SMALL, MEDIUM, LARGE
    }
}

================
File: main/java/io/github/pokemeetup/utils/storage/DesktopFileSystem.java
================
package io.github.pokemeetup.utils.storage;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import io.github.pokemeetup.FileSystemDelegate;
import io.github.pokemeetup.utils.GameLogger;

import java.io.*;
import java.nio.charset.StandardCharsets;

public class DesktopFileSystem implements FileSystemDelegate {

    @Override
    public boolean exists(String path) {
        return Gdx.files.local(path).exists();
    }

    @Override
    public void createDirectory(String path) {
        FileHandle dir = Gdx.files.local(path);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }
    @Override
    public void moveFile(String sourcePath, String destinationPath) throws IOException {
        File sourceFile = new File(sourcePath);
        File destFile = new File(destinationPath);

        if (!sourceFile.exists()) {
            throw new FileNotFoundException("Source file does not exist: " + sourcePath);
        }

        boolean success = sourceFile.renameTo(destFile);
        if (!success) {
            throw new IOException("Failed to move file from " + sourcePath + " to " + destinationPath);
        }
    }

    @Override
    public void writeString(String path, String content) throws IOException {
        try {
            Gdx.files.local(path).writeString(content, false);
        } catch (Exception e) {
            throw new IOException("Failed to write to file: " + path, e);
        }
    }

    @Override
    public String readString(String path) throws IOException {
        try {
            return Gdx.files.local(path).readString();
        } catch (Exception e) {
            throw new IOException("Failed to read from file: " + path, e);
        }
    }

    @Override
    public void deleteFile(String path) {
        FileHandle file = Gdx.files.local(path);
        if (file.exists()) {
            file.delete();
        }
    }

    @Override
    public void deleteDirectory(String path) {
        FileHandle dir = Gdx.files.local(path);
        if (dir.exists() && dir.isDirectory()) {
            dir.deleteDirectory();
        }
    }

    @Override
    public boolean isDirectory(String path) {
        return Gdx.files.local(path).isDirectory();
    }

    @Override
    public String[] list(String path) {
        FileHandle dir = Gdx.files.local(path);
        if (dir.exists() && dir.isDirectory()) {
            FileHandle[] files = dir.list();
            String[] names = new String[files.length];
            for (int i = 0; i < files.length; i++) {
                names[i] = files[i].name();
            }
            return names;
        }
        return new String[0];
    }

    @Override
    public void copyFile(String sourcePath, String destinationPath) throws IOException {
        try {
            FileHandle source = Gdx.files.local(sourcePath);
            FileHandle destination = Gdx.files.local(destinationPath);
            source.copyTo(destination);
        } catch (Exception e) {
            throw new IOException("Failed to copy file from " + sourcePath + " to " + destinationPath, e);
        }
    }

    @Override
    public InputStream openInputStream(String path) throws IOException {
        try {
            return Gdx.files.local(path).read();
        } catch (Exception e) {
            throw new IOException("Failed to open input stream: " + path, e);
        }
    }

    @Override
    public OutputStream openOutputStream(String path) throws IOException {
        try {
            return Gdx.files.local(path).write(false);
        } catch (Exception e) {
            throw new IOException("Failed to open output stream: " + path, e);
        }
    }
}

================
File: main/java/io/github/pokemeetup/utils/storage/GameFileSystem.java
================
package io.github.pokemeetup.utils.storage;

import io.github.pokemeetup.FileSystemDelegate;
import io.github.pokemeetup.utils.GameLogger;

import java.io.*;

public class GameFileSystem {
    private static GameFileSystem instance;
    private FileSystemDelegate delegate;

    public FileSystemDelegate getDelegate() {
        checkDelegate();
        return delegate;
    }
    private GameFileSystem() {}
    public void moveFile(String sourcePath, String destinationPath) throws IOException {
        checkDelegate();
        try {
            delegate.moveFile(sourcePath, destinationPath);
        } catch (IOException e) {
            GameLogger.error("Failed to move file from " + sourcePath + " to " + destinationPath + ": " + e.getMessage());
            throw e;
        }
    }
    public static GameFileSystem getInstance() {
        if (instance == null) {
            instance = new GameFileSystem();
        }
        return instance;
    }

    public void setDelegate(FileSystemDelegate delegate) {
        this.delegate = delegate;
        GameLogger.info("File system delegate set: " + delegate.getClass().getSimpleName());
    }

    public void writeString(String path, String content) throws IOException {
        checkDelegate();
        try {
            delegate.writeString(path, content);
        } catch (IOException e) {
            GameLogger.error("Failed to write to file: " + path);
            throw e;
        }
    }

    public String readString(String path) throws IOException {
        checkDelegate();
        try {
            return delegate.readString(path);
        } catch (IOException e) {
            GameLogger.error("Failed to read from file: " + path);
            throw e;
        }
    }

    public boolean exists(String path) {
        checkDelegate();
        return delegate.exists(path);
    }

    public void createDirectory(String path) {
        checkDelegate();
        try {
            delegate.createDirectory(path);
        } catch (Exception e) {
            GameLogger.error("Failed to create directory: " + path);
            throw e;
        }
    }

    public void deleteFile(String path) {
        checkDelegate();
        try {
            delegate.deleteFile(path);
        } catch (Exception e) {
            GameLogger.error("Failed to delete file: " + path);
            throw e;
        }
    }

    public void deleteDirectory(String path) {
        checkDelegate();
        try {
            delegate.deleteDirectory(path);
        } catch (Exception e) {
            GameLogger.error("Failed to delete directory: " + path);
            throw e;
        }
    }

    public boolean isDirectory(String path) {
        checkDelegate();
        return !delegate.isDirectory(path);
    }

    public String[] list(String path) {
        checkDelegate();
        return delegate.list(path);
    }


    private void checkDelegate() {
        if (delegate == null) {
            throw new IllegalStateException("FileSystemDelegate not set. Call setDelegate() first.");
        }
    }
}

================
File: main/java/io/github/pokemeetup/utils/storage/InventoryConverter.java
================
package io.github.pokemeetup.utils.storage;

import io.github.pokemeetup.system.Player;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.system.gameplay.inventory.Item;
import io.github.pokemeetup.system.data.ItemData;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

public class InventoryConverter {



    public static ItemData itemToItemData(Item item) {
        if (item == null) {
            return null;
        }

        // Create new ItemData with DEEP copy of all properties
        ItemData itemData = new ItemData();
        itemData.setItemId(item.getName());
        itemData.setCount(item.getCount());
        // Use original UUID to maintain item identity
        itemData.setUuid(item.getUuid() != null ? item.getUuid() : UUID.randomUUID());
        itemData.setDurability(item.getDurability());
        itemData.setMaxDurability(item.getMaxDurability());

        GameLogger.info("Converting Item to ItemData: " + item.getName() + " x" + item.getCount());
        return itemData;
    }

    public static Item itemDataToItem(ItemData itemData) {
        if (itemData == null) {
            return null;
        }

        // Create a new instance and DEEP copy all properties
        Item item = new Item(itemData.getItemId());

        // IMPORTANT: Deep copy all properties
        item.setCount(itemData.getCount());
        // Use original UUID to maintain item identity across operations
        item.setUuid(itemData.getUuid() != null ? itemData.getUuid() : UUID.randomUUID());
        item.setDurability(itemData.getDurability());
        item.setMaxDurability(itemData.getMaxDurability());

        GameLogger.info("Converting ItemData to Item: " + itemData.getItemId() + " x" + itemData.getCount());
        return item;
    }

        public static void extractInventoryDataFromPlayer(Player player, PlayerData playerData) {
            if (player == null || playerData == null) {
                GameLogger.error("Cannot extract inventory from null Player or PlayerData");
                return;
            }

            try {
                Inventory inventory = player.getInventory();
                if (inventory == null) {
                    GameLogger.error("Player inventory is null");
                    playerData.setInventoryItems(new ArrayList<>(Collections.nCopies(Inventory.INVENTORY_SIZE, null)));
                    return;
                }

                List<ItemData> items = new ArrayList<>(Inventory.INVENTORY_SIZE);
                for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                    ItemData item = inventory.getItemAt(i);
                    if (item != null && item.isValid()) {
                        items.add(item.copy()); // Create deep copy
                    } else {
                        items.add(null);
                    }
                }
                playerData.setInventoryItems(items);
                GameLogger.info("Extracted " + items.stream().filter(Objects::nonNull).count() +
                    " items from inventory");
            } catch (Exception e) {
                GameLogger.error("Error extracting inventory data: " + e.getMessage());
                e.printStackTrace();
            }
        }

    public static List<ItemData> duplicateItemDataList(List<ItemData> itemDataList) {
        List<ItemData> duplicatedList = new ArrayList<>();
        for (ItemData item : itemDataList) {
            if (item != null) {
                duplicatedList.add(item.copy());
            } else {
                duplicatedList.add(null);
            }
        }
        return duplicatedList;
    }

    @Deprecated
    public static List<String> toPlayerDataFormat(List<ItemData> items) {
        List<String> itemStrings = new ArrayList<>();
        for (ItemData item : items) {
            if (item != null) {
                itemStrings.add(item.getItemId() + ":" + item.getCount());
            } else {
                itemStrings.add(null);
            }
        }
        return itemStrings;
    }
    public static boolean addItemToInventory(Inventory inventory, ItemData newItem) {
        if (inventory == null || newItem == null) {
            GameLogger.error("Inventory or newItem is null. Cannot add item.");
            return false;
        }

        synchronized (inventory) {
            boolean added = inventory.addItem(newItem.copyWithUUID());
            if (added) {
                GameLogger.info("Item added to inventory successfully: " + newItem.getItemId());
            } else {
                GameLogger.error("Failed to add item to inventory: " + newItem.getItemId());
            }
            return added;
        }
    }
}

================
File: main/java/io/github/pokemeetup/utils/storage/JsonConfig.java
================
package io.github.pokemeetup.utils.storage;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonValue;
import com.badlogic.gdx.utils.JsonWriter;
import io.github.pokemeetup.context.GameContext;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.system.data.*;
import io.github.pokemeetup.system.gameplay.inventory.Inventory;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;

public class JsonConfig {
    private static final String SINGLE_PLAYER_DIR = "worlds/singleplayer/";
    private static Json instance;

    public static WorldData loadWorldData(String worldName) {
        // Add check for multiplayer mode
        if (GameContext.get().getGameClient() != null &&
            !GameContext.get().getGameClient().isSinglePlayer()) {
            GameLogger.info("Skipping local world load in multiplayer mode");
            return null;
        }

        try {
            FileHandle worldDir = Gdx.files.local(SINGLE_PLAYER_DIR + worldName);
            FileHandle worldFile = worldDir.child("world.json");

            if (!worldFile.exists()) {
                GameLogger.error("World file not found: " + worldFile.path());
                return null;
            }
            String jsonContent = worldFile.readString();
            Json json = getInstance();

            return json.fromJson(WorldData.class, jsonContent);

        } catch (Exception e) {
            GameLogger.error("Error loading world data: " + e.getMessage());
            return null;
        }
    }public static synchronized Json getInstance() {
        if (instance == null) {
            instance = new Json();
            instance.setOutputType(JsonWriter.OutputType.json);
            instance.setTypeName(null);
            instance.setUsePrototypes(false);
            setupSerializers(instance);
        }
        return instance;
    }


    private static void setupSerializers(Json json) {


        json.setSerializer(WorldData.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, WorldData world, Class knownType) {
                json.writeObjectStart();
                synchronized (world.getTimeLock()) {
                    json.writeValue("worldTimeInMinutes", world.getWorldTimeInMinutes());
                    json.writeValue("playedTime", world.getPlayedTime());
                    json.writeValue("dayLength", world.getDayLength());
                }
                json.writeValue("name", world.getName());
                json.writeValue("lastPlayed", world.getLastPlayed());
                json.writeValue("config", world.getConfig());
                json.writeValue("players", world.getPlayers());
                json.writeValue("pokemonData", world.getPokemonData());
                json.writeValue("commands_allowed", world.commandsAllowed());
                json.writeObjectEnd();
            }

            @Override
            public WorldData read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null) {
                    return null;
                }
                WorldData world = new WorldData();

                String name = jsonData.getString("name", null);
                if (name == null || name.trim().isEmpty()) {
                    GameLogger.error("Missing or empty world name in JSON data");
                    return null; // Return null instead of throwing exception
                }
                JsonValue timeValue = jsonData.get("worldTimeInMinutes");
                if (timeValue != null) {
                    world.setWorldTimeInMinutes(timeValue.asDouble());
                }

                JsonValue playedValue = jsonData.get("playedTime");
                if (playedValue != null) {
                    world.setPlayedTime(playedValue.asLong());
                }

                JsonValue dayLengthValue = jsonData.get("dayLength");
                if (dayLengthValue != null) {
                    world.setDayLength(dayLengthValue.asFloat());
                }

                world.setName(jsonData.getString("name", ""));
                world.setLastPlayed(jsonData.getLong("lastPlayed", System.currentTimeMillis()));
                WorldData.WorldConfig config = json.readValue(WorldData.WorldConfig.class, jsonData.get("config"));
                if (config == null) {
                    config = new WorldData.WorldConfig(System.currentTimeMillis());
                }
                world.setConfig(config);

                // Players
                JsonValue playersObject = jsonData.get("players");
                if (playersObject != null && playersObject.isObject()) {
                    HashMap<String, PlayerData> players = new HashMap<>();
                    for (JsonValue playerEntry = playersObject.child; playerEntry != null; playerEntry = playerEntry.next) {
                        String username = playerEntry.name;
                        PlayerData playerData = json.readValue(PlayerData.class, playerEntry);
                        if (playerData != null) {
                            players.put(username, playerData);
                        }
                    }
                    world.setPlayers(players);
                }

                // PokemonData
                PokemonData pokemonData = json.readValue(PokemonData.class, jsonData.get("pokemonData"));
                if (pokemonData == null) {
                    pokemonData = new PokemonData();
                }
                world.setPokemonData(pokemonData);

                // Commands Allowed
                world.setCommandsAllowed(jsonData.getBoolean("commands_allowed", false));

                return world;
            }
        });

        json.setSerializer(WorldData.WorldConfig.class, new Json.Serializer<WorldData.WorldConfig>() {
            @Override
            public void write(Json json, WorldData.WorldConfig config, Class knownType) {
                json.writeObjectStart();
                json.writeValue("seed", config.getSeed());
                json.writeValue("treeSpawnRate", config.getTreeSpawnRate());
                json.writeValue("pokemonSpawnRate", config.getPokemonSpawnRate());
                json.writeValue("spawnTileX", config.getTileSpawnX());
                json.writeValue("spawnTileY", config.getTileSpawnY());
                json.writeObjectEnd();
            }

            @Override
            public WorldData.WorldConfig read(Json json, JsonValue jsonData, Class type) {
                WorldData.WorldConfig config = new WorldData.WorldConfig();
                config.setSeed(jsonData.getLong("seed", System.currentTimeMillis()));
                config.setTreeSpawnRate(jsonData.getFloat("treeSpawnRate", 0.15f));
                config.setPokemonSpawnRate(jsonData.getFloat("pokemonSpawnRate", 0.05f));
                config.setTileSpawnX(jsonData.getInt("spawnTileX", 0));
                config.setTileSpawnY(jsonData.getInt("spawnTileY", 0));
                return config;
            }
        });

        json.setSerializer(PlayerData.class, new Json.Serializer<PlayerData>() {
            @Override
            public void write(Json json, PlayerData playerData, Class knownType) {
                json.writeObjectStart();
                json.writeValue("username", playerData.getUsername());
                json.writeValue("x", playerData.getX());
                json.writeValue("y", playerData.getY());
                json.writeValue("direction", playerData.getDirection());
                json.writeValue("isMoving", playerData.isMoving());
                json.writeValue("wantsToRun", playerData.isWantsToRun());

                // Inventory Items
                json.writeArrayStart("inventoryItems");
                if (playerData.getInventoryItems() != null) {
                    for (ItemData item : playerData.getInventoryItems()) {
                        json.writeValue(item);
                    }
                }
                json.writeArrayEnd();

                // Party Pokemon
                json.writeArrayStart("partyPokemon");
                if (playerData.getPartyPokemon() != null) {
                    for (PokemonData pokemon : playerData.getPartyPokemon()) {
                        json.writeValue(pokemon);
                    }
                }
                json.writeArrayEnd();

                json.writeObjectEnd();
            }

            @Override
            public PlayerData read(Json json, JsonValue jsonData, Class type) {
                PlayerData playerData = new PlayerData();
                playerData.setUsername(jsonData.getString("username", "Player"));
                playerData.setX(jsonData.getFloat("x", 0f));
                playerData.setY(jsonData.getFloat("y", 0f));
                playerData.setDirection(jsonData.getString("direction", "down"));
                playerData.setMoving(jsonData.getBoolean("isMoving", false));
                playerData.setWantsToRun(jsonData.getBoolean("wantsToRun", false));

                // Inventory Items
                JsonValue inventoryArray = jsonData.get("inventoryItems");
                List<ItemData> inventory = new ArrayList<>(Inventory.INVENTORY_SIZE);
                for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                    inventory.add(null);
                }
                if (inventoryArray != null && inventoryArray.isArray()) {
                    int index = 0;
                    for (JsonValue itemValue = inventoryArray.child; itemValue != null && index < Inventory.INVENTORY_SIZE; itemValue = itemValue.next, index++) {
                        ItemData item = json.readValue(ItemData.class, itemValue);
                        inventory.set(index, item);
                    }
                }
                playerData.setInventoryItems(inventory);

                // Party Pokemon
                JsonValue partyArray = jsonData.get("partyPokemon");
                List<PokemonData> party = new ArrayList<>(6);
                for (int i = 0; i < 6; i++) {
                    party.add(null);
                }
                if (partyArray != null && partyArray.isArray()) {
                    int index = 0;
                    for (JsonValue pokemonValue = partyArray.child; pokemonValue != null && index < 6; pokemonValue = pokemonValue.next, index++) {
                        PokemonData pokemon = json.readValue(PokemonData.class, pokemonValue);
                        party.set(index, pokemon);
                    }
                }
                playerData.setPartyPokemon(party);

                return playerData;
            }
        });
        json.setSerializer(ItemData.class, new Json.Serializer<>() {
            @Override
            public void write(Json json, ItemData itemData, Class knownType) {
                if (itemData == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();
                json.writeValue("itemId", itemData.getItemId());
                json.writeValue("count", itemData.getCount());
                json.writeValue("uuid", itemData.getUuid() != null ? itemData.getUuid().toString() : UUID.randomUUID().toString());
                json.writeValue("durability", itemData.getDurability());
                json.writeValue("maxDurability", itemData.getMaxDurability());
                json.writeObjectEnd();
            }

            @Override
            public ItemData read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return null;
                }

                ItemData itemData = new ItemData();

                String itemId;
                try {
                    itemId = jsonData.getString("itemId");
                } catch (Exception e) {
                    GameLogger.error("ItemData deserialization error: Missing 'itemId'. Skipping item.");
                    return null; // Skip this item
                }

                itemData.setCount(jsonData.getInt("count", 1));
                try {
                    String uuidStr = jsonData.getString("uuid", null);
                    itemData.setUuid(uuidStr != null ? UUID.fromString(uuidStr) : UUID.randomUUID());
                } catch (IllegalArgumentException e) {
                    itemData.setUuid(UUID.randomUUID());
                }

                itemData.setDurability(jsonData.getInt("durability", -1));
                itemData.setMaxDurability(jsonData.getInt("maxDurability", -1));

                // Set itemId after other fields
                itemData.setItemId(itemId);

                return itemData;
            }
        });

        json.setSerializer(PokemonData.class, new Json.Serializer<PokemonData>() {
            @Override
            public void write(Json json, PokemonData pokemonData, Class knownType) {
                if (pokemonData == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();

                // Basic Info
                json.writeValue("name", pokemonData.getName());
                json.writeValue("uuid", pokemonData.getUuid() != null ? pokemonData.getUuid().toString() : UUID.randomUUID().toString());
                json.writeValue("level", pokemonData.getLevel());
                json.writeValue("nature", pokemonData.getNature());

                // Primary Type
                if (pokemonData.getPrimaryType() != null) {
                    json.writeValue("primaryType", pokemonData.getPrimaryType().name());
                } else {
                    json.writeValue("primaryType", "NORMAL"); // Default to NORMAL if null
                }

                // Secondary Type
                if (pokemonData.getSecondaryType() != null) {
                    json.writeValue("secondaryType", pokemonData.getSecondaryType().name());
                }

                // Stats
                if (pokemonData.getStats() != null) {
                    json.writeValue("stats", pokemonData.getStats());
                }

                // Base Stats
                json.writeValue("baseHp", pokemonData.getBaseHp());
                json.writeValue("baseAttack", pokemonData.getBaseAttack());
                json.writeValue("baseDefense", pokemonData.getBaseDefense());
                json.writeValue("baseSpAtk", pokemonData.getBaseSpAtk());
                json.writeValue("baseSpDef", pokemonData.getBaseSpDef());
                json.writeValue("baseSpeed", pokemonData.getBaseSpeed());

                // Experience
                json.writeValue("currentExperience", pokemonData.getCurrentExperience());
                json.writeValue("experienceToNextLevel", pokemonData.getExperienceToNextLevel());

                // Current HP
                json.writeValue("currentHp", pokemonData.getCurrentHp());

                // Moves
                json.writeArrayStart("moves");
                if (pokemonData.getMoves() != null) {
                    for (PokemonData.MoveData move : pokemonData.getMoves()) {
                        json.writeValue(move);
                    }
                }
                json.writeArrayEnd();

                json.writeObjectEnd();
            }

            @Override
            public PokemonData read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return null;
                }

                PokemonData pokemonData = new PokemonData();

                pokemonData.setName(jsonData.getString("name", "Unknown"));
                String uuidStr = jsonData.getString("uuid", null);
                pokemonData.setUuid(uuidStr != null ? UUID.fromString(uuidStr) : UUID.randomUUID());
                pokemonData.setLevel(jsonData.getInt("level", 1));
                pokemonData.setNature(jsonData.getString("nature", "Unknown"));

                // Primary Type
                String primaryTypeStr = jsonData.getString("primaryType", "NORMAL");
                try {
                    pokemonData.setPrimaryType(Pokemon.PokemonType.valueOf(primaryTypeStr));
                } catch (IllegalArgumentException e) {
                    GameLogger.error("Invalid primary type '" + primaryTypeStr + "'. Defaulting to NORMAL.");
                    pokemonData.setPrimaryType(Pokemon.PokemonType.NORMAL);
                }

                // Secondary Type
                if (jsonData.has("secondaryType")) {
                    String secondaryTypeStr = jsonData.getString("secondaryType");
                    try {
                        pokemonData.setSecondaryType(Pokemon.PokemonType.valueOf(secondaryTypeStr));
                    } catch (IllegalArgumentException e) {
                        GameLogger.error("Invalid secondary type '" + secondaryTypeStr + "'. Setting to null.");
                        pokemonData.setSecondaryType(null);
                    }
                }

                // Stats
                JsonValue statsValue = jsonData.get("stats");
                if (statsValue != null) {
                    PokemonData.Stats stats = json.readValue(PokemonData.Stats.class, statsValue);
                    pokemonData.setStats(stats);
                }

                // Base Stats
                pokemonData.setBaseHp(jsonData.getInt("baseHp", 1));
                pokemonData.setBaseAttack(jsonData.getInt("baseAttack", 1));
                pokemonData.setBaseDefense(jsonData.getInt("baseDefense", 1));
                pokemonData.setBaseSpAtk(jsonData.getInt("baseSpAtk", 1));
                pokemonData.setBaseSpDef(jsonData.getInt("baseSpDef", 1));
                pokemonData.setBaseSpeed(jsonData.getInt("baseSpeed", 1));

                // Experience
                pokemonData.setCurrentExperience(jsonData.getInt("currentExperience", 0));
                pokemonData.setExperienceToNextLevel(jsonData.getInt("experienceToNextLevel", 100));

                // Current HP
                pokemonData.setCurrentHp(jsonData.getInt("currentHp", pokemonData.getBaseHp()));

                // Moves
                JsonValue movesArray = jsonData.get("moves");
                if (movesArray != null && movesArray.isArray()) {
                    List<PokemonData.MoveData> moves = new ArrayList<>();
                    for (JsonValue moveValue = movesArray.child; moveValue != null; moveValue = moveValue.next) {
                        PokemonData.MoveData moveData = json.readValue(PokemonData.MoveData.class, moveValue);
                        moves.add(moveData);
                    }
                    pokemonData.setMoves(moves);
                }

                return pokemonData;
            }
        });
        json.setSerializer(PokemonData.Stats.class, new Json.Serializer<PokemonData.Stats>() {
            @Override
            public void write(Json json, PokemonData.Stats stats, Class knownType) {
                if (stats == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();
                json.writeValue("hp", stats.getHp());
                json.writeValue("attack", stats.getAttack());
                json.writeValue("defense", stats.getDefense());
                json.writeValue("specialAttack", stats.getSpecialAttack());
                json.writeValue("specialDefense", stats.getSpecialDefense());
                json.writeValue("speed", stats.getSpeed());

                // IVs
                json.writeArrayStart("ivs");
                for (int iv : stats.ivs) {
                    json.writeValue(iv);
                }
                json.writeArrayEnd();

                // EVs
                json.writeArrayStart("evs");
                for (int ev : stats.evs) {
                    json.writeValue(ev);
                }
                json.writeArrayEnd();

                json.writeObjectEnd();
            }
            @Override
            public PokemonData.Stats read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return new PokemonData.Stats(); // Return default stats
                }

                PokemonData.Stats stats = new PokemonData.Stats();
                stats.setHp(jsonData.getInt("hp", 1));
                stats.setAttack(jsonData.getInt("attack", 1));
                stats.setDefense(jsonData.getInt("defense", 1));
                stats.setSpecialAttack(jsonData.getInt("specialAttack", 1));
                stats.setSpecialDefense(jsonData.getInt("specialDefense", 1));
                stats.setSpeed(jsonData.getInt("speed", 1));

                // IVs
                JsonValue ivsArray = jsonData.get("ivs");
                if (ivsArray != null && ivsArray.isArray()) {
                    int[] ivs = new int[6];
                    int index = 0;
                    for (JsonValue ivValue = ivsArray.child; ivValue != null && index < 6; ivValue = ivValue.next, index++) {
                        ivs[index] = ivValue.asInt();
                    }
                    stats.ivs = ivs;
                }

                // EVs
                JsonValue evsArray = jsonData.get("evs");
                if (evsArray != null && evsArray.isArray()) {
                    int[] evs = new int[6];
                    int index = 0;
                    for (JsonValue evValue = evsArray.child; evValue != null && index < 6; evValue = evValue.next, index++) {
                        evs[index] = evValue.asInt();
                    }
                    stats.evs = evs;
                }

                return stats;
            }
        });

        json.setSerializer(PokemonData.MoveData.class, new Json.Serializer<PokemonData.MoveData>() {
            @Override
            public void write(Json json, PokemonData.MoveData moveData, Class knownType) {
                if (moveData == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();
                json.writeValue("name", moveData.getName());
                json.writeValue("type", moveData.getType() != null ? moveData.getType().name() : "NORMAL");
                json.writeValue("power", moveData.getPower());
                json.writeValue("accuracy", moveData.getAccuracy());
                json.writeValue("pp", moveData.getPp());
                json.writeValue("maxPp", moveData.getMaxPp());
                json.writeValue("isSpecial", moveData.isSpecial());
                json.writeValue("description", moveData.getDescription());
                json.writeValue("canFlinch", moveData.isCanFlinch());
                json.writeValue("effect", moveData.effect);
                json.writeObjectEnd();
            }
            @Override
            public PokemonData.MoveData read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return null;
                }

                PokemonData.MoveData moveData = new PokemonData.MoveData();
                moveData.setName(jsonData.getString("name", "Unknown"));
                String typeStr = jsonData.getString("type", "NORMAL");
                try {
                    moveData.setType(Pokemon.PokemonType.valueOf(typeStr));
                } catch (IllegalArgumentException e) {
                    GameLogger.error("Invalid move type '" + typeStr + "'. Defaulting to NORMAL.");
                    moveData.setType(Pokemon.PokemonType.NORMAL);
                }

                moveData.setPower(jsonData.getInt("power", 0));
                moveData.setAccuracy(jsonData.getInt("accuracy", 100));
                moveData.setPp(jsonData.getInt("pp", 0));
                moveData.setMaxPp(jsonData.getInt("maxPp", 0));
                moveData.setSpecial(jsonData.getBoolean("isSpecial", false));
                moveData.setDescription(jsonData.getString("description", ""));
                moveData.setCanFlinch(jsonData.getBoolean("canFlinch", false));

                // Effect
                JsonValue effectValue = jsonData.get("effect");
                if (effectValue != null && effectValue.isObject()) {
                    moveData.effect = json.readValue(PokemonData.MoveData.MoveEffectData.class, effectValue);
                }

                return moveData;
            }
        });
        json.setSerializer(PokemonData.MoveData.MoveEffectData.class, new Json.Serializer<PokemonData.MoveData.MoveEffectData>() {
            @Override
            public void write(Json json, PokemonData.MoveData.MoveEffectData effectData, Class knownType) {
                if (effectData == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();
                if (effectData.getStatusEffect() != null) {
                    json.writeValue("statusEffect", effectData.getStatusEffect().name());
                }
                if (effectData.getStatModifiers() != null && !effectData.getStatModifiers().isEmpty()) {
                    json.writeObjectStart("statModifiers");
                    for (Map.Entry<String, Integer> entry : effectData.getStatModifiers().entrySet()) {
                        json.writeValue(entry.getKey(), entry.getValue());
                    }
                    json.writeObjectEnd();
                }
                json.writeValue("effectType", effectData.getEffectType());
                json.writeValue("chance", effectData.getChance());
                json.writeValue("animation", effectData.getAnimation());
                json.writeValue("sound", effectData.getSound());
                json.writeValue("duration", effectData.getDuration());
                json.writeObjectEnd();
            }
            @Override
            public PokemonData.MoveData.MoveEffectData read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return null;
                }

                PokemonData.MoveData.MoveEffectData effectData = new PokemonData.MoveData.MoveEffectData();

                if (jsonData.has("statusEffect")) {
                    String statusStr = jsonData.getString("statusEffect");
                    try {
                        effectData.setStatusEffect(Pokemon.Status.valueOf(statusStr));
                    } catch (IllegalArgumentException e) {
                        GameLogger.error("Invalid status effect '" + statusStr + "'. Ignoring.");
                    }
                }

                JsonValue statModifiersValue = jsonData.get("statModifiers");
                if (statModifiersValue != null && statModifiersValue.isObject()) {
                    Map<String, Integer> statModifiers = new HashMap<>();
                    for (JsonValue statEntry = statModifiersValue.child; statEntry != null; statEntry = statEntry.next) {
                        statModifiers.put(statEntry.name, statEntry.asInt());
                    }
                    effectData.setStatModifiers(statModifiers);
                }

                effectData.setEffectType(jsonData.getString("effectType", ""));
                effectData.setChance(jsonData.getFloat("chance", 0f));
                effectData.setAnimation(jsonData.getString("animation", ""));
                effectData.setSound(jsonData.getString("sound", ""));
                effectData.setDuration(jsonData.getInt("duration", 0));

                return effectData;
            }
        });

        json.setSerializer(PokemonData.WildPokemonData.class, new Json.Serializer<PokemonData.WildPokemonData>() {
            @Override
            public void write(Json json, PokemonData.WildPokemonData wildPokemonData, Class knownType) {
                if (wildPokemonData == null) {
                    json.writeValue(null);
                    return;
                }

                json.writeObjectStart();
                json.writeValue("name", wildPokemonData.getName());
                json.writeValue("level", wildPokemonData.getLevel());
                json.writeValue("position", wildPokemonData.getPosition());
                json.writeValue("direction", wildPokemonData.getDirection());
                json.writeValue("isMoving", wildPokemonData.isMoving());
                json.writeValue("spawnTime", wildPokemonData.getSpawnTime());

                // Primary Type
                if (wildPokemonData.getPrimaryType() != null) {
                    json.writeValue("primaryType", wildPokemonData.getPrimaryType().name());
                } else {
                    json.writeValue("primaryType", "NORMAL");
                }

                // Secondary Type
                if (wildPokemonData.getSecondaryType() != null) {
                    json.writeValue("secondaryType", wildPokemonData.getSecondaryType().name());
                }

                json.writeValue("currentHp", wildPokemonData.getCurrentHp());

                // Stats
                if (wildPokemonData.getStats() != null) {
                    json.writeValue("stats", wildPokemonData.getStats());
                }

                // Moves
                json.writeArrayStart("moves");
                if (wildPokemonData.getMoves() != null) {
                    for (PokemonData.MoveData move : wildPokemonData.getMoves()) {
                        json.writeValue(move);
                    }
                }
                json.writeArrayEnd();

                json.writeValue("uuid", wildPokemonData.getUuid() != null ? wildPokemonData.getUuid().toString() : UUID.randomUUID().toString());

                json.writeObjectEnd();
            }

            @Override
            public PokemonData.WildPokemonData read(Json json, JsonValue jsonData, Class type) {
                if (jsonData == null || jsonData.isNull()) {
                    return null;
                }

                PokemonData.WildPokemonData wildPokemonData = new PokemonData.WildPokemonData();
                wildPokemonData.setName(jsonData.getString("name", "Unknown"));
                wildPokemonData.setLevel(jsonData.getInt("level", 1));

                // Position
                JsonValue positionValue = jsonData.get("position");
                if (positionValue != null && positionValue.isObject()) {
                    float x = positionValue.getFloat("x", 0f);
                    float y = positionValue.getFloat("y", 0f);
                    wildPokemonData.setPosition(new Vector2(x, y));
                } else {
                    wildPokemonData.setPosition(new Vector2(0f, 0f));
                }

                wildPokemonData.setDirection(jsonData.getString("direction", "down"));
                wildPokemonData.setMoving(jsonData.getBoolean("isMoving", false));
                wildPokemonData.setSpawnTime(jsonData.getLong("spawnTime", System.currentTimeMillis()));

                // Primary Type
                String primaryTypeStr = jsonData.getString("primaryType", "NORMAL");
                try {
                    wildPokemonData.setPrimaryType(Pokemon.PokemonType.valueOf(primaryTypeStr));
                } catch (IllegalArgumentException e) {
                    GameLogger.error("Invalid primary type '" + primaryTypeStr + "' in WildPokemonData. Defaulting to NORMAL.");
                    wildPokemonData.setPrimaryType(Pokemon.PokemonType.NORMAL);
                }

                // Secondary Type
                if (jsonData.has("secondaryType")) {
                    String secondaryTypeStr = jsonData.getString("secondaryType");
                    try {
                        wildPokemonData.setSecondaryType(Pokemon.PokemonType.valueOf(secondaryTypeStr));
                    } catch (IllegalArgumentException e) {
                        GameLogger.error("Invalid secondary type '" + secondaryTypeStr + "' in WildPokemonData. Setting to null.");
                        wildPokemonData.setSecondaryType(null);
                    }
                }

                wildPokemonData.setCurrentHp(jsonData.getFloat("currentHp", 1f));

                // Stats
                JsonValue statsValue = jsonData.get("stats");
                if (statsValue != null) {
                    PokemonData.Stats stats = json.readValue(PokemonData.Stats.class, statsValue);
                    wildPokemonData.setStats(stats);
                }

                // Moves
                JsonValue movesValue = jsonData.get("moves");
                if (movesValue != null && movesValue.isArray()) {
                    List<PokemonData.MoveData> moves = new ArrayList<>();
                    for (JsonValue moveValue = movesValue.child; moveValue != null; moveValue = moveValue.next) {
                        PokemonData.MoveData moveData = json.readValue(PokemonData.MoveData.class, moveValue);
                        moves.add(moveData);
                    }
                    wildPokemonData.setMoves(moves);
                }

                String uuidStr = jsonData.getString("uuid", null);
                wildPokemonData.setUuid(uuidStr != null ? UUID.fromString(uuidStr) : UUID.randomUUID());

                return wildPokemonData;
            }
        });
    }

    private static void validatePlayerInventory(PlayerData playerData) {
        if (playerData.getInventoryItems() == null) {
            List<ItemData> items = new ArrayList<>(Inventory.INVENTORY_SIZE);
            for (int i = 0; i < Inventory.INVENTORY_SIZE; i++) {
                items.add(null);
            }
            playerData.setInventoryItems(items);
        }
    }

    private static void validatePlayerPokemon(PlayerData playerData) {
        if (playerData.getPartyPokemon() == null) {
            List<PokemonData> pokemon = new ArrayList<>(6);
            for (int i = 0; i < 6; i++) {
                pokemon.add(null);
            }
            playerData.setPartyPokemon(pokemon);
        }
    }


    private static int calculateExperienceForLevel(int level) {
        return (int) (100 * Math.pow(level, 3) / 5); // Basic Pokemon experience formula
    }


}

================
File: main/java/io/github/pokemeetup/utils/textures/AssetManagerSingleton.java
================
// src/io/github/pokemeetup/managers/AssetManagerSingleton.java

package io.github.pokemeetup.utils.textures;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;

/**
 * Singleton class for managing shared assets like Skin and TextureAtlas.
 */
public class AssetManagerSingleton {
    private static Skin skin;
    private static TextureAtlas textureAtlas;

    /**
     * Retrieves the singleton instance of the Skin.
     *
     * @return The Skin instance.
     */
    public static Skin getSkin() {
        if (skin == null) {
            skin = new Skin(Gdx.files.internal("Skins/uiskin.json"));
        }
        return skin;
    }

    /**
     * Retrieves the singleton instance of the TextureAtlas.
     *
     * @return The TextureAtlas instance.
     */
    public static TextureAtlas getTextureAtlas() {
        if (textureAtlas == null) {
            textureAtlas = new TextureAtlas(Gdx.files.internal("atlas/game-atlas"));
        }
        return textureAtlas;
    }

    /**
     * Disposes of the Skin and TextureAtlas when they're no longer needed.
     */
    public static void dispose() {
        if (skin != null) {
            skin.dispose();
            skin = null;
        }
        if (textureAtlas != null) {
            textureAtlas.dispose();
            textureAtlas = null;
        }
    }
}

================
File: main/java/io/github/pokemeetup/utils/textures/BattleAssets.java
================
package io.github.pokemeetup.utils.textures;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.ui.ProgressBar;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import io.github.pokemeetup.pokemon.Pokemon;
import io.github.pokemeetup.utils.GameLogger;

import java.util.HashMap;
import java.util.Map;

public class BattleAssets {
    private static final int STATUS_ICON_HEIGHT = 16;
    private static final int TYPE_ICON_SIZE = 32;
    private static final Color HP_HIGH = new Color(0.28f, 0.78f, 0.45f, 1f);    // Green
    private static final Color HP_MED = new Color(1f, 0.85f, 0f, 1f);          // Yellow
    private static final Color HP_LOW = new Color(1f, 0.22f, 0.38f, 1f);       // Red

    private TextureAtlas uiAtlas;
    private TextureRegionDrawable battleBackground;
    private TextureRegionDrawable menuBackground;
    private TextureRegionDrawable buttonNormal;
    private TextureRegionDrawable buttonPressed;
    private Map<String, TextureRegionDrawable> backgrounds;
    private Map<String, TextureRegionDrawable> buttons;
    private Map<String, TextureRegionDrawable> hpBars;
    private Map<String, TextureRegionDrawable> databoxes;
    private Map<String, TextureRegion> statusIcons;
    private Map<Pokemon.PokemonType, TextureRegion> typeIcons;
    public BattleAssets() {
        // Initialize all maps in constructor
        backgrounds = new HashMap<>();
        buttons = new HashMap<>();
        hpBars = new HashMap<>();
        databoxes = new HashMap<>();
        statusIcons = new HashMap<>();
        typeIcons = new HashMap<>();
    }


    private void loadButtons() {
        buttons = new HashMap<>();
        TextureRegion buttonSheet = uiAtlas.findRegion("battle-buttons");

        if (buttonSheet == null) {
            GameLogger.error( "Failed to find battle-buttons region in atlas");
            return;
        }

        int buttonWidth = buttonSheet.getRegionWidth() / 2;
        int buttonHeight = buttonSheet.getRegionHeight() / 2;

        // Move buttons
        TextureRegion moveNormal = new TextureRegion(buttonSheet, 0, 0, buttonWidth, buttonHeight);
        TextureRegion movePressed = new TextureRegion(buttonSheet, buttonWidth, 0, buttonWidth, buttonHeight);

        // Action buttons
        TextureRegion actionNormal = new TextureRegion(buttonSheet, 0, buttonHeight,
            (int)(buttonWidth/1.5f), buttonHeight);
        TextureRegion actionPressed = new TextureRegion(buttonSheet,
            (int)(buttonWidth/1.5f), buttonHeight, (int)(buttonWidth/1.5f), buttonHeight);

        buttons.put("move-normal", new TextureRegionDrawable(moveNormal));
        buttons.put("move-pressed", new TextureRegionDrawable(movePressed));
        buttons.put("action-normal", new TextureRegionDrawable(actionNormal));
        buttons.put("action-pressed", new TextureRegionDrawable(actionPressed));
    }

    private void loadDataboxes() {
        databoxes = new HashMap<>();
        TextureRegion normal = uiAtlas.findRegion("hotbar_bg");
        TextureRegion foe = uiAtlas.findRegion("hotbar_bg");

        if (normal == null || foe == null) {
            GameLogger.error( "Failed to find databox regions in atlas");
            return;
        }

        databoxes.put("normal", new TextureRegionDrawable(normal));
        databoxes.put("foe", new TextureRegionDrawable(foe));
    }

    private void loadBackgrounds() {
        backgrounds = new HashMap<>();
        TextureRegion menuBg = uiAtlas.findRegion("battle-menu-bg");
        TextureRegion window = uiAtlas.findRegion("window");

        if (menuBg != null) {
            backgrounds.put("battle-menu-bg", new TextureRegionDrawable(menuBg));
        }
        if (window != null) {
            backgrounds.put("window", new TextureRegionDrawable(window));
        }
    }

    private void loadHPBars() {
        TextureRegion hpSheet = uiAtlas.findRegion("hp-bars");
        if (hpSheet == null) {
            GameLogger.error( "HP bars texture region not found");
            return;
        }

        int barHeight = hpSheet.getRegionHeight() / 4;
        hpBars.put("background", new TextureRegionDrawable(
            new TextureRegion(hpSheet, 0, 0, hpSheet.getRegionWidth(), barHeight)));
        hpBars.put("green", new TextureRegionDrawable(
            new TextureRegion(hpSheet, 0, barHeight, hpSheet.getRegionWidth(), barHeight)));
        hpBars.put("yellow", new TextureRegionDrawable(
            new TextureRegion(hpSheet, 0, barHeight * 2, hpSheet.getRegionWidth(), barHeight)));
        hpBars.put("red", new TextureRegionDrawable(
            new TextureRegion(hpSheet, 0, barHeight * 3, hpSheet.getRegionWidth(), barHeight)));
    }

    private void loadStatusIcons() {
        TextureRegion statusSheet = uiAtlas.findRegion("status-icons");
        if (statusSheet == null) {
            GameLogger.error( "Status icons texture region not found");
            return;
        }

        String[] conditions = {"PSN", "PAR", "BRN", "FRZ", "SLP", "TOX"};
        int iconWidth = statusSheet.getRegionWidth() / conditions.length;

        for (int i = 0; i < conditions.length; i++) {
            TextureRegion icon = new TextureRegion(statusSheet,
                i * iconWidth, 0, iconWidth, STATUS_ICON_HEIGHT);
            statusIcons.put(conditions[i], icon);
        }
    }    public TextureRegionDrawable getButtonDrawable(String key) {
        return buttons.get(key);
    }

    public TextureRegionDrawable getDataboxNormal() {
        return databoxes.get("normal");
    }

    public TextureRegionDrawable getDataboxFoe() {
        return databoxes.get("foe");
    }

    public TextureRegionDrawable getBackground(String key) {
        return backgrounds.get(key);
    }

    public TextureRegion getStatusIcon(String status) {
        return statusIcons.get(status);
    }

    public TextureAtlas getUiAtlas() {
        return uiAtlas;
    }

    public Map<String, TextureRegionDrawable> getBackgrounds() {
        return backgrounds;
    }

    public Map<String, TextureRegionDrawable> getButtons() {
        return buttons;
    }

    public Map<String, TextureRegionDrawable> getHpBars() {
        return hpBars;
    }

    public Map<String, TextureRegionDrawable> getDataboxes() {
        return databoxes;
    }

    public Map<String, TextureRegion> getStatusIcons() {
        return statusIcons;
    }

    public Map<Pokemon.PokemonType, TextureRegion> getTypeIcons() {
        return typeIcons;
    }

    private void loadTypeIcons() {
        TextureRegion typeSheet = uiAtlas.findRegion("pokemon-type-icons");
        if (typeSheet == null) {
            GameLogger.error( "Pokemon type icons texture region not found");
            return;
        }

        int cols = typeSheet.getRegionWidth() / TYPE_ICON_SIZE;
        Pokemon.PokemonType[] types = Pokemon.PokemonType.values();

        for (int i = 0; i < types.length; i++) {
            int x = (i % cols) * TYPE_ICON_SIZE;
            int y = (i / cols) * TYPE_ICON_SIZE;
            TextureRegion icon = new TextureRegion(typeSheet, x, y, TYPE_ICON_SIZE, TYPE_ICON_SIZE);
            typeIcons.put(types[i], icon);
        }
    }



    // In BattleAssets class
    public void initialize() {
        if (uiAtlas != null) {
            // Already initialized
            return;
        }

        try {
            FileHandle atlasFile = Gdx.files.internal("atlas/ui-gfx-atlas.atlas");
            if (!atlasFile.exists()) {
                GameLogger.error("UI atlas file not found at: atlas/ui-gfx-atlas.atlas");
                throw new RuntimeException("UI atlas file not found");
            }

            uiAtlas = new TextureAtlas(atlasFile);

            // Only load if not already loaded
            if (backgrounds.isEmpty()) loadBackgrounds();
            if (buttons.isEmpty()) loadButtons();
            if (hpBars.isEmpty()) loadHPBars();
            if (databoxes.isEmpty()) loadDataboxes();
            if (statusIcons.isEmpty()) loadStatusIcons();
            if (typeIcons.isEmpty()) loadTypeIcons();

            GameLogger.info("Battle assets initialized/reused successfully");

        } catch (Exception e) {
            GameLogger.error("Failed to initialize battle assets: " + e.getMessage());
            throw new RuntimeException("Failed to initialize battle assets", e);
        }
    }

    // Modify dispose to be more selective
    public void dispose() {
        // Don't dispose shared textures from TextureManager
        // Only clear references
        if (backgrounds != null) backgrounds.clear();
        if (buttons != null) buttons.clear();
        if (hpBars != null) hpBars.clear();
        if (databoxes != null) databoxes.clear();
        if (statusIcons != null) statusIcons.clear();
        if (typeIcons != null) typeIcons.clear();

        // Don't dispose uiAtlas as it's managed by TextureManager
        uiAtlas = null;
    }
    public ProgressBar.ProgressBarStyle createHPBarStyle(float percentage) {
        ProgressBar.ProgressBarStyle style = new ProgressBar.ProgressBarStyle();

        // Create background (dark gray)
        Pixmap bgPixmap = new Pixmap(32, 16, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(51/255f, 51/255f, 51/255f, 1); // #333333
        bgPixmap.fill();
        style.background = new TextureRegionDrawable(new TextureRegion(new Texture(bgPixmap)));
        bgPixmap.dispose();

        // Create foreground bar
        Pixmap fgPixmap = new Pixmap(32, 14, Pixmap.Format.RGBA8888);

        // Set color based on percentage
        if (percentage > 0.5f) {
            fgPixmap.setColor(71/255f, 201/255f, 93/255f, 1);  // #47C95D
        } else if (percentage > 0.2f) {
            fgPixmap.setColor(255/255f, 217/255f, 0/255f, 1);  // #FFD900
        } else {
            fgPixmap.setColor(255/255f, 57/255f, 57/255f, 1);  // #FF3939
        }

        fgPixmap.fill();
        style.knob = new TextureRegionDrawable(new TextureRegion(new Texture(fgPixmap)));
        style.knobBefore = style.knob;
        fgPixmap.dispose();

        return style;
    }


    private void createFallbackBackgrounds() {
        // Create simple colored backgrounds as fallback
        Pixmap bgPixmap = new Pixmap(384, 128, Pixmap.Format.RGBA8888);
        bgPixmap.setColor(0, 0, 0, 0.8f);
        bgPixmap.fill();
        battleBackground = new TextureRegionDrawable(new TextureRegion(new Texture(bgPixmap)));
        menuBackground = battleBackground;
        bgPixmap.dispose();
    }

    private void createFallbackButtons() {
        // Create simple button backgrounds as fallback
        Pixmap buttonPixmap = new Pixmap(192, 48, Pixmap.Format.RGBA8888);
        buttonPixmap.setColor(0.3f, 0.3f, 0.3f, 1);
        buttonPixmap.fill();
        buttonNormal = new TextureRegionDrawable(new TextureRegion(new Texture(buttonPixmap)));

        buttonPixmap.setColor(0.4f, 0.4f, 0.4f, 1);
        buttonPixmap.fill();
        buttonPressed = new TextureRegionDrawable(new TextureRegion(new Texture(buttonPixmap)));
        buttonPixmap.dispose();
    }



}

================
File: main/java/io/github/pokemeetup/utils/textures/BlockTextureManager.java
================
package io.github.pokemeetup.utils.textures;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.utils.GameLogger;

import java.util.HashMap;
import java.util.Map;

public class BlockTextureManager {
    private static final Map<String, Boolean> chestStates = new HashMap<>();  // Track chest open/closed states
    private static final float FRAME_DURATION = 0.35f; // Adjust animation speed
    private static final Map<String, Animation<TextureRegion>> blockAnimations = new HashMap<>();
    private static final Map<String, TextureRegion[]> blockFrames = new HashMap<>();
    private final Map<String, TextureRegion> itemIcons;
    public BlockTextureManager() {
        this.itemIcons = new HashMap<>();
        initializeBlockTextures();
    }


    private static int getCustomAnimationFrame(float stateTime) {
        // Calculate which frame we should be on in the sequence: 0->1->2->1
        float totalCycleDuration = FRAME_DURATION * 4; // Time for complete cycle
        float cycleTime = stateTime % totalCycleDuration;
        int frame = (int) (cycleTime / FRAME_DURATION);

        // Map frame numbers to our desired sequence (0->1->2->1)
        switch (frame) {
            case 0: return 0; // First frame
            case 1: return 1; // Second frame
            case 2: return 2; // Third frame
            case 3: return 1; // Back to second frame
            default: return 0;
        }
    }

    public static TextureRegion getBlockFrame(PlaceableBlock block, float stateTime) {
        String blockId = block.getType().id;

        if (blockId.equals("chest")) {
            TextureRegion[] frames = blockFrames.get(blockId);
            if (frames != null) {
                boolean isOpen = block.isChestOpen();
                return frames[isOpen ? 1 : 0];
            }
            return null;
        }

        Animation<TextureRegion> animation = blockAnimations.get(blockId);
        if (animation != null) {
            if (blockId.equals("craftingtable") || blockId.equals("furnace")) {
                int frameIndex = getCustomAnimationFrame(stateTime);
                TextureRegion[] frames = blockFrames.get(blockId);
                if (frames != null && frameIndex < frames.length) {
                    return frames[frameIndex];
                }
            }
            return animation.getKeyFrame(stateTime, true);
        }
        return null;
    }



    private void initializeBlockTextures() {
        // Initialize existing blocks (chest, crafting table, furnace, wooden planks)
        initializeExistingBlocks();

        // Initialize new house-related blocks
        initializeHouseBlocks();

        // Initialize roof-related blocks
        initializeRoofBlocks();

        GameLogger.info("Initialized block textures - Blocks loaded: " + blockFrames.keySet());
    }



    private void initializeHouseBlocks() {
        // Initialize house middle section
        initializeSingleFrameBlock("house_middlesection");
        initializeSingleFrameBlock("house_middlesection_part");
        initializeSingleFrameBlock("house_midsection_part");
        initializeSingleFrameBlock("house_part");
        initializeSingleFrameBlock("house_planks");
        initializeSingleFrameBlock("wooden_door");
    }
    private void initializeExistingBlocks() {
        // Chest initialization
        TextureRegion chestRegion = TextureManager.blocks.findRegion("chest");
        if (chestRegion != null) {
            TextureRegion[] chestFrames = new TextureRegion[2];
            int frameWidth = chestRegion.getRegionWidth() / 2;

            chestFrames[0] = new TextureRegion(
                chestRegion.getTexture(),
                chestRegion.getRegionX(),
                chestRegion.getRegionY(),
                frameWidth,
                chestRegion.getRegionHeight()
            );
            chestFrames[1] = new TextureRegion(
                chestRegion.getTexture(),
                chestRegion.getRegionX() + frameWidth,
                chestRegion.getRegionY(),
                frameWidth,
                chestRegion.getRegionHeight()
            );

            blockFrames.put("chest", chestFrames);
            blockAnimations.put("chest", new Animation<>(FRAME_DURATION, chestFrames));
            itemIcons.put("chest", chestFrames[0]);
        }

        // Crafting table initialization
        TextureRegion craftingTableRegion = TextureManager.blocks.findRegion("craftingtable");
        if (craftingTableRegion != null) {
            TextureRegion[] craftingFrames = new TextureRegion[3];
            int frameWidth = craftingTableRegion.getRegionWidth() / 3;

            for (int i = 0; i < 3; i++) {
                craftingFrames[i] = new TextureRegion(
                    craftingTableRegion.getTexture(),
                    craftingTableRegion.getRegionX() + (i * frameWidth),
                    craftingTableRegion.getRegionY(),
                    frameWidth,
                    craftingTableRegion.getRegionHeight()
                );
            }
            blockFrames.put("craftingtable", craftingFrames);
            blockAnimations.put("craftingtable", new Animation<>(FRAME_DURATION, craftingFrames));
            itemIcons.put("craftingtable", craftingFrames[0]);
        }

        // Furnace initialization
        TextureRegion furnaceRegion = TextureManager.blocks.findRegion("furnace");
        if (furnaceRegion != null) {
            TextureRegion[] furnaceFrames = new TextureRegion[3];
            int frameWidth = furnaceRegion.getRegionWidth() / 3;

            for (int i = 0; i < 3; i++) {
                furnaceFrames[i] = new TextureRegion(
                    furnaceRegion.getTexture(),
                    furnaceRegion.getRegionX() + (i * frameWidth),
                    furnaceRegion.getRegionY(),
                    frameWidth,
                    furnaceRegion.getRegionHeight()
                );
            }
            blockFrames.put("furnace", furnaceFrames);
            blockAnimations.put("furnace", new Animation<>(FRAME_DURATION, furnaceFrames));
            itemIcons.put("furnace", furnaceFrames[0]);
        }

        // Wooden planks initialization
        TextureRegion woodenPlanks = TextureManager.blocks.findRegion("wooden_planks");
        if (woodenPlanks != null) {
            TextureRegion[] planksFrames = {new TextureRegion(woodenPlanks)};
            blockFrames.put("wooden_planks", planksFrames);
            blockAnimations.put("wooden_planks", new Animation<>(FRAME_DURATION, planksFrames));
            itemIcons.put("wooden_planks", planksFrames[0]);
        }
    }
    private void initializeRoofBlocks() {
        // Initialize roof pieces
        initializeSingleFrameBlock("roof_corner");
        initializeSingleFrameBlock("roof_middle");
        initializeSingleFrameBlock("roof_middle_outer");
        initializeSingleFrameBlock("roof_middle_outerside");
        initializeSingleFrameBlock("roof_middle_outside");
        initializeSingleFrameBlock("roof_middle_part");
        initializeSingleFrameBlock("roofinner");
    }

    private void initializeSingleFrameBlock(String blockId) {
        TextureRegion region = TextureManager.blocks.findRegion(blockId);
        if (region != null) {
            TextureRegion[] frames = {new TextureRegion(region)};
            blockFrames.put(blockId, frames);
            blockAnimations.put(blockId, new Animation<>(FRAME_DURATION, frames));
            itemIcons.put(blockId, frames[0]);
        }
    }
    public TextureRegion getItemIcon(String blockId) {
        return itemIcons.get(blockId);
    }

}

================
File: main/java/io/github/pokemeetup/utils/textures/TextureManager.java
================
package io.github.pokemeetup.utils.textures;

    import com.badlogic.gdx.graphics.Color;
    import com.badlogic.gdx.graphics.Pixmap;
    import com.badlogic.gdx.graphics.Texture;
    import com.badlogic.gdx.graphics.g2d.TextureAtlas;
    import com.badlogic.gdx.graphics.g2d.TextureRegion;
    import io.github.pokemeetup.pokemon.Pokemon;
    import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
    import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
    import io.github.pokemeetup.utils.GameLogger;

    import java.util.HashMap;
    import java.util.Map;

    import static io.github.pokemeetup.utils.textures.TileType.*;

    public class TextureManager {
        public static final int TYPE_ICON_WIDTH = 64;
        public static final int TYPE_ICON_HEIGHT = 38;
        public static final int STATUS_ICON_WIDTH = 44;
        public static final int STATUS_ICON_HEIGHT = 16;
        public static final Map<Integer, TextureRegion> tileTextures = new HashMap<>();
        private static final Map<BiomeType, Map<Integer, TextureRegion>> biomeTileTextures = new HashMap<>();
        private static final Map<Pokemon.PokemonType, TextureRegion> typeIcons = new HashMap<>();
        private static final Map<StatusCondition, TextureRegion> statusIcons = new HashMap<>();
        private static final Map<Pokemon.PokemonType, Color> TYPE_COLORS = new HashMap<>();
        private static final Map<StatusCondition, Color> STATUS_COLORS = new HashMap<>();
        public static TextureAtlas ui;
        public static TextureAtlas pokemonback;
        public static TextureAtlas buildings;
        public static TextureAtlas pokemonfront;
        public static TextureAtlas pokemonicon;
        public static TextureAtlas pokemonoverworld;
        public static TextureAtlas items;
        public static TextureAtlas boy;
        public static TextureAtlas tiles;
        public static TextureAtlas hairstyles;
        public static TextureAtlas battlebacks;
        public static TextureAtlas mountains;
        public static TextureAtlas effects;
        public static TextureAtlas blocks;
        public static TextureAtlas characters;
        public static TextureAtlas clothing;

        private static boolean usingFallbackSystem = false;
        private static Texture whitePixel;

        static {
            // Initialize status colors
            STATUS_COLORS.put(StatusCondition.NONE, Color.WHITE);
            STATUS_COLORS.put(StatusCondition.SLEEP, Color.GRAY);
            STATUS_COLORS.put(StatusCondition.POISON, new Color(0.627f, 0.439f, 0.627f, 1));
            STATUS_COLORS.put(StatusCondition.BURN, new Color(0.940f, 0.501f, 0.376f, 1));
            STATUS_COLORS.put(StatusCondition.FREEZE, new Color(0.564f, 0.815f, 0.940f, 1));
            STATUS_COLORS.put(StatusCondition.PARALYSIS, new Color(0.972f, 0.815f, 0.376f, 1));
            STATUS_COLORS.put(StatusCondition.TOXIC, new Color(0.5f, 0.1f, 0.5f, 1));
            STATUS_COLORS.put(StatusCondition.CONFUSION, new Color(0.940f, 0.376f, 0.564f, 1));
        }

        static {
            // Update type color mappings
            // Initialize type colors
            TYPE_COLORS.put(Pokemon.PokemonType.NORMAL, new Color(0.658f, 0.658f, 0.658f, 1));    // A8A878
            TYPE_COLORS.put(Pokemon.PokemonType.FIGHTING, new Color(0.752f, 0.470f, 0.470f, 1));  // C03028
            TYPE_COLORS.put(Pokemon.PokemonType.FLYING, new Color(0.658f, 0.564f, 0.940f, 1));    // A890F0
            TYPE_COLORS.put(Pokemon.PokemonType.POISON, new Color(0.627f, 0.439f, 0.627f, 1));    // A040A0
            TYPE_COLORS.put(Pokemon.PokemonType.GROUND, new Color(0.878f, 0.752f, 0.470f, 1));    // E0C068
            TYPE_COLORS.put(Pokemon.PokemonType.ROCK, new Color(0.752f, 0.658f, 0.439f, 1));      // B8A038
            TYPE_COLORS.put(Pokemon.PokemonType.BUG, new Color(0.658f, 0.752f, 0.439f, 1));       // A8B820
            TYPE_COLORS.put(Pokemon.PokemonType.GHOST, new Color(0.439f, 0.439f, 0.627f, 1));     // 705898
            TYPE_COLORS.put(Pokemon.PokemonType.STEEL, new Color(0.752f, 0.752f, 0.815f, 1));     // B8B8D0
            TYPE_COLORS.put(Pokemon.PokemonType.FIRE, new Color(0.940f, 0.501f, 0.376f, 1));      // F08030
            TYPE_COLORS.put(Pokemon.PokemonType.WATER, new Color(0.376f, 0.564f, 0.940f, 1));     // 6890F0
            TYPE_COLORS.put(Pokemon.PokemonType.GRASS, new Color(0.470f, 0.815f, 0.376f, 1));     // 78C850
            TYPE_COLORS.put(Pokemon.PokemonType.ELECTRIC, new Color(0.972f, 0.815f, 0.376f, 1));  // F8D030
            TYPE_COLORS.put(Pokemon.PokemonType.PSYCHIC, new Color(0.940f, 0.376f, 0.564f, 1));   // F85888
            TYPE_COLORS.put(Pokemon.PokemonType.ICE, new Color(0.564f, 0.815f, 0.940f, 1));       // 98D8D8
            TYPE_COLORS.put(Pokemon.PokemonType.DRAGON, new Color(0.439f, 0.376f, 0.940f, 1));    // 7038F8
            TYPE_COLORS.put(Pokemon.PokemonType.DARK, new Color(0.439f, 0.376f, 0.376f, 1));      // 705848
            TYPE_COLORS.put(Pokemon.PokemonType.FAIRY, new Color(0.940f, 0.627f, 0.940f, 1));     // F0B6BC
            TYPE_COLORS.put(Pokemon.PokemonType.UNKNOWN, new Color(0.470f, 0.470f, 0.470f, 1));   // 68A090

        }



        private static void createFallbackIcons() {
            for (Pokemon.PokemonType type : Pokemon.PokemonType.values()) {
                Color color = TYPE_COLORS.get(type);
                TextureRegion icon = createColoredIcon(color, TYPE_ICON_WIDTH, TYPE_ICON_HEIGHT);
                typeIcons.put(type, icon);
            }

            for (StatusCondition status : StatusCondition.values()) {
                if (status != StatusCondition.NONE) {
                    Color color = STATUS_COLORS.get(status);
                    TextureRegion icon = createColoredIcon(color, STATUS_ICON_WIDTH, STATUS_ICON_HEIGHT);
                    statusIcons.put(status, icon);
                }
            }
        }

        public static TextureRegion getTextureForObjectType(WorldObject.ObjectType objectType) {
            switch (objectType) {
                case TREE_0:
                    return tiles.findRegion("treeONE");
                case TREE_1:
                    return tiles.findRegion("treeTWO");
                case SNOW_TREE:
                    return tiles.findRegion("snow_tree");
                case HAUNTED_TREE:
                    return tiles.findRegion("haunted_tree");
                case POKEBALL:
                    return items.findRegion("pokeball");
                case CACTUS:
                    return tiles.findRegion("desert_cactus");
                case SUNFLOWER:
                    return tiles.findRegion("sunflower");
                case VINES:
                    return tiles.findRegion("vines");
                case RAIN_TREE:
                    return tiles.findRegion("rain_tree");
                case BUSH:
                    return tiles.findRegion("bush");
                case DEAD_TREE:
                    return tiles.findRegion("dead_tree");
                case SMALL_HAUNTED_TREE:
                    return tiles.findRegion("small_haunted_tree");
                case RUINS_TREE:
                    return tiles.findRegion("ruins_tree");
                case RUIN_POLE:
                    return tiles.findRegion("ruins_pole");
                case APRICORN_TREE:
                    return tiles.findRegion("apricorn_tree_grown");
                default:
                    GameLogger.error("Missing texture for object type: " + objectType);
                    return null;
            }
        }

        private static TextureRegion createColoredIcon(Color color, int width, int height) {
            Pixmap pixmap = new Pixmap(width, height, Pixmap.Format.RGBA8888);
            pixmap.setColor(color);
            pixmap.fillRectangle(0, 0, width, height);

            // Add a border
            pixmap.setColor(Color.WHITE);
            pixmap.drawRectangle(0, 0, width, height);

            Texture texture = new Texture(pixmap);
            pixmap.dispose();

            return new TextureRegion(texture);
        }

        private static void loadTypeAndStatusIcons() {
            TextureRegion typesSheet = ui.findRegion("types");
            TextureRegion statusSheet = ui.findRegion("statuses");

            if (typesSheet == null || statusSheet == null) {
                GameLogger.info("Sprite sheets not found, using fallback system");
                usingFallbackSystem = true;
                createFallbackIcons();
                return;
            }

            TextureRegion[][] statusFrames = statusSheet.split(STATUS_ICON_WIDTH, STATUS_ICON_HEIGHT);
            for (StatusCondition status : StatusCondition.values()) {
                if (status != StatusCondition.NONE && (status.getIndex() - 1) < statusFrames.length) { // Corrected condition
                    statusIcons.put(status, statusFrames[status.getIndex() - 1][0]); // Corrected access
                } else if (status != StatusCondition.NONE) {
                    GameLogger.error("Missing status icon for: " + status.name());
                }
            }

            boolean hasAllIcons = true;
            for (Pokemon.PokemonType type : Pokemon.PokemonType.values()) {
                if (!typeIcons.containsKey(type)) {
                    hasAllIcons = false;
                    break;
                }
            }

            for (StatusCondition status : StatusCondition.values()) {
                if (status != StatusCondition.NONE && !statusIcons.containsKey(status)) {
                    hasAllIcons = false;
                    break;
                }
            }

            if (!hasAllIcons) {
                GameLogger.info("Missing icons detected, using fallback system");
                usingFallbackSystem = true;
                createFallbackIcons();
            }
        }

        public static TextureRegion getStatusIcon(StatusCondition status) {
            return statusIcons.get(status);
        }

        // Helper method to get type color
        public static Color getTypeColor(Pokemon.PokemonType type) {
            return TYPE_COLORS.getOrDefault(type, Color.WHITE);
        }

        public static TextureRegion getOverworldSprite(String name) {
            if (name == null) {
                GameLogger.error("Attempted to get overworld sprite with null name.");
                return null;
            }

            // Normalize the name to lowercase to ensure consistency
            String normalizedName = name.toUpperCase();

            TextureRegion sprite = pokemonoverworld.findRegion(normalizedName + "_overworld");
            if (sprite == null) {
                GameLogger.error("Overworld sprite for Pokémon '" + name + "' not found.");
                return null;
            }
            return sprite;
        }


        public static TextureAtlas getUi() {
            return ui;
        }

        public static TextureAtlas getPokemonback() {
            return pokemonback;
        }

        public static TextureAtlas getPokemonfront() {
            return pokemonfront;
        }

        public static TextureAtlas getPokemonicon() {
            return pokemonicon;
        }

        public static TextureAtlas getPokemonoverworld() {
            return pokemonoverworld;
        }

        public static TextureAtlas getItems() {
            return items;
        }

        public static TextureAtlas getBoy() {
            try {
                if (boy == null) {
                    GameLogger.error("Boy atlas is null");
                    return null;
                }

                // Verify atlas textures
                for (Texture texture : boy.getTextures()) {
                    if (texture == null) {
                        GameLogger.error("Boy atlas texture is null or disposed");
                        return null;
                    }
                }

                // Verify some key regions
                String[] testRegions = {
                    "boy_walk_down",
                    "boy_walk_up",
                    "boy_run_down",
                    "boy_run_up"
                };

                for (String regionName : testRegions) {
                    TextureAtlas.AtlasRegion region = boy.findRegion(regionName, 1);
                    if (region == null || region.getTexture() == null) {
                        GameLogger.error("Critical region missing or invalid: " + regionName);
                        return null;
                    }
                }

                return boy;
            } catch (Exception e) {
                GameLogger.error("Error accessing boy atlas: " + e.getMessage());
                return null;
            }

        }

        public static void debugAtlasState(String name, TextureAtlas atlas) {
            if (atlas == null) {
                return;
            }

            try {
            } catch (Exception e) {
            }
        }

        public static TextureAtlas getBattlebacks() {
            return battlebacks;
        }

        public static TextureAtlas getTiles() {
            return tiles;
        }

        public static Texture getWhitePixel() {
            if (whitePixel == null) {
                // Create on demand if not initialized
                Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
                pixmap.setColor(Color.WHITE);
                pixmap.fill();
                whitePixel = new Texture(pixmap);
                pixmap.dispose();
            }
            return whitePixel;
        }

        public static void initialize(TextureAtlas battlebacks, TextureAtlas ui,
                                      TextureAtlas pokemonback, TextureAtlas pokemonfront, TextureAtlas pokemonicon,
                                      TextureAtlas pokemonoverworld, TextureAtlas items, TextureAtlas boy,
                                      TextureAtlas tiles, TextureAtlas effects, TextureAtlas mountains
            , TextureAtlas blocks, TextureAtlas characters, TextureAtlas clothing, TextureAtlas hairstyles, TextureAtlas buildings) {

            TextureManager.effects = effects;
            TextureManager.battlebacks = battlebacks;
            TextureManager.ui = ui;
            TextureManager.pokemonback = pokemonback;
            TextureManager.pokemonfront = pokemonfront;
            TextureManager.pokemonicon = pokemonicon;
            TextureManager.pokemonoverworld = pokemonoverworld;
            TextureManager.items = items;
            TextureManager.boy = boy;
            TextureManager.tiles = tiles;
            TextureManager.mountains = mountains;
            TextureManager.blocks = blocks;
            TextureManager.characters = characters;
            TextureManager.clothing = clothing;
            TextureManager.hairstyles = hairstyles;
            TextureManager.buildings = buildings;

            // Create white pixel texture
            Pixmap pixmap = new Pixmap(1, 1, Pixmap.Format.RGBA8888);
            pixmap.setColor(Color.WHITE);
            pixmap.fill();
            whitePixel = new Texture(pixmap);
            for (Texture texture : tiles.getTextures()) {
                texture.setFilter(Texture.TextureFilter.Nearest, Texture.TextureFilter.Nearest);
            }
            loadTypeAndStatusIcons();
            loadCentralTileTextures();

            GameLogger.info("=== Initializing Texture Manager ===");
            debugAtlas("tiles", tiles);
            debugAtlas("ui", ui);
            debugAtlas("boy", boy);
            debugAtlas("effects", effects);
            GameLogger.info("=== Texture Manager Initialization Complete ===");

        }

        private static void loadCentralTileTextures() {
            // Ensure tiles atlas is loaded
            if (tiles == null) {
                GameLogger.error("Tiles atlas is not initialized!");
                return;
            }
    //            loadAllBiomeTextures();
            GameLogger.info("=== Starting Texture Loading ===");

            // First log all available regions
            GameLogger.info("Available regions in atlas:");
            if (tiles != null) {
                for (TextureAtlas.AtlasRegion region : tiles.getRegions()) {
                    GameLogger.info(" - " + region.name);
                }
            }
            assert tiles != null;
            tileTextures.put(WATER, tiles.findRegion("water"));
            tileTextures.put(GRASS, tiles.findRegion("grass"));
            tileTextures.put(SAND, tiles.findRegion("sand"));
            tileTextures.put(ROCK, tiles.findRegion("rock"));
            tileTextures.put(SNOW, tiles.findRegion("snow_base"));
            tileTextures.put(HAUNTED_GRASS, tiles.findRegion("haunted_grass"));
            tileTextures.put(SNOW_TALL_GRASS, tiles.findRegion("snow_tall_grass"));
            tileTextures.put(HAUNTED_TALL_GRASS, tiles.findRegion("haunted_tall_grass"));
            tileTextures.put(HAUNTED_SHROOM, tiles.findRegion("haunted_shroom"));
            tileTextures.put(HAUNTED_SHROOMS, tiles.findRegion("haunted_shrooms"));
            tileTextures.put(TALL_GRASS, tiles.findRegion("tall_grass"));
            tileTextures.put(FOREST_GRASS, tiles.findRegion("forest_grass"));
            tileTextures.put(FOREST_TALL_GRASS, tiles.findRegion("forest_tall_grass"));
            tileTextures.put(RAIN_FOREST_GRASS, tiles.findRegion("forest_grass"));
            tileTextures.put(RAIN_FOREST_TALL_GRASS, tiles.findRegion("rain_forest_tall_grass"));
            tileTextures.put(DESERT_SAND, tiles.findRegion("desert_sand"));
            tileTextures.put(DESERT_ROCKS, tiles.findRegion("desert_rock"));
            tileTextures.put(DESERT_GRASS, tiles.findRegion("desert_grass"));
            tileTextures.put(GRASS_2, tiles.findRegion("grass", 2));
            tileTextures.put(FLOWER, tiles.findRegion("flower",1));
            tileTextures.put(FLOWER_1, tiles.findRegion("flower", 1));
            tileTextures.put(TALL_GRASS_2, tiles.findRegion("tall_grass", 3));
            tileTextures.put(TALL_GRASS_3, tiles.findRegion("tall_grass", 2));
            tileTextures.put(FLOWER_2, tiles.findRegion("flower", 1));
            tileTextures.put(GRASS_3, tiles.findRegion("grass", 3));
            tileTextures.put(SNOW_2, tiles.findRegion("snow_grass"));
            tileTextures.put(SNOW_3, tiles.findRegion("snow_base"));
            tileTextures.put(RUINS_GRASS_0, tiles.findRegion("ruins_grass", 0));
            tileTextures.put(RUINS_GRASS, tiles.findRegion("ruins_grass", 1));
            tileTextures.put(RUINS_TALL_GRASS, tiles.findRegion("ruins_tall_grass", 0));
            tileTextures.put(RUINS_BRICKS, tiles.findRegion("ruin_bricks", 0));
            tileTextures.put(CAVE_ENTRANCE, tiles.findRegion("cave_entrance"));
            tileTextures.put(MOUNTAIN_TILE_TOP_LEFT_ROCK_BG, tiles.findRegion("MOUNTAIN_TILE_TOP_LEFT_ROCK_BG"));
            tileTextures.put(MOUNTAIN_TILE_TOP_MID, tiles.findRegion("MOUNTAIN_TILE_TOP_MID"));
            tileTextures.put(MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG, tiles.findRegion("MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG"));
            tileTextures.put(MOUNTAIN_TILE_MID_LEFT, tiles.findRegion("MOUNTAIN_TILE_MID_LEFT"));
            tileTextures.put(MOUNTAIN_TILE_CENTER, tiles.findRegion("MOUNTAIN_TILE_CENTER"));
            tileTextures.put(MOUNTAIN_TILE_MID_RIGHT, tiles.findRegion("MOUNTAIN_TILE_MID_RIGHT"));
            tileTextures.put(MOUNTAIN_TILE_BOT_LEFT_ROCK_BG, tiles.findRegion("MOUNTAIN_TILE_BOT_LEFT_ROCK_BG"));
            tileTextures.put(MOUNTAIN_TILE_BOT_MID, tiles.findRegion("MOUNTAIN_TILE_BOT_MID"));
            tileTextures.put(MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG, tiles.findRegion("MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG"));
            tileTextures.put(MOUNTAIN_TILE_TOP_LEFT_GRASS_BG, tiles.findRegion("MOUNTAIN_TILE_TOP_LEFT_GRASS_BG"));
            tileTextures.put(MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG, tiles.findRegion("MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG"));
            tileTextures.put(MOUNTAIN_TILE_BOT_RIGHT_GRASS_BG, tiles.findRegion("MOUNTAIN_TILE_BOT_RIGHT_GRASS_BG"));
            tileTextures.put(TileType.MOUNTAIN_WALL, tiles.findRegion("mountainBASEMIDDLE"));
            tileTextures.put(TileType.MOUNTAIN_CORNER_TL, tiles.findRegion("mountainTOPLEFT")); // Top-left corner
            tileTextures.put(TileType.MOUNTAIN_CORNER_TR, tiles.findRegion("mountaintopRIGHT")); // Top-right corner
            tileTextures.put(TileType.MOUNTAIN_CORNER_BL, tiles.findRegion("mountainBASELEFT")); // Bottom-left corner
            tileTextures.put(TileType.MOUNTAIN_CORNER_BR, tiles.findRegion("mountainbaseRIGHT")); // Bottom-right corner
            tileTextures.put(TileType.MOUNTAIN_SLOPE_LEFT, tiles.findRegion("tile080"));
            tileTextures.put(TileType.MOUNTAIN_SLOPE_RIGHT, tiles.findRegion("tile046"));
            tileTextures.put(TileType.MOUNTAIN_STAIRS, tiles.findRegion("mountainstairsMiddle"));
            tileTextures.put(TileType.MOUNTAIN_PATH, tiles.findRegion("tile081"));
            tileTextures.put(TileType.MOUNTAIN_BASE_EDGE, tiles.findRegion("tile038"));
            tileTextures.put(TileType.MOUNTAIN_STAIRS_LEFT, tiles.findRegion("mountainstairsLEFT")); // Left stairs
            tileTextures.put(TileType.MOUNTAIN_STAIRS_RIGHT, tiles.findRegion("mountainstarsRIGHT")); // Right stairs
            tileTextures.put(TileType.MOUNTAIN_PEAK, tiles.findRegion("tile0118"));
            tileTextures.put(TileType.MOUNTAIN_BASE, tiles.findRegion("mountainBASEMIDDLE"));
            tileTextures.put(TileType.MOUNTAIN_EDGE_LEFT, tiles.findRegion("MOUNTAINMIDDLELEFT"));
            tileTextures.put(TileType.MOUNTAIN_EDGE_RIGHT, tiles.findRegion("mountainMIDDLERIGHT"));
            tileTextures.put(TileType.MOUNTAIN_EDGE_TOP, tiles.findRegion("tile029"));
            tileTextures.put(TileType.MOUNTAIN_EDGE_BOTTOM, tiles.findRegion("tile089"));
            tileTextures.put(TileType.MOUNTAIN_CORNER_INNER_TOPLEFT, tiles.findRegion("tile029"));
            tileTextures.put(STAIRS, tiles.findRegion("tile052"));
            tileTextures.put(MOUNTAIN_TILE_CONNECTING_CORNER_TOP_LEFT, tiles.findRegion("MOUNTAIN_TILE_CONNECTING_CORNER_TOP_LEFT"));
            tileTextures.put(MOUNTAIN_TILE_CONNECTING_CORNER_TOP_RIGHT, tiles.findRegion("MOUNTAIN_TILE_CONNECTING_CORNER_TOP_RIGHT"));
            tileTextures.put(MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_LEFT, tiles.findRegion("MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_LEFT"));
            tileTextures.put(MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_RIGHT, tiles.findRegion("MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_RIGHT"));

            // Add other tile types as needed
            for (TextureRegion texture : tileTextures.values()) {
                if (texture != null && texture.getTexture() != null) {
                    texture.getTexture().setFilter(Texture.TextureFilter.Nearest, Texture.TextureFilter.Nearest);
                }
            }
            GameLogger.info("TileType name mappings:");
            for (Map.Entry<Integer, String> entry : TileType.getTileTypeNames().entrySet()) {
                GameLogger.info(String.format("Tile ID %d -> Name '%s'", entry.getKey(), entry.getValue()));
            }

            // Log each texture loading attempt
            for (Map.Entry<Integer, String> entry : TileType.getTileTypeNames().entrySet()) {
                int tileId = entry.getKey();
                String tileName = entry.getValue();
                TextureRegion region = tiles.findRegion(tileName);
                tileTextures.put(tileId, region);

                if (region == null) {
                } else {
                    GameLogger.info(String.format("Successfully loaded texture for tile %d (name: %s)", tileId, tileName));
                }
            }
        }


        public static TextureRegion getTileTexture(int tileType) {
            return tileTextures.get(tileType);
        }

        private static void debugAtlas(String name, TextureAtlas atlas) {
            if (atlas == null) {
                GameLogger.error(name + " atlas is null!");
                return;
            }
            GameLogger.info(name + " atlas regions:");
            for (TextureAtlas.AtlasRegion region : atlas.getRegions()) {
                GameLogger.info("  - " + region.name +
                    " (x=" + region.getRegionX() +
                    ", y=" + region.getRegionY() +
                    ", w=" + region.getRegionWidth() +
                    ", h=" + region.getRegionHeight() + ")");
            }
        }


        public enum StatusCondition {
            NONE(0),
            SLEEP(1),
            POISON(2),
            BURN(3),
            FREEZE(4),
            PARALYSIS(5),
            TOXIC(6),    // Bad poison
            CONFUSION(7);

            private final int index;

            StatusCondition(int index) {
                this.index = index;
            }

            public int getIndex() {
                return index;
            }
        }
    }

================
File: main/java/io/github/pokemeetup/utils/textures/TexturePackerConfig.java
================
package io.github.pokemeetup.utils.textures;

import com.badlogic.gdx.tools.texturepacker.TexturePacker;
import com.badlogic.gdx.graphics.Texture.TextureFilter;

public class TexturePackerConfig {
    // Flag to enable/disable packing - set to false for production
    public static final boolean SHOULD_PACK = false;

    // Pack your textures - call this from your desktop launcher
    public static void pack() {
        if (!SHOULD_PACK) return;

        TexturePacker.Settings settings = new TexturePacker.Settings();

        // Basic settings
        settings.maxWidth = 2048;
        settings.maxHeight = 2048;
        settings.pot = true;
        settings.combineSubdirectories = true;

        // Pixel-perfect settings for tilesets
        settings.filterMin = TextureFilter.Nearest;
        settings.filterMag = TextureFilter.Nearest;
        settings.paddingX = 2;
        settings.paddingY = 2;

        // Enable this if you need to debug atlas packing
        settings.debug = false;

        try {

            // You can have multiple atlases for different purposes
            TexturePacker.process(settings,
                "assets/raw/tilesets",
                "assets/packed/tilesets",
                "tileset-atlas");

        } catch (Exception e) {
            System.err.println("Error packing textures: " + e.getMessage());
        }
    }
}

================
File: main/java/io/github/pokemeetup/utils/textures/TextureUtils.java
================
package io.github.pokemeetup.utils.textures;

import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

public class TextureUtils {
    public static Pixmap textureRegionToPixmap(TextureRegion region) {
        if (region == null) return null;

        Texture texture = region.getTexture();
        if (!texture.getTextureData().isPrepared()) {
            texture.getTextureData().prepare();
        }

        Pixmap originalPixmap = texture.getTextureData().consumePixmap();
        Pixmap regionPixmap = new Pixmap(
            region.getRegionWidth(),
            region.getRegionHeight(),
            Pixmap.Format.RGBA8888
        );

        // Copy the region's pixels
        regionPixmap.drawPixmap(
            originalPixmap,
            0, 0,
            region.getRegionX(), region.getRegionY(),
            region.getRegionWidth(), region.getRegionHeight()
        );

        originalPixmap.dispose();
        return regionPixmap;
    }
}

================
File: main/java/io/github/pokemeetup/utils/textures/TileNameParser.java
================
package io.github.pokemeetup.utils.textures;

import io.github.pokemeetup.utils.GameLogger;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TileNameParser {
    private static final Pattern COMPLEX_TILE_PATTERN =
        Pattern.compile("^([a-z]+)_([a-z]+)(?:_([a-z]+))?_(\\d+)_(\\d+)$");

    public static ParsedTileName parseTileName(String tileName) {
        Matcher matcher = COMPLEX_TILE_PATTERN.matcher(tileName.toLowerCase());
        if (!matcher.matches()) {
            GameLogger.error("Failed to parse tile name: " + tileName);
            return null;
        }

        try {
            String biome = matcher.group(1);
            String baseType = matcher.group(2);
            String modifier = matcher.group(3); // might be null
            int row = Integer.parseInt(matcher.group(4));
            int col = Integer.parseInt(matcher.group(5));

            return new ParsedTileName(biome, baseType, modifier, row, col);
        } catch (NumberFormatException e) {
            GameLogger.error("Failed to parse indices for tile: " + tileName);
            return null;
        }
    }

    public static class ParsedTileName {
        public final String biome;
        public final String baseType;
        public final String modifier;
        public final int row;
        public final int col;

        private ParsedTileName(String biome, String baseType, String modifier, int row, int col) {
            this.biome = biome;
            this.baseType = baseType;
            this.modifier = modifier;
            this.row = row;
            this.col = col;
        }
    }

}

================
File: main/java/io/github/pokemeetup/utils/textures/TileNameValidator.java
================
package io.github.pokemeetup.utils.textures;

import io.github.pokemeetup.utils.GameLogger;

import java.util.Collection;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
public class TileNameValidator {
    private static final Pattern TILE_NAME_PATTERN = Pattern.compile("^[a-z]+_[a-z_]+_\\d+_\\d+$");

    public  void validateBiomeTileNames(Collection<String> tileNames, String biomeName) {
        List<String> invalidTiles = tileNames.stream()
            .filter(name -> !isValidTileName(name))
            .collect(Collectors.toList());

        if (!invalidTiles.isEmpty()) {
            GameLogger.error("Invalid tile names found in " + biomeName + " biome:");
            invalidTiles.forEach(name -> GameLogger.error(" - " + name));

        }
    }

    public static boolean isValidTileName(String tileName) {
        if (tileName == null || tileName.isEmpty()) {
            return false;
        }

        // Special case for simplified formats (e.g., snow_ground_0)
        if (tileName.matches("\\w+_\\w+_\\d+$")) {
            return true;
        }

        // Standard format (e.g., biome_type_x_y)
        String[] parts = tileName.split("_");

        // Must have at least 3 parts: biome_type_number
        if (parts.length < 3) {
            return false;
        }

        // The last two parts should be numbers
        try {
            // Handle both x_y and single number formats
            if (parts.length >= 4) {
                Integer.parseInt(parts[parts.length - 2]);
                Integer.parseInt(parts[parts.length - 1]);
            } else {
                Integer.parseInt(parts[parts.length - 1]);
            }
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
    public static String normalizeTileName(String tileName) {
        // Handle the simplified format (e.g., snow_ground_0)
        if (tileName.matches("\\w+_\\w+_\\d+$")) {
            String[] parts = tileName.split("_");
            // Convert to standard format biome_type_x_y
            return String.format("%s_%s_%s_0", parts[0], parts[1], parts[2]);
        }
        return tileName;
    }
}

================
File: main/java/io/github/pokemeetup/utils/textures/TilesetSplitter.java
================
package io.github.pokemeetup.utils.textures;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.utils.Array;
import java.util.*;

public class TilesetSplitter {
    public static class TilePosition {
        public final int row;
        public final int col;
        public final int index;

        public TilePosition(int row, int col, int index) {
            this.row = row;
            this.col = col;
            this.index = index;
        }

        // Get coordinate-based name (e.g., "3_4" for row 3, col 4)
        public String getCoordName() {
            return row + "_" + col;
        }
    }

    public static class Tile {
        public final TextureRegion region;
        public final TilePosition position;

        public Tile(TextureRegion region, TilePosition position) {
            this.region = region;
            this.position = position;
        }
    }

    /**
     * Splits tileset and provides position information for each tile
     */
    public static Array<Tile> splitTilesetWithPosition(TextureAtlas atlas, String regionName,
                                                       int tileWidth, int tileHeight, int spacing) {

        TextureAtlas.AtlasRegion region = atlas.findRegion(regionName);
        if (region == null) {
            throw new IllegalArgumentException("Region '" + regionName + "' not found in atlas");
        }

        Array<Tile> tiles = new Array<>();

        int numRows = region.getRegionHeight() / (tileHeight + spacing);
        int numCols = region.getRegionWidth() / (tileWidth + spacing);

        int index = 0;
        for (int row = 0; row < numRows; row++) {
            for (int col = 0; col < numCols; col++) {
                TextureRegion tileRegion = new TextureRegion(region,
                    col * (tileWidth + spacing),
                    row * (tileHeight + spacing),
                    tileWidth,
                    tileHeight
                );

                TilePosition position = new TilePosition(row, col, index);
                tiles.add(new Tile(tileRegion, position));
                index++;
            }
        }

        return tiles;
    }

    /**
     * Custom naming strategy interface
     */
    public interface TileNamingStrategy {
        String getName(TilePosition position, String baseRegionName);
    }

    // Some predefined naming strategies
    public static final TileNamingStrategy COORD_NAMING = (pos, base) ->
        base + "_" + pos.row + "_" + pos.col;

    public static final TileNamingStrategy ROW_FIRST_NAMING = (pos, base) ->
        base + "_row" + pos.row + "_" + pos.col;

    public static final TileNamingStrategy LAYER_NAMING = (pos, base) ->
        String.format("%s_layer%d_tile%d", base, pos.row, pos.col);

    /**
     * Split tileset with custom naming strategy
     */
    public static Map<String, TextureRegion> splitTilesetCustomNaming(
        TextureAtlas atlas,
        String regionName,
        int tileWidth,
        int tileHeight,
        int spacing,
        TileNamingStrategy namingStrategy) {

        Array<Tile> tiles = splitTilesetWithPosition(atlas, regionName, tileWidth, tileHeight, spacing);
        Map<String, TextureRegion> namedTiles = new HashMap<>();

        for (Tile tile : tiles) {
            String name = namingStrategy.getName(tile.position, regionName);
            namedTiles.put(name, tile.region);
        }

        return namedTiles;
    }
}

================
File: main/java/io/github/pokemeetup/utils/textures/TileType.java
================
package io.github.pokemeetup.utils.textures;

import java.util.HashMap;
import java.util.Map;

public class TileType {
    // Base terrain types
    public static final int WATER = 0;
    public static final int GRASS = 1;
    public static final int SAND = 2;
    public static final int ROCK = 3;
    public static final int SNOW = 4;

    // Special terrain types
    public static final int HAUNTED_GRASS = 5;
    public static final int SNOW_TALL_GRASS = 6;
    public static final int HAUNTED_TALL_GRASS = 7;
    public static final int HAUNTED_SHROOM = 8;
    public static final int HAUNTED_SHROOMS = 9;
    public static final int TALL_GRASS = 10;

    // Forest types
    public static final int FOREST_GRASS = 11;
    public static final int FOREST_TALL_GRASS = 12;

    // Rain forest types
    public static final int RAIN_FOREST_GRASS = 13;
    public static final int RAIN_FOREST_TALL_GRASS = 14;

    // Desert types
    public static final int DESERT_SAND = 15;
    public static final int DESERT_ROCKS = 16;
    public static final int DESERT_GRASS = 17;

    // Decorative types
    public static final int FLOWER_1 = 18;
    public static final int FLOWER_2 = 19;
    public static final int FLOWER = 20;
    public static final int TALL_GRASS_2 = 21;
    public static final int GRASS_2 = 22;
    public static final int GRASS_3 = 23;
    public static final int TALL_GRASS_3 = 24;

    public static final int MOUNTAIN_CORNER_INNER_TOPLEFT = 27;
    public static final int MOUNTAIN_CORNER_INNER_BOTTOMRIGHT = 30;

    // Mountain Features
    public static final int MOUNTAIN_STAIRS_LEFT = 31; // Left side stairs
    public static final int MOUNTAIN_STAIRS_RIGHT = 32; // Right side stairs
    public static final int STAIRS = 235;

    // Mountain Snow Variants
    public static final int MOUNTAIN_SNOW_BASE = 36;

    // Mountain Tiles
    public static final int MOUNTAIN_BASE = 25;       // Base mountain tile
    public static final int MOUNTAIN_PEAK = 26;       // Mountain peak
    public static final int MOUNTAIN_SLOPE_LEFT = 27; // Left slope
    public static final int MOUNTAIN_SLOPE_RIGHT = 28; // Right slope
    public static final int MOUNTAIN_WALL = 29;       // Mountain wall
    public static final int MOUNTAIN_STAIRS = 30;     // Standard stairs
    public static final int MOUNTAIN_CORNER_TL = 33;  // Top-left corner
    public static final int MOUNTAIN_CORNER_TR = 34;  // Top-right corner
    public static final int MOUNTAIN_CORNER_BL = 35;  // Bottom-left corner
    public static final int MOUNTAIN_CORNER_BR = 36;  // Bottom-right corner
    // Mountain Corner Types
    public static final int MOUNTAIN_CORNER_OUTER_TOPLEFT = 39;
    public static final int MOUNTAIN_CORNER_OUTER_BOTTOMRIGHT = 42;

    // Mountain Base Components
    public static final int MOUNTAIN_BASE_EDGE = 38;      // Basic mountain edge tile
    public static final int MOUNTAIN_PATH = 40;           // Walkable mountain path

    // Mountain Edges
    public static final int MOUNTAIN_EDGE_LEFT = 47;      // Left edge
    public static final int MOUNTAIN_EDGE_RIGHT = 48;     // Right edge
    public static final int MOUNTAIN_EDGE_TOP = 49;       // Top edge
    public static final int MOUNTAIN_EDGE_BOTTOM = 50;    // Bottom edge
    public static final int SNOW_2 = 51;
    public static final int SNOW_3 = 52;
    public static final int RUINS_GRASS = 53;
    public static final int RUINS_GRASS_0 = 54;
    public static final int RUINS_TALL_GRASS = 55;
    public static final int RUINS_BRICKS = 56;
    public static final int WATER_PUDDLE = 140;
    public static final int WATER_PUDDLE_TOP_LEFT = 141;
    public static final int WATER_PUDDLE_TOP_MIDDLE = 142;
    public static final int WATER_PUDDLE_TOP_RIGHT = 143;
    public static final int WATER_PUDDLE_LEFT_MIDDLE = 144;
    public static final int WATER_PUDDLE_RIGHT_MIDDLE = 145;
    public static final int WATER_PUDDLE_BOTTOM_LEFT = 146;
    public static final int WATER_PUDDLE_BOTTOM_MIDDLE = 147;
    public static final int WATER_PUDDLE_BOTTOM_RIGHT = 148;
    public static final int MOUNTAIN_TILE_TOP_LEFT_GRASS_BG = 209;
    public static final int MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG = 210;
    public static final int MOUNTAIN_TILE_BOT_RIGHT_GRASS_BG = 211;
    public static final int MOUNTAIN_TILE_BOT_LEFT_GRASS_BG = 212;
    public static final int MOUNTAIN_TILE_TOP_LEFT_ROCK_BG = 200;
    public static final int MOUNTAIN_TILE_TOP_MID = 201;
    public static final int MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG = 202;
    public static final int MOUNTAIN_TILE_MID_LEFT = 203;
    public static final int MOUNTAIN_TILE_CENTER = 204;
    public static final int MOUNTAIN_TILE_MID_RIGHT = 205;
    public static final int MOUNTAIN_TILE_BOT_LEFT_ROCK_BG = 206;
    public static final int MOUNTAIN_TILE_BOT_MID = 207;
    public static final int MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG = 208;
    public static final int MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_LEFT = 213;
    public static final int MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_RIGHT = 214;
    public static final int MOUNTAIN_TILE_CONNECTING_CORNER_TOP_LEFT = 215;
    public static final int MOUNTAIN_TILE_CONNECTING_CORNER_TOP_RIGHT = 216;

    public static final int CAVE_ENTRANCE = 149;

    private static final Map<Integer, String> tileTypeNames = new HashMap<>();
    private static final Map<Integer, String> mountainTileNames = new HashMap<>();

    static {
        tileTypeNames.put(WATER, "water");
        tileTypeNames.put(GRASS, "grass");
        tileTypeNames.put(SAND, "sand");
        tileTypeNames.put(ROCK, "rock");
        tileTypeNames.put(SNOW, "snow_base");
        tileTypeNames.put(WATER_PUDDLE, "water_puddle");
        tileTypeNames.put(WATER_PUDDLE_TOP_LEFT, "water_puddle_top_left_corner");
        tileTypeNames.put(WATER_PUDDLE_TOP_MIDDLE, "water_puddle_top_middle");
        tileTypeNames.put(WATER_PUDDLE_TOP_RIGHT, "water_puddle_top_right_corner");
        tileTypeNames.put(WATER_PUDDLE_LEFT_MIDDLE, "water_puddle_left_middle");
        tileTypeNames.put(WATER_PUDDLE_RIGHT_MIDDLE, "water_puddle_right_middle");
        tileTypeNames.put(WATER_PUDDLE_BOTTOM_LEFT, "water_puddle_bottom_left_corner");
        tileTypeNames.put(WATER_PUDDLE_BOTTOM_MIDDLE, "water_puddle_bottom_middle");
        tileTypeNames.put(WATER_PUDDLE_BOTTOM_RIGHT, "water_puddle_bottom_right_corner");

        // Initialize special terrain names
        tileTypeNames.put(HAUNTED_GRASS, "haunted_grass");
        tileTypeNames.put(SNOW_TALL_GRASS, "snow_tall_grass");
        tileTypeNames.put(HAUNTED_TALL_GRASS, "haunted_tall_grass");
        tileTypeNames.put(HAUNTED_SHROOM, "haunted_shroom");
        tileTypeNames.put(HAUNTED_SHROOMS, "haunted_shrooms");
        tileTypeNames.put(TALL_GRASS, "tall_grass");

        // Initialize forest names
        tileTypeNames.put(FOREST_GRASS, "forest_grass");
        tileTypeNames.put(FOREST_TALL_GRASS, "forest_tall_grass");

        // Initialize rain forest names
        tileTypeNames.put(RAIN_FOREST_GRASS, "rainforest_grass");
        tileTypeNames.put(RAIN_FOREST_TALL_GRASS, "rain_forest_tall_grass");
        tileTypeNames.put(STAIRS, "tile052");

        // Initialize desert names
        tileTypeNames.put(DESERT_SAND, "desert_sand");
        tileTypeNames.put(DESERT_ROCKS, "desert_rock");
        tileTypeNames.put(DESERT_GRASS, "desert_grass");

        // Initialize decorative names with indices where needed
        tileTypeNames.put(FLOWER, "flower");
        tileTypeNames.put(FLOWER_1, "flower");
        tileTypeNames.put(FLOWER_2, "flower");
        tileTypeNames.put(TALL_GRASS_2, "tall_grass");
        tileTypeNames.put(TALL_GRASS_3, "tall_grass");
        tileTypeNames.put(SNOW_2, "snow_grass");
        tileTypeNames.put(SNOW_3, "snow_base");
        tileTypeNames.put(GRASS_2, "grass");
        tileTypeNames.put(GRASS_3, "grass");
        tileTypeNames.put(MOUNTAIN_BASE_EDGE, "tile038");
        tileTypeNames.put(TileType.MOUNTAIN_SLOPE_RIGHT, "tile046");
        tileTypeNames.put(MOUNTAIN_WALL, "mountainBASEMIDDLE");
        tileTypeNames.put(MOUNTAIN_PEAK, "mountaintopRIGHT");
        tileTypeNames.put(MOUNTAIN_PATH, "tile081");
        tileTypeNames.put(MOUNTAIN_STAIRS, "mountainstairsMiddle");
        tileTypeNames.put(MOUNTAIN_BASE, "mountainBASEMIDDLE");
        tileTypeNames.put(MOUNTAIN_STAIRS_LEFT, "mountainstairsLEFT");  // Left stairs
        tileTypeNames.put(MOUNTAIN_STAIRS_RIGHT, "mountainstarsRIGHT"); // Right stairs
        tileTypeNames.put(MOUNTAIN_CORNER_TL, "mountainTOPLEFT"); // Top-left corner
        tileTypeNames.put(MOUNTAIN_CORNER_TR, "mountaintopRIGHT"); // Top-right corner
        tileTypeNames.put(MOUNTAIN_CORNER_BL, "mountainBASELEFT"); // Bottom-left corner
        tileTypeNames.put(MOUNTAIN_CORNER_OUTER_BOTTOMRIGHT, "mountainbaseRIGHT"); // Bottom-right corner
        tileTypeNames.put(MOUNTAIN_CORNER_BR, "mountainbaseRIGHT"); // Bottom-right corner
        tileTypeNames.put(MOUNTAIN_EDGE_LEFT, "mountainTOPLEFT");
        tileTypeNames.put(MOUNTAIN_EDGE_RIGHT, "mountaintopRIGHT");
        tileTypeNames.put(MOUNTAIN_EDGE_TOP, "tile050");
        tileTypeNames.put(MOUNTAIN_CORNER_INNER_TOPLEFT, "tile029");
        tileTypeNames.put(MOUNTAIN_EDGE_BOTTOM, "tile051");
        tileTypeNames.put(RUINS_GRASS, "ruins_grass");
        tileTypeNames.put(RUINS_GRASS_0, "ruins_grass");
        tileTypeNames.put(RUINS_TALL_GRASS, "ruins_tall_grass");
        tileTypeNames.put(RUINS_BRICKS, "ruin_bricks");
        tileTypeNames.put(CAVE_ENTRANCE, "cave_entrance");
        tileTypeNames.put(MOUNTAIN_TILE_TOP_LEFT_ROCK_BG, "MOUNTAIN_TILE_TOP_LEFT_ROCK_BG");
        tileTypeNames.put(MOUNTAIN_TILE_TOP_MID, "MOUNTAIN_TILE_TOP_MID");
        tileTypeNames.put(MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG, "MOUNTAIN_TILE_TOP_RIGHT_ROCK_BG");
        tileTypeNames.put(MOUNTAIN_TILE_MID_LEFT, "MOUNTAIN_TILE_MID_LEFT");
        tileTypeNames.put(MOUNTAIN_TILE_CENTER, "MOUNTAIN_TILE_CENTER");
        tileTypeNames.put(MOUNTAIN_TILE_MID_RIGHT, "MOUNTAIN_TILE_MID_RIGHT");
        tileTypeNames.put(MOUNTAIN_TILE_BOT_LEFT_ROCK_BG, "MOUNTAIN_TILE_BOT_LEFT_ROCK_BG");
        tileTypeNames.put(MOUNTAIN_TILE_BOT_MID, "MOUNTAIN_TILE_BOT_MID");
        tileTypeNames.put(MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG, "MOUNTAIN_TILE_BOT_RIGHT_ROCK_BG");
        tileTypeNames.put(MOUNTAIN_TILE_TOP_LEFT_GRASS_BG, "MOUNTAIN_TILE_TOP_LEFT_GRASS_BG");
        tileTypeNames.put(MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG, "MOUNTAIN_TILE_TOP_RIGHT_GRASS_BG");
        tileTypeNames.put(MOUNTAIN_TILE_BOT_LEFT_GRASS_BG, "MOUNTAIN_TILE_BOT_LEFT_GRASS_BG");
        tileTypeNames.put(MOUNTAIN_TILE_CONNECTING_CORNER_TOP_LEFT, "MOUNTAIN_TILE_CONNECTING_CORNER_TOP_LEFT");
        tileTypeNames.put(MOUNTAIN_TILE_CONNECTING_CORNER_TOP_RIGHT, "MOUNTAIN_TILE_CONNECTING_CORNER_TOP_RIGHT");
        tileTypeNames.put(MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_LEFT, "MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_LEFT");
        tileTypeNames.put(MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_RIGHT, "MOUNTAIN_TILE_CONNECTING_CORNER_BOTTOM_RIGHT");


        // Add mountain tiles to main tile names
        tileTypeNames.putAll(mountainTileNames);
    }

    public static boolean isWaterPuddle(int tileType) {
        return tileType >= WATER_PUDDLE && tileType <= WATER_PUDDLE_BOTTOM_RIGHT;
    }

    public static Map<Integer, String> getTileTypeNames() {
        return tileTypeNames;
    }

    public static Map<Integer, String> getMountainTileNames() {
        return mountainTileNames;
    }

    public static boolean isMountainTile(int tileType) {
        return tileType >= MOUNTAIN_BASE && tileType <= MOUNTAIN_CORNER_OUTER_BOTTOMRIGHT;
    }

    public static boolean isPassableMountainTile(int tileType) {
        return tileType == MOUNTAIN_STAIRS_LEFT ||
            tileType == MOUNTAIN_STAIRS_RIGHT ||
            tileType == STAIRS ||
            tileType == MOUNTAIN_SNOW_BASE;
    }

    public static boolean isPassableTile(int tileType) {
        // Basic terrain types that are passable
        if (tileType == GRASS || tileType == SAND || tileType == SNOW_TALL_GRASS || tileType == SNOW || tileType == SNOW_2 || tileType == SNOW_3 || tileType == GRASS_3 || tileType == FOREST_TALL_GRASS || tileType == HAUNTED_SHROOM || tileType == HAUNTED_SHROOMS || tileType == MOUNTAIN_STAIRS ||
            tileType == HAUNTED_GRASS || tileType == HAUNTED_TALL_GRASS || tileType == FOREST_GRASS || tileType == RAIN_FOREST_TALL_GRASS ||
            tileType == RAIN_FOREST_GRASS || tileType == DESERT_SAND || tileType == DESERT_GRASS || tileType == FLOWER_2 || tileType == GRASS_2 || tileType == TALL_GRASS || tileType == TALL_GRASS_2 || tileType == TALL_GRASS_3 || tileType == FLOWER_1 || tileType == FLOWER ||
            tileType == RUINS_BRICKS || tileType == RUINS_TALL_GRASS || tileType == RUINS_GRASS_0 || tileType == RUINS_GRASS) {
            return true;
        }
        if (isWaterPuddle(tileType)) {
            return true;
        }
        // Mountain types that are passable (stairs and paths)
        return tileType == MOUNTAIN_STAIRS_LEFT || tileType == MOUNTAIN_STAIRS_RIGHT || tileType == MOUNTAIN_TILE_CENTER ||
            tileType == STAIRS;
    }

    public static boolean isMountainCorner(int tileType) {
        return (tileType >= MOUNTAIN_CORNER_INNER_TOPLEFT && tileType <= MOUNTAIN_CORNER_INNER_BOTTOMRIGHT) ||
            (tileType >= MOUNTAIN_CORNER_OUTER_TOPLEFT && tileType <= MOUNTAIN_CORNER_OUTER_BOTTOMRIGHT);
    }

}

================
File: main/java/io/github/pokemeetup/utils/textures/TileTypeMapping.java
================
package io.github.pokemeetup.utils.textures;

import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType.PLAINS;

public class TileTypeMapping {


    public enum SpriteCategory {
        GROUND,      // Basic terrain
        DECORATIVE,  // Surface decorations
        WATER,       // Water, ice, lava
        PATH,        // Walkable paths

        STRUCTURE,    // Walls, rocks, built elements
        OBJECT    // Walls, rocks, built elements
    }
    private final Map<String, SpriteInfo> spriteInfoMap = new HashMap<>();

    public static class SpriteInfo {
        public final SpriteCategory category;
        public final String baseKey;
        public final int variance; // Number of variations
        public final boolean isAnimated;

        public SpriteInfo(SpriteCategory category, String baseKey, int variance, boolean isAnimated) {
            this.category = category;
            this.baseKey = baseKey;
            this.variance = variance;
            this.isAnimated = isAnimated;
        }
    }

    public void registerSprite(String tileKey, SpriteCategory category, int variance, boolean isAnimated) {
        String baseKey = tileKey.split("_\\d+")[0]; // Strip variation number
        spriteInfoMap.put(tileKey, new SpriteInfo(category, baseKey, variance, isAnimated));
    }

    public SpriteInfo getSpriteInfo(String tileKey) {
        return spriteInfoMap.get(tileKey);
    }

    public List<String> getTilesByCategory(SpriteCategory category) {
        return spriteInfoMap.entrySet().stream()
            .filter(e -> e.getValue().category == category)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }

    // Initialize standard mappings for each biome
    public void initializeBiomeMappings(BiomeType biomeType) {
        String prefix = biomeType.name().toLowerCase();
        switch(biomeType) {
            case PLAINS:
                registerSprite(prefix + "_grass", SpriteCategory.GROUND, 3, false);
                registerSprite(prefix + "_flowers", SpriteCategory.DECORATIVE, 2, false);
                registerSprite(prefix + "_ground", SpriteCategory.GROUND, 2, false);
                registerSprite(prefix + "_water", SpriteCategory.WATER, 1, true);
                break;
            case DESERT:
                registerSprite(prefix + "_ground", SpriteCategory.GROUND, 2, false);
                registerSprite(prefix + "_vegetation", SpriteCategory.DECORATIVE, 2, false);
                break;
        }
    }
}

================
File: main/java/io/github/pokemeetup/utils/TimeUtils.java
================
package io.github.pokemeetup.utils;

import java.text.SimpleDateFormat;
import java.util.Date;

public class TimeUtils {
    private static final SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm:ss");
    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd HH:mm");

    public static String formatTime(long timestamp) {
        if (System.currentTimeMillis() - timestamp < 24 * 60 * 60 * 1000) {
            // If less than 24 hours ago, show only time
            return timeFormat.format(new Date(timestamp));
        }
        // Otherwise show date and time
        return dateFormat.format(new Date(timestamp));
    }
}

================
File: main/java/io/github/pokemeetup/utils/UUIDSerializer.java
================
package io.github.pokemeetup.utils;

import com.esotericsoftware.kryo.Serializer;
import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

import java.util.UUID;

public class UUIDSerializer extends Serializer<UUID> {
    @Override
    public void write(Kryo kryo, Output output, UUID uuid) {
        output.writeLong(uuid.getMostSignificantBits());
        output.writeLong(uuid.getLeastSignificantBits());
    }

    @Override
    public UUID read(Kryo kryo, Input input, Class<UUID> type) {
        long mostSigBits = input.readLong();
        long leastSigBits = input.readLong();
        return new UUID(mostSigBits, leastSigBits);
    }
}
 file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-22T10:55:27.311Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
main/java/org/discord/context/ServerGameContext.java
main/java/org/discord/DeploymentHelper.java
main/java/org/discord/files/ServerFileDelegate.java
main/java/org/discord/files/WorldObject.java
main/java/org/discord/GameServer.java
main/java/org/discord/PluginManager.java
main/java/org/discord/ServerBlockManager.java
main/java/org/discord/ServerLauncher.java
main/java/org/discord/ServerWorldObjectManager.java
main/java/org/discord/utils/ServerWorldManager.java

================================================================
Files
================================================================

================
File: main/java/org/discord/context/ServerGameContext.java
================
package org.discord.context;

import io.github.pokemeetup.multiplayer.server.ServerStorageSystem;
import io.github.pokemeetup.system.gameplay.overworld.World;
import org.discord.utils.ServerWorldManager;

public final class ServerGameContext {
    private static ServerGameContext instance;
    private final ServerWorldManager worldManager;
    private final ServerStorageSystem storageSystem;


    private ServerGameContext(ServerWorldManager worldManager, ServerStorageSystem storageSystem) {
        this.worldManager = worldManager;
        this.storageSystem = storageSystem;
    }

    public static void init(ServerWorldManager worldManager, ServerStorageSystem storageSystem) {
        if (instance != null) {
            throw new IllegalStateException("ServerGameContext already initialized!");
        }
        instance = new ServerGameContext(worldManager, storageSystem);
    }

    public static ServerGameContext get() {
        if (instance == null) {
            throw new IllegalStateException("ServerGameContext not initialized yet!");
        }
        return instance;
    }

    public ServerStorageSystem getStorageSystem() {
        return storageSystem;
    }

    public ServerWorldManager getWorldManager() {
        return worldManager;
    }

    public void dispose() {
        if (worldManager != null) {
            worldManager.shutdown();
        }
        instance = null;
    }
}

================
File: main/java/org/discord/DeploymentHelper.java
================
package org.discord;

import com.badlogic.gdx.utils.Json;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

public class DeploymentHelper {
    public static void createServerDeployment(Path deploymentDir) throws IOException {
        System.out.println("Creating server deployment in: " + deploymentDir.toAbsolutePath());

        // Create directory structure
        createDirectory(deploymentDir);
        createDirectory(Paths.get(deploymentDir.toString(), "config"));
        createDirectory(Paths.get(deploymentDir.toString(), "plugins"));
        createDirectory(Paths.get(deploymentDir.toString(), "worlds"));
        createDirectory(Paths.get(deploymentDir.toString(), "logs"));
        createDirectory(Paths.get(deploymentDir.toString(), "server/data"));
       // Check if we're running from JAR or development environment
        Path serverJar;
        if (isRunningFromJar()) {
            // When running from JAR, use the current JAR
            serverJar = getCurrentJarPath();
            System.out.println("Running from JAR: " + serverJar);
        } else {
            // In development, look for the JAR in build directory
            serverJar = Paths.get("server.jar");
            System.out.println("Running in development mode, looking for: " + serverJar);
        }

        if (Files.exists(serverJar)) {
            Files.copy(serverJar, Paths.get(deploymentDir.toString(), "server.jar"));
            System.out.println("Copied server JAR successfully");
        } else {
            System.out.println("Warning: Server JAR not found at: " + serverJar);
            // Continue anyway as we might be in development mode
        }

        // Create configurations
        createDefaultConfig(deploymentDir);
        createBiomesConfig(deploymentDir);

        // Create start scripts
        createStartScripts(deploymentDir);

        // Make shell script executable on Unix
        Path startSh = Paths.get(deploymentDir.toString(), "start.sh");
        if (Files.exists(startSh)) {
            startSh.toFile().setExecutable(true);
        }

        // Create README
        createReadme(deploymentDir);

        System.out.println("Server deployment completed successfully");
    }

    private static boolean isRunningFromJar() {
        String className = DeploymentHelper.class.getName().replace('.', '/');
        String classJar = DeploymentHelper.class.getResource("/" + className + ".class").toString();
        return classJar.startsWith("jar:");
    }

    private static Path getCurrentJarPath() {
        try {
            return Paths.get(DeploymentHelper.class.getProtectionDomain().getCodeSource().getLocation().toURI());
        } catch (Exception e) {
            return Paths.get("server.jar");
        }
    }

    private static void createDirectory(Path dir) throws IOException {
        if (!Files.exists(dir)) {
            Files.createDirectories(dir);
            System.out.println("Created directory: " + dir);
        }
    }

    private static void createBiomesConfig(Path deploymentDir) throws IOException {
        // Create biomes configuration
        List<Map<String, Object>> biomes = new ArrayList<>();

        // Define each biome
        for (BiomeType type : BiomeType.values()) {
            Map<String, Object> biome = new HashMap<>();
            biome.put("name", type.name().toLowerCase());
            biome.put("type", type.name());
            biome.put("allowedTileTypes", Arrays.asList(1, 2, 3));

            // Create tile distribution
            Map<String, Double> distribution = new HashMap<>();
            switch (type) {
                case DESERT:
                    distribution.put("1", 85.0);
                    distribution.put("2", 10.0);
                    distribution.put("3", 5.0);
                    break;
                case FOREST:
                    distribution.put("1", 60.0);
                    distribution.put("2", 30.0);
                    distribution.put("3", 10.0);
                    break;
                case SNOW:
                    distribution.put("1", 75.0);
                    distribution.put("2", 20.0);
                    distribution.put("3", 5.0);
                    break;
                case HAUNTED:
                    distribution.put("1", 65.0);
                    distribution.put("2", 25.0);
                    distribution.put("3", 10.0);
                    break;
                default:
                    distribution.put("1", 70.0);
                    distribution.put("2", 20.0);
                    distribution.put("3", 10.0);
                    break;
            }
            biome.put("tileDistribution", distribution);

            // Add spawn configuration
            List<String> spawnableObjects = new ArrayList<>();
            Map<String, Double> spawnChances = new HashMap<>();

            switch (type) {
                case FOREST:
                    spawnableObjects.add("TREE");
                    spawnChances.put("TREE", 0.7);
                    break;
                case DESERT:
                    spawnableObjects.add("CACTUS");
                    spawnChances.put("CACTUS", 0.4);
                    break;
                case SNOW:
                    spawnableObjects.add("SNOW_TREE");
                    spawnChances.put("SNOW_TREE", 0.5);
                    break;
                case HAUNTED:
                    spawnableObjects.add("HAUNTED_TREE");
                    spawnChances.put("HAUNTED_TREE", 0.6);
                    break;
            }

            biome.put("spawnableObjects", spawnableObjects);
            biome.put("spawnChances", spawnChances);

            biomes.add(biome);
        }
        // Write biomes configuration to both server data and config directories
        Json json = new Json();
        String biomesJson = json.prettyPrint(biomes);

        // Save to server/data directory
        Path serverDataPath = Paths.get(deploymentDir.toString(), "config/biomes.json");
        Files.write(serverDataPath, biomesJson.getBytes(StandardCharsets.UTF_8));

        // Also save to config directory for reference
        Path configPath = Paths.get(deploymentDir.toString(), "config/biomes.json");
        Files.write(configPath, biomesJson.getBytes(StandardCharsets.UTF_8));

    }



    // Helper method to create both start scripts
    private static void createStartScripts(Path deploymentDir) throws IOException {
        // Create Windows batch file
        try {
            createWindowsScript(deploymentDir);
            System.out.println("Created start.bat successfully");
        } catch (IOException e) {
            throw new IOException("Failed to create start.bat: " + e.getMessage());
        }

        // Create Unix shell script
        try {
            createUnixScript(deploymentDir);
            System.out.println("Created start.sh successfully");
        } catch (IOException e) {
            throw new IOException("Failed to create start.sh: " + e.getMessage());
        }
    }

    // Create Windows batch script
    private static void createWindowsScript(Path deploymentDir) throws IOException {
        String batScript =
            "@echo off\n" +
                "setlocal enabledelayedexpansion\n\n" +
                ":: Set Java path if needed\n" +
                "set JAVA_HOME=\n" +
                "if defined JAVA_HOME (\n" +
                "    set JAVA=\"%JAVA_HOME%/bin/java\"\n" +
                ") else (\n" +
                "    set JAVA=java\n" +
                ")\n\n" +
                ":: Set memory options\n" +
                "set MIN_MEMORY=1G\n" +
                "set MAX_MEMORY=4G\n\n" +
                ":: Start server\n" +
                "echo Starting Pokemon Meetup Server...\n" +
                "%JAVA% -Xms%MIN_MEMORY% -Xmx%MAX_MEMORY% -jar server.jar\n" +
                "pause\n";

        Path batPath = Paths.get(deploymentDir.toString(), "start.bat");
        Files.write(batPath, batScript.getBytes(StandardCharsets.UTF_8));
    }

    // Create Unix shell script
    private static void createUnixScript(Path deploymentDir) throws IOException {
        String shScript =
            "#!/bin/bash\n\n" +
                "# Set Java path if needed\n" +
                "if [ -n \"$JAVA_HOME\" ]; then\n" +
                "    JAVA=\"$JAVA_HOME/bin/java\"\n" +
                "else\n" +
                "    JAVA=\"java\"\n" +
                "fi\n\n" +
                "# Set memory options\n" +
                "MIN_MEMORY=\"1G\"\n" +
                "MAX_MEMORY=\"4G\"\n\n" +
                "# Start server\n" +
                "echo \"Starting Pokemon Meetup Server...\"\n" +
                "$JAVA -Xms$MIN_MEMORY -Xmx$MAX_MEMORY -jar server.jar\n";

        Path shPath = Paths.get(deploymentDir.toString(), "start.sh");
        Files.write(shPath, shScript.getBytes(StandardCharsets.UTF_8));

        // Make shell script executable
        try {
            shPath.toFile().setExecutable(true);
        } catch (SecurityException e) {
            System.out.println("Warning: Could not make start.sh executable: " + e.getMessage());
        }
    }

    private static void createDefaultConfig(Path deploymentDir) throws IOException {
        ServerConnectionConfig config = new ServerConnectionConfig(
            "0.0.0.0",
            54555,
            54556,
            "Pokemon Meetup Server",
            true,
            100
        );

        Json json = new Json();
        Path configFile = Paths.get(deploymentDir.toString(), "config/server.json");
        Files.write(configFile, Arrays.asList(json.prettyPrint(config).split("\n")), StandardCharsets.UTF_8);
    }

    private static void createReadme(Path deploymentDir) throws IOException {
        String readme =
            "Pokemon Meetup Server\n" +
                "====================\n\n" +
                "Quick Start:\n" +
                "1. Edit config/server.json to configure your server\n" +
                "2. On Windows: Run start.bat\n" +
                "   On Linux/Mac: Run ./start.sh\n" +
                "3. Server will create necessary directories on first run\n\n" +
                "Plugins:\n" +
                "- Place plugin .jar files in the plugins directory\n" +
                "- Server will load plugins automatically on startup\n\n" +
                "Configuration:\n" +
                "- Server settings: config/server.json\n" +
                "- Plugin configs: config/<plugin-id>.json\n\n" +
                "Logs:\n" +
                "- Server logs are stored in the logs directory\n\n" +
                "Support:\n" +
                "- Issues: https://github.com/yourusername/pokemon-meetup/issues\n" +
                "- Wiki: https://github.com/yourusername/pokemon-meetup/wiki\n";

        Path readmeFile = Paths.get(deploymentDir.toString(), "README.md");
        Files.write(readmeFile, Arrays.asList(readme.split("\n")), StandardCharsets.UTF_8);
    }

}

================
File: main/java/org/discord/files/ServerFileDelegate.java
================
package org.discord.files;

import io.github.pokemeetup.FileSystemDelegate;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.logging.Logger;

public class ServerFileDelegate implements FileSystemDelegate {
    private static final Logger logger = Logger.getLogger(ServerFileDelegate.class.getName());
    private final String basePath;
    @Override
    public void moveFile(String sourcePath, String destinationPath) throws IOException {
        File sourceFile = new File(sourcePath);
        File destFile = new File(destinationPath);

        if (!sourceFile.exists()) {
            throw new FileNotFoundException("Source file does not exist: " + sourcePath);
        }

        boolean success = sourceFile.renameTo(destFile);
        if (!success) {
            throw new IOException("Failed to move file from " + sourcePath + " to " + destinationPath);
        }
    }
    public ServerFileDelegate() {
        // Use working directory as base path
        this.basePath = System.getProperty("user.dir");
        logger.info("Initialized server file system with base path: " + basePath);
    }

    private Path getPath(String path) {
        return Paths.get(basePath, path);
    }

    @Override
    public boolean exists(String path) {
        return Files.exists(getPath(path));
    }

    @Override
    public void createDirectory(String path) {
        try {
            Files.createDirectories(getPath(path));
        } catch (IOException e) {
            logger.severe("Failed to create directory: " + path);
            throw new RuntimeException("Failed to create directory: " + path, e);
        }
    }

    @Override
    public void writeString(String path, String content) throws IOException {
        Path filePath = getPath(path);
        Files.createDirectories(filePath.getParent());
        Files.writeString(filePath, content, StandardCharsets.UTF_8);
    }

    @Override
    public String readString(String path) throws IOException {
        return Files.readString(getPath(path), StandardCharsets.UTF_8);
    }

    @Override
    public void deleteFile(String path) {
        try {
            Files.deleteIfExists(getPath(path));
        } catch (IOException e) {
            logger.severe("Failed to delete file: " + path);
            throw new RuntimeException("Failed to delete file: " + path, e);
        }
    }

    @Override
    public void deleteDirectory(String path) {
        try {
            Files.walk(getPath(path))
                .sorted((a, b) -> -a.compareTo(b))
                .forEach(p -> {
                    try {
                        Files.delete(p);
                    } catch (IOException e) {
                        logger.severe("Failed to delete: " + p);
                    }
                });
        } catch (IOException e) {
            logger.severe("Failed to delete directory: " + path);
            throw new RuntimeException("Failed to delete directory: " + path, e);
        }
    }

    @Override
    public boolean isDirectory(String path) {
        return Files.isDirectory(getPath(path));
    }

    @Override
    public String[] list(String path) {
        try {
            return Files.list(getPath(path))
                .map(p -> p.getFileName().toString())
                .toArray(String[]::new);
        } catch (IOException e) {
            logger.severe("Failed to list directory: " + path);
            return new String[0];
        }
    }

    @Override
    public void copyFile(String sourcePath, String destinationPath) throws IOException {
        Files.copy(getPath(sourcePath), getPath(destinationPath),
            StandardCopyOption.REPLACE_EXISTING);
    }

    @Override
    public InputStream openInputStream(String path) throws IOException {
        return Files.newInputStream(getPath(path));
    }

    @Override
    public OutputStream openOutputStream(String path) throws IOException {
        Path filePath = getPath(path);
        Files.createDirectories(filePath.getParent());
        return Files.newOutputStream(filePath);
    }
}

================
File: main/java/org/discord/files/WorldObject.java
================
package org.discord.files;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class WorldObject {
    private String id;  // Unique identifier
    private io.github.pokemeetup.system.gameplay.overworld.WorldObject.ObjectType type;
    private int tileX, tileY;
    private boolean isCollidable;

    public WorldObject(int tileX, int tileY, io.github.pokemeetup.system.gameplay.overworld.WorldObject.ObjectType type) {
        this.id = UUID.randomUUID().toString();
        this.tileX = tileX;
        this.tileY = tileY;
        this.type = type;
        this.isCollidable = type.isCollidable;
    }

    public void setId(String id) {
        this.id = id;
    }

    public void setType(io.github.pokemeetup.system.gameplay.overworld.WorldObject.ObjectType type) {
        this.type = type;
    }

    public void setTileX(int tileX) {
        this.tileX = tileX;
    }

    public void setTileY(int tileY) {
        this.tileY = tileY;
    }

    public void setCollidable(boolean collidable) {
        isCollidable = collidable;
    }

    public String getId() {
        return id;
    }

    public io.github.pokemeetup.system.gameplay.overworld.WorldObject.ObjectType getType() {
        return type;
    }

    public int getTileX() {
        return tileX;
    }

    public int getTileY() {
        return tileY;
    }

    public boolean isCollidable() {
        return isCollidable;
    }

    // Getters and network serialization methods
    public Map<String, Object> getSerializableData() {
        Map<String, Object> data = new HashMap<>();
        data.put("id", id);
        data.put("tileX", tileX);
        data.put("tileY", tileY);
        data.put("type", type.name());
        return data;
    }
}

================
File: main/java/org/discord/GameServer.java
================
package org.discord;

import com.badlogic.gdx.math.Vector2;
import com.esotericsoftware.kryonet.FrameworkMessage;
import com.esotericsoftware.kryonet.Server;
import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.Listener;
import com.esotericsoftware.minlog.Log;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.blocks.PlaceableBlock;
import io.github.pokemeetup.managers.BiomeManager;
import io.github.pokemeetup.managers.BiomeTransitionResult;
import io.github.pokemeetup.managers.DatabaseManager;
import io.github.pokemeetup.multiplayer.PlayerManager;
import io.github.pokemeetup.multiplayer.ServerPlayer;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.multiplayer.server.PlayerDataManager;
import io.github.pokemeetup.multiplayer.server.ServerStorageSystem;
import io.github.pokemeetup.multiplayer.server.storage.FileStorage;
import io.github.pokemeetup.system.data.BlockSaveData;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.multiplayer.server.events.EventManager;
import io.github.pokemeetup.pokemon.WildPokemon;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.PokemonData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.gameplay.inventory.ItemManager;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;
import io.github.pokemeetup.system.gameplay.overworld.biomes.Biome;
import io.github.pokemeetup.system.gameplay.overworld.biomes.BiomeType;
import io.github.pokemeetup.utils.GameLogger;
import io.github.pokemeetup.utils.PasswordUtils;
import io.github.pokemeetup.utils.textures.TextureManager;
import org.discord.context.ServerGameContext;

import java.io.IOException;
import java.net.ServerSocket;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

import static io.github.pokemeetup.system.gameplay.overworld.WorldObject.WorldObjectManager.MAX_POKEBALLS_PER_CHUNK;
import static io.github.pokemeetup.system.gameplay.overworld.WorldObject.WorldObjectManager.POKEBALL_SPAWN_CHANCE;

public class GameServer {
    private static final int WRITE_BUFFER = 1024 * 1024;
    private static final int OBJECT_BUFFER = 512 * 1024;
    private static final int SCHEDULER_POOL_SIZE = 3;
    private static final long AUTH_TIMEOUT = 10000;
    private static final int SYNC_BATCH_SIZE = 10;
    private static final float SYNC_INTERVAL = 1 / 20f;
    private static final long SAVE_INTERVAL = 300000;
    private final ServerWorldObjectManager worldObjectManager;
    private final Server networkServer;
    private final ServerConnectionConfig config;
    private final BiomeManager biomeManager;
    private final EventManager eventManager;
    private final DatabaseManager databaseManager;
    private final ConcurrentHashMap<Integer, String> connectedPlayers;
    private final PlayerManager playerManager;
    private final ScheduledExecutorService scheduler;
    private final Queue<NetworkProtocol.PlayerUpdate> pendingUpdates = new ConcurrentLinkedQueue<>();
    private final Map<String, Integer> activeUserConnections = new ConcurrentHashMap<>();
    private final Map<String, ServerPlayer> activePlayers = new ConcurrentHashMap<>();
    private final Map<String, ConnectionInfo> activeConnections = new ConcurrentHashMap<>();
    private final Map<String, Long> recentDisconnects = new ConcurrentHashMap<>();
    private final WorldData worldData;
    private PluginManager pluginManager;
    private ServerBlockManager blockManager;
    private volatile boolean running;
    private NetworkProtocol.ServerInfo serverInfo;


    public GameServer(ServerConnectionConfig config) {
        this.scheduler = Executors.newScheduledThreadPool(SCHEDULER_POOL_SIZE, r -> {
            Thread thread = new Thread(r, "GameServer-Scheduler");
            thread.setDaemon(true);
            return thread;
        });
        ItemManager.setServerMode(true);
        ItemManager.initialize(null);
        this.config = config;
        this.networkServer = new Server(WRITE_BUFFER, OBJECT_BUFFER);
        NetworkProtocol.registerClasses(networkServer.getKryo());
        scheduler.scheduleAtFixedRate(() -> {
            try {
                ServerGameContext.get().getStorageSystem().getPlayerDataManager().flush();
            } catch (Exception e) {
                GameLogger.error("Scheduled player data flush failed: " + e.getMessage());
            }
        }, 300000, 300000, TimeUnit.MILLISECONDS);

        networkServer.getKryo().setReferences(false);

        this.worldObjectManager = new ServerWorldObjectManager();

        this.databaseManager = new DatabaseManager();
        this.eventManager = new EventManager();
        this.connectedPlayers = new ConcurrentHashMap<>();
        this.playerManager = new PlayerManager(ServerGameContext.get().getStorageSystem());


        try {
            this.worldData = initializeMultiplayerWorld();
            this.blockManager = new ServerBlockManager();
            setupNetworkListener();
            this.pluginManager = new PluginManager(worldData);
            this.biomeManager = new BiomeManager(worldData.getConfig().getSeed());
        } catch (Exception e) {
            GameLogger.error("Failed to initialize game world: " + e.getMessage());
            throw new RuntimeException("Failed to initialize server world", e);
        }
    }

    private WorldData initializeMultiplayerWorld() {
        try {
            // Load or create WorldData
            WorldData worldData = ServerGameContext.get().getWorldManager().getWorld(CreatureCaptureGame.MULTIPLAYER_WORLD_NAME);
            if (worldData == null) {
                // Create new WorldData
                worldData = ServerGameContext.get().getWorldManager().createWorld(
                    CreatureCaptureGame.MULTIPLAYER_WORLD_NAME,
                    System.currentTimeMillis(),
                    0.15f,
                    0.05f
                );
                ServerGameContext.get().getWorldManager().saveWorld(worldData);
            }

            return worldData;
        } catch (Exception e) {
            GameLogger.error("Failed to initialize multiplayer world: " + e.getMessage());
            throw new RuntimeException("WorldData initialization failed", e);
        }
    }

    private void broadcastPlayerStates() {
        scheduler.scheduleAtFixedRate(() -> {
            try {
                List<NetworkProtocol.PlayerUpdate> updates = new ArrayList<>();
                NetworkProtocol.PlayerUpdate update;

                while ((update = pendingUpdates.poll()) != null && updates.size() < SYNC_BATCH_SIZE) {
                    updates.add(update);
                }

                if (updates.isEmpty()) return;

                NetworkProtocol.PlayerPosition position = new NetworkProtocol.PlayerPosition();
                position.players = new HashMap<>();
                updates.forEach(u -> position.players.put(u.username, u));

                // Broadcast to all connected clients
                networkServer.sendToAllTCP(position);

            } catch (Exception e) {
                GameLogger.error("Error broadcasting player states: " + e.getMessage());
            }
        }, 0, (long) (SYNC_INTERVAL * 1000), TimeUnit.MILLISECONDS);
    }

    private void handleDisconnect(Connection connection) {
        String username = connectedPlayers.get(connection.getID());
        if (username != null) {
            GameLogger.info("Handling disconnect for user: " + username);

            synchronized (activeConnections) {
                try {
                    // Save player data before cleanup
                    ServerPlayer player = activePlayers.get(username);
                    if (player != null) {
                        PlayerData finalState = player.getData();
                        UUID playerUUID = UUID.nameUUIDFromBytes(username.getBytes());
                        // Save data
                        ServerGameContext.get().getStorageSystem().getPlayerDataManager().savePlayerData(playerUUID, finalState);
                        // Force save to disk
                        ServerGameContext.get().getStorageSystem().getPlayerDataManager().flush();

                        GameLogger.info("Saved final state for: " + username);
                    }

                    // Existing cleanup code...
                    recentDisconnects.put(username, System.currentTimeMillis());
                    activeConnections.remove(username);
                    cleanupPlayerSession(connection.getID(), username);

                    // Broadcast disconnect
                    NetworkProtocol.PlayerLeft leftMessage = new NetworkProtocol.PlayerLeft();
                    leftMessage.username = username;
                    leftMessage.timestamp = System.currentTimeMillis();
                    networkServer.sendToAllTCP(leftMessage);

                } catch (Exception e) {
                    GameLogger.error("Error during disconnect handling: " + e.getMessage());
                }
            }
        }
    }

    public void shutdown() {
        try {
            GameLogger.info("Starting server shutdown sequence...");

            // Notify clients
            NetworkProtocol.ServerShutdown shutdownMsg = new NetworkProtocol.ServerShutdown();
            shutdownMsg.reason = "Server is shutting down";
            networkServer.sendToAllTCP(shutdownMsg);

            // Save all active player data
            synchronized (activePlayers) {
                for (Map.Entry<String, ServerPlayer> entry : activePlayers.entrySet()) {
                    try {
                        String username = entry.getKey();
                        ServerPlayer player = entry.getValue();
                        if (player != null && player.getData() != null) {
                            UUID playerUUID = UUID.nameUUIDFromBytes(username.getBytes());
                            PlayerData finalState = player.getData();
                            ServerGameContext.get().getStorageSystem().getPlayerDataManager().savePlayerData(playerUUID, finalState);
                            GameLogger.info("Saved shutdown data for player: " + username);
                        }
                    } catch (Exception e) {
                        GameLogger.error("Error saving player data during shutdown: " + e.getMessage());
                    }
                }
                // Final flush after all saves
                ServerGameContext.get().getStorageSystem().getPlayerDataManager().flush();
            }

            // Save world state if exists
            if (worldData != null) {
                try {
                    GameLogger.info("Saving world data during shutdown...");
                    worldData.setLastPlayed(System.currentTimeMillis());
                    ServerGameContext.get().getWorldManager().saveWorld(worldData);
                } catch (Exception e) {
                    GameLogger.error("Error saving world data during shutdown: " + e.getMessage());
                }
            }

            // Wait for saves to complete
            Thread.sleep(500);

            running = false;
            networkServer.stop();
            if (scheduler != null) {
                scheduler.shutdown();
                try {
                    if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                        scheduler.shutdownNow();
                    }
                } catch (InterruptedException e) {
                    scheduler.shutdownNow();
                }
            }

            GameLogger.info("Server shutdown completed successfully");
        } catch (Exception e) {
            GameLogger.error("Error during server shutdown: " + e.getMessage());
            if (networkServer != null) {
                networkServer.stop();
            }
        }
    }
    private void handleServerInfoRequest(Connection connection, NetworkProtocol.ServerInfoRequest request) {
        try {
            NetworkProtocol.ServerInfoResponse response = new NetworkProtocol.ServerInfoResponse();
            serverInfo.playerCount = connectedPlayers.size();
            response.serverInfo = serverInfo;
            response.timestamp = System.currentTimeMillis();

            connection.sendTCP(response);
        } catch (Exception e) {
            GameLogger.error("Error handling server info request: " + e.getMessage());
        }
    }

    private void cleanupPlayerSession(int connectionId, String username) {
        synchronized (activeUserConnections) {
            activeUserConnections.remove(username);
            connectedPlayers.remove(connectionId);
            ServerPlayer player = activePlayers.remove(username);

            if (player != null) {
                try {
                    // Save player state before cleanup
                    PlayerData finalState = player.getData();
                    ServerGameContext.get().getStorageSystem().savePlayerData(finalState.getUsername(), finalState);
                } catch (Exception e) {
                    GameLogger.error("Error saving player state during cleanup: " + e.getMessage());
                }
            }
        }
    }

    private void sendSuccessfulLoginResponse(Connection connection, ServerPlayer player) {
        NetworkProtocol.LoginResponse response = new NetworkProtocol.LoginResponse();
        response.success = true;
        response.username = player.getUsername();
        response.message = "Login successful";
        response.x = (int) player.getPosition().x;
        response.y = (int) player.getPosition().y;
        response.seed = worldData.getConfig().getSeed();
        response.worldTimeInMinutes = worldData.getWorldTimeInMinutes();
        response.dayLength = worldData.getDayLength();
        response.timestamp = System.currentTimeMillis();

        response.playerData = player.getData();
        connection.sendTCP(response);
    }

    private void broadcastPlayerJoin(Connection connection, ServerPlayer player) {
        NetworkProtocol.PlayerJoined joinMessage = new NetworkProtocol.PlayerJoined();
        joinMessage.username = player.getUsername();
        joinMessage.x = player.getPosition().x;
        joinMessage.y = player.getPosition().y;
        joinMessage.timestamp = System.currentTimeMillis();

        // Send to all except the joining player
        networkServer.sendToAllExceptTCP(connection.getID(), joinMessage);

        // Send system message about join
        NetworkProtocol.ChatMessage systemMessage = new NetworkProtocol.ChatMessage();
        systemMessage.sender = "System";
        systemMessage.content = player.getUsername() + " has joined the game";
        systemMessage.type = NetworkProtocol.ChatType.SYSTEM;
        systemMessage.timestamp = System.currentTimeMillis();

        // Send to everyone including the new player
        networkServer.sendToAllTCP(systemMessage);
    }

    private Connection findConnection(int connectionId) {
        for (Connection conn : networkServer.getConnections()) {
            if (conn.getID() == connectionId) {
                return conn;
            }
        }
        return null;
    }

    private void sendLoginFailure(Connection connection, String message) {
        NetworkProtocol.LoginResponse response = new NetworkProtocol.LoginResponse();
        response.success = false;
        response.message = message;
        response.timestamp = System.currentTimeMillis();

        try {
            connection.sendTCP(response);
            GameLogger.info("Sent login failure: " + message);
        } catch (Exception e) {
            GameLogger.error("Error sending login failure: " + e.getMessage());
        }
    }

    private void handlePlayerDisconnect(Connection connection) {
        String username = connectedPlayers.get(connection.getID());
        if (username != null) {
            synchronized (activeUserConnections) {
                // Save player data before removing
                ServerPlayer player = playerManager.getPlayer(username);
                if (player != null) {
                    try {
                        // Save final state and ensure it's persisted
                        PlayerData finalState = player.getData();
                        ServerGameContext.get().getStorageSystem().savePlayerData(player.getUsername(), finalState);
                        GameLogger.info("Saved player data for " + username + " on disconnect");
                    } catch (Exception e) {
                        GameLogger.error("Error saving player data for " + username + ": " + e.getMessage());
                    }
                }

                // Existing cleanup code...
                playerManager.removePlayer(username);
                activeUserConnections.remove(username);
                connectedPlayers.remove(connection.getID());

                // Broadcast disconnect
                NetworkProtocol.PlayerLeft leftMessage = new NetworkProtocol.PlayerLeft();
                leftMessage.username = username;
                leftMessage.timestamp = System.currentTimeMillis();
                networkServer.sendToAllTCP(leftMessage);

                GameLogger.info("Player disconnected: " + username);
            }
        }
    }

    private void handlePlayerUpdate(Connection connection, NetworkProtocol.PlayerUpdate update) {
        try {
            String username = connectedPlayers.get(connection.getID());
            if (username == null || !username.equals(update.username)) {
                GameLogger.error("Username mismatch in player update");
                return;
            }

            ServerPlayer player = activePlayers.get(username);
            if (player == null) {
                GameLogger.error("No active player found for: " + username);
                return;
            }

            // Update server player data
            PlayerData playerData = player.getData();
            if (playerData == null) {
                GameLogger.error("No player data found for active player: " + username);
                return;
            }

            // Update the data
            playerData.setX(update.x);
            playerData.setY(update.y);
            playerData.setDirection(update.direction);
            playerData.setMoving(update.isMoving);
            playerData.setWantsToRun(update.wantsToRun);

            if (update.inventoryItems != null) {
                playerData.setInventoryItems(Arrays.asList(update.inventoryItems));
            }
            if (update.partyPokemon != null) {
                playerData.setPartyPokemon(update.partyPokemon);
            }

            // Save to storage
            UUID playerUUID = UUID.nameUUIDFromBytes(username.getBytes());
            ServerGameContext.get().getStorageSystem().getPlayerDataManager().savePlayerData(playerUUID, playerData);

            // Broadcast update
            networkServer.sendToAllTCP(update);

        } catch (Exception e) {
            GameLogger.error("Error handling player update: " + e.getMessage());
        }
    }

    private void handlePokemonSpawn(Connection connection, NetworkProtocol.WildPokemonSpawn spawnRequest) {
        try {
            WorldData world = ServerGameContext.get().getWorldManager().getWorld(CreatureCaptureGame.MULTIPLAYER_WORLD_NAME);
            if (world == null) {
                GameLogger.error("Cannot spawn Pokemon: World is null");
                return;
            }

            if (!isValidSpawnPosition(spawnRequest.x, spawnRequest.y)) {
                GameLogger.error("Invalid spawn position: " + spawnRequest.x + "," + spawnRequest.y);
                return;
            }

            WildPokemon pokemon = createWildPokemon(spawnRequest);
            if (pokemon == null) {
                GameLogger.error("Failed to create Pokemon from spawn request");
                return;
            }
            // Create broadcast message
            NetworkProtocol.WildPokemonSpawn broadcastSpawn = createSpawnBroadcast(pokemon);

            // Broadcast to all clients
            try {
                networkServer.sendToAllTCP(broadcastSpawn);
                GameLogger.info("Broadcast Pokemon spawn: " + pokemon.getName() +
                    " (UUID: " + pokemon.getUuid() + ")");
            } catch (Exception e) {
                GameLogger.error("Failed to broadcast Pokemon spawn: " + e.getMessage());
                world.removeWildPokemon(pokemon.getUuid());
            }

        } catch (Exception e) {
            GameLogger.error("Error handling Pokemon spawn: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private boolean isValidSpawnPosition(float x, float y) {
        int tileX = (int) (x / World.TILE_SIZE);
        int tileY = (int) (y / World.TILE_SIZE);

        if (tileX < 0 || tileX >= World.WORLD_SIZE ||
            tileY < 0 || tileY >= World.WORLD_SIZE) {
            return false;
        }

        WorldData world = ServerGameContext.get().getWorldManager().getWorld(CreatureCaptureGame.MULTIPLAYER_WORLD_NAME);
        if (world == null) return false;

        return true;
    }

    private NetworkProtocol.WildPokemonSpawn createSpawnBroadcast(WildPokemon pokemon) {
        NetworkProtocol.WildPokemonSpawn broadcast = new NetworkProtocol.WildPokemonSpawn();
        broadcast.uuid = pokemon.getUuid();
        broadcast.x = pokemon.getX();
        broadcast.y = pokemon.getY();
        PokemonData pokemonData = new PokemonData();
        pokemonData.setName(pokemon.getName());
        pokemonData.setLevel(pokemon.getLevel());
        pokemonData.setPrimaryType(pokemon.getPrimaryType());
        pokemonData.setSecondaryType(pokemon.getSecondaryType());

        // Set stats
        if (pokemon.getStats() != null) {
            PokemonData.Stats stats = new PokemonData.Stats(pokemon.getStats());
            pokemonData.setStats(stats);
        }

        // Set moves
        List<PokemonData.MoveData> moves = pokemon.getMoves().stream()
            .map(PokemonData.MoveData::fromMove)
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
        pokemonData.setMoves(moves);

        broadcast.data = pokemonData;
        broadcast.timestamp = System.currentTimeMillis();

        return broadcast;
    }

    private WildPokemon createWildPokemon(NetworkProtocol.WildPokemonSpawn spawnRequest) {
        try {
            WildPokemon pokemon = new WildPokemon(
                spawnRequest.data.getName(),
                spawnRequest.data.getLevel(),
                (int) spawnRequest.x,
                (int) spawnRequest.y,
                TextureManager.getOverworldSprite(spawnRequest.data.getName())
            );
            pokemon.setUuid(spawnRequest.uuid != null ? spawnRequest.uuid : UUID.randomUUID());
            pokemon.setSpawnTime(System.currentTimeMillis() / 1000L);

            return pokemon;
        } catch (Exception e) {
            GameLogger.error("Error creating WildPokemon: " + e.getMessage());
            return null;
        }
    }

    private boolean authenticateUser(String username, String password) {
        String storedHash = databaseManager.getPasswordHash(username);
        if (storedHash == null) {
            GameLogger.error("Authentication failed: Username '" + username + "' does not exist.");
            return false;
        }
        return PasswordUtils.verifyPassword(password, storedHash);
    }

    private void handleLoginRequest(Connection connection, NetworkProtocol.LoginRequest request) {
        try {
            GameLogger.info("Processing login request for: " + request.username);

            UUID playerUUID = UUID.nameUUIDFromBytes(request.username.getBytes());
            GameLogger.info("Checking player data for UUID: " + playerUUID);

            // Load or create player data FIRST
            PlayerData playerData = ServerGameContext.get().getStorageSystem().getPlayerDataManager().loadPlayerData(playerUUID);
            if (playerData == null) {
                GameLogger.info("Creating new player data for: " + request.username);
                playerData = new PlayerData(request.username);
                playerData.setX(0);
                playerData.setY(0);
                playerData.setDirection("down");
                playerData.setMoving(false);
                playerData.setInventoryItems(new ArrayList<>());
                playerData.setPartyPokemon(new ArrayList<>());

                // Save immediately
                ServerGameContext.get().getStorageSystem().getPlayerDataManager().savePlayerData(playerUUID, playerData);
                ServerGameContext.get().getStorageSystem().getPlayerDataManager().flush(); // Ensure it's written to disk
                GameLogger.info("Created and saved new player data for: " + request.username);
            }

            // Continue with authentication
            if (!authenticateUser(request.username, request.password)) {
                sendLoginFailure(connection, "Invalid credentials");
                return;
            }

            synchronized (activeConnections) {
                // Handle existing connection
                handleExistingConnection(request.username);

                // Create new connection
                ConnectionInfo newConnection = new ConnectionInfo(connection.getID());
                activeConnections.put(request.username, newConnection);

                // Create server player with the loaded/created data
                ServerPlayer player = new ServerPlayer(request.username, playerData);

                // Register the player
                activePlayers.put(request.username, player);
                connectedPlayers.put(connection.getID(), request.username);
                newConnection.isAuthenticated = true;

                // Send successful response
                sendSuccessfulLoginResponse(connection, player);

                // Broadcast join
                if (!recentDisconnects.containsKey(request.username)) {
                    broadcastPlayerJoin(connection, player);
                }

                GameLogger.info("Login successful for: " + request.username);
            }

        } catch (Exception e) {
            GameLogger.error("Login error for " + request.username + ": " + e.getMessage());
            e.printStackTrace();
            sendLoginFailure(connection, "Server error occurred");
        }
    }

    private void handleExistingConnection(String username) throws InterruptedException {
        ConnectionInfo existingConnection = activeConnections.get(username);
        if (existingConnection != null) {
            Connection oldConnection = findConnection(existingConnection.connectionId);
            if (oldConnection != null && oldConnection.isConnected()) {
                NetworkProtocol.ForceDisconnect forceDisconnect = new NetworkProtocol.ForceDisconnect();
                forceDisconnect.reason = "Logged in from another location";
                oldConnection.sendTCP(forceDisconnect);
                Thread.sleep(100);
                oldConnection.close();

                cleanupPlayerSession(existingConnection.connectionId, username);
                Thread.sleep(500);
            }
        }
    }

    private PlayerData createNewPlayerData(String username) {
        PlayerData playerData = new PlayerData(username);
        playerData.setX(0);
        playerData.setY(0);
        playerData.setDirection("down");
        playerData.setMoving(false);
        playerData.setInventoryItems(new ArrayList<>());
        playerData.setPartyPokemon(new ArrayList<>());
        return playerData;
    }

    private void cleanupFailedLogin(String username, int connectionId) {
        try {
            activeConnections.remove(username);
            activePlayers.remove(username);
            connectedPlayers.remove(connectionId);
        } catch (Exception e) {
            GameLogger.error("Error cleaning up failed login: " + e.getMessage());
        }
    }

    private void setupNetworkListener() {
        networkServer.addListener(new Listener() {
            @Override
            public void connected(Connection connection) {
                try {
                    GameLogger.info("New connection attempt from: " + connection.getRemoteAddressTCP());
                    // Check max players
                    if (playerManager.getOnlinePlayers().size() >= config.getMaxPlayers()) {
                        GameLogger.info("Connection rejected: Max players reached");
                        sendConnectionResponse(connection, false, "Server is full");
                        scheduler.schedule(() -> connection.close(), 100, TimeUnit.MILLISECONDS);
                        return;
                    }

                    // Send success response
                    NetworkProtocol.ConnectionResponse response = new NetworkProtocol.ConnectionResponse();
                    response.success = true;
                    response.message = "Connection established";
                    connection.sendTCP(response);

                    GameLogger.info("Connection " + connection.getID() + " established - awaiting authentication");

                    // Set authentication timeout
                    scheduler.schedule(() -> {
                        if (!connectedPlayers.containsKey(connection.getID())) {
                            GameLogger.info("Authentication timeout for connection: " + connection.getID());
                            connection.close();
                        }
                    }, AUTH_TIMEOUT, TimeUnit.MILLISECONDS);

                } catch (Exception e) {
                    GameLogger.error("Error handling connection: " + e.getMessage());
                    connection.close();
                }
            }

            @Override
            public void received(Connection connection, Object object) {
                try {
                    if (object instanceof FrameworkMessage) {
                        // Ignore KryoNet's internal messages
                        return;
                    }
                    if (object instanceof NetworkProtocol.WorldObjectUpdate) {
                        NetworkProtocol.WorldObjectUpdate update = (NetworkProtocol.WorldObjectUpdate) object;
                        // Validate object data
                        if (update.data == null || update.data.isEmpty()) {
                            GameLogger.error("Invalid WorldObjectUpdate received - empty data");
                            return;
                        }
                    }

                    if (object instanceof NetworkProtocol.LoginRequest) {
                        handleLoginRequest(connection, (NetworkProtocol.LoginRequest) object);
                        return;
                    }

                    if (object instanceof NetworkProtocol.RegisterRequest) {
                        handleRegisterRequest(connection, (NetworkProtocol.RegisterRequest) object);
                        return;
                    }

                    if (object instanceof NetworkProtocol.ChunkRequest) {
                        handleChunkRequest(connection, (NetworkProtocol.ChunkRequest) object);
                        return;
                    }
                    if (object instanceof NetworkProtocol.BlockPlacement) {
                        handleBlockPlacement(connection, (NetworkProtocol.BlockPlacement) object);
                    }

                    // Handle other message types based on authentication
                    String username = connectedPlayers.get(connection.getID());
                    if (username == null) {
                        GameLogger.error("Received unauthorized message from Connection " + connection.getID());
                        return;
                    }

                    processAuthenticatedMessage(connection, object);
                } catch (Exception e) {
                    GameLogger.error("Error handling message: " + e.getMessage());
                }
            }

            @Override
            public void disconnected(Connection connection) {
                handleDisconnect(connection);
            }
        });
    }

    private void initializePeriodicTasks() {
        scheduler.scheduleAtFixedRate(() -> {
            try {
                // Save world data periodically
                if (worldData != null) {
                    ServerGameContext.get().getWorldManager().saveWorld(worldData);
                    GameLogger.info("World data saved periodically.");
                }
            } catch (Exception e) {
                GameLogger.error("Error during periodic world save: " + e.getMessage());
            }
        }, SAVE_INTERVAL, SAVE_INTERVAL, TimeUnit.MILLISECONDS);
    }

    private void handleLogout(Connection connection, NetworkProtocol.Logout logout) {
        String username = connectedPlayers.get(connection.getID());
        if (username != null && username.equals(logout.username)) {
            try {
                // Save final state
                ServerPlayer player = playerManager.getPlayer(username);
                if (player != null) {
                    PlayerData finalState = player.getData();
                    WorldData worldData = ServerGameContext.get().getWorldManager().getWorld(CreatureCaptureGame.MULTIPLAYER_WORLD_NAME);
                    if (worldData != null) {
                        worldData.savePlayerData(username, finalState, true);
                        ServerGameContext.get().getWorldManager().saveWorld(worldData);
                    }
                }

                // Clean up connection
                handlePlayerDisconnect(connection);

                // Send acknowledgment
                NetworkProtocol.LogoutResponse response = new NetworkProtocol.LogoutResponse();
                response.success = true;
                connection.sendTCP(response);

            } catch (Exception e) {
                GameLogger.error("Error handling logout: " + e.getMessage());
                NetworkProtocol.LogoutResponse response = new NetworkProtocol.LogoutResponse();
                response.success = false;
                response.message = "Error saving state";
                connection.sendTCP(response);
            }
        }
    }

    private void sendConnectionResponse(Connection connection, boolean success, String message) {
        NetworkProtocol.ConnectionResponse response = new NetworkProtocol.ConnectionResponse();
        response.success = success;
        response.message = message;

        try {
            connection.sendTCP(response);
        } catch (Exception e) {
            GameLogger.error("Error sending connection response: " + e.getMessage());
        }
    }

    private void handleChatMessage(Connection connection, NetworkProtocol.ChatMessage message) {
        if (message == null || message.content == null || message.content.isEmpty()) {
            return;
        }

        if (message.timestamp == 0) {
            message.timestamp = System.currentTimeMillis();
        }

        for (Connection conn : networkServer.getConnections()) {
            if (conn.getID() != connection.getID()) {
                try {
                    networkServer.sendToTCP(conn.getID(), message);
                } catch (Exception e) {
                }
            }
        }
    }

    private void sendRegistrationResponse(Connection connection, boolean success, String message) {
        NetworkProtocol.RegisterResponse response = new NetworkProtocol.RegisterResponse();
        response.success = success;
        response.message = message;
        networkServer.sendToTCP(connection.getID(), response);
    }

    private boolean isValidUsername(String username) {
        return username != null &&
            username.length() >= 3 &&
            username.length() <= 20 &&
            username.matches("^[a-zA-Z0-9_]+$");
    }

    private void handleRegisterRequest(Connection connection, NetworkProtocol.RegisterRequest request) {
        try {
            GameLogger.info("Processing registration request for username: " + request.username);

            // Basic validation
            if (request.username == null || request.username.isEmpty() ||
                request.password == null || request.password.isEmpty()) {
                sendRegistrationResponse(connection, false, "Username and password are required.");
                return;
            }

            // Validate username format
            if (!isValidUsername(request.username)) {
                sendRegistrationResponse(connection, false,
                    "Username must be 3-20 characters long and contain only letters, numbers, and underscores.");
                return;
            }

            // Check if username already exists
            if (databaseManager.checkUsernameExists(request.username)) {
                sendRegistrationResponse(connection, false, "Username already exists.");
                return;
            }

            // Attempt to register the player in database
            boolean success = databaseManager.registerPlayer(request.username, request.password);

            if (success) {
                GameLogger.info("Successfully registered new player: " + request.username);
                sendRegistrationResponse(connection, true, "Registration successful!");
            } else {
                GameLogger.error("Failed to register player: " + request.username);
                sendRegistrationResponse(connection, false, "Registration failed. Please try again.");
            }

        } catch (Exception e) {
            GameLogger.error("Error during registration: " + e.getMessage());
            sendRegistrationResponse(connection, false, "An error occurred during registration.");
        }
    }

    public void start() {
        try {
            GameLogger.info("Starting server...");

            if (!isPortAvailable(config.getTcpPort())) {
                throw new IOException("TCP port " + config.getTcpPort() + " is already in use.");
            }

            if (!isPortAvailable(config.getUdpPort())) {
                throw new IOException("UDP port " + config.getUdpPort() + " is already in use.");
            }

            GameLogger.info("Storage system initialized");

            GameLogger.info("World manager initialized");
            initializePeriodicTasks();
            // Load plugins
            pluginManager.loadPlugins();
            pluginManager.enablePlugins();
            GameLogger.info("Plugins loaded");

            // Register network classes
            NetworkProtocol.registerClasses(networkServer.getKryo());
            GameLogger.info("Network classes registered");

            networkServer.start();

            broadcastPlayerStates();

            networkServer.bind(config.getTcpPort(), config.getUdpPort());
            running = true;

            GameLogger.info("Server started successfully on TCP port " + config.getTcpPort() +
                " and UDP port " + config.getUdpPort());
            GameLogger.info("Maximum players: " + config.getMaxPlayers());

        } catch (Exception e) {
            GameLogger.info("Failed to start server: " + e.getMessage());
            e.printStackTrace();
            throw new RuntimeException("Server failed to start", e);
        }
    }

    private boolean isPortAvailable(int port) {
        try (ServerSocket ss = new ServerSocket(port)) {
            ss.setReuseAddress(true);
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    public void stop() {
        if (!running) return;
        running = false;

        GameLogger.info("Shutting down server...");
        if (worldData != null) {
            ServerGameContext.get().getWorldManager().saveWorld(worldData);
        }

        playerManager.getOnlinePlayers().forEach(player -> {
            try {
                Integer connectionId = activeUserConnections.get(player.getUsername());
                if (connectionId != null) {
                    Connection[] connections = networkServer.getConnections();
                    Connection targetConnection = null;
                    for (Connection conn : connections) {
                        if (conn.getID() == connectionId) {
                            targetConnection = conn;
                            break;
                        }
                    }
                    if (targetConnection != null) {
                        targetConnection.close();
                        GameLogger.info("Disconnected player: " + player.getUsername());
                    }
                }
            } catch (Exception e) {
                GameLogger.info("Error disconnecting player " + player.getUsername() + ": " + e.getMessage());
            }
        });
        pluginManager.disablePlugins();
        eventManager.shutdown();
        if (networkServer != null) {
            networkServer.stop();
        }

        GameLogger.info("Server shutdown complete.");
    }

    // In GameServer.java, modify handleChunkRequest:
    private void handleChunkRequest(Connection connection, NetworkProtocol.ChunkRequest request) {
        try {
            int chunkX = request.chunkX;
            int chunkY = request.chunkY;
            Vector2 chunkPos = new Vector2(chunkX, chunkY);

            // Get or generate the chunk
            Chunk chunk = worldData.getChunks().get(chunkPos);
            if (chunk == null) {
                chunk = generateNewChunk(chunkX, chunkY);
                worldData.getChunks().put(chunkPos, chunk);
            }

            // Create response
            NetworkProtocol.ChunkData response = new NetworkProtocol.ChunkData();
            response.chunkX = chunkX;
            response.chunkY = chunkY;
            response.biomeType = chunk.getBiome().getType();
            response.tileData = chunk.getTileData();
            response.timestamp = System.currentTimeMillis();

            // Convert block data to network format
            List<BlockSaveData.BlockData> blockDataList = chunk.getBlockDataForSave();
            if (blockDataList != null && !blockDataList.isEmpty()) {
                // Set both blockData and blocks fields for compatibility
                response.blockData = blockDataList;
                response.blocks = new ArrayList<>();

                // Convert BlockSaveData to Map format
                for (BlockSaveData.BlockData blockData : blockDataList) {
                    Map<String, Object> blockMap = new HashMap<>();
                    blockMap.put("type", blockData.type);
                    blockMap.put("tileX", blockData.x);
                    blockMap.put("tileY", blockData.y);
                    blockMap.put("isFlipped", blockData.isFlipped);
                    blockMap.put("isChestOpen", blockData.isChestOpen);
                    if (blockData.chestData != null) {
                        blockMap.put("chestData", blockData.chestData);
                    }
                    response.blocks.add(blockMap);
                }

                GameLogger.info("Sending " + blockDataList.size() + " blocks for chunk " + chunkPos);
            }

            // Get world objects for this chunk
            List<WorldObject> chunkObjects = worldData.getChunkObjects().get(chunkPos);
            if (chunkObjects == null || chunkObjects.isEmpty()) {
                // Generate objects if none exist
                chunkObjects = generateChunkObjects(chunk, chunkPos);
                worldData.addChunkObjects(chunkPos, chunkObjects);
            }

            // Convert objects to network format
            response.worldObjects = new ArrayList<>();
            for (WorldObject obj : chunkObjects) {
                Map<String, Object> objData = new HashMap<>();
                objData.put("type", obj.getType().name());
                objData.put("tileX", obj.getTileX());
                objData.put("tileY", obj.getTileY());
                objData.put("id", obj.getId());
                response.worldObjects.add(objData);
            }

            GameLogger.info("Sending chunk data for " + chunkPos + " with " +
                response.worldObjects.size() + " objects and " +
                (response.blocks != null ? response.blocks.size() : 0) + " blocks");

            connection.sendTCP(response);

        } catch (Exception e) {
            GameLogger.error("Error handling chunk request: " + e.getMessage());
        }
    }

    private void handleWorldObjectUpdate(Connection connection, NetworkProtocol.WorldObjectUpdate update) {
        String username = connectedPlayers.get(connection.getID());
        if (username == null) {
            GameLogger.error("Unauthorized world object update attempt.");
            return;
        }

        switch (update.type) {
            case ADD:
                // Optionally handle object addition from clients if allowed
                break;
            case REMOVE:
                // Validate and remove the object
                boolean removed = worldObjectManager.removeObject(update.objectId);
                if (removed) {
                    // Broadcast removal to other clients
                    networkServer.sendToAllExceptTCP(connection.getID(), update);
                } else {
                    GameLogger.error("Failed to remove object: " + update.objectId);
                }
                break;
            case UPDATE:
                // Handle object updates if necessary
                break;
        }
    }

    private void processAuthenticatedMessage(Connection connection, Object message) {
        String username = connectedPlayers.get(connection.getID());
        if (username == null) {
            GameLogger.error("Received message from non-authenticated connection: " + connection.getID());
            return;
        }

        ServerPlayer player = activePlayers.get(username);
        if (player == null) {
            GameLogger.error("No player instance found for authenticated user: " + username);
            // Attempt to recover
            PlayerData savedData = ServerGameContext.get().getStorageSystem().getPlayerDataManager().loadPlayerData(UUID.nameUUIDFromBytes(username.getBytes()));
            if (savedData != null) {
                player = new ServerPlayer(username, savedData);
                activePlayers.put(username, player);
                GameLogger.info("Recovered player instance for: " + username);
            } else {
                connection.close(); // Force disconnect if unrecoverable
                return;
            }
        }

        try {
            if (message instanceof NetworkProtocol.PlayerUpdate) {
                handlePlayerUpdate(connection, (NetworkProtocol.PlayerUpdate) message);
            } else if (message instanceof NetworkProtocol.ChatMessage) {
                handleChatMessage(connection, (NetworkProtocol.ChatMessage) message);
            } else if (message instanceof NetworkProtocol.WorldObjectUpdate) {
                handleWorldObjectUpdate(connection, (NetworkProtocol.WorldObjectUpdate) message);
            } else if (message instanceof NetworkProtocol.PlayerAction) {
                handlePlayerAction(connection, (NetworkProtocol.PlayerAction) message);
            }
        } catch (Exception e) {
            GameLogger.error("Error processing message for " + username + ": " + e.getMessage());
        }
    }

    private void handlePlayerAction(Connection connection, NetworkProtocol.PlayerAction action) {
        String username = connectedPlayers.get(connection.getID());
        if (username == null || !username.equals(action.playerId)) {
            GameLogger.error("Unauthorized player action attempt by " + action.playerId);
            return;
        }

        switch (action.actionType) {
            case CHOP_START:
                handleChopStart(action);
                networkServer.sendToAllExceptTCP(connection.getID(), action);
                break;
            case CHOP_STOP:
                handleChopProgress(action);
                networkServer.sendToAllExceptTCP(connection.getID(), action);
                break;

            // *** NEW: PUNCH START / STOP ***
            case PUNCH_START:
                // No server "tree removal" logic for punch, just broadcast
                networkServer.sendToAllExceptTCP(connection.getID(), action);
                GameLogger.info("Player " + action.playerId + " started punching");
                break;
            case PUNCH_STOP:
                networkServer.sendToAllExceptTCP(connection.getID(), action);
                GameLogger.info("Player " + action.playerId + " stopped punching");
                break;
        }
    }

    private void handleChopStart(NetworkProtocol.PlayerAction action) {
        if (action == null || action.playerId == null || action.targetPosition == null) {
            GameLogger.error("Invalid chop start action received");
            return;
        }

        try {
            // Validate player exists
            ServerPlayer player = playerManager.getPlayer(action.playerId);
            if (player == null) {
                GameLogger.error("Player not found for chop action: " + action.playerId);
                return;
            }

            // Calculate chunk position from target coordinates
            Vector2 chunkPos = new Vector2(
                (int) Math.floor(action.targetPosition.x / (World.CHUNK_SIZE * World.TILE_SIZE)),
                (int) Math.floor(action.targetPosition.y / (World.CHUNK_SIZE * World.TILE_SIZE))
            );

            // Get chunk's objects
            List<WorldObject> chunkObjects = worldData.getChunkObjects().get(chunkPos);
            if (chunkObjects == null) {
                GameLogger.error("No objects found in chunk: " + chunkPos);
                return;
            }

            // Find the targeted tree
            WorldObject targetTree = null;
            float minDistance = Float.MAX_VALUE;

            for (WorldObject obj : chunkObjects) {
                if (isChoppable(obj.getType())) {
                    float dist = Vector2.dst(
                        obj.getPixelX(),
                        obj.getPixelY(),
                        action.targetPosition.x,
                        action.targetPosition.y
                    );

                    if (dist < minDistance) {
                        minDistance = dist;
                        targetTree = obj;
                    }
                }
            }

            if (targetTree != null) {
                // Store the chopping state
                player.setChoppingObject(targetTree);

                // Broadcast the chop start action to other players
                NetworkProtocol.PlayerAction broadcastAction = new NetworkProtocol.PlayerAction();
                broadcastAction.playerId = action.playerId;
                broadcastAction.actionType = NetworkProtocol.ActionType.CHOP_START;
                broadcastAction.targetPosition = new Vector2(targetTree.getPixelX(), targetTree.getPixelY());

                networkServer.sendToAllExceptTCP(
                    activeUserConnections.get(action.playerId),
                    broadcastAction
                );

                GameLogger.info("Player " + action.playerId + " started chopping tree at " +
                    targetTree.getPixelX() + "," + targetTree.getPixelY());
            }
        } catch (Exception e) {
            GameLogger.error("Error handling chop start: " + e.getMessage());
        }
    }

    // Handle completion of tree chopping
    private void handleChopProgress(NetworkProtocol.PlayerAction action) {
        if (action == null || action.playerId == null) {
            return;
        }

        try {
            ServerPlayer player = playerManager.getPlayer(action.playerId);
            if (player == null) return;

            WorldObject choppedTree = player.getChoppingObject();
            if (choppedTree == null) return;

            // Clear the chopping state
            player.setChoppingObject(null);

            // Calculate chunk position
            Vector2 chunkPos = new Vector2(
                (int) Math.floor(choppedTree.getPixelX() / (World.CHUNK_SIZE * World.TILE_SIZE)),
                (int) Math.floor(choppedTree.getPixelY() / (World.CHUNK_SIZE * World.TILE_SIZE))
            );

            // Remove the tree
            List<WorldObject> chunkObjects = worldData.getChunkObjects().get(chunkPos);
            if (chunkObjects != null) {
                chunkObjects.remove(choppedTree);
                worldData.getChunkObjects().put(chunkPos, chunkObjects);

                // Create and broadcast tree removal update
                NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
                update.objectId = choppedTree.getId();
                update.type = NetworkProtocol.NetworkObjectUpdateType.REMOVE;

                // Broadcast to all players except the chopper
                networkServer.sendToAllExceptTCP(
                    activeUserConnections.get(action.playerId),
                    update
                );

                GameLogger.info("Player " + action.playerId + " finished chopping tree at " +
                    choppedTree.getPixelX() + "," + choppedTree.getPixelY());
            }
        } catch (Exception e) {
            GameLogger.error("Error handling chop progress: " + e.getMessage());
        }
    }

    private void handlePokeballSpawning(Vector2 chunkPos, Chunk chunk) {
        try {
            List<WorldObject> chunkObjects = worldData.getChunkObjects().computeIfAbsent(chunkPos, k -> new ArrayList<>());

            // Count existing pokeballs
            long pokeballCount = chunkObjects.stream()
                .filter(obj -> obj.getType() == WorldObject.ObjectType.POKEBALL)
                .count();
            Random random = new Random();
            // Check if we can spawn a new pokeball
            if (pokeballCount < MAX_POKEBALLS_PER_CHUNK && random.nextFloat() < POKEBALL_SPAWN_CHANCE) {
                // Find valid spawn location
                int attempts = 10;
                while (attempts > 0) {
                    int localX = random.nextInt(Chunk.CHUNK_SIZE);
                    int localY = random.nextInt(Chunk.CHUNK_SIZE);

                    int worldTileX = (int) (chunkPos.x * Chunk.CHUNK_SIZE + localX);
                    int worldTileY = (int) (chunkPos.y * Chunk.CHUNK_SIZE + localY);

                    // Check if location is valid (e.g., on grass or walkable terrain)
                    if (chunk.isPassable(localX, localY)) {
                        // Create new pokeball object
                        WorldObject pokeball = new WorldObject(
                            worldTileX,
                            worldTileY,
                            null, // Server doesn't need texture
                            WorldObject.ObjectType.POKEBALL
                        );

                        // Add to chunk objects
                        chunkObjects.add(pokeball);

                        // Create spawn update
                        NetworkProtocol.WorldObjectUpdate update = new NetworkProtocol.WorldObjectUpdate();
                        update.objectId = pokeball.getId();
                        update.type = NetworkProtocol.NetworkObjectUpdateType.ADD;
                        update.data = pokeball.getSerializableData();

                        // Broadcast to all players
                        networkServer.sendToAllTCP(update);

                        GameLogger.info("Spawned pokeball at " + worldTileX + "," + worldTileY);
                        break;
                    }
                    attempts--;
                }
            }
        } catch (Exception e) {
            GameLogger.error("Error handling pokeball spawn: " + e.getMessage());
        }
    }

    private boolean isChoppable(WorldObject.ObjectType type) {
        return type == WorldObject.ObjectType.TREE_0 ||
            type == WorldObject.ObjectType.TREE_1 ||
            type == WorldObject.ObjectType.SNOW_TREE ||
            type == WorldObject.ObjectType.HAUNTED_TREE ||
            type == WorldObject.ObjectType.RAIN_TREE ||
            type == WorldObject.ObjectType.APRICORN_TREE ||
            type == WorldObject.ObjectType.RUINS_TREE;
    }

    private float getObjectDensityMultiplier(BiomeType biomeType) {
        switch (biomeType) {
            case FOREST:
                return 1.5f;
            case DESERT:
                return 0.3f;
            case SNOW:
                return 0.8f;
            case HAUNTED:
                return 1.2f;
            default:
                return 1.0f;
        }
    }

    private void handleBlockPlacement(Connection connection, NetworkProtocol.BlockPlacement placement) {
        String username = connectedPlayers.get(connection.getID());
        if (username == null || !username.equals(placement.username)) {
            GameLogger.error("Unauthorized block placement attempt by " + placement.username);
            return;
        }

        switch (placement.action) {
            case PLACE:
                // Place the block in the server's world
                boolean placed = blockManager.placeBlock(PlaceableBlock.BlockType.fromItemId(placement.blockTypeId), placement.tileX, placement.tileY);
                if (placed) {
                    // Broadcast to other clients
                    networkServer.sendToAllExceptTCP(connection.getID(), placement);
                } else {
                    GameLogger.error("Failed to place block at (" + placement.tileX + ", " + placement.tileY + ")");
                }
                break;
            case REMOVE:
                // Remove the block from the server's world
                blockManager.removeBlock(placement.tileX, placement.tileY);
                // Broadcast to other clients
                networkServer.sendToAllExceptTCP(connection.getID(), placement);
                break;
        }
    }

    private Chunk generateNewChunk(int chunkX, int chunkY) {
        try {
            // Calculate world coordinates
            float worldX = chunkX * World.CHUNK_SIZE * World.TILE_SIZE;
            float worldY = chunkY * World.CHUNK_SIZE * World.TILE_SIZE;

            // Get biome for chunk
            BiomeTransitionResult biomeTransition = biomeManager.getBiomeAt(worldX, worldY);
            if (biomeTransition == null || biomeTransition.getPrimaryBiome() == null) {
                GameLogger.error("Invalid biome transition at: " + worldX + "," + worldY);
                return null;
            }

            Biome biome = biomeTransition.getPrimaryBiome();
            GameLogger.info("Generating chunk at (" + chunkX + "," + chunkY +
                ") with biome: " + biome.getType());

            Chunk chunk = new Chunk(chunkX, chunkY, biome, worldData.getConfig().getSeed(), biomeManager);

            int[][] tileData = new int[World.CHUNK_SIZE][World.CHUNK_SIZE];
            Random random = new Random(worldData.getConfig().getSeed() + (chunkX * 31L + chunkY * 17L));

            Map<Integer, Integer> distribution = biome.getTileDistribution();

            for (int x = 0; x < World.CHUNK_SIZE; x++) {
                for (int y = 0; y < World.CHUNK_SIZE; y++) {
                    int tileType = selectTileType(distribution, random);
                    tileData[x][y] = tileType;
                }
            }

            chunk.setTileData(tileData);
            try {
                List<io.github.pokemeetup.system.gameplay.overworld.WorldObject> objects = generateChunkObjects(chunk, new Vector2(chunkX, chunkY));
                if (!objects.isEmpty()) {
                    Vector2 chunkPos = new Vector2(chunkX, chunkY);
                    worldData.addChunkObjects(chunkPos, objects);
                }
            } catch (Exception e) {
                GameLogger.error("Error generating chunk objects: " + e.getMessage());
            }

            return chunk;

        } catch (Exception e) {
            GameLogger.error("Error generating chunk: " + e.getMessage());
            return null;
        }
    }

    private List<io.github.pokemeetup.system.gameplay.overworld.WorldObject> generateChunkObjects(Chunk chunk, Vector2 chunkPos) {
        List<io.github.pokemeetup.system.gameplay.overworld.WorldObject> objects = new ArrayList<>();
        Random random = new Random(worldData.getConfig().getSeed() + (chunk.getChunkX() * 31L + chunk.getChunkY() * 17L));
        float baseObjectDensity = worldData.getConfig().getTreeSpawnRate();

        float biomeMultiplier = getObjectDensityMultiplier(chunk.getBiome().getType());
        float density = baseObjectDensity * biomeMultiplier;
        List<ObjectType> possibleTypes = new ArrayList<>();
        switch (chunk.getBiome().getType()) {
            case FOREST:
                possibleTypes.add(ObjectType.TREE);
                possibleTypes.add(ObjectType.BUSH);
                break;
            case DESERT:
                possibleTypes.add(ObjectType.CACTUS);
                possibleTypes.add(ObjectType.DEAD_TREE);
                break;
            case SNOW:
                possibleTypes.add(ObjectType.SNOW_TREE);
                break;
            case HAUNTED:
                possibleTypes.add(ObjectType.HAUNTED_TREE);
                possibleTypes.add(ObjectType.SMALL_HAUNTED_TREE);
                break;
            default:
                possibleTypes.add(ObjectType.TREE);
                possibleTypes.add(ObjectType.BUSH);
        }

        for (int x = 0; x < World.CHUNK_SIZE; x++) {
            for (int y = 0; y < World.CHUNK_SIZE; y++) {
                if (random.nextFloat() < density) {
                    float worldX = (chunkPos.x * World.CHUNK_SIZE + x) * World.TILE_SIZE;
                    float worldY = (chunkPos.y * World.CHUNK_SIZE + y) * World.TILE_SIZE;

                    ObjectType type = possibleTypes.get(random.nextInt(possibleTypes.size()));
                    io.github.pokemeetup.system.gameplay.overworld.WorldObject obj = new io.github.pokemeetup.system.gameplay.overworld.WorldObject(
                        (int) worldY / World.TILE_SIZE,
                        (int) worldX / World.TILE_SIZE,
                        null,  // No texture on server
                        io.github.pokemeetup.system.gameplay.overworld.WorldObject.ObjectType.valueOf(type.name())
                    );

                    objects.add(obj);
                }
            }
        }

        return objects;
    }

    private int selectTileType(Map<Integer, Integer> distribution, Random random) {
        int roll = random.nextInt(100);
        int total = 0;

        for (Map.Entry<Integer, Integer> entry : distribution.entrySet()) {
            total += entry.getValue();
            if (roll < total) {
                return entry.getKey();
            }
        }

        return distribution.keySet().iterator().next();
    }

    public ServerConnectionConfig getConfig() {
        return config;
    }


    public enum ObjectType {
        TREE,
        TREE_1,
        TREE_0,
        RUINS_TREE,
        APRICORN_TREE,
        BUSH,
        CACTUS,
        SNOW_TREE,
        HAUNTED_TREE,
        DEAD_TREE,
        RAIN_TREE,
        SMALL_HAUNTED_TREE,
        POKEBALL,
        VINES;
    }

    private static class ConnectionInfo {
        final int connectionId;
        final long connectionTime;
        volatile boolean isAuthenticated;

        ConnectionInfo(int connectionId) {
            this.connectionId = connectionId;
            this.connectionTime = System.currentTimeMillis();
            this.isAuthenticated = false;
        }
    }

}

================
File: main/java/org/discord/PluginManager.java
================
package org.discord;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import io.github.pokemeetup.multiplayer.server.plugin.PluginConfig;
import io.github.pokemeetup.multiplayer.server.plugin.ServerPlugin;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.system.servers.PluginContext;

import java.io.*;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.logging.Logger;

public class PluginManager {
    private static final Logger logger = Logger.getLogger(PluginManager.class.getName());
    private final Map<String, ServerPlugin> loadedPlugins = new ConcurrentHashMap<>();
    private final Map<String, PluginConfig> pluginConfigs = new ConcurrentHashMap<>();
    private final Path pluginsDir;
    private final WorldData gameWorld;

    public PluginManager(WorldData gameWorld) {
        this.gameWorld = gameWorld;
        this.pluginsDir = Paths.get("plugins");
        createPluginDirectory();
    }

    private void createPluginDirectory() {
        try {
            Files.createDirectories(pluginsDir);
        } catch (IOException e) {
            logger.severe("Failed to create plugins directory: " + e.getMessage());
            throw new RuntimeException("Failed to create plugins directory", e);
        }
    }

    public void loadPlugins() {
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(pluginsDir, "*.jar")) {
            for (Path jarPath : stream) {
                loadPlugin(jarPath);
            }
        } catch (IOException e) {
            logger.severe("Error loading plugins: " + e.getMessage());
        }
    }

    private void loadPlugin(Path jarPath) {
        try (JarFile jarFile = new JarFile(jarPath.toFile())) {
            // Load plugin.yml
            JarEntry configEntry = jarFile.getJarEntry("plugin.yml");
            if (configEntry == null) {
                throw new IllegalStateException("Missing plugin.yml in " + jarPath.getFileName());
            }

            // Load and parse config
            PluginConfig config = loadPluginConfig(jarFile.getInputStream(configEntry));

            // Validate dependencies
            validateDependencies(config);

            // Create isolated classloader for plugin
            URLClassLoader classLoader = new URLClassLoader(
                new URL[]{jarPath.toUri().toURL()},
                getClass().getClassLoader()
            );

            // Load main plugin class
            Class<?> mainClass = Class.forName(config.getMainClass(), true, classLoader);
            if (!ServerPlugin.class.isAssignableFrom(mainClass)) {
                throw new IllegalStateException("Plugin main class must implement ServerPlugin interface");
            }

            ServerPlugin plugin = (ServerPlugin) mainClass.getDeclaredConstructor().newInstance();

            // Create plugin context and initialize
            Map<String, Object> pluginConfig = loadPluginConfig(plugin.getId());
            PluginContext context = new PluginContext(gameWorld, pluginConfig);
            plugin.onLoad(context);

            // Store loaded plugin
            loadedPlugins.put(plugin.getId(), plugin);
            pluginConfigs.put(plugin.getId(), config);

            logger.info("Successfully loaded plugin: " + config.getName() + " v" + config.getVersion());

        } catch (Exception e) {
            logger.severe("Failed to load plugin " + jarPath.getFileName() + ": " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void validateDependencies(PluginConfig config) {
        for (String dependency : config.getDependencies()) {
            if (!loadedPlugins.containsKey(dependency)) {
                throw new IllegalStateException("Missing required dependency: " + dependency);
            }
        }
    }

    private PluginConfig loadPluginConfig(InputStream input) {
        try {
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            try (Reader reader = new InputStreamReader(input)) {
                return gson.fromJson(reader, PluginConfig.class);
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to load plugin config", e);
        }
    }

    public void enablePlugins() {
        List<String> enableOrder = calculateEnableOrder();
        for (String pluginId : enableOrder) {
            ServerPlugin plugin = loadedPlugins.get(pluginId);
            try {
                plugin.onEnable();
                logger.info("Enabled plugin: " + pluginId);
            } catch (Exception e) {
                logger.severe("Failed to enable plugin " + pluginId + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    private List<String> calculateEnableOrder() {
        // Simple topological sort for dependencies
        Map<String, Set<String>> graph = new HashMap<>();
        for (Map.Entry<String, PluginConfig> entry : pluginConfigs.entrySet()) {
            graph.put(entry.getKey(), new HashSet<>(entry.getValue().getDependencies()));
        }

        List<String> result = new ArrayList<>();
        Set<String> visited = new HashSet<>();

        for (String plugin : graph.keySet()) {
            if (!visited.contains(plugin)) {
                visitPlugin(plugin, graph, visited, new HashSet<>(), result);
            }
        }

        return result;
    }

    private void visitPlugin(String plugin, Map<String, Set<String>> graph,
                             Set<String> visited, Set<String> visiting, List<String> result) {
        visiting.add(plugin);

        Set<String> dependencies = graph.get(plugin) != null ? graph.get(plugin) : new HashSet<>();
        for (String dep : dependencies) {
            if (visiting.contains(dep)) {
                throw new IllegalStateException("Circular dependency detected: " + plugin + " -> " + dep);
            }
            if (!visited.contains(dep)) {
                visitPlugin(dep, graph, visited, visiting, result);
            }
        }

        visiting.remove(plugin);
        visited.add(plugin);
        result.add(plugin);
    }

    public void disablePlugins() {
        List<String> disableOrder = new ArrayList<>(loadedPlugins.keySet());
        Collections.reverse(disableOrder);  // Disable in reverse order

        for (String pluginId : disableOrder) {
            try {
                ServerPlugin plugin = loadedPlugins.get(pluginId);
                plugin.onDisable();
                logger.info("Disabled plugin: " + pluginId);
            } catch (Exception e) {
                logger.severe("Error disabling plugin " + pluginId + ": " + e.getMessage());
            }
        }
        loadedPlugins.clear();
        pluginConfigs.clear();
    }

    // Public API
    public ServerPlugin getPlugin(String id) {
        return loadedPlugins.get(id);
    }

    public Collection<ServerPlugin> getPlugins() {
        return Collections.unmodifiableCollection(loadedPlugins.values());
    }

    public void savePluginConfig(String pluginId, Map<String, Object> config) {
        Path configPath = pluginsDir.resolve(pluginId + ".json");
        try {
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            String json = gson.toJson(config);
            Files.write(configPath, json.getBytes(StandardCharsets.UTF_8));
        } catch (IOException e) {
            logger.severe("Failed to save config for plugin " + pluginId + ": " + e.getMessage());
        }
    }

    public Map<String, Object> loadPluginConfig(String pluginId) {
        Path configPath = pluginsDir.resolve(pluginId + ".json");
        if (!Files.exists(configPath)) {
            ServerPlugin plugin = loadedPlugins.get(pluginId);
            return plugin != null ? new HashMap<>() : new HashMap<>();
        }

        try {
            Gson gson = new GsonBuilder().create();
            byte[] bytes = Files.readAllBytes(configPath);
            String json = new String(bytes, StandardCharsets.UTF_8);
            @SuppressWarnings("unchecked")
            Map<String, Object> config = gson.fromJson(json, Map.class);
            return config != null ? config : new HashMap<>();
        } catch (IOException e) {
            logger.severe("Failed to load config for plugin " + pluginId + ": " + e.getMessage());
            return new HashMap<>();
        }
    }
}

================
File: main/java/org/discord/ServerBlockManager.java
================
package org.discord;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.blocks.PlaceableBlock;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class ServerBlockManager {
    private final Map<Vector2, PlaceableBlock> placedBlocks = new ConcurrentHashMap<>();

    public boolean placeBlock(PlaceableBlock.BlockType type, int tileX, int tileY) {
        Vector2 pos = new Vector2(tileX, tileY);
        if (placedBlocks.containsKey(pos)) {
            return false;
        }
        PlaceableBlock block = new PlaceableBlock(type, pos);
        placedBlocks.put(pos, block);
        return true;
    }

    public void removeBlock(int tileX, int tileY) {
        Vector2 pos = new Vector2(tileX, tileY);
        if (placedBlocks.containsKey(pos)) {
            return;
        }
        placedBlocks.remove(pos);
    }

    public Map<Vector2, PlaceableBlock> getPlacedBlocks() {
        return placedBlocks;
    }
}

================
File: main/java/org/discord/ServerLauncher.java
================
package org.discord;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import io.github.pokemeetup.CreatureCaptureGame;
import io.github.pokemeetup.multiplayer.server.ServerStorageSystem;
import io.github.pokemeetup.multiplayer.server.config.ServerConnectionConfig;
import io.github.pokemeetup.system.gameplay.overworld.World;
import io.github.pokemeetup.utils.storage.GameFileSystem;
import org.discord.context.ServerGameContext;
import org.discord.files.ServerFileDelegate;
import org.discord.utils.ServerWorldManager;
import org.h2.tools.Server;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.logging.Logger;

public class ServerLauncher {
    private static final String DEFAULT_ICON = "server-icon.png";
    private static final String DEFAULT_MOTD = "Basic and default server description fr!";
    private static final Logger logger = Logger.getLogger(ServerLauncher.class.getName());
    private static final Path SERVER_ROOT = Paths.get(".");
    public static ServerStorageSystem storage;

    public static void main(String[] args) {
        Server h2Server = null;
        try {
            // Initialize server deployment
            logger.info("Initializing server deployment...");
            DeploymentHelper.createServerDeployment(SERVER_ROOT);
            logger.info("Server deployment initialized");

            // Initialize file system
            GameFileSystem.getInstance().setDelegate(new ServerFileDelegate());
            logger.info("Server file system initialized");

            // Start H2 Database Server
            h2Server = startH2Server();

            // Load server configuration
            ServerConnectionConfig config = loadServerConfig();
            logger.info("Server configuration loaded");

            // Initialize storage and world management
            storage = new ServerStorageSystem();
            logger.info("World management system initialized");
            ServerWorldManager serverWorldManager = ServerWorldManager.getInstance(storage);
            serverWorldManager.loadWorld("multiplayer_world");
            ServerGameContext.init(serverWorldManager,storage);
            GameServer server = new GameServer(config);
            server.start();
            logger.info("Game server started successfully");

            // Add shutdown hook
            addShutdownHook(server, h2Server);

        } catch (Exception e) {
            logger.severe("Failed to start server: " + e.getMessage());
            if (h2Server != null) {
                h2Server.stop();
            }
            System.exit(1);
        }
    }

    private static Server startH2Server() throws Exception {
        Server h2Server = Server.createTcpServer(
            "-tcpPort", "9101",
            "-tcpAllowOthers",
            "-ifNotExists",
            "-baseDir", "./data"
        ).start();

        if (h2Server.isRunning(true)) {
            logger.info("H2 Database Server started on port 9101");
        }
        return h2Server;
    }

    private static ServerConnectionConfig loadServerConfig() throws IOException {
        Path configDir = SERVER_ROOT.resolve("config");
        Path configFile = configDir.resolve("server.json");

        try {
            if (!configFile.toFile().exists()) {
                logger.info("Configuration not found, loading defaults");
                return new ServerConnectionConfig(
                    "0.0.0.0",
                    54555,
                    54556,
                    "Pokemon Meetup Server",
                    true,
                    100
                );
            }

            Gson gson = new GsonBuilder()
                .setPrettyPrinting()
                .serializeNulls()
                .create();

            String jsonContent = Files.readString(configFile);
            ServerConnectionConfig config = gson.fromJson(jsonContent, ServerConnectionConfig.class);
            config.setServerIP("0.0.0.0");

            return config;
        } catch (Exception e) {
            Path iconPath = SERVER_ROOT.resolve(DEFAULT_ICON);
            if (!Files.exists(iconPath)) {
                // Copy default icon from resources
                try (InputStream is = ServerLauncher.class.getResourceAsStream("/assets/default-server-icon.png")) {
                    if (is != null) {
                        Files.copy(is, iconPath);
                    }
                }
            }
            logger.warning("Error loading config: " + e.getMessage() + ". Using defaults.");
            ServerConnectionConfig config = new ServerConnectionConfig(
                "0.0.0.0",
                54555,
                54556,
                "Pokemon Meetup Server",
                true,
                100
            );
            config.setMotd(DEFAULT_MOTD);
            config.setIconPath(DEFAULT_ICON);
            return config;
        }
    }
    private static void addShutdownHook(GameServer server, Server h2Server) {
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            logger.info("Shutting down server...");
            try {
                server.shutdown();
                logger.info("Game server stopped");

                storage.shutdown();

                if (h2Server != null) {
                    h2Server.stop();
                    logger.info("Database server stopped");
                }

            } catch (Exception e) {
                logger.severe("Error during shutdown: " + e.getMessage());
            }
        }));
    }
}

================
File: main/java/org/discord/ServerWorldObjectManager.java
================
package org.discord;

import com.badlogic.gdx.math.Vector2;
import io.github.pokemeetup.multiplayer.network.NetworkProtocol;
import io.github.pokemeetup.system.gameplay.overworld.Chunk;
import io.github.pokemeetup.system.gameplay.overworld.WorldObject;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class ServerWorldObjectManager {
    private final Map<Vector2, List<WorldObject>> objectsByChunk = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, NetworkProtocol.WorldObjectData> worldObjects = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, String> objectLocks = new ConcurrentHashMap<>(); // objectId -> playerId

    public void addObject(WorldObject object) {
        Vector2 chunkPos = getChunkPosition(object.getTileX(), object.getTileY());
        List<WorldObject> objects = objectsByChunk.computeIfAbsent(chunkPos, k -> new CopyOnWriteArrayList<>());
        objects.add(object);
    }

    /**
     * Attempts to lock a WorldObject for a specific player.
     *
     * @param objectId The ID of the WorldObject.
     * @param playerId The ID of the player attempting to lock.
     * @return True if the lock was successful, false otherwise.
     */
    public boolean lockObject(String objectId, String playerId) {
        return objectLocks.putIfAbsent(objectId, playerId) == null;
    }

    /**
     * Unlocks a WorldObject.
     *
     * @param objectId The ID of the WorldObject.
     * @param playerId The ID of the player attempting to unlock.
     * @return True if the unlock was successful, false otherwise.
     */
    public boolean unlockObject(String objectId, String playerId) {
        return objectLocks.remove(objectId, playerId);
    }

    /**
     * Checks if a WorldObject is currently locked.
     *
     * @param objectId The ID of the WorldObject.
     * @return True if locked, false otherwise.
     */
    public boolean isLocked(String objectId) {
        return objectLocks.containsKey(objectId);
    }

    /**
     * Retrieves the ID of the player who locked the WorldObject.
     *
     * @param objectId The ID of the WorldObject.
     * @return The playerId if locked, null otherwise.
     */
    public String getLocker(String objectId) {
        return objectLocks.get(objectId);
    }

    /**
     * Retrieves a WorldObjectData instance by its ID.
     *
     * @param objectId The ID of the WorldObject.
     * @return The WorldObjectData if exists, null otherwise.
     */
    public NetworkProtocol.WorldObjectData getObjectData(String objectId) {
        return worldObjects.get(objectId);
    }

    public boolean removeObject(String objectId) {
        for (List<WorldObject> objects : objectsByChunk.values()) {
            objects.removeIf(obj -> obj.getId().equals(objectId));
        }
        return false;
    }

    public List<WorldObject> getObjectsForChunk(Vector2 chunkPos) {
        return objectsByChunk.getOrDefault(chunkPos, Collections.emptyList());
    }

    private Vector2 getChunkPosition(int tileX, int tileY) {
        int chunkX = Math.floorDiv(tileX, Chunk.CHUNK_SIZE);
        int chunkY = Math.floorDiv(tileY, Chunk.CHUNK_SIZE);
        return new Vector2(chunkX, chunkY);
    }
}

================
File: main/java/org/discord/utils/ServerWorldManager.java
================
package org.discord.utils;

import io.github.pokemeetup.multiplayer.server.ServerStorageSystem;
import io.github.pokemeetup.system.data.PlayerData;
import io.github.pokemeetup.system.data.PokemonData;
import io.github.pokemeetup.system.data.WorldData;
import io.github.pokemeetup.utils.GameLogger;

import java.util.*;
import java.util.concurrent.*;

public class ServerWorldManager {
    private static final long SAVE_INTERVAL = 300000; // 5 minutes
    private static ServerWorldManager instance;

    private final Map<String, WorldData> activeWorlds;
    private final ServerStorageSystem storage;
    private final Object worldLock = new Object();
    private final Map<String, Long> lastWorldAccess;
    private final ScheduledExecutorService scheduler;
    private final Map<UUID, PlayerData> playerDataCache;

    private ServerWorldManager(ServerStorageSystem storage) {
        this.storage = storage;
        this.activeWorlds = new ConcurrentHashMap<>();
        this.lastWorldAccess = new ConcurrentHashMap<>();
        this.playerDataCache = new ConcurrentHashMap<>();
        this.scheduler = Executors.newScheduledThreadPool(2);
        initializeAutoSave();
    }

    public static synchronized ServerWorldManager getInstance(ServerStorageSystem storage) {
        if (instance == null) {
            instance = new ServerWorldManager(storage);
        }
        return instance;
    }
    public void savePlayerData(String username, PlayerData data) {
        try {
            UUID playerUUID = UUID.nameUUIDFromBytes(username.getBytes());
            storage.getPlayerDataManager().savePlayerData(playerUUID, data);
            playerDataCache.put(playerUUID, data.copy());
            GameLogger.info("Saved player data for: " + username);

            // Ensure data is flushed to disk
            storage.flushPlayerData();

        } catch (Exception e) {
            GameLogger.error("Failed to save player data: " + e.getMessage());
        }
    }
    private void initializeAutoSave() {
        scheduler.scheduleAtFixedRate(() -> {
            synchronized (worldLock) {
                try {
                    // Save worlds that are marked dirty
                    for (Map.Entry<String, WorldData> entry : activeWorlds.entrySet()) {
                        if (entry.getValue().isDirty()) {
                            saveWorld(entry.getValue());
                            GameLogger.info("Auto-saved world: " + entry.getKey());
                        }
                    }

                    // Save all player data
                    for (Map.Entry<UUID, PlayerData> entry : playerDataCache.entrySet()) {
                        storage.getPlayerDataManager().savePlayerData(entry.getKey(), entry.getValue());
                    }

                    // Ensure data is flushed
                    storage.flushPlayerData();
                    GameLogger.info("Auto-saved player data");

                } catch (Exception e) {
                    GameLogger.error("Error during auto-save: " + e.getMessage());
                }
            }
        }, SAVE_INTERVAL, SAVE_INTERVAL, TimeUnit.MILLISECONDS);
    }
    public PlayerData loadPlayerData(String username) {
        try {
            UUID playerUUID = UUID.nameUUIDFromBytes(username.getBytes());

            // Check cache first
            PlayerData cached = playerDataCache.get(playerUUID);
            if (cached != null) {
                return cached.copy();
            }

            // Load from storage
            PlayerData data = storage.getPlayerDataManager().loadPlayerData(playerUUID);
            if (data != null) {
                // Validate and repair if needed
                if (data.validateAndRepairState()) {
                    GameLogger.info("Repaired player data for: " + username);
                    // Save the repaired data
                    savePlayerData(username, data);
                }
                playerDataCache.put(playerUUID, data.copy());
                GameLogger.info("Loaded player data for: " + username);
            } else {
                GameLogger.info("No existing player data found for: " + username);
            }
            return data;
        } catch (Exception e) {
            GameLogger.error("Failed to load player data: " + e.getMessage());
            return null;
        }
    }

    public WorldData loadWorld(String worldName) {
        synchronized (worldLock) {
            try {
                // Check if world is already loaded
                WorldData world = activeWorlds.get(worldName);
                if (world != null) {
                    lastWorldAccess.put(worldName, System.currentTimeMillis());
                    return world;
                }

                // Load from storage
                world = storage.loadWorld(worldName);
                if (world != null) {
                    world.validateAndRepair();
                    activeWorlds.put(worldName, world);
                    lastWorldAccess.put(worldName, System.currentTimeMillis());
                    GameLogger.info("Loaded world: " + worldName);
                }
                return world;
            } catch (Exception e) {
                GameLogger.error("Failed to load world: " + worldName + " - " + e.getMessage());
                return null;
            }
        }
    }
    public WorldData getWorld(String name) {
        synchronized (worldLock) {
            try {
                // First check active worlds
                WorldData world = activeWorlds.get(name);
                if (world != null) {
                    lastWorldAccess.put(name, System.currentTimeMillis());
                    return world;
                }

                // If not active, try loading it
                world = loadWorld(name);
                if (world != null) {
                    return world;
                }

                GameLogger.info("World '" + name + "' not found");
                return null;

            } catch (Exception e) {
                GameLogger.error("Error getting world: " + name + " - " + e.getMessage());
                return null;
            }
        }
    }

    public WorldData createWorld(String name, long seed, float treeSpawnRate, float pokemonSpawnRate) {
        synchronized (worldLock) {
            try {
                // Validate parameters
                if (name == null || name.trim().isEmpty()) {
                    throw new IllegalArgumentException("World name cannot be null or empty");
                }

                // Check if world already exists
                if (activeWorlds.containsKey(name) || storage.worldExists(name)) {
                    GameLogger.error("World '" + name + "' already exists");
                    return null;
                }

                GameLogger.info("Creating new world: " + name + " with seed: " + seed);

                // Create world configuration
                WorldData.WorldConfig config = new WorldData.WorldConfig();
                config.setSeed(seed);
                config.setTreeSpawnRate(treeSpawnRate);
                config.setPokemonSpawnRate(pokemonSpawnRate);

                // Create new world
                WorldData world = new WorldData(name);
                world.setName(name);
                world.setLastPlayed(System.currentTimeMillis());
                world.setConfig(config);
                world.setPlayers(new HashMap<>());
                world.setPokemonData(new PokemonData());

                // Save immediately
                storage.saveWorld(world);

                // Add to active worlds
                activeWorlds.put(name, world);
                lastWorldAccess.put(name, System.currentTimeMillis());

                GameLogger.info("Successfully created world: " + name);
                return world;

            } catch (Exception e) {
                GameLogger.error("Failed to create world: " + name + " - " + e.getMessage());
                return null;
            }
        }
    }

    public void saveWorld(WorldData world) {
        if (world == null) return;

        synchronized (worldLock) {
            try {
                // Create backup before saving
                storage.createWorldBackup(WorldData.fromJson(world.getName()));

                // Save world state
                storage.saveWorld(world);

                // Save player data
                if (world.getPlayers() != null) {
                    for (Map.Entry<String, PlayerData> entry : world.getPlayers().entrySet()) {
                        savePlayerData(entry.getKey(), entry.getValue());
                    }
                }

                world.setDirty(false);
                GameLogger.info("Saved world: " + world.getName());
            } catch (Exception e) {
                GameLogger.error("Failed to save world: " + world.getName() + " - " + e.getMessage());
            }
        }
    }

    public void unloadInactiveWorlds() {
        synchronized (worldLock) {
            long now = System.currentTimeMillis();
            Iterator<Map.Entry<String, Long>> it = lastWorldAccess.entrySet().iterator();

            while (it.hasNext()) {
                Map.Entry<String, Long> entry = it.next();
                if (now - entry.getValue() > SAVE_INTERVAL * 2) {
                    String worldName = entry.getKey();
                    WorldData world = activeWorlds.remove(worldName);
                    if (world != null && world.isDirty()) {
                        saveWorld(world);
                    }
                    it.remove();
                    GameLogger.info("Unloaded inactive world: " + worldName);
                }
            }
        }
    }

    public void shutdown() {
        try {
            GameLogger.info("Shutting down ServerWorldManager...");

            // Save all active worlds and player data
            synchronized (worldLock) {
                // Save worlds
                for (WorldData world : activeWorlds.values()) {
                    if (world.isDirty()) {
                        saveWorld(world);
                    }
                }

                // Save all player data
                for (Map.Entry<UUID, PlayerData> entry : playerDataCache.entrySet()) {
                    storage.getPlayerDataManager().savePlayerData(entry.getKey(), entry.getValue());
                }

                // Final flush
                storage.flushPlayerData();
            }

            scheduler.shutdown();
            try {
                if (!scheduler.awaitTermination(30, TimeUnit.SECONDS)) {
                    scheduler.shutdownNow();
                }
            } catch (InterruptedException e) {
                scheduler.shutdownNow();
            }

            // Clear collections
            activeWorlds.clear();
            lastWorldAccess.clear();
            playerDataCache.clear();

            GameLogger.info("ServerWorldManager shutdown complete");
        } catch (Exception e) {
            GameLogger.error("Error during shutdown: " + e.getMessage());
        }
    }
}
